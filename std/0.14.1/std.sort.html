<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.sort.html" class="active">sort</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.sort" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.sort</span><a href="#src.zig-std.sort">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.sort.Mode.html">std.sort.Mode</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.sort.equalRange" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">equalRange</span><a href="#src.zig-std.sort.equalRange">[src]</a></h2><div class="tldDocs"><p>Returns a tuple of the lower and upper indices in <code>items</code> between which all
elements return <code>.eq</code> when given to <code>compareFn</code>.</p>
<ul>
<li>If no element in <code>items</code> returns <code>.eq</code>, both indices are the
index of the first element in <code>items</code> returning <code>.gt</code>.</li>
<li>If no element in <code>items</code> returns <code>.gt</code>, both indices equal <code>items.len</code>.</li>
</ul>
<p><code>items</code> must be sorted in ascending order with respect to <code>compareFn</code>:</p>
<pre><code>[0]                                                   [len]
┌───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┐
│.lt│.lt│ \ \ │.lt│.eq│.eq│ \ \ │.eq│.gt│.gt│ \ \ │.gt│
└───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┘
├─────────────────┼─────────────────┼─────────────────┤
 ↳ zero or more    ↳ zero or more    ↳ zero or more
                  ├─────────────────┤
                   ↳ returned range
</code></pre>
<p><code>O(log n)</code> time complexity.</p>
<p>See also: <code><a href="std.sort.html#std.sort.binarySearch">binarySearch</a></code>, <code>lowerBound, </code>upperBound<code>, </code>partitionPoint<code>.</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> equalRange {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">orderU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderLength</span>(context: <span class="tok-type">usize</span>, item: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item.len);
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">0</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">0</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">1</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">2</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">2</span>, <span class="tok-number">2</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">2</span>, <span class="tok-number">3</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">8</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">5</span>, <span class="tok-number">6</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">64</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">6</span>, <span class="tok-number">6</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">100</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">2</span>, <span class="tok-number">6</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">15</span>, <span class="tok-number">22</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">8</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">2</span>, <span class="tok-number">2</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">3</span>, <span class="tok-number">5</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">1</span>, <span class="tok-number">1</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.orderF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">3</span>, <span class="tok-number">5</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;Mars&quot;</span>, <span class="tok-str">&quot;Venus&quot;</span>, <span class="tok-str">&quot;Earth&quot;</span>, <span class="tok-str">&quot;Saturn&quot;</span>, <span class="tok-str">&quot;Uranus&quot;</span>, <span class="tok-str">&quot;Mercury&quot;</span>, <span class="tok-str">&quot;Jupiter&quot;</span>, <span class="tok-str">&quot;Neptune&quot;</span> },
        <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>),
        S.orderLength,
    ));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.equalRange">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">equalRange</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>,
) <span class="tok-kw">struct</span> { <span class="tok-type">usize</span>, <span class="tok-type">usize</span> } {
    <span class="tok-kw">var</span> low: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> high: <span class="tok-type">usize</span> = items.len;

    <span class="tok-kw">while</span> (low &lt; high) {
        <span class="tok-kw">const</span> mid = low + (high - low) / <span class="tok-number">2</span>;
        <span class="tok-kw">switch</span> (compareFn(context, items[mid])) {
            .gt =&gt; {
                low = mid + <span class="tok-number">1</span>;
            },
            .lt =&gt; {
                high = mid;
            },
            .eq =&gt; {
                <span class="tok-kw">return</span> .{
                    low + <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(
                        T,
                        items[low..mid],
                        context,
                        compareFn,
                    ),
                    mid + <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.upperBound">upperBound</a>(
                        T,
                        items[mid..high],
                        context,
                        compareFn,
                    ),
                };
            },
        }
    }

    <span class="tok-kw">return</span> .{ low, low };
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.sort.block.block" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">block</span><a href="#src.zig-std.sort.block.block">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">block</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Stable in-place sort. O(n) best case, O(n*log(n)) worst case and average case.
O(1) memory (no allocator required).
Sorts in ascending order with respect to the given <code>lessThan</code> function.</p>
<p>NOTE: The algorithm only works when the comparison is less-than or greater-than.
(See <a href="https://github.com/ziglang/zig/issues/8289">https://github.com/ziglang/zig/issues/8289</a>)</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.block.block">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">block</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> lessThan = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> lt = lessThanFn(ctx, lhs, rhs);
            <span class="tok-kw">const</span> gt = lessThanFn(ctx, rhs, lhs);
            <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>(!(lt <span class="tok-kw">and</span> gt));
            <span class="tok-kw">return</span> lt;
        }
    }.lessThan <span class="tok-kw">else</span> lessThanFn;<span class="tok-comment">

    // Implementation ported from https://github.com/BonzaiThePenguin/WikiSort/blob/master/WikiSort.c
    </span><span class="tok-kw">var</span> cache: [<span class="tok-number">512</span>]T = <span class="tok-null">undefined</span>;

    <span class="tok-kw">if</span> (items.len &lt; <span class="tok-number">4</span>) {
        <span class="tok-kw">if</span> (items.len == <span class="tok-number">3</span>) {<span class="tok-comment">
            // hard coded insertion sort
            </span><span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);
            <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">2</span>], items[<span class="tok-number">1</span>])) {
                <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;items[<span class="tok-number">1</span>], &amp;items[<span class="tok-number">2</span>]);
                <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (items.len == <span class="tok-number">2</span>) {
            <span class="tok-kw">if</span> (lessThan(context, items[<span class="tok-number">1</span>], items[<span class="tok-number">0</span>])) <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;items[<span class="tok-number">0</span>], &amp;items[<span class="tok-number">1</span>]);
        }
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // sort groups of 4-8 items at a time using an unstable sorting network,
    // but keep track of the original item orders to force it to be stable
    // http://pages.ripco.net/~jgamble/nw.html
    </span><span class="tok-kw">var</span> iterator = <a href="std.sort.block.Iterator.html">Iterator</a>.<a href="std.sort.block.Iterator.html#std.sort.block.Iterator.init">init</a>(items.len, <span class="tok-number">4</span>);
    <span class="tok-kw">while</span> (!iterator.finished()) {
        <span class="tok-kw">var</span> order = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span> };
        <span class="tok-kw">const</span> range = iterator.nextRange();

        <span class="tok-kw">const</span> sliced_items = items[range.start..];
        <span class="tok-kw">switch</span> (range.length()) {
            <span class="tok-number">8</span> =&gt; {
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">6</span>, <span class="tok-number">7</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">6</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">7</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">6</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">7</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">6</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">6</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);
            },
            <span class="tok-number">7</span> =&gt; {
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">5</span>, <span class="tok-number">6</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">6</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">6</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);
            },
            <span class="tok-number">6</span> =&gt; {
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">4</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">5</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);
            },
            <span class="tok-number">5</span> =&gt; {
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">3</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">4</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);
            },
            <span class="tok-number">4</span> =&gt; {
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">1</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">2</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">0</span>, <span class="tok-number">2</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">3</span>, context, lessThan);
                <a href="std.sort.block.html#std.sort.block.swap">swap</a>(T, sliced_items, &amp;order, <span class="tok-number">1</span>, <span class="tok-number">2</span>, context, lessThan);
            },
            <span class="tok-kw">else</span> =&gt; {},
        }
    }
    <span class="tok-kw">if</span> (items.len &lt; <span class="tok-number">8</span>) <span class="tok-kw">return</span>;<span class="tok-comment">

    // then merge sort the higher levels, which can be 8-15, 16-31, 32-63, 64-127, etc.
    </span><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
        // if every A and B block will fit into the cache, use a special branch
        // specifically for merging with the cache
        // (we use &lt; rather than &lt;= since the block size might be one more than
        // iterator.length())
        </span><span class="tok-kw">if</span> (iterator.length() &lt; cache.len) {<span class="tok-comment">
            // if four subarrays fit into the cache, it's faster to merge both
            // pairs of subarrays into the cache,
            // then merge the two merged subarrays from the cache back into the original array
            </span><span class="tok-kw">if</span> ((iterator.length() + <span class="tok-number">1</span>) * <span class="tok-number">4</span> &lt;= cache.len <span class="tok-kw">and</span> iterator.length() * <span class="tok-number">4</span> &lt;= items.len) {
                iterator.begin();
                <span class="tok-kw">while</span> (!iterator.finished()) {<span class="tok-comment">
                    // merge A1 and B1 into the cache
                    </span><span class="tok-kw">var</span> A1 = iterator.nextRange();
                    <span class="tok-kw">var</span> B1 = iterator.nextRange();
                    <span class="tok-kw">var</span> A2 = iterator.nextRange();
                    <span class="tok-kw">var</span> B2 = iterator.nextRange();

                    <span class="tok-kw">if</span> (lessThan(context, items[B1.end - <span class="tok-number">1</span>], items[A1.start])) {<span class="tok-comment">
                        // the two ranges are in reverse order, so copy them in reverse order into the cache
                        </span><span class="tok-kw">const</span> a1_items = items[A1.start..A1.end];
                        <span class="tok-builtin">@memcpy</span>(cache[B1.length()..][<span class="tok-number">0</span>..a1_items.len], a1_items);
                        <span class="tok-kw">const</span> b1_items = items[B1.start..B1.end];
                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..b1_items.len], b1_items);
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B1.start], items[A1.end - <span class="tok-number">1</span>])) {<span class="tok-comment">
                        // these two ranges weren't already in order, so merge them into the cache
                        </span><a href="std.sort.block.html#std.sort.block.mergeInto">mergeInto</a>(T, items, A1, B1, cache[<span class="tok-number">0</span>..], context, lessThan);
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // if A1, B1, A2, and B2 are all in order, skip doing anything else
                        </span><span class="tok-kw">if</span> (!lessThan(context, items[B2.start], items[A2.end - <span class="tok-number">1</span>]) <span class="tok-kw">and</span> !lessThan(context, items[A2.start], items[B1.end - <span class="tok-number">1</span>])) <span class="tok-kw">continue</span>;<span class="tok-comment">

                        // copy A1 and B1 into the cache in the same order
                        </span><span class="tok-kw">const</span> a1_items = items[A1.start..A1.end];
                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..a1_items.len], a1_items);
                        <span class="tok-kw">const</span> b1_items = items[B1.start..B1.end];
                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..b1_items.len], b1_items);
                    }
                    A1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A1.start, B1.end);<span class="tok-comment">

                    // merge A2 and B2 into the cache
                    </span><span class="tok-kw">if</span> (lessThan(context, items[B2.end - <span class="tok-number">1</span>], items[A2.start])) {<span class="tok-comment">
                        // the two ranges are in reverse order, so copy them in reverse order into the cache
                        </span><span class="tok-kw">const</span> a2_items = items[A2.start..A2.end];
                        <span class="tok-builtin">@memcpy</span>(cache[A1.length() + B2.length() ..][<span class="tok-number">0</span>..a2_items.len], a2_items);
                        <span class="tok-kw">const</span> b2_items = items[B2.start..B2.end];
                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..b2_items.len], b2_items);
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B2.start], items[A2.end - <span class="tok-number">1</span>])) {<span class="tok-comment">
                        // these two ranges weren't already in order, so merge them into the cache
                        </span><a href="std.sort.block.html#std.sort.block.mergeInto">mergeInto</a>(T, items, A2, B2, cache[A1.length()..], context, lessThan);
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // copy A2 and B2 into the cache in the same order
                        </span><span class="tok-kw">const</span> a2_items = items[A2.start..A2.end];
                        <span class="tok-builtin">@memcpy</span>(cache[A1.length()..][<span class="tok-number">0</span>..a2_items.len], a2_items);
                        <span class="tok-kw">const</span> b2_items = items[B2.start..B2.end];
                        <span class="tok-builtin">@memcpy</span>(cache[A1.length() + A2.length() ..][<span class="tok-number">0</span>..b2_items.len], b2_items);
                    }
                    A2 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A2.start, B2.end);<span class="tok-comment">

                    // merge A1 and A2 from the cache into the items
                    </span><span class="tok-kw">const</span> A3 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(<span class="tok-number">0</span>, A1.length());
                    <span class="tok-kw">const</span> B3 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A1.length(), A1.length() + A2.length());

                    <span class="tok-kw">if</span> (lessThan(context, cache[B3.end - <span class="tok-number">1</span>], cache[A3.start])) {<span class="tok-comment">
                        // the two ranges are in reverse order, so copy them in reverse order into the items
                        </span><span class="tok-kw">const</span> a3_items = cache[A3.start..A3.end];
                        <span class="tok-builtin">@memcpy</span>(items[A1.start + A2.length() ..][<span class="tok-number">0</span>..a3_items.len], a3_items);
                        <span class="tok-kw">const</span> b3_items = cache[B3.start..B3.end];
                        <span class="tok-builtin">@memcpy</span>(items[A1.start..][<span class="tok-number">0</span>..b3_items.len], b3_items);
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, cache[B3.start], cache[A3.end - <span class="tok-number">1</span>])) {<span class="tok-comment">
                        // these two ranges weren't already in order, so merge them back into the items
                        </span><a href="std.sort.block.html#std.sort.block.mergeInto">mergeInto</a>(T, cache[<span class="tok-number">0</span>..], A3, B3, items[A1.start..], context, lessThan);
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // copy A3 and B3 into the items in the same order
                        </span><span class="tok-kw">const</span> a3_items = cache[A3.start..A3.end];
                        <span class="tok-builtin">@memcpy</span>(items[A1.start..][<span class="tok-number">0</span>..a3_items.len], a3_items);
                        <span class="tok-kw">const</span> b3_items = cache[B3.start..B3.end];
                        <span class="tok-builtin">@memcpy</span>(items[A1.start + A1.length() ..][<span class="tok-number">0</span>..b3_items.len], b3_items);
                    }
                }<span class="tok-comment">

                // we merged two levels at the same time, so we're done with this level already
                // (iterator.nextLevel() is called again at the bottom of this outer merge loop)
                </span>_ = iterator.nextLevel();
            } <span class="tok-kw">else</span> {
                iterator.begin();
                <span class="tok-kw">while</span> (!iterator.finished()) {
                    <span class="tok-kw">const</span> A = iterator.nextRange();
                    <span class="tok-kw">const</span> B = iterator.nextRange();

                    <span class="tok-kw">if</span> (lessThan(context, items[B.end - <span class="tok-number">1</span>], items[A.start])) {<span class="tok-comment">
                        // the two ranges are in reverse order, so a simple rotation should fix it
                        </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.rotate">rotate</a>(T, items[A.start..B.end], A.length());
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[B.start], items[A.end - <span class="tok-number">1</span>])) {<span class="tok-comment">
                        // these two ranges weren't already in order, so we'll need to merge them!
                        </span><span class="tok-kw">const</span> a_items = items[A.start..A.end];
                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..a_items.len], a_items);
                        <a href="std.sort.block.html#std.sort.block.mergeExternal">mergeExternal</a>(T, items, A, B, cache[<span class="tok-number">0</span>..], context, lessThan);
                    }
                }
            }
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // this is where the in-place merge logic starts!
            // 1. pull out two internal buffers each containing √A unique values
            //    1a. adjust block_size and buffer_size if we couldn't find enough unique values
            // 2. loop over the A and B subarrays within this level of the merge sort
            // 3. break A and B into blocks of size 'block_size'
            // 4. &quot;tag&quot; each of the A blocks with values from the first internal buffer
            // 5. roll the A blocks through the B blocks and drop/rotate them where they belong
            // 6. merge each A block with any B values that follow, using the cache or the second internal buffer
            // 7. sort the second internal buffer if it exists
            // 8. redistribute the two internal buffers back into the items
            </span><span class="tok-kw">var</span> block_size: <span class="tok-type">usize</span> = <a href="std.math.html">math</a>.<a href="std.math.sqrt.html#std.math.sqrt.sqrt">sqrt</a>(iterator.length());
            <span class="tok-kw">var</span> buffer_size = iterator.length() / block_size + <span class="tok-number">1</span>;<span class="tok-comment">

            // as an optimization, we really only need to pull out the internal buffers once for each level of merges
            // after that we can reuse the same buffers over and over, then redistribute it when we're finished with this level
            </span><span class="tok-kw">var</span> A: <a href="std.sort.block.Range.html">Range</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> B: <a href="std.sort.block.Range.html">Range</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> last: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> find: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> pull_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> pull = [_]<a href="std.sort.block.Pull.html">Pull</a>{
                <a href="std.sort.block.Pull.html">Pull</a>{
                    .from = <span class="tok-number">0</span>,
                    .to = <span class="tok-number">0</span>,
                    .count = <span class="tok-number">0</span>,
                    .range = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(<span class="tok-number">0</span>, <span class="tok-number">0</span>),
                },
                <a href="std.sort.block.Pull.html">Pull</a>{
                    .from = <span class="tok-number">0</span>,
                    .to = <span class="tok-number">0</span>,
                    .count = <span class="tok-number">0</span>,
                    .range = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(<span class="tok-number">0</span>, <span class="tok-number">0</span>),
                },
            };

            <span class="tok-kw">var</span> buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(<span class="tok-number">0</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">var</span> buffer2 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(<span class="tok-number">0</span>, <span class="tok-number">0</span>);<span class="tok-comment">

            // find two internal buffers of size 'buffer_size' each
            </span>find = buffer_size + buffer_size;
            <span class="tok-kw">var</span> find_separately = <span class="tok-null">false</span>;

            <span class="tok-kw">if</span> (block_size &lt;= cache.len) {<span class="tok-comment">
                // if every A block fits into the cache then we won't need the second internal buffer,
                // so we really only need to find 'buffer_size' unique values
                </span>find = buffer_size;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find &gt; iterator.length()) {<span class="tok-comment">
                // we can't fit both buffers into the same A or B subarray, so find two buffers separately
                </span>find = buffer_size;
                find_separately = <span class="tok-null">true</span>;
            }<span class="tok-comment">

            // we need to find either a single contiguous space containing 2√A unique values (which will be split up into two buffers of size √A each),
            // or we need to find one buffer of &lt; 2√A unique values, and a second buffer of √A unique values,
            // OR if we couldn't find that many unique values, we need the largest possible buffer we can get

            // in the case where it couldn't find a single buffer of at least √A unique values,
            // all of the Merge steps must be replaced by a different merge algorithm (MergeInPlace)
            </span>iterator.begin();
            <span class="tok-kw">while</span> (!iterator.finished()) {
                A = iterator.nextRange();
                B = iterator.nextRange();<span class="tok-comment">

                // just store information about where the values will be pulled from and to,
                // as well as how many values there are, to create the two internal buffers

                // check A for the number of unique values we need to fill an internal buffer
                // these values will be pulled out to the start of A
                </span>last = A.start;
                count = <span class="tok-number">1</span>;
                <span class="tok-kw">while</span> (count &lt; find) : ({
                    last = index;
                    count += <span class="tok-number">1</span>;
                }) {
                    index = <a href="std.sort.block.html#std.sort.block.findLastForward">findLastForward</a>(T, items, items[last], <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(last + <span class="tok-number">1</span>, A.end), find - count, context, lessThan);
                    <span class="tok-kw">if</span> (index == A.end) <span class="tok-kw">break</span>;
                }
                index = last;

                <span class="tok-kw">if</span> (count &gt;= buffer_size) {<span class="tok-comment">
                    // keep track of the range within the items where we'll need to &quot;pull out&quot; these values to create the internal buffer
                    </span>pull[pull_index] = <a href="std.sort.block.Pull.html">Pull</a>{
                        .range = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, B.end),
                        .count = count,
                        .from = index,
                        .to = A.start,
                    };
                    pull_index = <span class="tok-number">1</span>;

                    <span class="tok-kw">if</span> (count == buffer_size + buffer_size) {<span class="tok-comment">
                        // we were able to find a single contiguous section containing 2√A unique values,
                        // so this section can be used to contain both of the internal buffers we'll need
                        </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, A.start + buffer_size);
                        buffer2 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start + buffer_size, A.start + count);
                        <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find == buffer_size + buffer_size) {<span class="tok-comment">
                        // we found a buffer that contains at least √A unique values, but did not contain the full 2√A unique values,
                        // so we still need to find a second separate buffer of at least √A unique values
                        </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, A.start + count);
                        find = buffer_size;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (block_size &lt;= cache.len) {<span class="tok-comment">
                        // we found the first and only internal buffer that we need, so we're done!
                        </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, A.start + count);
                        <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find_separately) {<span class="tok-comment">
                        // found one buffer, but now find the other one
                        </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, A.start + count);
                        find_separately = <span class="tok-null">false</span>;
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // we found a second buffer in an 'A' subarray containing √A unique values, so we're done!
                        </span>buffer2 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, A.start + count);
                        <span class="tok-kw">break</span>;
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull_index == <span class="tok-number">0</span> <span class="tok-kw">and</span> count &gt; buffer1.length()) {<span class="tok-comment">
                    // keep track of the largest buffer we were able to find
                    </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, A.start + count);
                    pull[pull_index] = <a href="std.sort.block.Pull.html">Pull</a>{
                        .range = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, B.end),
                        .count = count,
                        .from = index,
                        .to = A.start,
                    };
                }<span class="tok-comment">

                // check B for the number of unique values we need to fill an internal buffer
                // these values will be pulled out to the end of B
                </span>last = B.end - <span class="tok-number">1</span>;
                count = <span class="tok-number">1</span>;
                <span class="tok-kw">while</span> (count &lt; find) : ({
                    last = index - <span class="tok-number">1</span>;
                    count += <span class="tok-number">1</span>;
                }) {
                    index = <a href="std.sort.block.html#std.sort.block.findFirstBackward">findFirstBackward</a>(T, items, items[last], <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.start, last), find - count, context, lessThan);
                    <span class="tok-kw">if</span> (index == B.start) <span class="tok-kw">break</span>;
                }
                index = last;

                <span class="tok-kw">if</span> (count &gt;= buffer_size) {<span class="tok-comment">
                    // keep track of the range within the items where we'll need to &quot;pull out&quot; these values to create the internal buffe
                    </span>pull[pull_index] = <a href="std.sort.block.Pull.html">Pull</a>{
                        .range = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, B.end),
                        .count = count,
                        .from = index,
                        .to = B.end,
                    };
                    pull_index = <span class="tok-number">1</span>;

                    <span class="tok-kw">if</span> (count == buffer_size + buffer_size) {<span class="tok-comment">
                        // we were able to find a single contiguous section containing 2√A unique values,
                        // so this section can be used to contain both of the internal buffers we'll need
                        </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.end - count, B.end - buffer_size);
                        buffer2 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.end - buffer_size, B.end);
                        <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find == buffer_size + buffer_size) {<span class="tok-comment">
                        // we found a buffer that contains at least √A unique values, but did not contain the full 2√A unique values,
                        // so we still need to find a second separate buffer of at least √A unique values
                        </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.end - count, B.end);
                        find = buffer_size;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (block_size &lt;= cache.len) {<span class="tok-comment">
                        // we found the first and only internal buffer that we need, so we're done!
                        </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.end - count, B.end);
                        <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (find_separately) {<span class="tok-comment">
                        // found one buffer, but now find the other one
                        </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.end - count, B.end);
                        find_separately = <span class="tok-null">false</span>;
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // buffer2 will be pulled out from a 'B' subarray, so if the first buffer was pulled out from the corresponding 'A' subarray,
                        // we need to adjust the end point for that A subarray so it knows to stop redistributing its values before reaching buffer2
                        </span><span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].range.start == A.start) pull[<span class="tok-number">0</span>].range.end -= pull[<span class="tok-number">1</span>].count;<span class="tok-comment">

                        // we found a second buffer in an 'B' subarray containing √A unique values, so we're done!
                        </span>buffer2 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.end - count, B.end);
                        <span class="tok-kw">break</span>;
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull_index == <span class="tok-number">0</span> <span class="tok-kw">and</span> count &gt; buffer1.length()) {<span class="tok-comment">
                    // keep track of the largest buffer we were able to find
                    </span>buffer1 = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.end - count, B.end);
                    pull[pull_index] = <a href="std.sort.block.Pull.html">Pull</a>{
                        .range = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, B.end),
                        .count = count,
                        .from = index,
                        .to = B.end,
                    };
                }
            }<span class="tok-comment">

            // pull out the two ranges so we can use them as internal buffers
            </span>pull_index = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (pull_index &lt; <span class="tok-number">2</span>) : (pull_index += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> length = pull[pull_index].count;

                <span class="tok-kw">if</span> (pull[pull_index].to &lt; pull[pull_index].from) {<span class="tok-comment">
                    // we're pulling the values out to the left, which means the start of an A subarray
                    </span>index = pull[pull_index].from;
                    count = <span class="tok-number">1</span>;
                    <span class="tok-kw">while</span> (count &lt; length) : (count += <span class="tok-number">1</span>) {
                        index = <a href="std.sort.block.html#std.sort.block.findFirstBackward">findFirstBackward</a>(T, items, items[index - <span class="tok-number">1</span>], <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(pull[pull_index].to, pull[pull_index].from - (count - <span class="tok-number">1</span>)), length - count, context, lessThan);
                        <span class="tok-kw">const</span> range = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(index + <span class="tok-number">1</span>, pull[pull_index].from + <span class="tok-number">1</span>);
                        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.rotate">rotate</a>(T, items[range.start..range.end], range.length() - count);
                        pull[pull_index].from = index + count;
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[pull_index].to &gt; pull[pull_index].from) {<span class="tok-comment">
                    // we're pulling values out to the right, which means the end of a B subarray
                    </span>index = pull[pull_index].from + <span class="tok-number">1</span>;
                    count = <span class="tok-number">1</span>;
                    <span class="tok-kw">while</span> (count &lt; length) : (count += <span class="tok-number">1</span>) {
                        index = <a href="std.sort.block.html#std.sort.block.findLastForward">findLastForward</a>(T, items, items[index], <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(index, pull[pull_index].to), length - count, context, lessThan);
                        <span class="tok-kw">const</span> range = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(pull[pull_index].from, index - <span class="tok-number">1</span>);
                        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.rotate">rotate</a>(T, items[range.start..range.end], count);
                        pull[pull_index].from = index - <span class="tok-number">1</span> - count;
                    }
                }
            }<span class="tok-comment">

            // adjust block_size and buffer_size based on the values we were able to pull out
            </span>buffer_size = buffer1.length();
            block_size = iterator.length() / buffer_size + <span class="tok-number">1</span>;<span class="tok-comment">

            // the first buffer NEEDS to be large enough to tag each of the evenly sized A blocks,
            // so this was originally here to test the math for adjusting block_size above
            // assert((iterator.length() + 1)/block_size &lt;= buffer_size);

            // now that the two internal buffers have been created, it's time to merge each A+B combination at this level of the merge sort!
            </span>iterator.begin();
            <span class="tok-kw">while</span> (!iterator.finished()) {
                A = iterator.nextRange();
                B = iterator.nextRange();<span class="tok-comment">

                // remove any parts of A or B that are being used by the internal buffers
                </span>start = A.start;
                <span class="tok-kw">if</span> (start == pull[<span class="tok-number">0</span>].range.start) {
                    <span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].from &gt; pull[<span class="tok-number">0</span>].to) {
                        A.start += pull[<span class="tok-number">0</span>].count;<span class="tok-comment">

                        // if the internal buffer takes up the entire A or B subarray, then there's nothing to merge
                        // this only happens for very small subarrays, like √4 = 2, 2 * (2 internal buffers) = 4,
                        // which also only happens when cache.len is small or 0 since it'd otherwise use MergeExternal
                        </span><span class="tok-kw">if</span> (A.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[<span class="tok-number">0</span>].from &lt; pull[<span class="tok-number">0</span>].to) {
                        B.end -= pull[<span class="tok-number">0</span>].count;
                        <span class="tok-kw">if</span> (B.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                    }
                }
                <span class="tok-kw">if</span> (start == pull[<span class="tok-number">1</span>].range.start) {
                    <span class="tok-kw">if</span> (pull[<span class="tok-number">1</span>].from &gt; pull[<span class="tok-number">1</span>].to) {
                        A.start += pull[<span class="tok-number">1</span>].count;
                        <span class="tok-kw">if</span> (A.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[<span class="tok-number">1</span>].from &lt; pull[<span class="tok-number">1</span>].to) {
                        B.end -= pull[<span class="tok-number">1</span>].count;
                        <span class="tok-kw">if</span> (B.length() == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                    }
                }

                <span class="tok-kw">if</span> (lessThan(context, items[B.end - <span class="tok-number">1</span>], items[A.start])) {<span class="tok-comment">
                    // the two ranges are in reverse order, so a simple rotation should fix it
                    </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.rotate">rotate</a>(T, items[A.start..B.end], A.length());
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lessThan(context, items[A.end], items[A.end - <span class="tok-number">1</span>])) {<span class="tok-comment">
                    // these two ranges weren't already in order, so we'll need to merge them!
                    </span><span class="tok-kw">var</span> findA: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">

                    // break the remainder of A into blocks. firstA is the uneven-sized first A block
                    </span><span class="tok-kw">var</span> blockA = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, A.end);
                    <span class="tok-kw">var</span> firstA = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(A.start, A.start + blockA.length() % block_size);<span class="tok-comment">

                    // swap the first value of each A block with the value in buffer1
                    </span><span class="tok-kw">var</span> indexA = buffer1.start;
                    index = firstA.end;
                    <span class="tok-kw">while</span> (index &lt; blockA.end) : ({
                        indexA += <span class="tok-number">1</span>;
                        index += block_size;
                    }) {
                        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;items[indexA], &amp;items[index]);
                    }<span class="tok-comment">

                    // start rolling the A blocks through the B blocks!
                    // whenever we leave an A block behind, we'll need to merge the previous A block with any B blocks that follow it, so track that information as well
                    </span><span class="tok-kw">var</span> lastA = firstA;
                    <span class="tok-kw">var</span> lastB = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(<span class="tok-number">0</span>, <span class="tok-number">0</span>);
                    <span class="tok-kw">var</span> blockB = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(B.start, B.start + <span class="tok-builtin">@min</span>(block_size, B.length()));
                    blockA.start += firstA.length();
                    indexA = buffer1.start;<span class="tok-comment">

                    // if the first unevenly sized A block fits into the cache, copy it there for when we go to Merge it
                    // otherwise, if the second buffer is available, block swap the contents into that
                    </span><span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {
                        <span class="tok-kw">const</span> last_a_items = items[lastA.start..lastA.end];
                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..last_a_items.len], last_a_items);
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {
                        <a href="std.sort.block.html#std.sort.block.blockSwap">blockSwap</a>(T, items, lastA.start, buffer2.start, lastA.length());
                    }

                    <span class="tok-kw">if</span> (blockA.length() &gt; <span class="tok-number">0</span>) {
                        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
                            // if there's a previous B block and the first value of the minimum A block is &lt;= the last value of the previous B block,
                            // then drop that minimum A block behind. or if there are no B blocks left then keep dropping the remaining A blocks.
                            </span><span class="tok-kw">if</span> ((lastB.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> !lessThan(context, items[lastB.end - <span class="tok-number">1</span>], items[indexA])) <span class="tok-kw">or</span> blockB.length() == <span class="tok-number">0</span>) {<span class="tok-comment">
                                // figure out where to split the previous B block, and rotate it at the split
                                </span><span class="tok-kw">const</span> B_split = <a href="std.sort.block.html#std.sort.block.binaryFirst">binaryFirst</a>(T, items, items[indexA], lastB, context, lessThan);
                                <span class="tok-kw">const</span> B_remaining = lastB.end - B_split;<span class="tok-comment">

                                // swap the minimum A block to the beginning of the rolling A blocks
                                </span><span class="tok-kw">var</span> minA = blockA.start;
                                findA = minA + block_size;
                                <span class="tok-kw">while</span> (findA &lt; blockA.end) : (findA += block_size) {
                                    <span class="tok-kw">if</span> (lessThan(context, items[findA], items[minA])) {
                                        minA = findA;
                                    }
                                }
                                <a href="std.sort.block.html#std.sort.block.blockSwap">blockSwap</a>(T, items, blockA.start, minA, block_size);<span class="tok-comment">

                                // swap the first item of the previous A block back with its original value, which is stored in buffer1
                                </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;items[blockA.start], &amp;items[indexA]);
                                indexA += <span class="tok-number">1</span>;<span class="tok-comment">

                                // locally merge the previous A block with the B values that follow it
                                // if lastA fits into the external cache we'll use that (with MergeExternal),
                                // or if the second internal buffer exists we'll use that (with MergeInternal),
                                // or failing that we'll use a strictly in-place merge algorithm (MergeInPlace)

                                </span><span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {
                                    <a href="std.sort.block.html#std.sort.block.mergeExternal">mergeExternal</a>(T, items, lastA, <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(lastA.end, B_split), cache[<span class="tok-number">0</span>..], context, lessThan);
                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {
                                    <a href="std.sort.block.html#std.sort.block.mergeInternal">mergeInternal</a>(T, items, lastA, <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(lastA.end, B_split), buffer2, context, lessThan);
                                } <span class="tok-kw">else</span> {
                                    <a href="std.sort.block.html#std.sort.block.mergeInPlace">mergeInPlace</a>(T, items, lastA, <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(lastA.end, B_split), context, lessThan);
                                }

                                <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span> <span class="tok-kw">or</span> block_size &lt;= cache.len) {<span class="tok-comment">
                                    // copy the previous A block into the cache or buffer2, since that's where we need it to be when we go to merge it anyway
                                    </span><span class="tok-kw">if</span> (block_size &lt;= cache.len) {
                                        <span class="tok-builtin">@memcpy</span>(cache[<span class="tok-number">0</span>..block_size], items[blockA.start..][<span class="tok-number">0</span>..block_size]);
                                    } <span class="tok-kw">else</span> {
                                        <a href="std.sort.block.html#std.sort.block.blockSwap">blockSwap</a>(T, items, blockA.start, buffer2.start, block_size);
                                    }<span class="tok-comment">

                                    // this is equivalent to rotating, but faster
                                    // the area normally taken up by the A block is either the contents of buffer2, or data we don't need anymore since we memcopied it
                                    // either way, we don't need to retain the order of those items, so instead of rotating we can just block swap B to where it belongs
                                    </span><a href="std.sort.block.html#std.sort.block.blockSwap">blockSwap</a>(T, items, B_split, blockA.start + block_size - B_remaining, B_remaining);
                                } <span class="tok-kw">else</span> {<span class="tok-comment">
                                    // we are unable to use the 'buffer2' trick to speed up the rotation operation since buffer2 doesn't exist, so perform a normal rotation
                                    </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.rotate">rotate</a>(T, items[B_split .. blockA.start + block_size], blockA.start - B_split);
                                }<span class="tok-comment">

                                // update the range for the remaining A blocks, and the range remaining from the B block after it was split
                                </span>lastA = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(blockA.start - B_remaining, blockA.start - B_remaining + block_size);
                                lastB = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(lastA.end, lastA.end + B_remaining);<span class="tok-comment">

                                // if there are no more A blocks remaining, this step is finished!
                                </span>blockA.start += block_size;
                                <span class="tok-kw">if</span> (blockA.length() == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (blockB.length() &lt; block_size) {<span class="tok-comment">
                                // move the last B block, which is unevenly sized, to before the remaining A blocks, by using a rotation
                                // the cache is disabled here since it might contain the contents of the previous A block
                                </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.rotate">rotate</a>(T, items[blockA.start..blockB.end], blockB.start - blockA.start);

                                lastB = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(blockA.start, blockA.start + blockB.length());
                                blockA.start += blockB.length();
                                blockA.end += blockB.length();
                                blockB.end = blockB.start;
                            } <span class="tok-kw">else</span> {<span class="tok-comment">
                                // roll the leftmost A block to the end by swapping it with the next B block
                                </span><a href="std.sort.block.html#std.sort.block.blockSwap">blockSwap</a>(T, items, blockA.start, blockB.start, block_size);
                                lastB = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(blockA.start, blockA.start + block_size);

                                blockA.start += block_size;
                                blockA.end += block_size;
                                blockB.start += block_size;

                                <span class="tok-kw">if</span> (blockB.end &gt; B.end - block_size) {
                                    blockB.end = B.end;
                                } <span class="tok-kw">else</span> {
                                    blockB.end += block_size;
                                }
                            }
                        }
                    }<span class="tok-comment">

                    // merge the last A block with the remaining B values
                    </span><span class="tok-kw">if</span> (lastA.length() &lt;= cache.len) {
                        <a href="std.sort.block.html#std.sort.block.mergeExternal">mergeExternal</a>(T, items, lastA, <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(lastA.end, B.end), cache[<span class="tok-number">0</span>..], context, lessThan);
                    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (buffer2.length() &gt; <span class="tok-number">0</span>) {
                        <a href="std.sort.block.html#std.sort.block.mergeInternal">mergeInternal</a>(T, items, lastA, <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(lastA.end, B.end), buffer2, context, lessThan);
                    } <span class="tok-kw">else</span> {
                        <a href="std.sort.block.html#std.sort.block.mergeInPlace">mergeInPlace</a>(T, items, lastA, <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(lastA.end, B.end), context, lessThan);
                    }
                }
            }<span class="tok-comment">

            // when we're finished with this merge step we should have the one
            // or two internal buffers left over, where the second buffer is all jumbled up
            // insertion sort the second buffer, then redistribute the buffers
            // back into the items using the opposite process used for creating the buffer

            // while an unstable sort like quicksort could be applied here, in benchmarks
            // it was consistently slightly slower than a simple insertion sort,
            // even for tens of millions of items. this may be because insertion
            // sort is quite fast when the data is already somewhat sorted, like it is here
            </span><a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.insertion">insertion</a>(T, items[buffer2.start..buffer2.end], context, lessThan);

            pull_index = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (pull_index &lt; <span class="tok-number">2</span>) : (pull_index += <span class="tok-number">1</span>) {
                <span class="tok-kw">var</span> unique = pull[pull_index].count * <span class="tok-number">2</span>;
                <span class="tok-kw">if</span> (pull[pull_index].from &gt; pull[pull_index].to) {<span class="tok-comment">
                    // the values were pulled out to the left, so redistribute them back to the right
                    </span><span class="tok-kw">var</span> buffer = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(pull[pull_index].range.start, pull[pull_index].range.start + pull[pull_index].count);
                    <span class="tok-kw">while</span> (buffer.length() &gt; <span class="tok-number">0</span>) {
                        index = <a href="std.sort.block.html#std.sort.block.findFirstForward">findFirstForward</a>(T, items, items[buffer.start], <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(buffer.end, pull[pull_index].range.end), unique, context, lessThan);
                        <span class="tok-kw">const</span> amount = index - buffer.end;
                        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.rotate">rotate</a>(T, items[buffer.start..index], buffer.length());
                        buffer.start += (amount + <span class="tok-number">1</span>);
                        buffer.end += amount;
                        unique -= <span class="tok-number">2</span>;
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (pull[pull_index].from &lt; pull[pull_index].to) {<span class="tok-comment">
                    // the values were pulled out to the right, so redistribute them back to the left
                    </span><span class="tok-kw">var</span> buffer = <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(pull[pull_index].range.end - pull[pull_index].count, pull[pull_index].range.end);
                    <span class="tok-kw">while</span> (buffer.length() &gt; <span class="tok-number">0</span>) {
                        index = <a href="std.sort.block.html#std.sort.block.findLastBackward">findLastBackward</a>(T, items, items[buffer.end - <span class="tok-number">1</span>], <a href="std.sort.block.Range.html">Range</a>.<a href="std.sort.block.Range.html#std.sort.block.Range.init">init</a>(pull[pull_index].range.start, buffer.start), unique, context, lessThan);
                        <span class="tok-kw">const</span> amount = buffer.start - index;
                        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.rotate">rotate</a>(T, items[index..buffer.end], amount);
                        buffer.start -= amount;
                        buffer.end -= (amount + <span class="tok-number">1</span>);
                        unique -= <span class="tok-number">2</span>;
                    }
                }
            }
        }<span class="tok-comment">

        // double the size of each A and B subarray that will be merged in the next level
        </span><span class="tok-kw">if</span> (!iterator.nextLevel()) <span class="tok-kw">break</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.pdq.pdq" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pdq</span><a href="#src.zig-std.sort.pdq.pdq">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pdq</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unstable in-place sort. n best case, n*log(n) worst case and average case.
log(n) memory (no allocator required).</p>
<p>Sorts in ascending order with respect to the given <code>lessThan</code> function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>lessThanFn: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.sort.pdq.pdq.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.sort.pdq.pdq.lessThan">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.sort.pdq.pdq.lessThan">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> lessThanFn(ctx.sub_ctx, ctx.items[a], ctx.items[b]);
}</code></pre></details></div></div><div class="decl"><h3 id="std.sort.pdq.pdq.swap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swap</span><a href="#src.zig-std.sort.pdq.pdq.swap">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.sort.pdq.pdq.swap">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;ctx.items[a], &amp;ctx.items[b]);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.pdq.pdq">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pdq</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Context = <span class="tok-kw">struct</span> {
        items: []T,
        sub_ctx: <span class="tok-builtin">@TypeOf</span>(context),

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> lessThanFn(ctx.sub_ctx, ctx.items[a], ctx.items[b]);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;ctx.items[a], &amp;ctx.items[b]);
        }
    };
    <a href="std.sort.pdq.html#std.sort.pdq.pdqContext">pdqContext</a>(<span class="tok-number">0</span>, items.len, Context{ .items = items, .sub_ctx = context });
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.pdq.pdqContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pdqContext</span><a href="#src.zig-std.sort.pdq.pdqContext">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pdqContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unstable in-place sort. O(n) best case, O(n*log(n)) worst case and average case.
O(log(n)) memory (no allocator required).
<code>context</code> must have methods <code>swap</code> and <code>lessThan</code>,
which each take 2 <code>usize</code> parameters indicating the index of an item.
Sorts in ascending order with respect to <code>lessThan</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.pdq.pdqContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pdqContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {<span class="tok-comment">
    // slices of up to this length get sorted using insertion sort.
    </span><span class="tok-kw">const</span> max_insertion = <span class="tok-number">24</span>;<span class="tok-comment">
    // number of allowed imbalanced partitions before switching to heap sort.
    </span><span class="tok-kw">const</span> max_limit = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.floorPowerOfTwo">floorPowerOfTwo</a>(<span class="tok-type">usize</span>, b - a) + <span class="tok-number">1</span>;<span class="tok-comment">

    // set upper bound on stack memory usage.
    </span><span class="tok-kw">const</span> Range = <span class="tok-kw">struct</span> { a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, limit: <span class="tok-type">usize</span> };
    <span class="tok-kw">const</span> stack_size = <a href="std.math.html">math</a>.<a href="std.math.log2.html#std.math.log2.log2">log2</a>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>) + <span class="tok-number">1</span>);
    <span class="tok-kw">var</span> stack: [stack_size]Range = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> range = Range{ .a = a, .b = b, .limit = max_limit };
    <span class="tok-kw">var</span> top: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> was_balanced = <span class="tok-null">true</span>;
        <span class="tok-kw">var</span> was_partitioned = <span class="tok-null">true</span>;

        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">const</span> len = range.b - range.a;<span class="tok-comment">

            // very short slices get sorted using insertion sort.
            </span><span class="tok-kw">if</span> (len &lt;= max_insertion) {
                <span class="tok-kw">break</span> <a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.insertionContext">insertionContext</a>(range.a, range.b, context);
            }<span class="tok-comment">

            // if too many bad pivot choices were made, simply fall back to heapsort in order to
            // guarantee O(n*log(n)) worst-case.
            </span><span class="tok-kw">if</span> (range.limit == <span class="tok-number">0</span>) {
                <span class="tok-kw">break</span> <a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.heapContext">heapContext</a>(range.a, range.b, context);
            }<span class="tok-comment">

            // if the last partitioning was imbalanced, try breaking patterns in the slice by shuffling
            // some elements around. Hopefully we'll choose a better pivot this time.
            </span><span class="tok-kw">if</span> (!was_balanced) {
                <a href="std.sort.pdq.html#std.sort.pdq.breakPatterns">breakPatterns</a>(range.a, range.b, context);
                range.limit -= <span class="tok-number">1</span>;
            }<span class="tok-comment">

            // choose a pivot and try guessing whether the slice is already sorted.
            </span><span class="tok-kw">var</span> pivot: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> hint = <a href="std.sort.pdq.html#std.sort.pdq.chosePivot">chosePivot</a>(range.a, range.b, &amp;pivot, context);

            <span class="tok-kw">if</span> (hint == .decreasing) {<span class="tok-comment">
                // The maximum number of swaps was performed, so items are likely
                // in reverse order. Reverse it to make sorting faster.
                </span><a href="std.sort.pdq.html#std.sort.pdq.reverseRange">reverseRange</a>(range.a, range.b, context);
                pivot = (range.b - <span class="tok-number">1</span>) - (pivot - range.a);
                hint = .increasing;
            }<span class="tok-comment">

            // if the last partitioning was decently balanced and didn't shuffle elements, and if pivot
            // selection predicts the slice is likely already sorted...
            </span><span class="tok-kw">if</span> (was_balanced <span class="tok-kw">and</span> was_partitioned <span class="tok-kw">and</span> hint == .increasing) {<span class="tok-comment">
                // try identifying several out-of-order elements and shifting them to correct
                // positions. If the slice ends up being completely sorted, we're done.
                </span><span class="tok-kw">if</span> (<a href="std.sort.pdq.html#std.sort.pdq.partialInsertionSort">partialInsertionSort</a>(range.a, range.b, context)) <span class="tok-kw">break</span>;
            }<span class="tok-comment">

            // if the chosen pivot is equal to the predecessor, then it's the smallest element in the
            // slice. Partition the slice into elements equal to and elements greater than the pivot.
            // This case is usually hit when the slice contains many duplicate elements.
            </span><span class="tok-kw">if</span> (range.a &gt; a <span class="tok-kw">and</span> !context.lessThan(range.a - <span class="tok-number">1</span>, pivot)) {
                range.a = <a href="std.sort.pdq.html#std.sort.pdq.partitionEqual">partitionEqual</a>(range.a, range.b, pivot, context);
                <span class="tok-kw">continue</span>;
            }<span class="tok-comment">

            // partition the slice.
            </span><span class="tok-kw">var</span> mid = pivot;
            was_partitioned = <a href="std.sort.pdq.html#std.sort.pdq.partition">partition</a>(range.a, range.b, &amp;mid, context);

            <span class="tok-kw">const</span> left_len = mid - range.a;
            <span class="tok-kw">const</span> right_len = range.b - mid;
            <span class="tok-kw">const</span> balanced_threshold = len / <span class="tok-number">8</span>;
            <span class="tok-kw">if</span> (left_len &lt; right_len) {
                was_balanced = left_len &gt;= balanced_threshold;
                stack[top] = .{ .a = range.a, .b = mid, .limit = range.limit };
                top += <span class="tok-number">1</span>;
                range.a = mid + <span class="tok-number">1</span>;
            } <span class="tok-kw">else</span> {
                was_balanced = right_len &gt;= balanced_threshold;
                stack[top] = .{ .a = mid + <span class="tok-number">1</span>, .b = range.b, .limit = range.limit };
                top += <span class="tok-number">1</span>;
                range.b = mid;
            }
        }

        top = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">usize</span>, top, <span class="tok-number">1</span>) <span class="tok-kw">catch</span> <span class="tok-kw">break</span>;
        range = stack[top];
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.insertion" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertion</span><a href="#src.zig-std.sort.insertion">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertion</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Stable in-place sort. O(n) best case, O(pow(n, 2)) worst case.
O(1) memory (no allocator required).
Sorts in ascending order with respect to the given <code>lessThan</code> function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.sort.insertion.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.sort.insertion.lessThan">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.sort.insertion.lessThan">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> lessThanFn(ctx.sub_ctx, ctx.items[a], ctx.items[b]);
}</code></pre></details></div></div><div class="decl"><h3 id="std.sort.insertion.swap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swap</span><a href="#src.zig-std.sort.insertion.swap">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.sort.insertion.swap">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;ctx.items[a], &amp;ctx.items[b]);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.insertion">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertion</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Context = <span class="tok-kw">struct</span> {
        items: []T,
        sub_ctx: <span class="tok-builtin">@TypeOf</span>(context),

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> lessThanFn(ctx.sub_ctx, ctx.items[a], ctx.items[b]);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;ctx.items[a], &amp;ctx.items[b]);
        }
    };
    <a href="std.sort.html#std.sort.insertionContext">insertionContext</a>(<span class="tok-number">0</span>, items.len, Context{ .items = items, .sub_ctx = context });
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.insertionContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">insertionContext</span><a href="#src.zig-std.sort.insertionContext">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertionContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Stable in-place sort. O(n) best case, O(pow(n, 2)) worst case.
O(1) memory (no allocator required).
<code>context</code> must have methods <code>swap</code> and <code>lessThan</code>,
which each take 2 <code>usize</code> parameters indicating the index of an item.
Sorts in ascending order with respect to <code>lessThan</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.insertionContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertionContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(a &lt;= b);

    <span class="tok-kw">var</span> i = a + <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i &lt; b) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> j = i;
        <span class="tok-kw">while</span> (j &gt; a <span class="tok-kw">and</span> context.lessThan(j, j - <span class="tok-number">1</span>)) : (j -= <span class="tok-number">1</span>) {
            context.swap(j, j - <span class="tok-number">1</span>);
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.heap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">heap</span><a href="#src.zig-std.sort.heap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">heap</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unstable in-place sort. O(n*log(n)) best case, worst case and average case.
O(1) memory (no allocator required).
Sorts in ascending order with respect to the given <code>lessThan</code> function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.sort.heap.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.sort.heap.lessThan">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.sort.heap.lessThan">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> lessThanFn(ctx.sub_ctx, ctx.items[a], ctx.items[b]);
}</code></pre></details></div></div><div class="decl"><h3 id="std.sort.heap.swap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swap</span><a href="#src.zig-std.sort.heap.swap">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.sort.heap.swap">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;ctx.items[a], &amp;ctx.items[b]);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.heap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">heap</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Context = <span class="tok-kw">struct</span> {
        items: []T,
        sub_ctx: <span class="tok-builtin">@TypeOf</span>(context),

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> lessThanFn(ctx.sub_ctx, ctx.items[a], ctx.items[b]);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;ctx.items[a], &amp;ctx.items[b]);
        }
    };
    <a href="std.sort.html#std.sort.heapContext">heapContext</a>(<span class="tok-number">0</span>, items.len, Context{ .items = items, .sub_ctx = context });
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.heapContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">heapContext</span><a href="#src.zig-std.sort.heapContext">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">heapContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unstable in-place sort. O(n*log(n)) best case, worst case and average case.
O(1) memory (no allocator required).
<code>context</code> must have methods <code>swap</code> and <code>lessThan</code>,
which each take 2 <code>usize</code> parameters indicating the index of an item.
Sorts in ascending order with respect to <code>lessThan</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.heapContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">heapContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(a &lt;= b);<span class="tok-comment">
    // build the heap in linear time.
    </span><span class="tok-kw">var</span> i = a + (b - a) / <span class="tok-number">2</span>;
    <span class="tok-kw">while</span> (i &gt; a) {
        i -= <span class="tok-number">1</span>;
        <a href="std.sort.html#std.sort.siftDown">siftDown</a>(a, i, b, context);
    }<span class="tok-comment">

    // pop maximal elements from the heap.
    </span>i = b;
    <span class="tok-kw">while</span> (i &gt; a) {
        i -= <span class="tok-number">1</span>;
        context.swap(a, i);
        <a href="std.sort.html#std.sort.siftDown">siftDown</a>(a, a, i, context);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.asc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">asc</span><a href="#src.zig-std.sort.asc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asc</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">fn</span> (<span class="tok-type">void</span>, T, T) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Use to generate a comparator function for a given type. e.g. <code>sort(u8, slice, {}, asc(u8))</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.sort.asc.inner" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inner</span><a href="#src.zig-std.sort.asc.inner">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inner</span>(_: <span class="tok-type">void</span>, a: T, b: T) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>_: <span class="tok-type">void</span></code></pre></div><div><pre><code>a: T</code></pre></div><div><pre><code>b: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.sort.asc.inner">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inner</span>(_: <span class="tok-type">void</span>, a: T, b: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a &lt; b;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.asc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asc</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">fn</span> (<span class="tok-type">void</span>, T, T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inner</span>(_: <span class="tok-type">void</span>, a: T, b: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> a &lt; b;
        }
    }.inner;
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.desc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">desc</span><a href="#src.zig-std.sort.desc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">desc</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">fn</span> (<span class="tok-type">void</span>, T, T) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Use to generate a comparator function for a given type. e.g. <code>sort(u8, slice, {}, desc(u8))</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.sort.desc.inner" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">inner</span><a href="#src.zig-std.sort.desc.inner">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inner</span>(_: <span class="tok-type">void</span>, a: T, b: T) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>_: <span class="tok-type">void</span></code></pre></div><div><pre><code>a: T</code></pre></div><div><pre><code>b: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.sort.desc.inner">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inner</span>(_: <span class="tok-type">void</span>, a: T, b: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a &gt; b;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.desc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">desc</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">fn</span> (<span class="tok-type">void</span>, T, T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inner</span>(_: <span class="tok-type">void</span>, a: T, b: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> a &gt; b;
        }
    }.inner;
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.sort.lessThan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.lessThan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> ctx.items[a] &lt; ctx.items[b];
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.swap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swap</span><a href="#src.zig-std.sort.swap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.swap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<span class="tok-type">i32</span>, &amp;ctx.items[a], &amp;ctx.items[b]);
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.binarySearch" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">binarySearch</span><a href="#src.zig-std.sort.binarySearch">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binarySearch</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>, ) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the index of an element in <code>items</code> returning <code>.eq</code> when given to <code>compareFn</code>.</p>
<ul>
<li>If there are multiple such elements, returns the index of any one of them.</li>
<li>If there are no such elements, returns <code>null</code>.</li>
</ul>
<p><code>items</code> must be sorted in ascending order with respect to <code>compareFn</code>:</p>
<pre><code>[0]                                                   [len]
┌───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┐
│.lt│.lt│ \ \ │.lt│.eq│.eq│ \ \ │.eq│.gt│.gt│ \ \ │.gt│
└───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┘
├─────────────────┼─────────────────┼─────────────────┤
 ↳ zero or more    ↳ zero or more    ↳ zero or more
                  ├─────────────────┤
                   ↳ if not null, returned
                     index is in this range
</code></pre>
<p><code>O(log n)</code> time complexity.</p>
<p>See also: <code>lowerBound, </code>upperBound<code>, </code>partitionPoint<code>, </code>equalRange<code>.</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> binarySearch {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">orderU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderLength</span>(context: <span class="tok-type">usize</span>, item: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item.len);
        }
    };
    <span class="tok-kw">const</span> R = <span class="tok-kw">struct</span> {
        b: <span class="tok-type">i32</span>,
        e: <span class="tok-type">i32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">r</span>(b: <span class="tok-type">i32</span>, e: <span class="tok-type">i32</span>) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{ .b = b, .e = e };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-builtin">@This</span>()) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">if</span> (context &lt; item.b) {
                <span class="tok-kw">return</span> .lt;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (context &gt; item.e) {
                <span class="tok-kw">return</span> .gt;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .eq;
            }
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">0</span>}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">4</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">7</span>, -<span class="tok-number">4</span>, <span class="tok-number">0</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">4</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">100</span>, -<span class="tok-number">25</span>, <span class="tok-number">2</span>, <span class="tok-number">98</span>, <span class="tok-number">99</span>, <span class="tok-number">100</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">98</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>, -<span class="tok-number">50</span>), R.r(-<span class="tok-number">40</span>, -<span class="tok-number">20</span>), R.r(-<span class="tok-number">10</span>, <span class="tok-number">20</span>), R.r(<span class="tok-number">30</span>, <span class="tok-number">40</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">45</span>), R.order));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>, -<span class="tok-number">50</span>), R.r(-<span class="tok-number">40</span>, -<span class="tok-number">20</span>), R.r(-<span class="tok-number">10</span>, <span class="tok-number">20</span>), R.r(<span class="tok-number">30</span>, <span class="tok-number">40</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">10</span>), R.order));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>, -<span class="tok-number">50</span>), R.r(-<span class="tok-number">40</span>, -<span class="tok-number">20</span>), R.r(-<span class="tok-number">10</span>, <span class="tok-number">20</span>), R.r(<span class="tok-number">30</span>, <span class="tok-number">40</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">20</span>), R.order));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;1234&quot;</span>, <span class="tok-str">&quot;vwxyz&quot;</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), S.orderLength));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.binarySearch">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binarySearch</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>,
) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> low: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> high: <span class="tok-type">usize</span> = items.len;

    <span class="tok-kw">while</span> (low &lt; high) {<span class="tok-comment">
        // Avoid overflowing in the midpoint calculation
        </span><span class="tok-kw">const</span> mid = low + (high - low) / <span class="tok-number">2</span>;
        <span class="tok-kw">switch</span> (compareFn(context, items[mid])) {
            .eq =&gt; <span class="tok-kw">return</span> mid,
            .gt =&gt; low = mid + <span class="tok-number">1</span>,
            .lt =&gt; high = mid,
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.lowerBound" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lowerBound</span><a href="#src.zig-std.sort.lowerBound">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lowerBound</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>, ) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the index of the first element in <code>items</code> that is greater than or equal to <code>context</code>,
as determined by <code>compareFn</code>. If no such element exists, returns <code>items.len</code>.</p>
<p><code>items</code> must be sorted in ascending order with respect to <code>compareFn</code>:</p>
<pre><code>[0]                                                   [len]
┌───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┐
│.lt│.lt│ \ \ │.lt│.eq│.eq│ \ \ │.eq│.gt│.gt│ \ \ │.gt│
└───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┘
├─────────────────┼─────────────────┼─────────────────┤
 ↳ zero or more    ↳ zero or more    ↳ zero or more
                  ├───┤
                   ↳ returned index
</code></pre>
<p><code>O(log n)</code> time complexity.</p>
<p>See also: <code><a href="std.sort.html#std.sort.binarySearch">binarySearch</a></code>, <code><a href="std.sort.html#std.sort.upperBound">upperBound</a></code>, <code><a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a></code>, <code><a href="std.sort.html#std.sort.equalRange">equalRange</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> lowerBound {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">compareU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">compareI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">compareF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
    };
    <span class="tok-kw">const</span> R = <span class="tok-kw">struct</span> {
        val: <span class="tok-type">i32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">r</span>(val: <span class="tok-type">i32</span>) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{ .val = val };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">compareFn</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-builtin">@This</span>()) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item.val);
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">5</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">64</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">100</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.compareI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.compareF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>), R.r(-<span class="tok-number">40</span>), R.r(-<span class="tok-number">10</span>), R.r(<span class="tok-number">30</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">20</span>), R.compareFn));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.lowerBound">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lowerBound</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">predicate</span>(ctx: <span class="tok-builtin">@TypeOf</span>(context), item: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> compareFn(ctx, item).invert() == .lt;
        }
    };
    <span class="tok-kw">return</span> <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(T, items, context, S.predicate);
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.upperBound" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">upperBound</span><a href="#src.zig-std.sort.upperBound">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">upperBound</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>, ) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the index of the first element in <code>items</code> that is greater than <code>context</code>, as determined
by <code>compareFn</code>. If no such element exists, returns <code>items.len</code>.</p>
<p><code>items</code> must be sorted in ascending order with respect to <code>compareFn</code>:</p>
<pre><code>[0]                                                   [len]
┌───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┐
│.lt│.lt│ \ \ │.lt│.eq│.eq│ \ \ │.eq│.gt│.gt│ \ \ │.gt│
└───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┘
├─────────────────┼─────────────────┼─────────────────┤
 ↳ zero or more    ↳ zero or more    ↳ zero or more
                                    ├───┤
                                     ↳ returned index
</code></pre>
<p><code>O(log n)</code> time complexity.</p>
<p>See also: <code><a href="std.sort.html#std.sort.binarySearch">binarySearch</a></code>, <code><a href="std.sort.html#std.sort.lowerBound">lowerBound</a></code>, <code><a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a></code>, <code><a href="std.sort.html#std.sort.equalRange">equalRange</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> upperBound {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">compareU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">compareI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">compareF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
    };
    <span class="tok-kw">const</span> R = <span class="tok-kw">struct</span> {
        val: <span class="tok-type">i32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">r</span>(val: <span class="tok-type">i32</span>) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{ .val = val };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">compareFn</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-builtin">@This</span>()) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item.val);
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">64</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">100</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.compareI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.compareF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>), R.r(-<span class="tok-number">40</span>), R.r(-<span class="tok-number">10</span>), R.r(<span class="tok-number">30</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">20</span>), R.compareFn));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.upperBound">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">upperBound</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">predicate</span>(ctx: <span class="tok-builtin">@TypeOf</span>(context), item: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> compareFn(ctx, item).invert() != .gt;
        }
    };
    <span class="tok-kw">return</span> <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(T, items, context, S.predicate);
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.partitionPoint" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">partitionPoint</span><a href="#src.zig-std.sort.partitionPoint">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">partitionPoint</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> predicate: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <span class="tok-type">bool</span>, ) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the index of the partition point of <code>items</code> in relation to the given predicate.</p>
<ul>
<li>If all elements of <code>items</code> satisfy the predicate the returned value is <code>items.len</code>.</li>
</ul>
<p><code>items</code> must contain a prefix for which all elements satisfy the predicate,
and beyond which none of the elements satisfy the predicate:</p>
<pre><code>[0]                                          [len]
┌────┬────┬─/ /─┬────┬─────┬─────┬─/ /─┬─────┐
│true│true│ \ \ │true│false│false│ \ \ │false│
└────┴────┴─/ /─┴────┴─────┴─────┴─/ /─┴─────┘
├────────────────────┼───────────────────────┤
 ↳ zero or more       ↳ zero or more
                     ├─────┤
                      ↳ returned index
</code></pre>
<p><code>O(log n)</code> time complexity.</p>
<p>See also: <code><a href="std.sort.html#std.sort.binarySearch">binarySearch</a></code>, <code>lowerBound, </code>upperBound<code>, </code>equalRange<code>.</code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>predicate: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> partitionPoint {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt; context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt; context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt; context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerEqU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt;= context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerEqI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt;= context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerEqF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt;= context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">isEven</span>(_: <span class="tok-type">void</span>, item: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item % <span class="tok-number">2</span> == <span class="tok-number">0</span>;
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">5</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">64</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">100</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.lowerI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.lowerF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">64</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">100</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.lowerEqI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.lowerEqF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">4</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">50</span>, <span class="tok-number">14</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span>, <span class="tok-number">71</span> }, {}, S.isEven));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.partitionPoint">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">partitionPoint</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> predicate: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <span class="tok-type">bool</span>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> low: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> high: <span class="tok-type">usize</span> = items.len;

    <span class="tok-kw">while</span> (low &lt; high) {
        <span class="tok-kw">const</span> mid = low + (high - low) / <span class="tok-number">2</span>;
        <span class="tok-kw">if</span> (predicate(context, items[mid])) {
            low = mid + <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            high = mid;
        }
    }
    <span class="tok-kw">return</span> low;
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.argMin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">argMin</span><a href="#src.zig-std.sort.argMin">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argMin</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> argMin {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">3</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">9</span>, <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">3</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">6</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">6</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.argMin">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argMin</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (items.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">var</span> smallest = items[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> smallest_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (items[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (lessThan(context, item, smallest)) {
            smallest = item;
            smallest_index = i + <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> smallest_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.min" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">min</span><a href="#src.zig-std.sort.min">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">min</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) ?T</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> min {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">2</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">9</span>, <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, -<span class="tok-number">10</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">6</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">6</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.min">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">min</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) ?T {
    <span class="tok-kw">const</span> i = <a href="std.sort.html#std.sort.argMin">argMin</a>(T, items, context, lessThan) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> items[i];
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.argMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">argMax</span><a href="#src.zig-std.sort.argMax">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argMax</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> argMax {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">4</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">9</span>, <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">6</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">6</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.argMax">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argMax</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (items.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">var</span> biggest = items[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> biggest_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (items[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (lessThan(context, biggest, item)) {
            biggest = item;
            biggest_index = i + <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> biggest_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.max" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">max</span><a href="#src.zig-std.sort.max">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">max</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) ?T</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> max {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">5</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">9</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">9</span>, <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">10</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">6</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">6</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.max">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">max</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) ?T {
    <span class="tok-kw">const</span> i = <a href="std.sort.html#std.sort.argMax">argMax</a>(T, items, context, lessThan) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> items[i];
}</code></pre></details></div></div><div class="decl"><h2 id="std.sort.isSorted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isSorted</span><a href="#src.zig-std.sort.isSorted">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSorted</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []<span class="tok-kw">const</span> T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> isSorted {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">10</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{-<span class="tok-number">20</span>}, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">10</span>, -<span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">4</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, {}, <a href="std.sort.html#std.sort.asc_u8">asc_u8</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;zyxw&quot;</span>, {}, <a href="std.sort.html#std.sort.desc_u8">desc_u8</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, {}, <a href="std.sort.html#std.sort.desc_u8">desc_u8</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;zyxw&quot;</span>, {}, <a href="std.sort.html#std.sort.asc_u8">asc_u8</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;ffff&quot;</span>, {}, <a href="std.sort.html#std.sort.asc_u8">asc_u8</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;ffff&quot;</span>, {}, <a href="std.sort.html#std.sort.desc_u8">desc_u8</a>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.sort.isSorted">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSorted</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i &lt; items.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (lessThan(context, items[i], items[i - <span class="tok-number">1</span>])) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }

    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.sort">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Mode = <span class="tok-kw">enum</span> { stable, unstable };

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> block = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;sort/block.zig&quot;</span>).block;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> pdq = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;sort/pdq.zig&quot;</span>).pdq;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> pdqContext = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;sort/pdq.zig&quot;</span>).pdqContext;

<span class="tok-comment">/// Stable in-place sort. O(n) best case, O(pow(n, 2)) worst case.</span>
<span class="tok-comment">/// O(1) memory (no allocator required).</span>
<span class="tok-comment">/// Sorts in ascending order with respect to the given `lessThan` function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertion</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Context = <span class="tok-kw">struct</span> {
        items: []T,
        sub_ctx: <span class="tok-builtin">@TypeOf</span>(context),

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> lessThanFn(ctx.sub_ctx, ctx.items[a], ctx.items[b]);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;ctx.items[a], &amp;ctx.items[b]);
        }
    };
    <a href="std.sort.html#std.sort.insertionContext">insertionContext</a>(<span class="tok-number">0</span>, items.len, Context{ .items = items, .sub_ctx = context });
}

<span class="tok-comment">/// Stable in-place sort. O(n) best case, O(pow(n, 2)) worst case.</span>
<span class="tok-comment">/// O(1) memory (no allocator required).</span>
<span class="tok-comment">/// `context` must have methods `swap` and `lessThan`,</span>
<span class="tok-comment">/// which each take 2 `usize` parameters indicating the index of an item.</span>
<span class="tok-comment">/// Sorts in ascending order with respect to `lessThan`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertionContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(a &lt;= b);

    <span class="tok-kw">var</span> i = a + <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i &lt; b) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> j = i;
        <span class="tok-kw">while</span> (j &gt; a <span class="tok-kw">and</span> context.lessThan(j, j - <span class="tok-number">1</span>)) : (j -= <span class="tok-number">1</span>) {
            context.swap(j, j - <span class="tok-number">1</span>);
        }
    }
}

<span class="tok-comment">/// Unstable in-place sort. O(n*log(n)) best case, worst case and average case.</span>
<span class="tok-comment">/// O(1) memory (no allocator required).</span>
<span class="tok-comment">/// Sorts in ascending order with respect to the given `lessThan` function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">heap</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Context = <span class="tok-kw">struct</span> {
        items: []T,
        sub_ctx: <span class="tok-builtin">@TypeOf</span>(context),

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> lessThanFn(ctx.sub_ctx, ctx.items[a], ctx.items[b]);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;ctx.items[a], &amp;ctx.items[b]);
        }
    };
    <a href="std.sort.html#std.sort.heapContext">heapContext</a>(<span class="tok-number">0</span>, items.len, Context{ .items = items, .sub_ctx = context });
}

<span class="tok-comment">/// Unstable in-place sort. O(n*log(n)) best case, worst case and average case.</span>
<span class="tok-comment">/// O(1) memory (no allocator required).</span>
<span class="tok-comment">/// `context` must have methods `swap` and `lessThan`,</span>
<span class="tok-comment">/// which each take 2 `usize` parameters indicating the index of an item.</span>
<span class="tok-comment">/// Sorts in ascending order with respect to `lessThan`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">heapContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(a &lt;= b);<span class="tok-comment">
    // build the heap in linear time.
    </span><span class="tok-kw">var</span> i = a + (b - a) / <span class="tok-number">2</span>;
    <span class="tok-kw">while</span> (i &gt; a) {
        i -= <span class="tok-number">1</span>;
        <a href="std.sort.html#std.sort.siftDown">siftDown</a>(a, i, b, context);
    }<span class="tok-comment">

    // pop maximal elements from the heap.
    </span>i = b;
    <span class="tok-kw">while</span> (i &gt; a) {
        i -= <span class="tok-number">1</span>;
        context.swap(a, i);
        <a href="std.sort.html#std.sort.siftDown">siftDown</a>(a, a, i, context);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">siftDown</span>(a: <span class="tok-type">usize</span>, target: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> cur = target;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
        // When we don't overflow from the multiply below, the following expression equals (2*cur) - (2*a) + a + 1
        // The `+ a + 1` is safe because:
        //  for `a &gt; 0` then `2a &gt;= a + 1`.
        //  for `a = 0`, the expression equals `2*cur+1`. `2*cur` is an even number, therefore adding 1 is safe.
        </span><span class="tok-kw">var</span> child = (<a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, cur - a, <span class="tok-number">2</span>) <span class="tok-kw">catch</span> <span class="tok-kw">break</span>) + a + <span class="tok-number">1</span>;<span class="tok-comment">

        // stop if we overshot the boundary
        </span><span class="tok-kw">if</span> (!(child &lt; b)) <span class="tok-kw">break</span>;<span class="tok-comment">

        // `next_child` is at most `b`, therefore no overflow is possible
        </span><span class="tok-kw">const</span> next_child = child + <span class="tok-number">1</span>;<span class="tok-comment">

        // store the greater child in `child`
        </span><span class="tok-kw">if</span> (next_child &lt; b <span class="tok-kw">and</span> context.lessThan(child, next_child)) {
            child = next_child;
        }<span class="tok-comment">

        // stop if the Heap invariant holds at `cur`.
        </span><span class="tok-kw">if</span> (context.lessThan(child, cur)) <span class="tok-kw">break</span>;<span class="tok-comment">

        // swap `cur` with the greater child,
        // move one step down, and continue sifting.
        </span>context.swap(child, cur);
        cur = child;
    }
}

<span class="tok-comment">/// Use to generate a comparator function for a given type. e.g. `sort(u8, slice, {}, asc(u8))`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asc</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">fn</span> (<span class="tok-type">void</span>, T, T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inner</span>(_: <span class="tok-type">void</span>, a: T, b: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> a &lt; b;
        }
    }.inner;
}

<span class="tok-comment">/// Use to generate a comparator function for a given type. e.g. `sort(u8, slice, {}, desc(u8))`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">desc</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-kw">fn</span> (<span class="tok-type">void</span>, T, T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">inner</span>(_: <span class="tok-type">void</span>, a: T, b: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> a &gt; b;
        }
    }.inner;
}

<span class="tok-kw">const</span> asc_u8 = <a href="std.sort.html#std.sort.asc">asc</a>(<span class="tok-type">u8</span>);
<span class="tok-kw">const</span> asc_i32 = <a href="std.sort.html#std.sort.asc">asc</a>(<span class="tok-type">i32</span>);
<span class="tok-kw">const</span> desc_u8 = <a href="std.sort.html#std.sort.desc">desc</a>(<span class="tok-type">u8</span>);
<span class="tok-kw">const</span> desc_i32 = <a href="std.sort.html#std.sort.desc">desc</a>(<span class="tok-type">i32</span>);

<span class="tok-kw">const</span> sort_funcs = &amp;[_]<span class="tok-kw">fn</span> (<span class="tok-kw">comptime</span> <span class="tok-type">type</span>, <span class="tok-kw">anytype</span>, <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> <span class="tok-kw">anytype</span>) <span class="tok-type">void</span>{
    <a href="std.sort.block.html#std.sort.block.block">block</a>,
    <a href="std.sort.pdq.html#std.sort.pdq.pdq">pdq</a>,
    <a href="std.sort.html#std.sort.insertion">insertion</a>,
    <a href="std.sort.html#std.sort.heap">heap</a>,
};

<span class="tok-kw">const</span> context_sort_funcs = &amp;[_]<span class="tok-kw">fn</span> (<span class="tok-type">usize</span>, <span class="tok-type">usize</span>, <span class="tok-kw">anytype</span>) <span class="tok-type">void</span>{<span class="tok-comment">
    // blockContext,
    </span><a href="std.sort.pdq.html#std.sort.pdq.pdqContext">pdqContext</a>,
    <a href="std.sort.html#std.sort.insertionContext">insertionContext</a>,
    <a href="std.sort.html#std.sort.heapContext">heapContext</a>,
};

<span class="tok-kw">const</span> IdAndValue = <span class="tok-kw">struct</span> {
    id: <span class="tok-type">usize</span>,
    value: <span class="tok-type">i32</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(context: <span class="tok-type">void</span>, a: <a href="std.sort.IdAndValue.html">IdAndValue</a>, b: <a href="std.sort.IdAndValue.html">IdAndValue</a>) <span class="tok-type">bool</span> {
        _ = context;
        <span class="tok-kw">return</span> a.value &lt; b.value;
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;stable sort&quot;</span> {
    <span class="tok-kw">const</span> expected = [_]<a href="std.sort.IdAndValue.html">IdAndValue</a>{
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">0</span> },
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">0</span> },
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">0</span> },
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">1</span> },
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">1</span> },
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">1</span> },
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">2</span> },
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">2</span> },
        <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">2</span> },
    };

    <span class="tok-kw">var</span> cases = [_][<span class="tok-number">9</span>]<a href="std.sort.IdAndValue.html">IdAndValue</a>{
        [_]<a href="std.sort.IdAndValue.html">IdAndValue</a>{
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">0</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">1</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">2</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">0</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">1</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">2</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">0</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">1</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">2</span> },
        },
        [_]<a href="std.sort.IdAndValue.html">IdAndValue</a>{
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">2</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">1</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">0</span>, .value = <span class="tok-number">0</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">2</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">1</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">1</span>, .value = <span class="tok-number">0</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">2</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">1</span> },
            <a href="std.sort.IdAndValue.html">IdAndValue</a>{ .id = <span class="tok-number">2</span>, .value = <span class="tok-number">0</span> },
        },
    };

    <span class="tok-kw">for</span> (&amp;cases) |*case| {
        <a href="std.sort.block.html#std.sort.block.block">block</a>(<a href="std.sort.IdAndValue.html">IdAndValue</a>, (case.*)[<span class="tok-number">0</span>..], {}, <a href="std.sort.IdAndValue.html">IdAndValue</a>.<a href="std.sort.IdAndValue.html#std.sort.IdAndValue.lessThan">lessThan</a>);
        <span class="tok-kw">for</span> (case.*, <span class="tok-number">0</span>..) |item, i| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(item.id == expected[i].id);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(item.value == expected[i].value);
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;stable sort fuzz testing&quot;</span> {
    <span class="tok-kw">var</span> prng = <a href="std.html">std</a>.<a href="std.Random.html">Random</a>.<a href="std.Random.Xoshiro256.html">DefaultPrng</a>.<a href="std.Random.Xoshiro256.html#std.Random.Xoshiro256.init">init</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.random_seed">random_seed</a>);
    <span class="tok-kw">const</span> random = prng.random();
    <span class="tok-kw">const</span> test_case_count = <span class="tok-number">10</span>;

    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..test_case_count) |_| {
        <span class="tok-kw">const</span> array_size = random.intRangeLessThan(<span class="tok-type">usize</span>, <span class="tok-number">0</span>, <span class="tok-number">1000</span>);
        <span class="tok-kw">const</span> array = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alloc</a>(<a href="std.sort.IdAndValue.html">IdAndValue</a>, array_size);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(array);<span class="tok-comment">
        // Value is a small random numbers to create collisions.
        // Id is a  reverse index to make sure sorting function only uses provided `lessThan`.
        </span><span class="tok-kw">for</span> (array, <span class="tok-number">0</span>..) |*item, index| {
            item.* = .{
                .value = random.intRangeLessThan(<span class="tok-type">i32</span>, <span class="tok-number">0</span>, <span class="tok-number">100</span>),
                .id = array_size - index,
            };
        }
        <a href="std.sort.block.html#std.sort.block.block">block</a>(<a href="std.sort.IdAndValue.html">IdAndValue</a>, array, {}, <a href="std.sort.IdAndValue.html">IdAndValue</a>.<a href="std.sort.IdAndValue.html#std.sort.IdAndValue.lessThan">lessThan</a>);
        <span class="tok-kw">if</span> (array_size &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">for</span> (array[<span class="tok-number">0</span> .. array_size - <span class="tok-number">1</span>], array[<span class="tok-number">1</span>..]) |x, y| {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(x.value &lt;= y.value);
                <span class="tok-kw">if</span> (x.value == y.value) {
                    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(x.id &gt; y.id);
                }
            }
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sort&quot;</span> {
    <span class="tok-kw">const</span> u8cases = [_][]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
            <span class="tok-str">&quot;&quot;</span>,
            <span class="tok-str">&quot;&quot;</span>,
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
            <span class="tok-str">&quot;a&quot;</span>,
            <span class="tok-str">&quot;a&quot;</span>,
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
            <span class="tok-str">&quot;az&quot;</span>,
            <span class="tok-str">&quot;az&quot;</span>,
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
            <span class="tok-str">&quot;za&quot;</span>,
            <span class="tok-str">&quot;az&quot;</span>,
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
            <span class="tok-str">&quot;asdf&quot;</span>,
            <span class="tok-str">&quot;adfs&quot;</span>,
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
            <span class="tok-str">&quot;one&quot;</span>,
            <span class="tok-str">&quot;eno&quot;</span>,
        },
    };

    <span class="tok-kw">const</span> i32cases = [_][]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{},
            &amp;[_]<span class="tok-type">i32</span>{},
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>},
            &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>},
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, -<span class="tok-number">1</span>, <span class="tok-number">0</span> },
            &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span> },
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">3</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> },
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">55</span>, <span class="tok-number">32</span>, <span class="tok-number">39</span>, <span class="tok-number">58</span>, <span class="tok-number">21</span>, <span class="tok-number">88</span>, <span class="tok-number">43</span>, <span class="tok-number">22</span>, <span class="tok-number">59</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">21</span>, <span class="tok-number">22</span>, <span class="tok-number">32</span>, <span class="tok-number">39</span>, <span class="tok-number">43</span>, <span class="tok-number">55</span>, <span class="tok-number">58</span>, <span class="tok-number">59</span>, <span class="tok-number">88</span> },
        },
    };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.sort.html#std.sort.sort_funcs">sort_funcs</a>) |sortFn| {
        <span class="tok-kw">for</span> (u8cases) |case| {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">20</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> slice = buf[<span class="tok-number">0</span>..case[<span class="tok-number">0</span>].len];
            <span class="tok-builtin">@memcpy</span>(slice, case[<span class="tok-number">0</span>]);
            sortFn(<span class="tok-type">u8</span>, slice, {}, <a href="std.sort.html#std.sort.asc_u8">asc_u8</a>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, slice, case[<span class="tok-number">1</span>]));
        }

        <span class="tok-kw">for</span> (i32cases) |case| {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">20</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> slice = buf[<span class="tok-number">0</span>..case[<span class="tok-number">0</span>].len];
            <span class="tok-builtin">@memcpy</span>(slice, case[<span class="tok-number">0</span>]);
            sortFn(<span class="tok-type">i32</span>, slice, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">i32</span>, slice, case[<span class="tok-number">1</span>]));
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sort descending&quot;</span> {
    <span class="tok-kw">const</span> rev_cases = [_][]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{},
            &amp;[_]<span class="tok-type">i32</span>{},
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>},
            &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>},
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span> },
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span> },
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, -<span class="tok-number">1</span>, <span class="tok-number">0</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span> },
        },
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">3</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span> },
        },
    };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.sort.html#std.sort.sort_funcs">sort_funcs</a>) |sortFn| {
        <span class="tok-kw">for</span> (rev_cases) |case| {
            <span class="tok-kw">var</span> buf: [<span class="tok-number">8</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> slice = buf[<span class="tok-number">0</span>..case[<span class="tok-number">0</span>].len];
            <span class="tok-builtin">@memcpy</span>(slice, case[<span class="tok-number">0</span>]);
            sortFn(<span class="tok-type">i32</span>, slice, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">i32</span>, slice, case[<span class="tok-number">1</span>]));
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sort with context in the middle of a slice&quot;</span> {
    <span class="tok-kw">const</span> Context = <span class="tok-kw">struct</span> {
        items: []<span class="tok-type">i32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> ctx.items[a] &lt; ctx.items[b];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(ctx: <span class="tok-builtin">@This</span>(), a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<span class="tok-type">i32</span>, &amp;ctx.items[a], &amp;ctx.items[b]);
        }
    };

    <span class="tok-kw">const</span> i32cases = [_][]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">i32</span>{
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">8</span>, <span class="tok-number">3</span>, <span class="tok-number">6</span>, <span class="tok-number">5</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span>, <span class="tok-number">9</span>, <span class="tok-number">7</span>, <span class="tok-number">10</span>, <span class="tok-number">55</span>, <span class="tok-number">32</span>, <span class="tok-number">39</span>, <span class="tok-number">58</span>, <span class="tok-number">21</span>, <span class="tok-number">88</span>, <span class="tok-number">43</span>, <span class="tok-number">22</span>, <span class="tok-number">59</span> },
            &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">50</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span>, <span class="tok-number">21</span>, <span class="tok-number">22</span>, <span class="tok-number">32</span>, <span class="tok-number">39</span>, <span class="tok-number">43</span>, <span class="tok-number">55</span>, <span class="tok-number">58</span>, <span class="tok-number">59</span>, <span class="tok-number">88</span> },
        },
    };

    <span class="tok-kw">const</span> ranges = [_]<span class="tok-kw">struct</span> { start: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span> }{
        .{ .start = <span class="tok-number">10</span>, .end = <span class="tok-number">20</span> },
        .{ .start = <span class="tok-number">1</span>, .end = <span class="tok-number">11</span> },
        .{ .start = <span class="tok-number">3</span>, .end = <span class="tok-number">7</span> },
    };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.sort.html#std.sort.context_sort_funcs">context_sort_funcs</a>) |sortFn| {
        <span class="tok-kw">for</span> (i32cases) |case| {
            <span class="tok-kw">for</span> (ranges) |range| {
                <span class="tok-kw">var</span> buf: [<span class="tok-number">20</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> slice = buf[<span class="tok-number">0</span>..case[<span class="tok-number">0</span>].len];
                <span class="tok-builtin">@memcpy</span>(slice, case[<span class="tok-number">0</span>]);
                sortFn(range.start, range.end, Context{ .items = slice });
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">i32</span>, case[<span class="tok-number">1</span>][range.start..range.end], slice[range.start..range.end]);
            }
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sort fuzz testing&quot;</span> {
    <span class="tok-kw">var</span> prng = <a href="std.html">std</a>.<a href="std.Random.html">Random</a>.<a href="std.Random.Xoshiro256.html">DefaultPrng</a>.<a href="std.Random.Xoshiro256.html#std.Random.Xoshiro256.init">init</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.random_seed">random_seed</a>);
    <span class="tok-kw">const</span> random = prng.random();
    <span class="tok-kw">const</span> test_case_count = <span class="tok-number">10</span>;

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.sort.html#std.sort.sort_funcs">sort_funcs</a>) |sortFn| {
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..test_case_count) |_| {
            <span class="tok-kw">const</span> array_size = random.intRangeLessThan(<span class="tok-type">usize</span>, <span class="tok-number">0</span>, <span class="tok-number">1000</span>);
            <span class="tok-kw">const</span> array = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alloc</a>(<span class="tok-type">i32</span>, array_size);
            <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(array);<span class="tok-comment">
            // populate with random data
            </span><span class="tok-kw">for</span> (array) |*item| {
                item.* = random.intRangeLessThan(<span class="tok-type">i32</span>, <span class="tok-number">0</span>, <span class="tok-number">100</span>);
            }
            sortFn(<span class="tok-type">i32</span>, array, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, array, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
        }
    }
}

<span class="tok-comment">/// Returns the index of an element in `items` returning `.eq` when given to `compareFn`.</span>
<span class="tok-comment">/// - If there are multiple such elements, returns the index of any one of them.</span>
<span class="tok-comment">/// - If there are no such elements, returns `null`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `items` must be sorted in ascending order with respect to `compareFn`:</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">/// [0]                                                   [len]</span>
<span class="tok-comment">/// ┌───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┐</span>
<span class="tok-comment">/// │.lt│.lt│ \ \ │.lt│.eq│.eq│ \ \ │.eq│.gt│.gt│ \ \ │.gt│</span>
<span class="tok-comment">/// └───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┘</span>
<span class="tok-comment">/// ├─────────────────┼─────────────────┼─────────────────┤</span>
<span class="tok-comment">///  ↳ zero or more    ↳ zero or more    ↳ zero or more</span>
<span class="tok-comment">///                   ├─────────────────┤</span>
<span class="tok-comment">///                    ↳ if not null, returned</span>
<span class="tok-comment">///                      index is in this range</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `O(log n)` time complexity.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `lowerBound, `upperBound`, `partitionPoint`, `equalRange`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binarySearch</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>,
) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> low: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> high: <span class="tok-type">usize</span> = items.len;

    <span class="tok-kw">while</span> (low &lt; high) {<span class="tok-comment">
        // Avoid overflowing in the midpoint calculation
        </span><span class="tok-kw">const</span> mid = low + (high - low) / <span class="tok-number">2</span>;
        <span class="tok-kw">switch</span> (compareFn(context, items[mid])) {
            .eq =&gt; <span class="tok-kw">return</span> mid,
            .gt =&gt; low = mid + <span class="tok-number">1</span>,
            .lt =&gt; high = mid,
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> binarySearch {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">orderU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderLength</span>(context: <span class="tok-type">usize</span>, item: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item.len);
        }
    };
    <span class="tok-kw">const</span> R = <span class="tok-kw">struct</span> {
        b: <span class="tok-type">i32</span>,
        e: <span class="tok-type">i32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">r</span>(b: <span class="tok-type">i32</span>, e: <span class="tok-type">i32</span>) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{ .b = b, .e = e };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-builtin">@This</span>()) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">if</span> (context &lt; item.b) {
                <span class="tok-kw">return</span> .lt;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (context &gt; item.e) {
                <span class="tok-kw">return</span> .gt;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .eq;
            }
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">0</span>}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">4</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">7</span>, -<span class="tok-number">4</span>, <span class="tok-number">0</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">4</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">100</span>, -<span class="tok-number">25</span>, <span class="tok-number">2</span>, <span class="tok-number">98</span>, <span class="tok-number">99</span>, <span class="tok-number">100</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">98</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>, -<span class="tok-number">50</span>), R.r(-<span class="tok-number">40</span>, -<span class="tok-number">20</span>), R.r(-<span class="tok-number">10</span>, <span class="tok-number">20</span>), R.r(<span class="tok-number">30</span>, <span class="tok-number">40</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">45</span>), R.order));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>, -<span class="tok-number">50</span>), R.r(-<span class="tok-number">40</span>, -<span class="tok-number">20</span>), R.r(-<span class="tok-number">10</span>, <span class="tok-number">20</span>), R.r(<span class="tok-number">30</span>, <span class="tok-number">40</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">10</span>), R.order));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>, -<span class="tok-number">50</span>), R.r(-<span class="tok-number">40</span>, -<span class="tok-number">20</span>), R.r(-<span class="tok-number">10</span>, <span class="tok-number">20</span>), R.r(<span class="tok-number">30</span>, <span class="tok-number">40</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">20</span>), R.order));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.binarySearch">binarySearch</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;1234&quot;</span>, <span class="tok-str">&quot;vwxyz&quot;</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), S.orderLength));
}

<span class="tok-comment">/// Returns the index of the first element in `items` that is greater than or equal to `context`,</span>
<span class="tok-comment">/// as determined by `compareFn`. If no such element exists, returns `items.len`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `items` must be sorted in ascending order with respect to `compareFn`:</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">/// [0]                                                   [len]</span>
<span class="tok-comment">/// ┌───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┐</span>
<span class="tok-comment">/// │.lt│.lt│ \ \ │.lt│.eq│.eq│ \ \ │.eq│.gt│.gt│ \ \ │.gt│</span>
<span class="tok-comment">/// └───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┘</span>
<span class="tok-comment">/// ├─────────────────┼─────────────────┼─────────────────┤</span>
<span class="tok-comment">///  ↳ zero or more    ↳ zero or more    ↳ zero or more</span>
<span class="tok-comment">///                   ├───┤</span>
<span class="tok-comment">///                    ↳ returned index</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `O(log n)` time complexity.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `binarySearch`, `upperBound`, `partitionPoint`, `equalRange`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lowerBound</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">predicate</span>(ctx: <span class="tok-builtin">@TypeOf</span>(context), item: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> compareFn(ctx, item).invert() == .lt;
        }
    };
    <span class="tok-kw">return</span> <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(T, items, context, S.predicate);
}

<span class="tok-kw">test</span> lowerBound {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">compareU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">compareI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">compareF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
    };
    <span class="tok-kw">const</span> R = <span class="tok-kw">struct</span> {
        val: <span class="tok-type">i32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">r</span>(val: <span class="tok-type">i32</span>) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{ .val = val };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">compareFn</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-builtin">@This</span>()) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item.val);
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">5</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">64</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">100</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.compareI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.compareF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>), R.r(-<span class="tok-number">40</span>), R.r(-<span class="tok-number">10</span>), R.r(<span class="tok-number">30</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">20</span>), R.compareFn));
}

<span class="tok-comment">/// Returns the index of the first element in `items` that is greater than `context`, as determined</span>
<span class="tok-comment">/// by `compareFn`. If no such element exists, returns `items.len`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `items` must be sorted in ascending order with respect to `compareFn`:</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">/// [0]                                                   [len]</span>
<span class="tok-comment">/// ┌───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┐</span>
<span class="tok-comment">/// │.lt│.lt│ \ \ │.lt│.eq│.eq│ \ \ │.eq│.gt│.gt│ \ \ │.gt│</span>
<span class="tok-comment">/// └───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┘</span>
<span class="tok-comment">/// ├─────────────────┼─────────────────┼─────────────────┤</span>
<span class="tok-comment">///  ↳ zero or more    ↳ zero or more    ↳ zero or more</span>
<span class="tok-comment">///                                     ├───┤</span>
<span class="tok-comment">///                                      ↳ returned index</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `O(log n)` time complexity.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `binarySearch`, `lowerBound`, `partitionPoint`, `equalRange`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">upperBound</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">predicate</span>(ctx: <span class="tok-builtin">@TypeOf</span>(context), item: T) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> compareFn(ctx, item).invert() != .gt;
        }
    };
    <span class="tok-kw">return</span> <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(T, items, context, S.predicate);
}

<span class="tok-kw">test</span> upperBound {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">compareU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">compareI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">compareF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
    };
    <span class="tok-kw">const</span> R = <span class="tok-kw">struct</span> {
        val: <span class="tok-type">i32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">r</span>(val: <span class="tok-type">i32</span>) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{ .val = val };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">compareFn</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-builtin">@This</span>()) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item.val);
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">64</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">100</span>), S.compareU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.compareI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.compareF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.upperBound">upperBound</a>(R, &amp;[_]R{ R.r(-<span class="tok-number">100</span>), R.r(-<span class="tok-number">40</span>), R.r(-<span class="tok-number">10</span>), R.r(<span class="tok-number">30</span>) }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, -<span class="tok-number">20</span>), R.compareFn));
}

<span class="tok-comment">/// Returns the index of the partition point of `items` in relation to the given predicate.</span>
<span class="tok-comment">/// - If all elements of `items` satisfy the predicate the returned value is `items.len`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `items` must contain a prefix for which all elements satisfy the predicate,</span>
<span class="tok-comment">/// and beyond which none of the elements satisfy the predicate:</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">/// [0]                                          [len]</span>
<span class="tok-comment">/// ┌────┬────┬─/ /─┬────┬─────┬─────┬─/ /─┬─────┐</span>
<span class="tok-comment">/// │true│true│ \ \ │true│false│false│ \ \ │false│</span>
<span class="tok-comment">/// └────┴────┴─/ /─┴────┴─────┴─────┴─/ /─┴─────┘</span>
<span class="tok-comment">/// ├────────────────────┼───────────────────────┤</span>
<span class="tok-comment">///  ↳ zero or more       ↳ zero or more</span>
<span class="tok-comment">///                      ├─────┤</span>
<span class="tok-comment">///                       ↳ returned index</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `O(log n)` time complexity.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `binarySearch`, `lowerBound, `upperBound`, `equalRange`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">partitionPoint</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> predicate: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <span class="tok-type">bool</span>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> low: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> high: <span class="tok-type">usize</span> = items.len;

    <span class="tok-kw">while</span> (low &lt; high) {
        <span class="tok-kw">const</span> mid = low + (high - low) / <span class="tok-number">2</span>;
        <span class="tok-kw">if</span> (predicate(context, items[mid])) {
            low = mid + <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            high = mid;
        }
    }
    <span class="tok-kw">return</span> low;
}

<span class="tok-kw">test</span> partitionPoint {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt; context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt; context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt; context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerEqU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt;= context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerEqI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt;= context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">lowerEqF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item &lt;= context;
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">isEven</span>(_: <span class="tok-type">void</span>, item: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> item % <span class="tok-number">2</span> == <span class="tok-number">0</span>;
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">5</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">64</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">100</span>), S.lowerU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.lowerI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.lowerF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">3</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">8</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">64</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">6</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">100</span>), S.lowerEqU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.lowerEqI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.lowerEqF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">4</span>, <a href="std.sort.html#std.sort.partitionPoint">partitionPoint</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">50</span>, <span class="tok-number">14</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span>, <span class="tok-number">71</span> }, {}, S.isEven));
}

<span class="tok-comment">/// Returns a tuple of the lower and upper indices in `items` between which all</span>
<span class="tok-comment">/// elements return `.eq` when given to `compareFn`.</span>
<span class="tok-comment">/// - If no element in `items` returns `.eq`, both indices are the</span>
<span class="tok-comment">/// index of the first element in `items` returning `.gt`.</span>
<span class="tok-comment">/// - If no element in `items` returns `.gt`, both indices equal `items.len`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `items` must be sorted in ascending order with respect to `compareFn`:</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">/// [0]                                                   [len]</span>
<span class="tok-comment">/// ┌───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┬───┬───┬─/ /─┬───┐</span>
<span class="tok-comment">/// │.lt│.lt│ \ \ │.lt│.eq│.eq│ \ \ │.eq│.gt│.gt│ \ \ │.gt│</span>
<span class="tok-comment">/// └───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┴───┴───┴─/ /─┴───┘</span>
<span class="tok-comment">/// ├─────────────────┼─────────────────┼─────────────────┤</span>
<span class="tok-comment">///  ↳ zero or more    ↳ zero or more    ↳ zero or more</span>
<span class="tok-comment">///                   ├─────────────────┤</span>
<span class="tok-comment">///                    ↳ returned range</span>
<span class="tok-comment">/// ```</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `O(log n)` time complexity.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `binarySearch`, `lowerBound, `upperBound`, `partitionPoint`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">equalRange</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> compareFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), T) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a>,
) <span class="tok-kw">struct</span> { <span class="tok-type">usize</span>, <span class="tok-type">usize</span> } {
    <span class="tok-kw">var</span> low: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> high: <span class="tok-type">usize</span> = items.len;

    <span class="tok-kw">while</span> (low &lt; high) {
        <span class="tok-kw">const</span> mid = low + (high - low) / <span class="tok-number">2</span>;
        <span class="tok-kw">switch</span> (compareFn(context, items[mid])) {
            .gt =&gt; {
                low = mid + <span class="tok-number">1</span>;
            },
            .lt =&gt; {
                high = mid;
            },
            .eq =&gt; {
                <span class="tok-kw">return</span> .{
                    low + <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.lowerBound">lowerBound</a>(
                        T,
                        items[low..mid],
                        context,
                        compareFn,
                    ),
                    mid + <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.upperBound">upperBound</a>(
                        T,
                        items[mid..high],
                        context,
                        compareFn,
                    ),
                };
            },
        }
    }

    <span class="tok-kw">return</span> .{ low, low };
}

<span class="tok-kw">test</span> equalRange {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">orderU32</span>(context: <span class="tok-type">u32</span>, item: <span class="tok-type">u32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderI32</span>(context: <span class="tok-type">i32</span>, item: <span class="tok-type">i32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderF32</span>(context: <span class="tok-type">f32</span>, item: <span class="tok-type">f32</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">orderLength</span>(context: <span class="tok-type">usize</span>, item: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(context, item.len);
        }
    };

    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">0</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">0</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">1</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">2</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">2</span>, <span class="tok-number">2</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">2</span>, <span class="tok-number">3</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">8</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">5</span>, <span class="tok-number">6</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">64</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">6</span>, <span class="tok-number">6</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">100</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">2</span>, <span class="tok-number">6</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>, <span class="tok-number">15</span>, <span class="tok-number">22</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">8</span>), S.orderI32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">2</span>, <span class="tok-number">2</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">3</span>, <span class="tok-number">5</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">u32</span>, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">5</span>), S.orderU32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">1</span>, <span class="tok-number">1</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(<span class="tok-type">f32</span>, &amp;[_]<span class="tok-type">f32</span>{ -<span class="tok-number">54.2</span>, -<span class="tok-number">26.7</span>, <span class="tok-number">0.0</span>, <span class="tok-number">56.55</span>, <span class="tok-number">100.1</span>, <span class="tok-number">322.0</span> }, <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, -<span class="tok-number">33.4</span>), S.orderF32));
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">3</span>, <span class="tok-number">5</span> }, <a href="std.sort.html#std.sort.equalRange">equalRange</a>(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;Mars&quot;</span>, <span class="tok-str">&quot;Venus&quot;</span>, <span class="tok-str">&quot;Earth&quot;</span>, <span class="tok-str">&quot;Saturn&quot;</span>, <span class="tok-str">&quot;Uranus&quot;</span>, <span class="tok-str">&quot;Mercury&quot;</span>, <span class="tok-str">&quot;Jupiter&quot;</span>, <span class="tok-str">&quot;Neptune&quot;</span> },
        <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>),
        S.orderLength,
    ));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argMin</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (items.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">var</span> smallest = items[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> smallest_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (items[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (lessThan(context, item, smallest)) {
            smallest = item;
            smallest_index = i + <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> smallest_index;
}

<span class="tok-kw">test</span> argMin {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">3</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">9</span>, <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">3</span>), <a href="std.sort.html#std.sort.argMin">argMin</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">6</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">6</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">min</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) ?T {
    <span class="tok-kw">const</span> i = <a href="std.sort.html#std.sort.argMin">argMin</a>(T, items, context, lessThan) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> items[i];
}

<span class="tok-kw">test</span> min {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">2</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">9</span>, <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, -<span class="tok-number">10</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), <a href="std.sort.html#std.sort.min">min</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">6</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">6</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argMax</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (items.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">var</span> biggest = items[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> biggest_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (items[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (lessThan(context, biggest, item)) {
            biggest = item;
            biggest_index = i + <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> biggest_index;
}

<span class="tok-kw">test</span> argMax {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-null">null</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">4</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">9</span>, <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">0</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">usize</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.argMax">argMax</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">6</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">6</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">max</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) ?T {
    <span class="tok-kw">const</span> i = <a href="std.sort.html#std.sort.argMax">argMax</a>(T, items, context, lessThan) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> items[i];
}

<span class="tok-kw">test</span> max {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">1</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">5</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">9</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">9</span>, <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">2</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">1</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">10</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), <a href="std.sort.html#std.sort.max">max</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">6</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">6</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSorted</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []<span class="tok-kw">const</span> T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThan: <span class="tok-kw">fn</span> (context: <span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i &lt; items.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (lessThan(context, items[i], items[i - <span class="tok-number">1</span>])) {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }
    }

    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-kw">test</span> isSorted {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{<span class="tok-number">10</span>}, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ -<span class="tok-number">10</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{}, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{-<span class="tok-number">20</span>}, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">10</span>, -<span class="tok-number">10</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">4</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span> }, {}, <a href="std.sort.html#std.sort.asc_i32">asc_i32</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">i32</span>, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }, {}, <a href="std.sort.html#std.sort.desc_i32">desc_i32</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, {}, <a href="std.sort.html#std.sort.asc_u8">asc_u8</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;zyxw&quot;</span>, {}, <a href="std.sort.html#std.sort.desc_u8">desc_u8</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, {}, <a href="std.sort.html#std.sort.desc_u8">desc_u8</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;zyxw&quot;</span>, {}, <a href="std.sort.html#std.sort.asc_u8">asc_u8</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;ffff&quot;</span>, {}, <a href="std.sort.html#std.sort.asc_u8">asc_u8</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.sort.html#std.sort.isSorted">isSorted</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;ffff&quot;</span>, {}, <a href="std.sort.html#std.sort.desc_u8">desc_u8</a>));
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
