<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.mem.html" class="active">mem</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.mem" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.mem</span><a href="#src.zig-std.mem">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.mem.Allocator.html">std.mem.Allocator</a></li><li><a href="std.mem.Alignment.html">std.mem.Alignment</a></li><li><a href="std.mem.DelimiterType.html">std.mem.DelimiterType</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.mem.ValidationAllocator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ValidationAllocator</span><a href="#src.zig-std.mem.ValidationAllocator">[src]</a></h2><div class="tldDocs"><p>Detects and asserts if the std.mem.Allocator interface is violated by the caller
or the allocator.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>underlying_allocator: T</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.mem.ValidationAllocator.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.mem.ValidationAllocator.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(underlying_allocator: T) <span class="tok-builtin">@This</span>()</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>underlying_allocator: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.ValidationAllocator.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(underlying_allocator: T) <span class="tok-builtin">@This</span>() {
    <span class="tok-kw">return</span> .{
        .underlying_allocator = underlying_allocator,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.ValidationAllocator.allocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allocator</span><a href="#src.zig-std.mem.ValidationAllocator.allocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.ValidationAllocator.allocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <a href="std.mem.Allocator.html">Allocator</a> {
    <span class="tok-kw">return</span> .{
        .ptr = self,
        .vtable = &amp;.{
            .alloc = <a href="std.mem.html#std.mem.ValidationAllocator.alloc">alloc</a>,
            .resize = <a href="std.mem.html#std.mem.ValidationAllocator.resize">resize</a>,
            .remap = <a href="std.mem.html#std.mem.ValidationAllocator.remap">remap</a>,
            .free = <a href="std.mem.html#std.mem.ValidationAllocator.free">free</a>,
        },
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.ValidationAllocator.alloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alloc</span><a href="#src.zig-std.mem.ValidationAllocator.alloc">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>( ctx: *<span class="tok-type">anyopaque</span>, n: <span class="tok-type">usize</span>, alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>, ) ?[*]<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: *<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>n: <span class="tok-type">usize</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.ValidationAllocator.alloc">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(
    ctx: *<span class="tok-type">anyopaque</span>,
    n: <span class="tok-type">usize</span>,
    alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>,
    ret_addr: <span class="tok-type">usize</span>,
) ?[*]<span class="tok-type">u8</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(n &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
    <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
    <span class="tok-kw">const</span> result = underlying.rawAlloc(n, alignment, ret_addr) <span class="tok-kw">orelse</span>
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <a href="std.debug.html#std.debug.assert">assert</a>(alignment.check(<span class="tok-builtin">@intFromPtr</span>(result)));
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.ValidationAllocator.resize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">resize</span><a href="#src.zig-std.mem.ValidationAllocator.resize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>( ctx: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>, ) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: *<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.ValidationAllocator.resize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(
    ctx: *<span class="tok-type">anyopaque</span>,
    buf: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    new_len: <span class="tok-type">usize</span>,
    ret_addr: <span class="tok-type">usize</span>,
) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
    <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
    <span class="tok-kw">return</span> underlying.rawResize(buf, alignment, new_len, ret_addr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.ValidationAllocator.remap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remap</span><a href="#src.zig-std.mem.ValidationAllocator.remap">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remap</span>( ctx: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>, ) ?[*]<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: *<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.ValidationAllocator.remap">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remap</span>(
    ctx: *<span class="tok-type">anyopaque</span>,
    buf: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    new_len: <span class="tok-type">usize</span>,
    ret_addr: <span class="tok-type">usize</span>,
) ?[*]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
    <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
    <span class="tok-kw">return</span> underlying.rawRemap(buf, alignment, new_len, ret_addr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.ValidationAllocator.free" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">free</span><a href="#src.zig-std.mem.ValidationAllocator.free">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>( ctx: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>, alignment: <a href="std.mem.Alignment.html">Alignment</a>, ret_addr: <span class="tok-type">usize</span>, ) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>ctx: *<span class="tok-type">anyopaque</span></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>alignment: <a href="std.mem.Alignment.html">Alignment</a></code></pre></div><div><pre><code>ret_addr: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.ValidationAllocator.free">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(
    ctx: *<span class="tok-type">anyopaque</span>,
    buf: []<span class="tok-type">u8</span>,
    alignment: <a href="std.mem.Alignment.html">Alignment</a>,
    ret_addr: <span class="tok-type">usize</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
    <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
    underlying.rawFree(buf, alignment, ret_addr);
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.ValidationAllocator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.mem.ValidationAllocator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.ValidationAllocator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <span class="tok-type">void</span> {
    self.underlying_allocator.reset();
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.ValidationAllocator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ValidationAllocator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        underlying_allocator: T,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(underlying_allocator: T) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{
                .underlying_allocator = underlying_allocator,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <a href="std.mem.Allocator.html">Allocator</a> {
            <span class="tok-kw">return</span> .{
                .ptr = self,
                .vtable = &amp;.{
                    .alloc = <a href="std.mem.html#std.mem.ValidationAllocator.alloc">alloc</a>,
                    .resize = <a href="std.mem.html#std.mem.ValidationAllocator.resize">resize</a>,
                    .remap = <a href="std.mem.html#std.mem.ValidationAllocator.remap">remap</a>,
                    .free = <a href="std.mem.html#std.mem.ValidationAllocator.free">free</a>,
                },
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getUnderlyingAllocatorPtr</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <a href="std.mem.Allocator.html">Allocator</a> {
            <span class="tok-kw">if</span> (T == <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-kw">return</span> self.underlying_allocator;
            <span class="tok-kw">return</span> self.underlying_allocator.allocator();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(
            ctx: *<span class="tok-type">anyopaque</span>,
            n: <span class="tok-type">usize</span>,
            alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>,
            ret_addr: <span class="tok-type">usize</span>,
        ) ?[*]<span class="tok-type">u8</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(n &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
            <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
            <span class="tok-kw">const</span> result = underlying.rawAlloc(n, alignment, ret_addr) <span class="tok-kw">orelse</span>
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(alignment.check(<span class="tok-builtin">@intFromPtr</span>(result)));
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(
            ctx: *<span class="tok-type">anyopaque</span>,
            buf: []<span class="tok-type">u8</span>,
            alignment: <a href="std.mem.Alignment.html">Alignment</a>,
            new_len: <span class="tok-type">usize</span>,
            ret_addr: <span class="tok-type">usize</span>,
        ) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
            <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
            <span class="tok-kw">return</span> underlying.rawResize(buf, alignment, new_len, ret_addr);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remap</span>(
            ctx: *<span class="tok-type">anyopaque</span>,
            buf: []<span class="tok-type">u8</span>,
            alignment: <a href="std.mem.Alignment.html">Alignment</a>,
            new_len: <span class="tok-type">usize</span>,
            ret_addr: <span class="tok-type">usize</span>,
        ) ?[*]<span class="tok-type">u8</span> {
            <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
            <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
            <span class="tok-kw">return</span> underlying.rawRemap(buf, alignment, new_len, ret_addr);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(
            ctx: *<span class="tok-type">anyopaque</span>,
            buf: []<span class="tok-type">u8</span>,
            alignment: <a href="std.mem.Alignment.html">Alignment</a>,
            ret_addr: <span class="tok-type">usize</span>,
        ) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
            <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
            underlying.rawFree(buf, alignment, ret_addr);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <span class="tok-type">void</span> {
            self.underlying_allocator.reset();
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.WindowIterator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">WindowIterator</span><a href="#src.zig-std.mem.WindowIterator">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>index: ?<span class="tok-type">usize</span></code></pre></div><div><pre><code>size: <span class="tok-type">usize</span></code></pre></div><div><pre><code>advance: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.mem.WindowIterator.first" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">first</span><a href="#src.zig-std.mem.WindowIterator.first">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the first window.
Call this only to get the first window and then use <code>next</code> to get
all subsequent windows.
Asserts that iteration has not begun.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.WindowIterator.first">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) []<span class="tok-kw">const</span> T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.next().?;
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.WindowIterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.mem.WindowIterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) ?[]<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the next window, or null if window is at end.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.WindowIterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
    <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> next_index = start + self.advance;
    <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (start + self.size &lt; self.buffer.len <span class="tok-kw">and</span> next_index &lt; self.buffer.len) blk: {
        self.index = next_index;
        <span class="tok-kw">break</span> :blk start + self.size;
    } <span class="tok-kw">else</span> blk: {
        self.index = <span class="tok-null">null</span>;
        <span class="tok-kw">break</span> :blk self.buffer.len;
    };

    <span class="tok-kw">return</span> self.buffer[start..end];
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.WindowIterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.mem.WindowIterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Resets the iterator to the initial window.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.WindowIterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) <span class="tok-type">void</span> {
    self.index = <span class="tok-number">0</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.WindowIterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">WindowIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        buffer: []<span class="tok-kw">const</span> T,
        index: ?<span class="tok-type">usize</span>,
        size: <span class="tok-type">usize</span>,
        advance: <span class="tok-type">usize</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Returns a slice of the first window.</span>
        <span class="tok-comment">/// Call this only to get the first window and then use `next` to get</span>
        <span class="tok-comment">/// all subsequent windows.</span>
        <span class="tok-comment">/// Asserts that iteration has not begun.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> self.next().?;
        }

        <span class="tok-comment">/// Returns a slice of the next window, or null if window is at end.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> next_index = start + self.advance;
            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (start + self.size &lt; self.buffer.len <span class="tok-kw">and</span> next_index &lt; self.buffer.len) blk: {
                self.index = next_index;
                <span class="tok-kw">break</span> :blk start + self.size;
            } <span class="tok-kw">else</span> blk: {
                self.index = <span class="tok-null">null</span>;
                <span class="tok-kw">break</span> :blk self.buffer.len;
            };

            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Resets the iterator to the initial window.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.TokenIterator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">TokenIterator</span><a href="#src.zig-std.mem.TokenIterator">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
    .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
    .scalar =&gt; T,
}</code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.mem.TokenIterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.mem.TokenIterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) ?[]<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the current token, or null if tokenization is
complete, and advances to the next token.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.TokenIterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
    <span class="tok-kw">const</span> result = self.peek() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    self.index += result.len;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.TokenIterator.peek" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">peek</span><a href="#src.zig-std.mem.TokenIterator.peek">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) ?[]<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the current token, or null if tokenization is
complete. Does not advance to the next token.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.TokenIterator.peek">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {<span class="tok-comment">
    // move to beginning of token
    </span><span class="tok-kw">while</span> (self.index &lt; self.buffer.len <span class="tok-kw">and</span> self.isDelimiter(self.index)) : (self.index += <span class="tok-kw">switch</span> (delimiter_type) {
        .sequence =&gt; self.delimiter.len,
        .any, .scalar =&gt; <span class="tok-number">1</span>,
    }) {}
    <span class="tok-kw">const</span> start = self.index;
    <span class="tok-kw">if</span> (start == self.buffer.len) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }<span class="tok-comment">

    // move to end of token
    </span><span class="tok-kw">var</span> end = start;
    <span class="tok-kw">while</span> (end &lt; self.buffer.len <span class="tok-kw">and</span> !self.isDelimiter(end)) : (end += <span class="tok-number">1</span>) {}

    <span class="tok-kw">return</span> self.buffer[start..end];
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.TokenIterator.rest" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rest</span><a href="#src.zig-std.mem.TokenIterator.rest">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.TokenIterator">Self</a>) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the remaining bytes. Does not affect iterator state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.mem.html#std.mem.TokenIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.TokenIterator.rest">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.TokenIterator">Self</a>) []<span class="tok-kw">const</span> T {<span class="tok-comment">
    // move to beginning of token
    </span><span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = self.index;
    <span class="tok-kw">while</span> (index &lt; self.buffer.len <span class="tok-kw">and</span> self.isDelimiter(index)) : (index += <span class="tok-kw">switch</span> (delimiter_type) {
        .sequence =&gt; self.delimiter.len,
        .any, .scalar =&gt; <span class="tok-number">1</span>,
    }) {}
    <span class="tok-kw">return</span> self.buffer[index..];
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.TokenIterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.mem.TokenIterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Resets the iterator to the initial token.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.TokenIterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) <span class="tok-type">void</span> {
    self.index = <span class="tok-number">0</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.TokenIterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TokenIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        buffer: []<span class="tok-kw">const</span> T,
        delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
            .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
            .scalar =&gt; T,
        },
        index: <span class="tok-type">usize</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Returns a slice of the current token, or null if tokenization is</span>
        <span class="tok-comment">/// complete, and advances to the next token.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> result = self.peek() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.index += result.len;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a slice of the current token, or null if tokenization is</span>
        <span class="tok-comment">/// complete. Does not advance to the next token.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {<span class="tok-comment">
            // move to beginning of token
            </span><span class="tok-kw">while</span> (self.index &lt; self.buffer.len <span class="tok-kw">and</span> self.isDelimiter(self.index)) : (self.index += <span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; self.delimiter.len,
                .any, .scalar =&gt; <span class="tok-number">1</span>,
            }) {}
            <span class="tok-kw">const</span> start = self.index;
            <span class="tok-kw">if</span> (start == self.buffer.len) {
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }<span class="tok-comment">

            // move to end of token
            </span><span class="tok-kw">var</span> end = start;
            <span class="tok-kw">while</span> (end &lt; self.buffer.len <span class="tok-kw">and</span> !self.isDelimiter(end)) : (end += <span class="tok-number">1</span>) {}

            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Returns a slice of the remaining bytes. Does not affect iterator state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.TokenIterator">Self</a>) []<span class="tok-kw">const</span> T {<span class="tok-comment">
            // move to beginning of token
            </span><span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = self.index;
            <span class="tok-kw">while</span> (index &lt; self.buffer.len <span class="tok-kw">and</span> self.isDelimiter(index)) : (index += <span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; self.delimiter.len,
                .any, .scalar =&gt; <span class="tok-number">1</span>,
            }) {}
            <span class="tok-kw">return</span> self.buffer[index..];
        }

        <span class="tok-comment">/// Resets the iterator to the initial token.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">isDelimiter</span>(self: <a href="std.mem.html#std.mem.TokenIterator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.startsWith">startsWith</a>(T, self.buffer[index..], self.delimiter),
                .any =&gt; {
                    <span class="tok-kw">const</span> item = self.buffer[index];
                    <span class="tok-kw">for</span> (self.delimiter) |delimiter_item| {
                        <span class="tok-kw">if</span> (item == delimiter_item) {
                            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                        }
                    }
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                },
                .scalar =&gt; <span class="tok-kw">return</span> self.buffer[index] == self.delimiter,
            }
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.SplitIterator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">SplitIterator</span><a href="#src.zig-std.mem.SplitIterator">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>index: ?<span class="tok-type">usize</span></code></pre></div><div><pre><code>delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
    .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
    .scalar =&gt; T,
}</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.mem.SplitIterator.first" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">first</span><a href="#src.zig-std.mem.SplitIterator.first">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the first field.
Call this only to get the first field and then use <code>next</code> to get all subsequent fields.
Asserts that iteration has not begun.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitIterator.first">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) []<span class="tok-kw">const</span> T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.next().?;
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.SplitIterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.mem.SplitIterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) ?[]<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the next field, or null if splitting is complete.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitIterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
    <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
        .sequence =&gt; <a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, self.buffer, start, self.delimiter),
        .any =&gt; <a href="std.mem.html#std.mem.indexOfAnyPos">indexOfAnyPos</a>(T, self.buffer, start, self.delimiter),
        .scalar =&gt; <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, self.buffer, start, self.delimiter),
    }) |delim_start| blk: {
        self.index = delim_start + <span class="tok-kw">switch</span> (delimiter_type) {
            .sequence =&gt; self.delimiter.len,
            .any, .scalar =&gt; <span class="tok-number">1</span>,
        };
        <span class="tok-kw">break</span> :blk delim_start;
    } <span class="tok-kw">else</span> blk: {
        self.index = <span class="tok-null">null</span>;
        <span class="tok-kw">break</span> :blk self.buffer.len;
    };
    <span class="tok-kw">return</span> self.buffer[start..end];
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.SplitIterator.peek" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">peek</span><a href="#src.zig-std.mem.SplitIterator.peek">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) ?[]<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the next field, or null if splitting is complete.
This method does not alter self.index.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitIterator.peek">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
    <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
        .sequence =&gt; <a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, self.buffer, start, self.delimiter),
        .any =&gt; <a href="std.mem.html#std.mem.indexOfAnyPos">indexOfAnyPos</a>(T, self.buffer, start, self.delimiter),
        .scalar =&gt; <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, self.buffer, start, self.delimiter),
    }) |delim_start| delim_start <span class="tok-kw">else</span> self.buffer.len;
    <span class="tok-kw">return</span> self.buffer[start..end];
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.SplitIterator.rest" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rest</span><a href="#src.zig-std.mem.SplitIterator.rest">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.SplitIterator">Self</a>) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the remaining bytes. Does not affect iterator state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.mem.html#std.mem.SplitIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitIterator.rest">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.SplitIterator">Self</a>) []<span class="tok-kw">const</span> T {
    <span class="tok-kw">const</span> end = self.buffer.len;
    <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> end;
    <span class="tok-kw">return</span> self.buffer[start..end];
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.SplitIterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.mem.SplitIterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Resets the iterator to the initial slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitIterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) <span class="tok-type">void</span> {
    self.index = <span class="tok-number">0</span>;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.SplitIterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SplitIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        buffer: []<span class="tok-kw">const</span> T,
        index: ?<span class="tok-type">usize</span>,
        delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
            .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
            .scalar =&gt; T,
        },

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Returns a slice of the first field.</span>
        <span class="tok-comment">/// Call this only to get the first field and then use `next` to get all subsequent fields.</span>
        <span class="tok-comment">/// Asserts that iteration has not begun.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> self.next().?;
        }

        <span class="tok-comment">/// Returns a slice of the next field, or null if splitting is complete.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; <a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, self.buffer, start, self.delimiter),
                .any =&gt; <a href="std.mem.html#std.mem.indexOfAnyPos">indexOfAnyPos</a>(T, self.buffer, start, self.delimiter),
                .scalar =&gt; <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, self.buffer, start, self.delimiter),
            }) |delim_start| blk: {
                self.index = delim_start + <span class="tok-kw">switch</span> (delimiter_type) {
                    .sequence =&gt; self.delimiter.len,
                    .any, .scalar =&gt; <span class="tok-number">1</span>,
                };
                <span class="tok-kw">break</span> :blk delim_start;
            } <span class="tok-kw">else</span> blk: {
                self.index = <span class="tok-null">null</span>;
                <span class="tok-kw">break</span> :blk self.buffer.len;
            };
            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Returns a slice of the next field, or null if splitting is complete.</span>
        <span class="tok-comment">/// This method does not alter self.index.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; <a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, self.buffer, start, self.delimiter),
                .any =&gt; <a href="std.mem.html#std.mem.indexOfAnyPos">indexOfAnyPos</a>(T, self.buffer, start, self.delimiter),
                .scalar =&gt; <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, self.buffer, start, self.delimiter),
            }) |delim_start| delim_start <span class="tok-kw">else</span> self.buffer.len;
            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Returns a slice of the remaining bytes. Does not affect iterator state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.SplitIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> end = self.buffer.len;
            <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> end;
            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Resets the iterator to the initial slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.SplitBackwardsIterator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">SplitBackwardsIterator</span><a href="#src.zig-std.mem.SplitBackwardsIterator">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>index: ?<span class="tok-type">usize</span></code></pre></div><div><pre><code>delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
    .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
    .scalar =&gt; T,
}</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.mem.SplitBackwardsIterator.first" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">first</span><a href="#src.zig-std.mem.SplitBackwardsIterator.first">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the first field.
Call this only to get the first field and then use <code>next</code> to get all subsequent fields.
Asserts that iteration has not begun.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitBackwardsIterator.first">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) []<span class="tok-kw">const</span> T {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == self.buffer.len);
    <span class="tok-kw">return</span> self.next().?;
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.SplitBackwardsIterator.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.mem.SplitBackwardsIterator.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) ?[]<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the next field, or null if splitting is complete.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitBackwardsIterator.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
    <span class="tok-kw">const</span> end = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> start = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
        .sequence =&gt; <a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
        .any =&gt; <a href="std.mem.html#std.mem.lastIndexOfAny">lastIndexOfAny</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
        .scalar =&gt; <a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
    }) |delim_start| blk: {
        self.index = delim_start;
        <span class="tok-kw">break</span> :blk delim_start + <span class="tok-kw">switch</span> (delimiter_type) {
            .sequence =&gt; self.delimiter.len,
            .any, .scalar =&gt; <span class="tok-number">1</span>,
        };
    } <span class="tok-kw">else</span> blk: {
        self.index = <span class="tok-null">null</span>;
        <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
    };
    <span class="tok-kw">return</span> self.buffer[start..end];
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.SplitBackwardsIterator.rest" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rest</span><a href="#src.zig-std.mem.SplitBackwardsIterator.rest">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Returns a slice of the remaining bytes. Does not affect iterator state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitBackwardsIterator.rest">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) []<span class="tok-kw">const</span> T {
    <span class="tok-kw">const</span> end = self.index <span class="tok-kw">orelse</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> self.buffer[<span class="tok-number">0</span>..end];
}</code></pre></details></div></div><div class="decl"><h3 id="std.mem.SplitBackwardsIterator.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.mem.SplitBackwardsIterator.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Resets the iterator to the initial slice.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.mem.SplitBackwardsIterator.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) <span class="tok-type">void</span> {
    self.index = self.buffer.len;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.SplitBackwardsIterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SplitBackwardsIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        buffer: []<span class="tok-kw">const</span> T,
        index: ?<span class="tok-type">usize</span>,
        delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
            .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
            .scalar =&gt; T,
        },

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Returns a slice of the first field.</span>
        <span class="tok-comment">/// Call this only to get the first field and then use `next` to get all subsequent fields.</span>
        <span class="tok-comment">/// Asserts that iteration has not begun.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == self.buffer.len);
            <span class="tok-kw">return</span> self.next().?;
        }

        <span class="tok-comment">/// Returns a slice of the next field, or null if splitting is complete.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> end = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> start = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; <a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
                .any =&gt; <a href="std.mem.html#std.mem.lastIndexOfAny">lastIndexOfAny</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
                .scalar =&gt; <a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
            }) |delim_start| blk: {
                self.index = delim_start;
                <span class="tok-kw">break</span> :blk delim_start + <span class="tok-kw">switch</span> (delimiter_type) {
                    .sequence =&gt; self.delimiter.len,
                    .any, .scalar =&gt; <span class="tok-number">1</span>,
                };
            } <span class="tok-kw">else</span> blk: {
                self.index = <span class="tok-null">null</span>;
                <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
            };
            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Returns a slice of the remaining bytes. Does not affect iterator state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> end = self.index <span class="tok-kw">orelse</span> <span class="tok-number">0</span>;
            <span class="tok-kw">return</span> self.buffer[<span class="tok-number">0</span>..end];
        }

        <span class="tok-comment">/// Resets the iterator to the initial slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) <span class="tok-type">void</span> {
            self.index = self.buffer.len;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.minMax" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">minMax</span><a href="#src.zig-std.mem.minMax">[src]</a></h2><div class="tldDocs"><p>Finds the smallest and largest number in a slice. O(n).
Returns an anonymous struct with the fields <code><a href="std.mem.html#std.mem.min">min</a></code> and <code><a href="std.mem.html#std.mem.max">max</a></code>.
<code>slice</code> must not be empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> minMax {
    {
        <span class="tok-kw">const</span> actual_min, <span class="tok-kw">const</span> actual_max = minMax(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), actual_min);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'g'</span>), actual_max);
    }
    {
        <span class="tok-kw">const</span> actual_min, <span class="tok-kw">const</span> actual_max = minMax(<span class="tok-type">u8</span>, <span class="tok-str">&quot;bcdefga&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), actual_min);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'g'</span>), actual_max);
    }
    {
        <span class="tok-kw">const</span> actual_min, <span class="tok-kw">const</span> actual_max = minMax(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), actual_min);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), actual_max);
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.minMax">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">minMax</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-kw">struct</span> { T, T } {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> running_minimum = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> running_maximum = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..]) |item| {
        running_minimum = <span class="tok-builtin">@min</span>(running_minimum, item);
        running_maximum = <span class="tok-builtin">@max</span>(running_maximum, item);
    }
    <span class="tok-kw">return</span> .{ running_minimum, running_maximum };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfMinMax" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">indexOfMinMax</span><a href="#src.zig-std.mem.indexOfMinMax">[src]</a></h2><div class="tldDocs"><p>Finds the indices of the smallest and largest number in a slice. O(n).
Returns the indices of the smallest and largest numbers in that order.
<code>slice</code> must not be empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> indexOfMinMax {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">6</span> }, <a href="std.mem.html#std.mem.indexOfMinMax">indexOfMinMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">1</span>, <span class="tok-number">0</span> }, <a href="std.mem.html#std.mem.indexOfMinMax">indexOfMinMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;gabcdef&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">0</span> }, <a href="std.mem.html#std.mem.indexOfMinMax">indexOfMinMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfMinMax">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfMinMax</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-kw">struct</span> { <span class="tok-type">usize</span>, <span class="tok-type">usize</span> } {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> minVal = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> maxVal = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> minIdx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> maxIdx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (item &lt; minVal) {
            minVal = item;
            minIdx = i + <span class="tok-number">1</span>;
        }
        <span class="tok-kw">if</span> (item &gt; maxVal) {
            maxVal = item;
            maxIdx = i + <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> .{ minIdx, maxIdx };
}</code></pre></details></div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.mem.byte_size_in_bits" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">byte_size_in_bits</span><a href="#src.zig-std.mem.byte_size_in_bits">[src]</a></h2><div class="tldDocs"><p>The standard library currently thoroughly depends on byte size
being 8 bits.  (see the use of u8 throughout allocation code as
the &quot;byte&quot; type.)  Code which depends on this can reference this
declaration.  If we ever try to port the standard library to a
non-8-bit-byte platform, this will allow us to search for things
which need to be updated.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.byte_size_in_bits">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> byte_size_in_bits = <span class="tok-number">8</span></code></pre></details></div></div><div class="decl"><h2 id="std.mem.readPackedIntNative" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">readPackedIntNative</span><a href="#src.zig-std.mem.readPackedIntNative">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.readPackedIntNative">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> readPackedIntNative = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
    .little =&gt; <a href="std.mem.html#std.mem.readPackedIntLittle">readPackedIntLittle</a>,
    .big =&gt; <a href="std.mem.html#std.mem.readPackedIntBig">readPackedIntBig</a>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.readPackedIntForeign" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">readPackedIntForeign</span><a href="#src.zig-std.mem.readPackedIntForeign">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.readPackedIntForeign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> readPackedIntForeign = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
    .little =&gt; <a href="std.mem.html#std.mem.readPackedIntBig">readPackedIntBig</a>,
    .big =&gt; <a href="std.mem.html#std.mem.readPackedIntLittle">readPackedIntLittle</a>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.writePackedIntNative" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">writePackedIntNative</span><a href="#src.zig-std.mem.writePackedIntNative">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.writePackedIntNative">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> writePackedIntNative = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
    .little =&gt; <a href="std.mem.html#std.mem.writePackedIntLittle">writePackedIntLittle</a>,
    .big =&gt; <a href="std.mem.html#std.mem.writePackedIntBig">writePackedIntBig</a>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.writePackedIntForeign" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">writePackedIntForeign</span><a href="#src.zig-std.mem.writePackedIntForeign">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.writePackedIntForeign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> writePackedIntForeign = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
    .little =&gt; <a href="std.mem.html#std.mem.writePackedIntBig">writePackedIntBig</a>,
    .big =&gt; <a href="std.mem.html#std.mem.writePackedIntLittle">writePackedIntLittle</a>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.tokenize" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">tokenize</span><a href="#src.zig-std.mem.tokenize">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.tokenize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> tokenize = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; use tokenizeAny, tokenizeSequence, or tokenizeScalar&quot;</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.mem.split" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">split</span><a href="#src.zig-std.mem.split">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.split">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> split = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; use splitSequence, splitAny, or splitScalar&quot;</span>)</code></pre></details></div></div><div class="decl"><h2 id="std.mem.splitBackwards" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">splitBackwards</span><a href="#src.zig-std.mem.splitBackwards">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.splitBackwards">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> splitBackwards = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; use splitBackwardsSequence, splitBackwardsAny, or splitBackwardsScalar&quot;</span>)</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.mem.validationWrap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">validationWrap</span><a href="#src.zig-std.mem.validationWrap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validationWrap</span>(allocator: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.ValidationAllocator">ValidationAllocator</a>(<span class="tok-builtin">@TypeOf</span>(allocator))</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.validationWrap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validationWrap</span>(allocator: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.ValidationAllocator">ValidationAllocator</a>(<span class="tok-builtin">@TypeOf</span>(allocator)) {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.ValidationAllocator">ValidationAllocator</a>(<span class="tok-builtin">@TypeOf</span>(allocator)).init(allocator);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignAllocLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignAllocLen</span><a href="#src.zig-std.mem.alignAllocLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignAllocLen</span>(full_len: <span class="tok-type">usize</span>, alloc_len: <span class="tok-type">usize</span>, len_align: <span class="tok-type">u29</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>An allocator helper function.  Adjusts an allocation length satisfy <code>len_align</code>.
<code>full_len</code> should be the full capacity of the allocation which may be greater
than the <code><a href="std.mem.html#std.mem.len">len</a></code> that was requested.  This function should only be used by allocators
that are unaffected by <code>len_align</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>full_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>alloc_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>len_align: <span class="tok-type">u29</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignAllocLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignAllocLen</span>(full_len: <span class="tok-type">usize</span>, alloc_len: <span class="tok-type">usize</span>, len_align: <span class="tok-type">u29</span>) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(alloc_len &gt; <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(alloc_len &gt;= len_align);
    <a href="std.debug.html#std.debug.assert">assert</a>(full_len &gt;= alloc_len);
    <span class="tok-kw">if</span> (len_align == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> alloc_len;
    <span class="tok-kw">const</span> adjusted = <a href="std.mem.html#std.mem.alignBackwardAnyAlign">alignBackwardAnyAlign</a>(<span class="tok-type">usize</span>, full_len, len_align);
    <a href="std.debug.html#std.debug.assert">assert</a>(adjusted &gt;= alloc_len);
    <span class="tok-kw">return</span> adjusted;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.copyForwards" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copyForwards</span><a href="#src.zig-std.mem.copyForwards">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyForwards</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, dest: []T, source: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Copy all of source into dest at position 0.
dest.len must be &gt;= source.len.
If the slices overlap, dest.ptr must be &lt;= src.ptr.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>dest: []T</code></pre></div><div><pre><code>source: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.copyForwards">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyForwards</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, dest: []T, source: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (dest[<span class="tok-number">0</span>..source.len], source) |*d, s| d.* = s;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.copyBackwards" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copyBackwards</span><a href="#src.zig-std.mem.copyBackwards">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyBackwards</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, dest: []T, source: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Copy all of source into dest at position 0.
dest.len must be &gt;= source.len.
If the slices overlap, dest.ptr must be &gt;= src.ptr.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>dest: []T</code></pre></div><div><pre><code>source: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.copyBackwards">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyBackwards</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, dest: []T, source: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {<span class="tok-comment">
    // TODO instead of manually doing this check for the whole array
    // and turning off runtime safety, the compiler should detect loops like
    // this and automatically omit safety checks for loops
    </span><span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(dest.len &gt;= source.len);
    <span class="tok-kw">var</span> i = source.len;
    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        dest[i] = source[i];
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.zeroes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">zeroes</span><a href="#src.zig-std.mem.zeroes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroes</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre></div><div class="tldDocs"><p>Generally, Zig users are encouraged to explicitly initialize all fields of a struct explicitly rather than using this function.
However, it is recognized that there are sometimes use cases for initializing all fields to a &quot;zero&quot; value. For example, when
interfacing with a C API where this practice is more common and relied upon. If you are performing code review and see this
function used, examine closely - it may be a code smell.
Zero initializes the type.
This can be used to zero-initialize any type for which it makes sense. Structs will be initialized recursively.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> zeroes {
    <span class="tok-kw">const</span> C_struct = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        x: <span class="tok-type">u32</span>,
        y: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">128</span>),
    };

    <span class="tok-kw">var</span> a = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(C_struct);<span class="tok-comment">

    // Extern structs should have padding zeroed out.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(a)), <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;a));

    a.y += <span class="tok-number">10</span>;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.x == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.y == <span class="tok-number">10</span>);

    <span class="tok-kw">const</span> ZigStruct = <span class="tok-kw">struct</span> {
        <span class="tok-kw">comptime</span> comptime_field: <span class="tok-type">u8</span> = <span class="tok-number">5</span>,

        integral_types: <span class="tok-kw">struct</span> {
            integer_0: <span class="tok-type">i0</span>,
            integer_8: <span class="tok-type">i8</span>,
            integer_16: <span class="tok-type">i16</span>,
            integer_32: <span class="tok-type">i32</span>,
            integer_64: <span class="tok-type">i64</span>,
            integer_128: <span class="tok-type">i128</span>,
            unsigned_0: <span class="tok-type">u0</span>,
            unsigned_8: <span class="tok-type">u8</span>,
            unsigned_16: <span class="tok-type">u16</span>,
            unsigned_32: <span class="tok-type">u32</span>,
            unsigned_64: <span class="tok-type">u64</span>,
            unsigned_128: <span class="tok-type">u128</span>,

            float_32: <span class="tok-type">f32</span>,
            float_64: <span class="tok-type">f64</span>,
        },

        pointers: <span class="tok-kw">struct</span> {
            optional: ?*<span class="tok-type">u8</span>,
            c_pointer: [*c]<span class="tok-type">u8</span>,
            slice: []<span class="tok-type">u8</span>,
            nullTerminatedString: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        },

        array: [<span class="tok-number">2</span>]<span class="tok-type">u32</span>,
        vector_u32: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u32</span>),
        vector_f32: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>),
        vector_bool: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">bool</span>),
        optional_int: ?<span class="tok-type">u8</span>,
        empty: <span class="tok-type">void</span>,
        sentinel: [<span class="tok-number">3</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> b = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(ZigStruct);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">5</span>), b.comptime_field);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-number">0</span>), b.integral_types.integer_0);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-number">0</span>), b.integral_types.integer_8);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-number">0</span>), b.integral_types.integer_16);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>), b.integral_types.integer_32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-number">0</span>), b.integral_types.integer_64);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, <span class="tok-number">0</span>), b.integral_types.integer_128);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_0);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_8);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_16);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_64);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_128);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">0</span>), b.integral_types.float_32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">0</span>), b.integral_types.float_64);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?*<span class="tok-type">u8</span>, <span class="tok-null">null</span>), b.pointers.optional);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>([*c]<span class="tok-type">u8</span>, <span class="tok-null">null</span>), b.pointers.c_pointer);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>([]<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{}), b.pointers.slice);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>([:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>), b.pointers.nullTerminatedString);
    <span class="tok-kw">for</span> (b.array) |e| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), e);
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@TypeOf</span>(b.vector_u32), <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>)), b.vector_u32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@TypeOf</span>(b.vector_f32), <span class="tok-builtin">@splat</span>(<span class="tok-number">0.0</span>)), b.vector_f32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@TypeOf</span>(b.vector_bool), <span class="tok-builtin">@splat</span>(<span class="tok-null">false</span>)), b.vector_bool);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), b.optional_int);
    <span class="tok-kw">for</span> (b.sentinel) |e| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), e);
    }

    <span class="tok-kw">const</span> C_union = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">const</span> c = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(C_union);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), c.a);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), c.b);

    <span class="tok-kw">const</span> comptime_union = <span class="tok-kw">comptime</span> <a href="std.mem.html#std.mem.zeroes">zeroes</a>(C_union);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), comptime_union.a);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), comptime_union.b);<span class="tok-comment">

    // Ensure zero sized struct with fields is initialized correctly.
    </span>_ = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(<span class="tok-kw">struct</span> { handle: <span class="tok-type">void</span> });
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.zeroes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroes</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .<span class="tok-type">comptime_int</span>, .int, .<span class="tok-type">comptime_float</span>, .float =&gt; {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-number">0</span>);
        },
        .@&quot;enum&quot; =&gt; {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>));
        },
        .<span class="tok-type">void</span> =&gt; {
            <span class="tok-kw">return</span> {};
        },
        .<span class="tok-type">bool</span> =&gt; {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
        .optional, .<span class="tok-null">null</span> =&gt; {
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        },
        .@&quot;struct&quot; =&gt; |struct_info| {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">undefined</span>;
            <span class="tok-kw">if</span> (struct_info.layout == .@&quot;extern&quot;) {
                <span class="tok-kw">var</span> item: T = <span class="tok-null">undefined</span>;
                <span class="tok-builtin">@memset</span>(<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;item), <span class="tok-number">0</span>);
                <span class="tok-kw">return</span> item;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> structure: T = <span class="tok-null">undefined</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (struct_info.fields) |field| {
                    <span class="tok-kw">if</span> (!field.is_comptime) {
                        <span class="tok-builtin">@field</span>(structure, field.name) = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(field.<span class="tok-type">type</span>);
                    }
                }
                <span class="tok-kw">return</span> structure;
            }
        },
        .pointer =&gt; |ptr_info| {
            <span class="tok-kw">switch</span> (ptr_info.size) {
                .slice =&gt; {
                    <span class="tok-kw">if</span> (ptr_info.sentinel()) |sentinel| {
                        <span class="tok-kw">if</span> (ptr_info.child == <span class="tok-type">u8</span> <span class="tok-kw">and</span> sentinel == <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> <span class="tok-str">&quot;&quot;</span>;<span class="tok-comment"> // A special case for the most common use-case: null-terminated strings.
                        </span>}
                        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't set a sentinel slice to zero. This would require allocating memory.&quot;</span>);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> &amp;[_]ptr_info.child{};
                    }
                },
                .c =&gt; {
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                },
                .one, .many =&gt; {
                    <span class="tok-kw">if</span> (ptr_info.is_allowzero) <span class="tok-kw">return</span> <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0</span>);
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Only nullable and allowzero pointers can be set to zero.&quot;</span>);
                },
            }
        },
        .array =&gt; |info| {
            <span class="tok-kw">return</span> <span class="tok-builtin">@splat</span>(<a href="std.mem.html#std.mem.zeroes">zeroes</a>(info.child));
        },
        .vector =&gt; |info| {
            <span class="tok-kw">return</span> <span class="tok-builtin">@splat</span>(<a href="std.mem.html#std.mem.zeroes">zeroes</a>(info.child));
        },
        .@&quot;union&quot; =&gt; |info| {
            <span class="tok-kw">if</span> (info.layout == .@&quot;extern&quot;) {
                <span class="tok-kw">var</span> item: T = <span class="tok-null">undefined</span>;
                <span class="tok-builtin">@memset</span>(<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;item), <span class="tok-number">0</span>);
                <span class="tok-kw">return</span> item;
            }
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't set a &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot; to zero.&quot;</span>);
        },
        .enum_literal,
        .error_union,
        .error_set,
        .@&quot;fn&quot;,
        .<span class="tok-type">type</span>,
        .<span class="tok-type">noreturn</span>,
        .<span class="tok-null">undefined</span>,
        .@&quot;opaque&quot;,
        .frame,
        .@&quot;anyframe&quot;,
        =&gt; {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't set a &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot; to zero.&quot;</span>);
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.zeroInit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">zeroInit</span><a href="#src.zig-std.mem.zeroInit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInit</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, init: <span class="tok-kw">anytype</span>) T</code></pre></div><div class="tldDocs"><p>Initializes all fields of the struct with their default value, or zero values if no default value is present.
If the field is present in the provided initial values, it will have that value instead.
Structs are initialized recursively.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> zeroInit {
    <span class="tok-kw">const</span> I = <span class="tok-kw">struct</span> {
        d: <span class="tok-type">f64</span>,
    };

    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: ?<span class="tok-type">bool</span>,
        c: I,
        e: [<span class="tok-number">3</span>]<span class="tok-type">u8</span>,
        f: <span class="tok-type">i64</span> = -<span class="tok-number">1</span>,
    };

    <span class="tok-kw">const</span> s = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(S, .{
        .a = <span class="tok-number">42</span>,
    });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(S{
        .a = <span class="tok-number">42</span>,
        .b = <span class="tok-null">null</span>,
        .c = .{
            .d = <span class="tok-number">0</span>,
        },
        .e = [<span class="tok-number">3</span>]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> },
        .f = -<span class="tok-number">1</span>,
    }, s);

    <span class="tok-kw">const</span> Color = <span class="tok-kw">struct</span> {
        r: <span class="tok-type">u8</span>,
        g: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u8</span>,
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> c = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Color, .{ <span class="tok-number">255</span>, <span class="tok-number">255</span> });
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Color{
        .r = <span class="tok-number">255</span>,
        .g = <span class="tok-number">255</span>,
        .b = <span class="tok-number">0</span>,
        .a = <span class="tok-number">0</span>,
    }, c);

    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
        foo: <span class="tok-type">u8</span> = <span class="tok-number">69</span>,
        bar: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> f = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Foo, .{});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Foo{
        .foo = <span class="tok-number">69</span>,
        .bar = <span class="tok-number">0</span>,
    }, f);

    <span class="tok-kw">const</span> Bar = <span class="tok-kw">struct</span> {
        foo: <span class="tok-type">u32</span> = <span class="tok-number">666</span>,
        bar: <span class="tok-type">u32</span> = <span class="tok-number">420</span>,
    };

    <span class="tok-kw">const</span> b = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Bar, .{<span class="tok-number">69</span>});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Bar{
        .foo = <span class="tok-number">69</span>,
        .bar = <span class="tok-number">420</span>,
    }, b);

    <span class="tok-kw">const</span> Baz = <span class="tok-kw">struct</span> {
        foo: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;bar&quot;</span>,
    };

    <span class="tok-kw">const</span> baz1 = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Baz, .{});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Baz{}, baz1);

    <span class="tok-kw">const</span> baz2 = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Baz, .{ .foo = <span class="tok-str">&quot;zab&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;zab&quot;</span>, baz2.foo);

    <span class="tok-kw">const</span> NestedBaz = <span class="tok-kw">struct</span> {
        bbb: Baz,
    };
    <span class="tok-kw">const</span> nested_baz = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(NestedBaz, .{});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(NestedBaz{
        .bbb = Baz{},
    }, nested_baz);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.zeroInit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInit</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, init: <span class="tok-kw">anytype</span>) T {
    <span class="tok-kw">const</span> Init = <span class="tok-builtin">@TypeOf</span>(init);

    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |struct_info| {
            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Init)) {
                .@&quot;struct&quot; =&gt; |init_info| {
                    <span class="tok-kw">if</span> (init_info.is_tuple) {
                        <span class="tok-kw">if</span> (init_info.fields.len &gt; struct_info.fields.len) {
                            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Tuple initializer has more elements than there are fields in `&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;`&quot;</span>);
                        }
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (init_info.fields) |field| {
                            <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasField</span>(T, field.name)) {
                                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Encountered an initializer for `&quot;</span> ++ field.name ++ <span class="tok-str">&quot;`, but it is not a field of &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
                            }
                        }
                    }

                    <span class="tok-kw">var</span> value: T = <span class="tok-kw">if</span> (struct_info.layout == .@&quot;extern&quot;) <a href="std.mem.html#std.mem.zeroes">zeroes</a>(T) <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;

                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (struct_info.fields, <span class="tok-number">0</span>..) |field, i| {
                        <span class="tok-kw">if</span> (field.is_comptime) {
                            <span class="tok-kw">continue</span>;
                        }

                        <span class="tok-kw">if</span> (init_info.is_tuple <span class="tok-kw">and</span> init_info.fields.len &gt; i) {
                            <span class="tok-builtin">@field</span>(value, field.name) = <span class="tok-builtin">@field</span>(init, init_info.fields[i].name);
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<span class="tok-builtin">@TypeOf</span>(init), field.name)) {
                            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(field.<span class="tok-type">type</span>)) {
                                .@&quot;struct&quot; =&gt; {
                                    <span class="tok-builtin">@field</span>(value, field.name) = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(field.<span class="tok-type">type</span>, <span class="tok-builtin">@field</span>(init, field.name));
                                },
                                <span class="tok-kw">else</span> =&gt; {
                                    <span class="tok-builtin">@field</span>(value, field.name) = <span class="tok-builtin">@field</span>(init, field.name);
                                },
                            }
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (field.defaultValue()) |val| {
                            <span class="tok-builtin">@field</span>(value, field.name) = val;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(field.<span class="tok-type">type</span>)) {
                                .@&quot;struct&quot; =&gt; {
                                    <span class="tok-builtin">@field</span>(value, field.name) = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(field.<span class="tok-type">type</span>, .{});
                                },
                                <span class="tok-kw">else</span> =&gt; {
                                    <span class="tok-builtin">@field</span>(value, field.name) = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(value, field.name)));
                                },
                            }
                        }
                    }

                    <span class="tok-kw">return</span> value;
                },
                <span class="tok-kw">else</span> =&gt; {
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The initializer must be a struct&quot;</span>);
                },
            }
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't default init a &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.mem.sort">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.sort">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.block.html#std.sort.block.block">block</a>(T, items, context, lessThanFn);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.sortUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstable</span><a href="#src.zig-std.mem.sortUnstable">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, context: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>, ) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.sortUnstable">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.pdq.html#std.sort.pdq.pdq">pdq</a>(T, items, context, lessThanFn);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.sortContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortContext</span><a href="#src.zig-std.mem.sortContext">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>TODO: currently this just calls <code>insertionSortContext</code>. The block sort implementation
in this file needs to be adapted to use the sort context.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.sortContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.insertionContext">insertionContext</a>(a, b, context);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.sortUnstableContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstableContext</span><a href="#src.zig-std.mem.sortUnstableContext">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.sortUnstableContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.pdq.html#std.sort.pdq.pdqContext">pdqContext</a>(a, b, context);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.order" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">order</span><a href="#src.zig-std.mem.order">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: []<span class="tok-kw">const</span> T, rhs: []<span class="tok-kw">const</span> T) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div><div class="tldDocs"><p>Compares two slices of numbers lexicographically. O(n).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>lhs: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>rhs: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> order {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, <span class="tok-str">&quot;bee&quot;</span>) == .lt);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>) == .eq);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc0&quot;</span>) == .lt);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;&quot;</span>) == .eq);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;a&quot;</span>) == .lt);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.order">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: []<span class="tok-kw">const</span> T, rhs: []<span class="tok-kw">const</span> T) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
    <span class="tok-kw">const</span> n = <span class="tok-builtin">@min</span>(lhs.len, rhs.len);
    <span class="tok-kw">for</span> (lhs[<span class="tok-number">0</span>..n], rhs[<span class="tok-number">0</span>..n]) |lhs_elem, rhs_elem| {
        <span class="tok-kw">switch</span> (<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(lhs_elem, rhs_elem)) {
            .eq =&gt; <span class="tok-kw">continue</span>,
            .lt =&gt; <span class="tok-kw">return</span> .lt,
            .gt =&gt; <span class="tok-kw">return</span> .gt,
        }
    }
    <span class="tok-kw">return</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(lhs.len, rhs.len);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.orderZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderZ</span><a href="#src.zig-std.mem.orderZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderZ</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> T, rhs: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> T) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div><div class="tldDocs"><p>Compares two many-item pointers with NUL-termination lexicographically.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>lhs: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>rhs: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> orderZ {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, <span class="tok-str">&quot;bee&quot;</span>) == .lt);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>) == .eq);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc0&quot;</span>) == .lt);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;&quot;</span>) == .eq);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;a&quot;</span>) == .lt);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.orderZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderZ</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> T, rhs: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> T) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (lhs[i] == rhs[i] <span class="tok-kw">and</span> lhs[i] != <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(lhs[i], rhs[i]);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.mem.lessThan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: []<span class="tok-kw">const</span> T, rhs: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if lhs &lt; rhs, false otherwise</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>lhs: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>rhs: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> lessThan {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, <span class="tok-str">&quot;bee&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc0&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;a&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.lessThan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: []<span class="tok-kw">const</span> T, rhs: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.order">order</a>(T, lhs, rhs) == .lt;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.mem.eql">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: []<span class="tok-kw">const</span> T, b: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if and only if the slices have the same length and all elements
compare true using equality operator.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>a: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>b: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> eql {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, <span class="tok-str">&quot;abcd&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdef&quot;</span>, <span class="tok-str">&quot;abZdef&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-str">&quot;abcdef&quot;</span>));

    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">type</span>, &amp;.{ <span class="tok-type">bool</span>, <span class="tok-type">f32</span> }, &amp;.{ <span class="tok-type">bool</span>, <span class="tok-type">f32</span> }));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">type</span>, &amp;.{ <span class="tok-type">bool</span>, <span class="tok-type">f32</span> }, &amp;.{ <span class="tok-type">f32</span>, <span class="tok-type">bool</span> }));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">type</span>, &amp;.{ <span class="tok-type">bool</span>, <span class="tok-type">f32</span> }, &amp;.{<span class="tok-type">bool</span>}));

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">comptime_int</span>, &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> }, &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> }));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">comptime_int</span>, &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> }, &amp;.{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span> }));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">comptime_int</span>, &amp;.{<span class="tok-number">1</span>}, &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span> }));
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">void</span>, &amp;.{ {}, {} }, &amp;.{ {}, {} }));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">void</span>, &amp;.{{}}, &amp;.{ {}, {} }));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.eql">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: []<span class="tok-kw">const</span> T, b: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (!<span class="tok-builtin">@inComptime</span>() <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(T) != <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T) <span class="tok-kw">and</span>
        <a href="std.mem.html#std.mem.eqlBytes_allowed">eqlBytes_allowed</a>)
    {
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.eqlBytes">eqlBytes</a>(<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(a), <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(b));
    }

    <span class="tok-kw">if</span> (a.len != b.len) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (a.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> a.ptr == b.ptr) <span class="tok-kw">return</span> <span class="tok-null">true</span>;

    <span class="tok-kw">for</span> (a, b) |a_elem, b_elem| {
        <span class="tok-kw">if</span> (a_elem != b_elem) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfDiff" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfDiff</span><a href="#src.zig-std.mem.indexOfDiff">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfDiff</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: []<span class="tok-kw">const</span> T, b: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Compares two slices and returns the index of the first inequality.
Returns null if the slices are equal.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>a: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>b: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> indexOfDiff {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one&quot;</span>, <span class="tok-str">&quot;one&quot;</span>), <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two&quot;</span>, <span class="tok-str">&quot;one&quot;</span>), <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one&quot;</span>, <span class="tok-str">&quot;one two&quot;</span>), <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one twx&quot;</span>, <span class="tok-str">&quot;one two&quot;</span>), <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;xne&quot;</span>, <span class="tok-str">&quot;one&quot;</span>), <span class="tok-number">0</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfDiff">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfDiff</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: []<span class="tok-kw">const</span> T, b: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> shortest = <span class="tok-builtin">@min</span>(a.len, b.len);
    <span class="tok-kw">if</span> (a.ptr == b.ptr)
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a.len == b.len) <span class="tok-null">null</span> <span class="tok-kw">else</span> shortest;
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; shortest) : (index += <span class="tok-number">1</span>) <span class="tok-kw">if</span> (a[index] != b[index]) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a.len == b.len) <span class="tok-null">null</span> <span class="tok-kw">else</span> shortest;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.span" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">span</span><a href="#src.zig-std.mem.span">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">span</span>(ptr: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.Span">Span</a>(<span class="tok-builtin">@TypeOf</span>(ptr))</code></pre></div><div class="tldDocs"><p>Takes a sentinel-terminated pointer and returns a slice, iterating over the
memory to find the sentinel and determine the length.
Pointer attributes such as const are preserved.
<code>[*c]</code> pointers are assumed to be non-null and 0-terminated.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> span {
    <span class="tok-kw">var</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u16</span> = [_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@as</span>([*:<span class="tok-number">3</span>]<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span> :<span class="tok-number">3</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, <a href="std.mem.html#std.mem.span">span</a>(ptr), &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span> }));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?[:<span class="tok-number">0</span>]<span class="tok-type">u16</span>, <span class="tok-null">null</span>), <a href="std.mem.html#std.mem.span">span</a>(<span class="tok-builtin">@as</span>(?[*:<span class="tok-number">0</span>]<span class="tok-type">u16</span>, <span class="tok-null">null</span>)));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.span">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">span</span>(ptr: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.Span">Span</a>(<span class="tok-builtin">@TypeOf</span>(ptr)) {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)) == .optional) {
        <span class="tok-kw">if</span> (ptr) |non_null| {
            <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.span">span</a>(non_null);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }
    }
    <span class="tok-kw">const</span> Result = <a href="std.mem.html#std.mem.Span">Span</a>(<span class="tok-builtin">@TypeOf</span>(ptr));
    <span class="tok-kw">const</span> l = <a href="std.mem.html#std.mem.len">len</a>(ptr);
    <span class="tok-kw">const</span> ptr_info = <span class="tok-builtin">@typeInfo</span>(Result).pointer;
    <span class="tok-kw">if</span> (ptr_info.sentinel()) |s| {
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..l :s];
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..l];
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.sliceTo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sliceTo</span><a href="#src.zig-std.mem.sliceTo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceTo</span>(ptr: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> end: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(<span class="tok-builtin">@TypeOf</span>(ptr))) <a href="std.mem.html#std.mem.SliceTo">SliceTo</a>(<span class="tok-builtin">@TypeOf</span>(ptr), end)</code></pre></div><div class="tldDocs"><p>Takes a pointer to an array, a sentinel-terminated pointer, or a slice and iterates searching for
the first occurrence of <code>end</code>, returning the scanned slice.
If <code>end</code> is not found, the full length of the array/slice/sentinel terminated pointer is returned.
If the pointer type is sentinel terminated and <code>end</code> matches that terminator, the
resulting slice is also sentinel terminated.
Pointer properties such as mutability and alignment are preserved.
C pointers are assumed to be non-null.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>end: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(<span class="tok-builtin">@TypeOf</span>(ptr))</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> sliceTo {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aoeu&quot;</span>, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-str">&quot;aoeu&quot;</span>, <span class="tok-number">0</span>));

    {
        <span class="tok-kw">var</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u16</span> = [_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, &amp;array, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;array, <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">3</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(array[<span class="tok-number">0</span>..<span class="tok-number">3</span>], <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;array, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(array[<span class="tok-number">0</span>..<span class="tok-number">3</span>], <span class="tok-number">3</span>));

        <span class="tok-kw">const</span> sentinel_ptr = <span class="tok-builtin">@as</span>([*:<span class="tok-number">5</span>]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;array));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sentinel_ptr, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sentinel_ptr, <span class="tok-number">99</span>));

        <span class="tok-kw">const</span> optional_sentinel_ptr = <span class="tok-builtin">@as</span>(?[*:<span class="tok-number">5</span>]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;array));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(optional_sentinel_ptr, <span class="tok-number">3</span>).?);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(optional_sentinel_ptr, <span class="tok-number">99</span>).?);

        <span class="tok-kw">const</span> c_ptr = <span class="tok-builtin">@as</span>([*c]<span class="tok-type">u16</span>, &amp;array);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(c_ptr, <span class="tok-number">3</span>));

        <span class="tok-kw">const</span> slice: []<span class="tok-type">u16</span> = &amp;array;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(slice, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, &amp;array, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(slice, <span class="tok-number">99</span>));

        <span class="tok-kw">const</span> sentinel_slice: [:<span class="tok-number">5</span>]<span class="tok-type">u16</span> = array[<span class="tok-number">0</span>..<span class="tok-number">4</span> :<span class="tok-number">5</span>];
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sentinel_slice, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sentinel_slice, <span class="tok-number">99</span>));
    }
    {
        <span class="tok-kw">var</span> sentinel_array: [<span class="tok-number">5</span>:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = [_:<span class="tok-number">0</span>]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, sentinel_array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;sentinel_array, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, &amp;sentinel_array, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;sentinel_array, <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, &amp;sentinel_array, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;sentinel_array, <span class="tok-number">99</span>));
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?[]<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>(?[]<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <span class="tok-number">0</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.sliceTo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceTo</span>(ptr: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> end: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(<span class="tok-builtin">@TypeOf</span>(ptr))) <a href="std.mem.html#std.mem.SliceTo">SliceTo</a>(<span class="tok-builtin">@TypeOf</span>(ptr), end) {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)) == .optional) {
        <span class="tok-kw">const</span> non_null = ptr <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(non_null, end);
    }
    <span class="tok-kw">const</span> Result = <a href="std.mem.html#std.mem.SliceTo">SliceTo</a>(<span class="tok-builtin">@TypeOf</span>(ptr), end);
    <span class="tok-kw">const</span> length = <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(ptr, end);
    <span class="tok-kw">const</span> ptr_info = <span class="tok-builtin">@typeInfo</span>(Result).pointer;
    <span class="tok-kw">if</span> (ptr_info.sentinel()) |s| {
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..length :s];
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..length];
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.len" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">len</span><a href="#src.zig-std.mem.len">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Takes a sentinel-terminated pointer and iterates over the memory to find the
sentinel and determine the length.
<code>[*c]</code> pointers are assumed to be non-null and 0-terminated.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> len {
    <span class="tok-kw">var</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u16</span> = [_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">0</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@as</span>([*:<span class="tok-number">4</span>]<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">3</span> :<span class="tok-number">4</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.len">len</a>(ptr) == <span class="tok-number">3</span>);
    <span class="tok-kw">const</span> c_ptr = <span class="tok-builtin">@as</span>([*c]<span class="tok-type">u16</span>, ptr);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.len">len</a>(c_ptr) == <span class="tok-number">2</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value))) {
        .pointer =&gt; |info| <span class="tok-kw">switch</span> (info.size) {
            .many =&gt; {
                <span class="tok-kw">const</span> sentinel = info.sentinel() <span class="tok-kw">orelse</span>
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.len: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value)));
                <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(info.child, sentinel, value);
            },
            .c =&gt; {
                <a href="std.debug.html#std.debug.assert">assert</a>(value != <span class="tok-null">null</span>);
                <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(info.child, <span class="tok-number">0</span>, value);
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.len: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value))),
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.len: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value))),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfSentinel</span><a href="#src.zig-std.mem.indexOfSentinel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfSentinel</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> sentinel: T, p: [*:sentinel]<span class="tok-kw">const</span> T) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>sentinel: T</code></pre></div><div><pre><code>p: [*:sentinel]<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfSentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfSentinel</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> sentinel: T, p: [*:sentinel]<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.backend_supports_vectors">backend_supports_vectors</a> <span class="tok-kw">and</span>
        !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.inValgrind">inValgrind</a>() <span class="tok-kw">and</span><span class="tok-comment"> // https://github.com/ziglang/zig/issues/17717
        </span>!<span class="tok-builtin">@inComptime</span>() <span class="tok-kw">and</span>
        (<span class="tok-builtin">@typeInfo</span>(T) == .int <span class="tok-kw">or</span> <span class="tok-builtin">@typeInfo</span>(T) == .float) <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(<span class="tok-builtin">@bitSizeOf</span>(T)))
    {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).cpu.arch) {<span class="tok-comment">
            // The below branch assumes that reading past the end of the buffer is valid, as long
            // as we don't read into a new page. This should be the case for most architectures
            // which use paged memory, however should be confirmed before adding a new arch below.
            </span>.aarch64, .x86, .x86_64 =&gt; <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(T)) |block_len| {
                <span class="tok-kw">const</span> page_size = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>;
                <span class="tok-kw">const</span> block_size = <span class="tok-builtin">@sizeOf</span>(T) * block_len;
                <span class="tok-kw">const</span> Block = <span class="tok-builtin">@Vector</span>(block_len, T);
                <span class="tok-kw">const</span> mask: Block = <span class="tok-builtin">@splat</span>(sentinel);

                <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a> % <span class="tok-builtin">@sizeOf</span>(Block) == <span class="tok-number">0</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(page_size % <span class="tok-builtin">@sizeOf</span>(Block) == <span class="tok-number">0</span>);<span class="tok-comment">

                // First block may be unaligned
                </span><span class="tok-kw">const</span> start_addr = <span class="tok-builtin">@intFromPtr</span>(&amp;p[i]);
                <span class="tok-kw">const</span> offset_in_page = start_addr &amp; (page_size - <span class="tok-number">1</span>);
                <span class="tok-kw">if</span> (offset_in_page &lt;= page_size - <span class="tok-builtin">@sizeOf</span>(Block)) {<span class="tok-comment">
                    // Will not read past the end of a page, full block.
                    </span><span class="tok-kw">const</span> block: Block = p[i..][<span class="tok-number">0</span>..block_len].*;
                    <span class="tok-kw">const</span> matches = block == mask;
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@reduce</span>(.Or, matches)) {
                        <span class="tok-kw">return</span> i + <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(matches).?;
                    }

                    i += <span class="tok-builtin">@divExact</span>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, start_addr, block_size) - start_addr, <span class="tok-builtin">@sizeOf</span>(T));
                } <span class="tok-kw">else</span> {
                    <span class="tok-builtin">@branchHint</span>(.unlikely);<span class="tok-comment">
                    // Would read over a page boundary. Per-byte at a time until aligned or found.
                    // 0.39% chance this branch is taken for 4K pages at 16b block length.
                    //
                    // An alternate strategy is to do read a full block (the last in the page) and
                    // mask the entries before the pointer.
                    </span><span class="tok-kw">while</span> ((<span class="tok-builtin">@intFromPtr</span>(&amp;p[i]) &amp; (block_size - <span class="tok-number">1</span>)) != <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {
                        <span class="tok-kw">if</span> (p[i] == sentinel) <span class="tok-kw">return</span> i;
                    }
                }

                <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-builtin">@intFromPtr</span>(&amp;p[i]), block_size));
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> block: *<span class="tok-kw">const</span> Block = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(p[i..][<span class="tok-number">0</span>..block_len]));
                    <span class="tok-kw">const</span> matches = block.* == mask;
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@reduce</span>(.Or, matches)) {
                        <span class="tok-kw">return</span> i + <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(matches).?;
                    }
                    i += block_len;
                }
            },
            <span class="tok-kw">else</span> =&gt; {},
        }
    }

    <span class="tok-kw">while</span> (p[i] != sentinel) {
        i += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> i;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.allEqual" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">allEqual</span><a href="#src.zig-std.mem.allEqual">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allEqual</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, scalar: T) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if all elements in a slice are equal to the scalar value provided</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>scalar: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.allEqual">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allEqual</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, scalar: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">for</span> (slice) |item| {
        <span class="tok-kw">if</span> (item != scalar) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.trimLeft" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trimLeft</span><a href="#src.zig-std.mem.trimLeft">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimLeft</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Remove a set of values from the beginning of a slice.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>values_to_strip: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.trimLeft">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimLeft</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T {
    <span class="tok-kw">var</span> begin: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (begin &lt; slice.len <span class="tok-kw">and</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(T, values_to_strip, slice[begin]) != <span class="tok-null">null</span>) : (begin += <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> slice[begin..];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.trimRight" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trimRight</span><a href="#src.zig-std.mem.trimRight">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimRight</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Remove a set of values from the end of a slice.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>values_to_strip: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.trimRight">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimRight</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T {
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = slice.len;
    <span class="tok-kw">while</span> (end &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(T, values_to_strip, slice[end - <span class="tok-number">1</span>]) != <span class="tok-null">null</span>) : (end -= <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..end];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.trim" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trim</span><a href="#src.zig-std.mem.trim">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trim</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T</code></pre></div><div class="tldDocs"><p>Remove a set of values from the beginning and end of a slice.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>values_to_strip: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> trim {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo\n &quot;</span>, <a href="std.mem.html#std.mem.trimLeft">trimLeft</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot; foo\n &quot;</span>, <span class="tok-str">&quot; \n&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot; foo&quot;</span>, <a href="std.mem.html#std.mem.trimRight">trimRight</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot; foo\n &quot;</span>, <span class="tok-str">&quot; \n&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot; foo\n &quot;</span>, <span class="tok-str">&quot; \n&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot; \n&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.trim">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trim</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T {
    <span class="tok-kw">var</span> begin: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = slice.len;
    <span class="tok-kw">while</span> (begin &lt; end <span class="tok-kw">and</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(T, values_to_strip, slice[begin]) != <span class="tok-null">null</span>) : (begin += <span class="tok-number">1</span>) {}
    <span class="tok-kw">while</span> (end &gt; begin <span class="tok-kw">and</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(T, values_to_strip, slice[end - <span class="tok-number">1</span>]) != <span class="tok-null">null</span>) : (end -= <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> slice[begin..end];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfScalar</span><a href="#src.zig-std.mem.indexOfScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, value: T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Linear search for the index of a scalar value inside a slice.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>value: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, value: T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, slice, <span class="tok-number">0</span>, value);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.lastIndexOfScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lastIndexOfScalar</span><a href="#src.zig-std.mem.lastIndexOfScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, value: T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Linear search for the last index of a scalar value inside a slice.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>value: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.lastIndexOfScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, value: T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = slice.len;
    <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (slice[i] == value) <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfScalarPos" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfScalarPos</span><a href="#src.zig-std.mem.indexOfScalarPos">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfScalarPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, value: T) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>start_index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>value: T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> indexOfScalarPos {
    <span class="tok-kw">const</span> Types = [_]<span class="tok-type">type</span>{ <span class="tok-type">u8</span>, <span class="tok-type">u16</span>, <span class="tok-type">u32</span>, <span class="tok-type">u64</span> };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (Types) |T| {
        <span class="tok-kw">var</span> memory: [<span class="tok-number">64</span> / <span class="tok-builtin">@sizeOf</span>(T)]T = <span class="tok-null">undefined</span>;
        <span class="tok-builtin">@memset</span>(&amp;memory, <span class="tok-number">0xaa</span>);
        memory[memory.len - <span class="tok-number">1</span>] = <span class="tok-number">0</span>;

        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..memory.len) |i| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(memory.len - i - <span class="tok-number">1</span>, <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, memory[i..], <span class="tok-number">0</span>, <span class="tok-number">0</span>).?);
        }
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfScalarPos">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfScalarPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, value: T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (start_index &gt;= slice.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = start_index;
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.backend_supports_vectors">backend_supports_vectors</a> <span class="tok-kw">and</span>
        !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.inValgrind">inValgrind</a>() <span class="tok-kw">and</span><span class="tok-comment"> // https://github.com/ziglang/zig/issues/17717
        </span>!<span class="tok-builtin">@inComptime</span>() <span class="tok-kw">and</span>
        (<span class="tok-builtin">@typeInfo</span>(T) == .int <span class="tok-kw">or</span> <span class="tok-builtin">@typeInfo</span>(T) == .float) <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(<span class="tok-builtin">@bitSizeOf</span>(T)))
    {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(T)) |block_len| {<span class="tok-comment">
            // For Intel Nehalem (2009) and AMD Bulldozer (2012) or later, unaligned loads on aligned data result
            // in the same execution as aligned loads. We ignore older arch's here and don't bother pre-aligning.
            //
            // Use `std.simd.suggestVectorLength(T)` to get the same alignment as used in this function
            // however this usually isn't necessary unless your arch has a performance penalty due to this.
            //
            // This may differ for other arch's. Arm for example costs a cycle when loading across a cache
            // line so explicit alignment prologues may be worth exploration.

            // Unrolling here is ~10% improvement. We can then do one bounds check every 2 blocks
            // instead of one which adds up.
            </span><span class="tok-kw">const</span> Block = <span class="tok-builtin">@Vector</span>(block_len, T);
            <span class="tok-kw">if</span> (i + <span class="tok-number">2</span> * block_len &lt; slice.len) {
                <span class="tok-kw">const</span> mask: Block = <span class="tok-builtin">@splat</span>(value);
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">2</span>) |_| {
                        <span class="tok-kw">const</span> block: Block = slice[i..][<span class="tok-number">0</span>..block_len].*;
                        <span class="tok-kw">const</span> matches = block == mask;
                        <span class="tok-kw">if</span> (<span class="tok-builtin">@reduce</span>(.Or, matches)) {
                            <span class="tok-kw">return</span> i + <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(matches).?;
                        }
                        i += block_len;
                    }
                    <span class="tok-kw">if</span> (i + <span class="tok-number">2</span> * block_len &gt;= slice.len) <span class="tok-kw">break</span>;
                }
            }<span class="tok-comment">

            // {block_len, block_len / 2} check
            </span><span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">2</span>) |j| {
                <span class="tok-kw">const</span> block_x_len = block_len / (<span class="tok-number">1</span> &lt;&lt; j);
                <span class="tok-kw">comptime</span> <span class="tok-kw">if</span> (block_x_len &lt; <span class="tok-number">4</span>) <span class="tok-kw">break</span>;

                <span class="tok-kw">const</span> BlockX = <span class="tok-builtin">@Vector</span>(block_x_len, T);
                <span class="tok-kw">if</span> (i + block_x_len &lt; slice.len) {
                    <span class="tok-kw">const</span> mask: BlockX = <span class="tok-builtin">@splat</span>(value);
                    <span class="tok-kw">const</span> block: BlockX = slice[i..][<span class="tok-number">0</span>..block_x_len].*;
                    <span class="tok-kw">const</span> matches = block == mask;
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@reduce</span>(.Or, matches)) {
                        <span class="tok-kw">return</span> i + <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(matches).?;
                    }
                    i += block_x_len;
                }
            }
        }
    }

    <span class="tok-kw">for</span> (slice[i..], i..) |c, j| {
        <span class="tok-kw">if</span> (c == value) <span class="tok-kw">return</span> j;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfAny" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfAny</span><a href="#src.zig-std.mem.indexOfAny">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>values: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfAny">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfAnyPos">indexOfAnyPos</a>(T, slice, <span class="tok-number">0</span>, values);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.lastIndexOfAny" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lastIndexOfAny</span><a href="#src.zig-std.mem.lastIndexOfAny">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>values: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.lastIndexOfAny">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = slice.len;
    <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        <span class="tok-kw">for</span> (values) |value| {
            <span class="tok-kw">if</span> (slice[i] == value) <span class="tok-kw">return</span> i;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfAnyPos" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfAnyPos</span><a href="#src.zig-std.mem.indexOfAnyPos">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfAnyPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>start_index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>values: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfAnyPos">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfAnyPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (start_index &gt;= slice.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">for</span> (slice[start_index..], start_index..) |c, i| {
        <span class="tok-kw">for</span> (values) |value| {
            <span class="tok-kw">if</span> (c == value) <span class="tok-kw">return</span> i;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfNone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfNone</span><a href="#src.zig-std.mem.indexOfNone">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfNone</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Find the first item in <code>slice</code> which is not contained in <code>values</code>.</p>
<p>Comparable to <code>strspn</code> in the C standard library.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>values: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> indexOfNone {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc123&quot;</span>, <span class="tok-str">&quot;123&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOfNone">lastIndexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc123&quot;</span>, <span class="tok-str">&quot;123&quot;</span>).? == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123abc&quot;</span>, <span class="tok-str">&quot;123&quot;</span>).? == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOfNone">lastIndexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123abc&quot;</span>, <span class="tok-str">&quot;123&quot;</span>).? == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123123&quot;</span>, <span class="tok-str">&quot;123&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;333333&quot;</span>, <span class="tok-str">&quot;123&quot;</span>) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNonePos">indexOfNonePos</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc123&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">&quot;321&quot;</span>) == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfNone">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfNone</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfNonePos">indexOfNonePos</a>(T, slice, <span class="tok-number">0</span>, values);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.lastIndexOfNone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lastIndexOfNone</span><a href="#src.zig-std.mem.lastIndexOfNone">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfNone</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Find the last item in <code>slice</code> which is not contained in <code>values</code>.</p>
<p>Like <code>strspn</code> in the C standard library, but searches from the end.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>values: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.lastIndexOfNone">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfNone</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = slice.len;
    outer: <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        <span class="tok-kw">for</span> (values) |value| {
            <span class="tok-kw">if</span> (slice[i] == value) <span class="tok-kw">continue</span> :outer;
        }
        <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfNonePos" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfNonePos</span><a href="#src.zig-std.mem.indexOfNonePos">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfNonePos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Find the first item in <code>slice[start_index..]</code> which is not contained in <code>values</code>.
The returned index will be relative to the start of <code>slice</code>, and never less than <code>start_index</code>.</p>
<p>Comparable to <code>strspn</code> in the C standard library.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>start_index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>values: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfNonePos">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfNonePos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (start_index &gt;= slice.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    outer: <span class="tok-kw">for</span> (slice[start_index..], start_index..) |c, i| {
        <span class="tok-kw">for</span> (values) |value| {
            <span class="tok-kw">if</span> (c == value) <span class="tok-kw">continue</span> :outer;
        }
        <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOf</span><a href="#src.zig-std.mem.indexOf">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> indexOf {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten eleven&quot;</span>, <span class="tok-str">&quot;three four&quot;</span>).? == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten eleven&quot;</span>, <span class="tok-str">&quot;three four&quot;</span>).? == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten eleven&quot;</span>, <span class="tok-str">&quot;two two&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten eleven&quot;</span>, <span class="tok-str">&quot;two two&quot;</span>) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten&quot;</span>, <span class="tok-str">&quot;&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten&quot;</span>, <span class="tok-str">&quot;&quot;</span>).? == <span class="tok-number">48</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four&quot;</span>, <span class="tok-str">&quot;four&quot;</span>).? == <span class="tok-number">14</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three two four&quot;</span>, <span class="tok-str">&quot;two&quot;</span>).? == <span class="tok-number">14</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four&quot;</span>, <span class="tok-str">&quot;gour&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four&quot;</span>, <span class="tok-str">&quot;gour&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;fool&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;lfoo&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;fool&quot;</span>) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo foo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo foo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>).? == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOfAny">lastIndexOfAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;boo, cat&quot;</span>, <span class="tok-str">&quot;abo&quot;</span>).? == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;boo&quot;</span>, <span class="tok-str">'o'</span>).? == <span class="tok-number">2</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOf">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, haystack, <span class="tok-number">0</span>, needle);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.lastIndexOfLinear" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lastIndexOfLinear</span><a href="#src.zig-std.mem.lastIndexOfLinear">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfLinear</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Find the index in a slice of a sub-slice, searching from the end backwards.
To start looking at a different index, slice the haystack first.
Consider using <code><a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a></code> instead of this, which will automatically use a
more sophisticated algorithm on larger inputs.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.lastIndexOfLinear">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfLinear</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = haystack.len - needle.len;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(T, haystack[i..][<span class="tok-number">0</span>..needle.len], needle)) <span class="tok-kw">return</span> i;
        <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfPosLinear" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfPosLinear</span><a href="#src.zig-std.mem.indexOfPosLinear">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfPosLinear</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Consider using <code><a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a></code> instead of this, which will automatically use a
more sophisticated algorithm on larger inputs.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>start_index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> indexOfPosLinear {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;1&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;2&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;21&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;222&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;1&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;2&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;12&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;21&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;212&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;122&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;212112&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfPosLinear">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfPosLinear</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = start_index;
    <span class="tok-kw">const</span> end = haystack.len - needle.len;
    <span class="tok-kw">while</span> (i &lt;= end) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.eql">eql</a>(T, haystack[i..][<span class="tok-number">0</span>..needle.len], needle)) <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.lastIndexOf" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lastIndexOf</span><a href="#src.zig-std.mem.lastIndexOf">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Find the index in a slice of a sub-slice, searching from the end backwards.
To start looking at a different index, slice the haystack first.
Uses the Reverse Boyer-Moore-Horspool algorithm on large inputs;
<code><a href="std.mem.html#std.mem.lastIndexOfLinear">lastIndexOfLinear</a></code> on small inputs.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.lastIndexOf">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (needle.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> haystack.len;

    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T) <span class="tok-kw">or</span> haystack.len &lt; <span class="tok-number">52</span> <span class="tok-kw">or</span> needle.len &lt;= <span class="tok-number">4</span>)
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.lastIndexOfLinear">lastIndexOfLinear</a>(T, haystack, needle);

    <span class="tok-kw">const</span> haystack_bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(haystack);
    <span class="tok-kw">const</span> needle_bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(needle);

    <span class="tok-kw">var</span> skip_table: [<span class="tok-number">256</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <a href="std.mem.html#std.mem.boyerMooreHorspoolPreprocessReverse">boyerMooreHorspoolPreprocessReverse</a>(needle_bytes, skip_table[<span class="tok-number">0</span>..]);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = haystack_bytes.len - needle_bytes.len;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (i % <span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, haystack_bytes[i .. i + needle_bytes.len], needle_bytes)) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@divExact</span>(i, <span class="tok-builtin">@sizeOf</span>(T));
        }
        <span class="tok-kw">const</span> skip = skip_table[haystack_bytes[i]];
        <span class="tok-kw">if</span> (skip &gt; i) <span class="tok-kw">break</span>;
        i -= skip;
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfPos" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfPos</span><a href="#src.zig-std.mem.indexOfPos">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Uses Boyer-Moore-Horspool algorithm on large inputs; <code><a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a></code> on small inputs.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>start_index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfPos">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (needle.len &lt; <span class="tok-number">2</span>) {
        <span class="tok-kw">if</span> (needle.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> start_index;<span class="tok-comment">
        // indexOfScalarPos is significantly faster than indexOfPosLinear
        </span><span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, haystack, start_index, needle[<span class="tok-number">0</span>]);
    }

    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T) <span class="tok-kw">or</span> haystack.len &lt; <span class="tok-number">52</span> <span class="tok-kw">or</span> needle.len &lt;= <span class="tok-number">4</span>)
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(T, haystack, start_index, needle);

    <span class="tok-kw">const</span> haystack_bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(haystack);
    <span class="tok-kw">const</span> needle_bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(needle);

    <span class="tok-kw">var</span> skip_table: [<span class="tok-number">256</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <a href="std.mem.html#std.mem.boyerMooreHorspoolPreprocess">boyerMooreHorspoolPreprocess</a>(needle_bytes, skip_table[<span class="tok-number">0</span>..]);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = start_index * <span class="tok-builtin">@sizeOf</span>(T);
    <span class="tok-kw">while</span> (i &lt;= haystack_bytes.len - needle_bytes.len) {
        <span class="tok-kw">if</span> (i % <span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, haystack_bytes[i .. i + needle_bytes.len], needle_bytes)) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@divExact</span>(i, <span class="tok-builtin">@sizeOf</span>(T));
        }
        i += skip_table[haystack_bytes[i + needle_bytes.len - <span class="tok-number">1</span>]];
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.mem.count">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of needles inside the haystack
needle.len must be &gt; 0
does not count overlapping needles</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> count {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;h&quot;</span>) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;h&quot;</span>, <span class="tok-str">&quot;h&quot;</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hh&quot;</span>, <span class="tok-str">&quot;h&quot;</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;world!&quot;</span>, <span class="tok-str">&quot;hello&quot;</span>) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello world!&quot;</span>, <span class="tok-str">&quot;hello&quot;</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   abcabc   abc&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>) == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;udexdcbvbruhasdrw&quot;</span>, <span class="tok-str">&quot;bruh&quot;</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo bar&quot;</span>, <span class="tok-str">&quot;o bar&quot;</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foofoofoo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>) == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;fffffff&quot;</span>, <span class="tok-str">&quot;ff&quot;</span>) == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;owowowu&quot;</span>, <span class="tok-str">&quot;owowu&quot;</span>) == <span class="tok-number">1</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.count">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(needle.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> found: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, haystack, i, needle)) |idx| {
        i = idx + needle.len;
        found += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">return</span> found;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.containsAtLeast" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAtLeast</span><a href="#src.zig-std.mem.containsAtLeast">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAtLeast</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, expected_count: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if the haystack contains expected_count or more needles
needle.len must be &gt; 0
does not count overlapping needles
See also: <code><a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a></code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>expected_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> containsAtLeast {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">1</span>, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">2</span>, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">&quot;a&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;radaradar&quot;</span>, <span class="tok-number">1</span>, <span class="tok-str">&quot;radar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;radaradar&quot;</span>, <span class="tok-number">2</span>, <span class="tok-str">&quot;radar&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;radarradaradarradar&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">&quot;radar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;radarradaradarradar&quot;</span>, <span class="tok-number">4</span>, <span class="tok-str">&quot;radar&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   radar      radar   &quot;</span>, <span class="tok-number">2</span>, <span class="tok-str">&quot;radar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   radar      radar   &quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">&quot;radar&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.containsAtLeast">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAtLeast</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, expected_count: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(needle.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (expected_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> found: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, haystack, i, needle)) |idx| {
        i = idx + needle.len;
        found += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (found == expected_count) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.containsAtLeastScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAtLeastScalar</span><a href="#src.zig-std.mem.containsAtLeastScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAtLeastScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, expected_count: <span class="tok-type">usize</span>, needle: T) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if the haystack contains expected_count or more needles
See also: <code><a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a></code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>expected_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>needle: T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> containsAtLeastScalar {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">'a'</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">1</span>, <span class="tok-str">'a'</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">2</span>, <span class="tok-str">'a'</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">'a'</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;adadda&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">'d'</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;adadda&quot;</span>, <span class="tok-number">4</span>, <span class="tok-str">'d'</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.containsAtLeastScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAtLeastScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, expected_count: <span class="tok-type">usize</span>, needle: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (expected_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;

    <span class="tok-kw">var</span> found: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (haystack) |item| {
        <span class="tok-kw">if</span> (item == needle) {
            found += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (found == expected_count) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.readVarInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readVarInt</span><a href="#src.zig-std.mem.readVarInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readVarInt</span>(<span class="tok-kw">comptime</span> ReturnType: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) ReturnType</code></pre></div><div class="tldDocs"><p>Reads an integer from memory with size equal to bytes.len.
T specifies the return type, which must be large enough to store
the result.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ReturnType: <span class="tok-type">type</span></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> readVarInt {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u0</span>, &amp;[_]<span class="tok-type">u8</span>{}, .big) == <span class="tok-number">0x0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u0</span>, &amp;[_]<span class="tok-type">u8</span>{}, .little) == <span class="tok-number">0x0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x12</span>}, .big) == <span class="tok-number">0x12</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xde</span>}, .little) == <span class="tok-number">0xde</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }, .big) == <span class="tok-number">0x1234</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }, .little) == <span class="tok-number">0x3412</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>}, .big) == -<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xfe</span>}, .little) == -<span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xff</span>, <span class="tok-number">0xfd</span> }, .big) == -<span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xfc</span>, <span class="tok-number">0xff</span> }, .little) == -<span class="tok-number">4</span>);<span class="tok-comment">

    // Return type can be oversized (bytes.len * 8 &lt; @typeInfo(ReturnType).int.bits)
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u9</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x12</span>}, .little) == <span class="tok-number">0x12</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u9</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xde</span>}, .big) == <span class="tok-number">0xde</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u80</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x78</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x24</span> }, .big) == <span class="tok-number">0x123456789abcdef024</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u80</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xec</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x32</span>, <span class="tok-number">0x54</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x98</span>, <span class="tok-number">0xba</span>, <span class="tok-number">0xdc</span>, <span class="tok-number">0xfe</span> }, .little) == <span class="tok-number">0xfedcba9876543210ec</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i9</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>}, .big) == <span class="tok-number">0xff</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i9</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xfe</span>}, .little) == <span class="tok-number">0xfe</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.readVarInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readVarInt</span>(<span class="tok-kw">comptime</span> ReturnType: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) ReturnType {
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(ReturnType).int.bits &gt;= bytes.len * <span class="tok-number">8</span>);
    <span class="tok-kw">const</span> bits = <span class="tok-builtin">@typeInfo</span>(ReturnType).int.bits;
    <span class="tok-kw">const</span> signedness = <span class="tok-builtin">@typeInfo</span>(ReturnType).int.signedness;
    <span class="tok-kw">const</span> WorkType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(signedness, <span class="tok-builtin">@max</span>(<span class="tok-number">16</span>, bits));
    <span class="tok-kw">var</span> result: WorkType = <span class="tok-number">0</span>;
    <span class="tok-kw">switch</span> (endian) {
        .big =&gt; {
            <span class="tok-kw">for</span> (bytes) |b| {
                result = (result &lt;&lt; <span class="tok-number">8</span>) | b;
            }
        },
        .little =&gt; {
            <span class="tok-kw">const</span> ShiftType = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(WorkType);
            <span class="tok-kw">for</span> (bytes, <span class="tok-number">0</span>..) |b, index| {
                result = result | (<span class="tok-builtin">@as</span>(WorkType, b) &lt;&lt; <span class="tok-builtin">@as</span>(ShiftType, <span class="tok-builtin">@intCast</span>(index * <span class="tok-number">8</span>)));
            }
        },
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(ReturnType, <span class="tok-builtin">@truncate</span>(result));
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.readVarPackedInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readVarPackedInt</span><a href="#src.zig-std.mem.readVarPackedInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readVarPackedInt</span>( <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, bit_count: <span class="tok-type">usize</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>, signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a>, ) T</code></pre></div><div class="tldDocs"><p>Loads an integer from packed memory with provided bit_count, bit_offset, and signedness.
Asserts that T is large enough to store the read value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>bit_offset: <span class="tok-type">usize</span></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a></code></pre></div><div><pre><code>signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> readVarPackedInt {
    <span class="tok-kw">const</span> T = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u16</span>) { a: <span class="tok-type">u3</span>, b: <span class="tok-type">u7</span>, c: <span class="tok-type">u6</span> };
    <span class="tok-kw">var</span> st = T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span>, .c = <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> b_field = <a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(<span class="tok-type">u64</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;st), <span class="tok-builtin">@bitOffsetOf</span>(T, <span class="tok-str">&quot;b&quot;</span>), <span class="tok-number">7</span>, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>(), .unsigned);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(st.b, b_field);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.readVarPackedInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readVarPackedInt</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    bit_offset: <span class="tok-type">usize</span>,
    bit_count: <span class="tok-type">usize</span>,
    endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>,
    signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a>,
) T {
    <span class="tok-kw">const</span> uN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> iN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> Log2N = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(T);

    <span class="tok-kw">const</span> read_size = (bit_count + (bit_offset % <span class="tok-number">8</span>) + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;
    <span class="tok-kw">const</span> bit_shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(bit_offset % <span class="tok-number">8</span>));
    <span class="tok-kw">const</span> pad = <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@bitSizeOf</span>(T) - bit_count));

    <span class="tok-kw">const</span> lowest_byte = <span class="tok-kw">switch</span> (endian) {
        .big =&gt; bytes.len - (bit_offset / <span class="tok-number">8</span>) - read_size,
        .little =&gt; bit_offset / <span class="tok-number">8</span>,
    };
    <span class="tok-kw">const</span> read_bytes = bytes[lowest_byte..][<span class="tok-number">0</span>..read_size];

    <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &lt;= <span class="tok-number">8</span>) {<span class="tok-comment">
        // These are the same shifts/masks we perform below, but adds `@truncate`/`@intCast`
        // where needed since int is smaller than a byte.
        </span><span class="tok-kw">const</span> value = <span class="tok-kw">if</span> (read_size == <span class="tok-number">1</span>) b: {
            <span class="tok-kw">break</span> :b <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(read_bytes[<span class="tok-number">0</span>] &gt;&gt; bit_shift));
        } <span class="tok-kw">else</span> b: {
            <span class="tok-kw">const</span> i: <span class="tok-type">u1</span> = <span class="tok-builtin">@intFromBool</span>(endian == .big);
            <span class="tok-kw">const</span> head = <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(read_bytes[i] &gt;&gt; bit_shift));
            <span class="tok-kw">const</span> tail_shift = <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">8</span>) - bit_shift));
            <span class="tok-kw">const</span> tail = <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(read_bytes[<span class="tok-number">1</span> - i]));
            <span class="tok-kw">break</span> :b (tail &lt;&lt; tail_shift) | head;
        };
        <span class="tok-kw">switch</span> (signedness) {
            .signed =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(iN, <span class="tok-builtin">@bitCast</span>(value)) &lt;&lt; pad) &gt;&gt; pad)),
            .unsigned =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(value)) &lt;&lt; pad) &gt;&gt; pad)),
        }
    }<span class="tok-comment">

    // Copy the value out (respecting endianness), accounting for bit_shift
    </span><span class="tok-kw">var</span> int: uN = <span class="tok-number">0</span>;
    <span class="tok-kw">switch</span> (endian) {
        .big =&gt; {
            <span class="tok-kw">for</span> (read_bytes[<span class="tok-number">0</span> .. read_size - <span class="tok-number">1</span>]) |elem| {
                int = elem | (int &lt;&lt; <span class="tok-number">8</span>);
            }
            int = (read_bytes[read_size - <span class="tok-number">1</span>] &gt;&gt; bit_shift) | (int &lt;&lt; (<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">8</span>) - bit_shift));
        },
        .little =&gt; {
            int = read_bytes[<span class="tok-number">0</span>] &gt;&gt; bit_shift;
            <span class="tok-kw">for</span> (read_bytes[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |elem, i| {
                int |= (<span class="tok-builtin">@as</span>(uN, elem) &lt;&lt; <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>((<span class="tok-number">8</span> * (i + <span class="tok-number">1</span>) - bit_shift))));
            }
        },
    }
    <span class="tok-kw">switch</span> (signedness) {
        .signed =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(iN, <span class="tok-builtin">@bitCast</span>(int)) &lt;&lt; pad) &gt;&gt; pad)),
        .unsigned =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(int)) &lt;&lt; pad) &gt;&gt; pad)),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.readInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readInt</span><a href="#src.zig-std.mem.readInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">readInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: *<span class="tok-kw">const</span> [<span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).int.bits, <span class="tok-number">8</span>)]<span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) T</code></pre></div><div class="tldDocs"><p>Reads an integer from memory with bit count specified by T.
The bit count of T must be evenly divisible by 8.
This function cannot fail and cannot cause undefined behavior.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: *<span class="tok-kw">const</span> [<span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).int.bits, <span class="tok-number">8</span>)]<span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> readInt {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u0</span>, &amp;[_]<span class="tok-type">u8</span>{}, .big) == <span class="tok-number">0x0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u0</span>, &amp;[_]<span class="tok-type">u8</span>{}, .little) == <span class="tok-number">0x0</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x32</span>}, .big) == <span class="tok-number">0x32</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x12</span>}, .little) == <span class="tok-number">0x12</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }, .big) == <span class="tok-number">0x1234</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }, .little) == <span class="tok-number">0x3412</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u72</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x78</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x24</span> }, .big) == <span class="tok-number">0x123456789abcdef024</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u72</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xec</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x32</span>, <span class="tok-number">0x54</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x98</span>, <span class="tok-number">0xba</span>, <span class="tok-number">0xdc</span>, <span class="tok-number">0xfe</span> }, .little) == <span class="tok-number">0xfedcba9876543210ec</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>}, .big) == -<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xfe</span>}, .little) == -<span class="tok-number">2</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xff</span>, <span class="tok-number">0xfd</span> }, .big) == -<span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xfc</span>, <span class="tok-number">0xff</span> }, .little) == -<span class="tok-number">4</span>);

    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.moreReadIntTests">moreReadIntTests</a>();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> <a href="std.mem.html#std.mem.moreReadIntTests">moreReadIntTests</a>();
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.readInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">readInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: *<span class="tok-kw">const</span> [<span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).int.bits, <span class="tok-number">8</span>)]<span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) T {
    <span class="tok-kw">const</span> value: T = <span class="tok-builtin">@bitCast</span>(buffer.*);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (endian == <a href="std.mem.html#std.mem.native_endian">native_endian</a>) value <span class="tok-kw">else</span> <span class="tok-builtin">@byteSwap</span>(value);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.readPackedInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readPackedInt</span><a href="#src.zig-std.mem.readPackedInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readPackedInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) T</code></pre></div><div class="tldDocs"><p>Loads an integer from packed memory.
Asserts that buffer contains at least bit_offset + @bitSizeOf(T) bits.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>bit_offset: <span class="tok-type">usize</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> readPackedInt {
    <span class="tok-kw">const</span> T = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u16</span>) { a: <span class="tok-type">u3</span>, b: <span class="tok-type">u7</span>, c: <span class="tok-type">u6</span> };
    <span class="tok-kw">var</span> st = T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span>, .c = <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> b_field = <a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u7</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;st), <span class="tok-builtin">@bitOffsetOf</span>(T, <span class="tok-str">&quot;b&quot;</span>), <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>());
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(st.b, b_field);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.readPackedInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readPackedInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) T {
    <span class="tok-kw">switch</span> (endian) {
        .little =&gt; <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.readPackedIntLittle">readPackedIntLittle</a>(T, bytes, bit_offset),
        .big =&gt; <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.readPackedIntBig">readPackedIntBig</a>(T, bytes, bit_offset),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.writeInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeInt</span><a href="#src.zig-std.mem.writeInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: *[<span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).int.bits, <span class="tok-number">8</span>)]<span class="tok-type">u8</span>, value: T, endian: <a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Writes an integer to memory, storing it in twos-complement.
This function always succeeds, has defined behavior for all inputs, but
the integer bit width must be divisible by 8.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: *[<span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).int.bits, <span class="tok-number">8</span>)]<span class="tok-type">u8</span></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> writeInt {
    <span class="tok-kw">var</span> buf0: [<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> buf1: [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> buf2: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> buf9: [<span class="tok-number">9</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u0</span>, &amp;buf0, <span class="tok-number">0x0</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf0[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{}));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u0</span>, &amp;buf0, <span class="tok-number">0x0</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf0[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{}));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u8</span>, &amp;buf1, <span class="tok-number">0x12</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf1[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x12</span>}));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u8</span>, &amp;buf1, <span class="tok-number">0x34</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf1[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x34</span>}));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u16</span>, &amp;buf2, <span class="tok-number">0x1234</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf2[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u16</span>, &amp;buf2, <span class="tok-number">0x5678</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf2[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x78</span>, <span class="tok-number">0x56</span> }));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u72</span>, &amp;buf9, <span class="tok-number">0x123456789abcdef024</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf9[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x78</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x24</span> }));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u72</span>, &amp;buf9, <span class="tok-number">0xfedcba9876543210ec</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf9[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xec</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x32</span>, <span class="tok-number">0x54</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x98</span>, <span class="tok-number">0xba</span>, <span class="tok-number">0xdc</span>, <span class="tok-number">0xfe</span> }));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">i8</span>, &amp;buf1, -<span class="tok-number">1</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf1[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>}));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">i8</span>, &amp;buf1, -<span class="tok-number">2</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf1[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xfe</span>}));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">i16</span>, &amp;buf2, -<span class="tok-number">3</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf2[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xff</span>, <span class="tok-number">0xfd</span> }));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">i16</span>, &amp;buf2, -<span class="tok-number">4</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf2[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xfc</span>, <span class="tok-number">0xff</span> }));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.writeInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: *[<span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).int.bits, <span class="tok-number">8</span>)]<span class="tok-type">u8</span>, value: T, endian: <a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span> {
    buffer.* = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (endian == <a href="std.mem.html#std.mem.native_endian">native_endian</a>) value <span class="tok-kw">else</span> <span class="tok-builtin">@byteSwap</span>(value));
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.writePackedInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writePackedInt</span><a href="#src.zig-std.mem.writePackedInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePackedInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, value: T, endian: <a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Stores an integer to packed memory.
Asserts that buffer contains at least bit_offset + @bitSizeOf(T) bits.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>bytes: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>bit_offset: <span class="tok-type">usize</span></code></pre></div><div><pre><code>value: T</code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> writePackedInt {
    <span class="tok-kw">const</span> T = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u16</span>) { a: <span class="tok-type">u3</span>, b: <span class="tok-type">u7</span>, c: <span class="tok-type">u6</span> };
    <span class="tok-kw">var</span> st = T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span>, .c = <span class="tok-number">4</span> };
    <a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<span class="tok-type">u7</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;st), <span class="tok-builtin">@bitOffsetOf</span>(T, <span class="tok-str">&quot;b&quot;</span>), <span class="tok-number">0x7f</span>, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>());
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">0x7f</span>, .c = <span class="tok-number">4</span> }, st);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.writePackedInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePackedInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, value: T, endian: <a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (endian) {
        .little =&gt; <a href="std.mem.html#std.mem.writePackedIntLittle">writePackedIntLittle</a>(T, bytes, bit_offset, value),
        .big =&gt; <a href="std.mem.html#std.mem.writePackedIntBig">writePackedIntBig</a>(T, bytes, bit_offset, value),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.writeVarPackedInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeVarPackedInt</span><a href="#src.zig-std.mem.writeVarPackedInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeVarPackedInt</span>(bytes: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, bit_count: <span class="tok-type">usize</span>, value: <span class="tok-kw">anytype</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Stores an integer to packed memory with provided bit_offset, bit_count, and signedness.
If negative, the written value is sign-extended.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bytes: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>bit_offset: <span class="tok-type">usize</span></code></pre></div><div><pre><code>bit_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> writeVarPackedInt {
    <span class="tok-kw">const</span> T = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u16</span>) { a: <span class="tok-type">u3</span>, b: <span class="tok-type">u7</span>, c: <span class="tok-type">u6</span> };
    <span class="tok-kw">var</span> st = T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span>, .c = <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> value: <span class="tok-type">u64</span> = <span class="tok-number">0x7f</span>;
    <a href="std.mem.html#std.mem.writeVarPackedInt">writeVarPackedInt</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;st), <span class="tok-builtin">@bitOffsetOf</span>(T, <span class="tok-str">&quot;b&quot;</span>), <span class="tok-number">7</span>, value, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(T{ .a = <span class="tok-number">1</span>, .b = value, .c = <span class="tok-number">4</span> }, st);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.writeVarPackedInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeVarPackedInt</span>(bytes: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, bit_count: <span class="tok-type">usize</span>, value: <span class="tok-kw">anytype</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(value);
    <span class="tok-kw">const</span> uN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T));

    <span class="tok-kw">const</span> bit_shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(bit_offset % <span class="tok-number">8</span>));
    <span class="tok-kw">const</span> write_size = (bit_count + bit_shift + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;
    <span class="tok-kw">const</span> lowest_byte = <span class="tok-kw">switch</span> (endian) {
        .big =&gt; bytes.len - (bit_offset / <span class="tok-number">8</span>) - write_size,
        .little =&gt; bit_offset / <span class="tok-number">8</span>,
    };
    <span class="tok-kw">const</span> write_bytes = bytes[lowest_byte..][<span class="tok-number">0</span>..write_size];

    <span class="tok-kw">if</span> (write_size == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (write_size == <span class="tok-number">1</span>) {<span class="tok-comment">
        // Single byte writes are handled specially, since we need to mask bits
        // on both ends of the byte.
        </span><span class="tok-kw">const</span> mask = (<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0xff</span>) &gt;&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-number">8</span> - bit_count)));
        <span class="tok-kw">const</span> new_bits = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(value)) &amp; mask)) &lt;&lt; bit_shift;
        write_bytes[<span class="tok-number">0</span>] = (write_bytes[<span class="tok-number">0</span>] &amp; ~(mask &lt;&lt; bit_shift)) | new_bits;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">var</span> remaining: T = value;<span class="tok-comment">

    // Iterate bytes forward for Little-endian, backward for Big-endian
    </span><span class="tok-kw">const</span> delta: <span class="tok-type">i2</span> = <span class="tok-kw">if</span> (endian == .big) -<span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> start = <span class="tok-kw">if</span> (endian == .big) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(write_bytes.len - <span class="tok-number">1</span>)) <span class="tok-kw">else</span> <span class="tok-number">0</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">isize</span> = start;<span class="tok-comment"> // isize for signed index arithmetic

    // Write first byte, using a mask to protects bits preceding bit_offset
    </span><span class="tok-kw">const</span> head_mask = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0xff</span>) &gt;&gt; bit_shift;
    write_bytes[<span class="tok-builtin">@intCast</span>(i)] &amp;= ~(head_mask &lt;&lt; bit_shift);
    write_bytes[<span class="tok-builtin">@intCast</span>(i)] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(remaining)) &amp; head_mask)) &lt;&lt; bit_shift;
    remaining = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(T, remaining, <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">8</span>) - bit_shift);
    i += delta;<span class="tok-comment">

    // Write bytes[1..bytes.len - 1]
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt; <span class="tok-number">8</span>) {
        <span class="tok-kw">const</span> loop_end = start + delta * (<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(write_size)) - <span class="tok-number">1</span>);
        <span class="tok-kw">while</span> (i != loop_end) : (i += delta) {
            write_bytes[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(i))] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(remaining))));
            remaining &gt;&gt;= <span class="tok-number">8</span>;
        }
    }<span class="tok-comment">

    // Write last byte, using a mask to protect bits following bit_offset + bit_count
    </span><span class="tok-kw">const</span> following_bits = -%<span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@truncate</span>(bit_shift + bit_count));
    <span class="tok-kw">const</span> tail_mask = (<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0xff</span>) &lt;&lt; following_bits) &gt;&gt; following_bits;
    write_bytes[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(i))] &amp;= ~tail_mask;
    write_bytes[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(i))] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(remaining)) &amp; tail_mask));
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.byteSwapAllFields" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">byteSwapAllFields</span><a href="#src.zig-std.mem.byteSwapAllFields">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">byteSwapAllFields</span>(<span class="tok-kw">comptime</span> S: <span class="tok-type">type</span>, ptr: *S) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Swap the byte order of all the members of the fields of a struct
(Changing their endianness)</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>S: <span class="tok-type">type</span></code></pre></div><div><pre><code>ptr: *S</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> byteSwapAllFields {
    <span class="tok-kw">const</span> T = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        f0: <span class="tok-type">u8</span>,
        f1: <span class="tok-type">u16</span>,
        f2: <span class="tok-type">u32</span>,
        f3: [<span class="tok-number">1</span>]<span class="tok-type">u8</span>,
        f4: <span class="tok-type">bool</span>,
        f5: <span class="tok-type">f32</span>,
    };
    <span class="tok-kw">const</span> K = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        f0: <span class="tok-type">u8</span>,
        f1: T,
        f2: <span class="tok-type">u16</span>,
        f3: [<span class="tok-number">1</span>]<span class="tok-type">u8</span>,
        f4: <span class="tok-type">bool</span>,
        f5: <span class="tok-type">f32</span>,
    };
    <span class="tok-kw">var</span> s = T{
        .f0 = <span class="tok-number">0x12</span>,
        .f1 = <span class="tok-number">0x1234</span>,
        .f2 = <span class="tok-number">0x12345678</span>,
        .f3 = .{<span class="tok-number">0x12</span>},
        .f4 = <span class="tok-null">true</span>,
        .f5 = <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x4640e400</span>))),
    };
    <span class="tok-kw">var</span> k = K{
        .f0 = <span class="tok-number">0x12</span>,
        .f1 = s,
        .f2 = <span class="tok-number">0x1234</span>,
        .f3 = .{<span class="tok-number">0x12</span>},
        .f4 = <span class="tok-null">false</span>,
        .f5 = <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x45d42800</span>))),
    };
    <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(T, &amp;s);
    <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(K, &amp;k);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(T{
        .f0 = <span class="tok-number">0x12</span>,
        .f1 = <span class="tok-number">0x3412</span>,
        .f2 = <span class="tok-number">0x78563412</span>,
        .f3 = .{<span class="tok-number">0x12</span>},
        .f4 = <span class="tok-null">true</span>,
        .f5 = <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x00e44046</span>))),
    }, s);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(K{
        .f0 = <span class="tok-number">0x12</span>,
        .f1 = s,
        .f2 = <span class="tok-number">0x3412</span>,
        .f3 = .{<span class="tok-number">0x12</span>},
        .f4 = <span class="tok-null">false</span>,
        .f5 = <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x0028d445</span>))),
    }, k);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.byteSwapAllFields">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">byteSwapAllFields</span>(<span class="tok-kw">comptime</span> S: <span class="tok-type">type</span>, ptr: *S) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(S)) {
        .@&quot;struct&quot; =&gt; {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(S)) |f| {
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(f.<span class="tok-type">type</span>)) {
                    .@&quot;struct&quot; =&gt; |struct_info| <span class="tok-kw">if</span> (struct_info.backing_integer) |Int| {
                        <span class="tok-builtin">@field</span>(ptr, f.name) = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@as</span>(Int, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@field</span>(ptr, f.name)))));
                    } <span class="tok-kw">else</span> {
                        <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(f.<span class="tok-type">type</span>, &amp;<span class="tok-builtin">@field</span>(ptr, f.name));
                    },
                    .array =&gt; <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(f.<span class="tok-type">type</span>, &amp;<span class="tok-builtin">@field</span>(ptr, f.name)),
                    .@&quot;enum&quot; =&gt; {
                        <span class="tok-builtin">@field</span>(ptr, f.name) = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@intFromEnum</span>(<span class="tok-builtin">@field</span>(ptr, f.name))));
                    },
                    .<span class="tok-type">bool</span> =&gt; {},
                    .float =&gt; |float_info| {
                        <span class="tok-builtin">@field</span>(ptr, f.name) = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, float_info.bits), <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@field</span>(ptr, f.name)))));
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-builtin">@field</span>(ptr, f.name) = <span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@field</span>(ptr, f.name));
                    },
                }
            }
        },
        .array =&gt; {
            <span class="tok-kw">for</span> (ptr) |*item| {
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(item.*))) {
                    .@&quot;struct&quot;, .array =&gt; <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(<span class="tok-builtin">@TypeOf</span>(item.*), item),
                    .@&quot;enum&quot; =&gt; {
                        item.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@intFromEnum</span>(item.*)));
                    },
                    .<span class="tok-type">bool</span> =&gt; {},
                    .float =&gt; |float_info| {
                        item.* = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, float_info.bits), <span class="tok-builtin">@bitCast</span>(item.*))));
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        item.* = <span class="tok-builtin">@byteSwap</span>(item.*);
                    },
                }
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;byteSwapAllFields expects a struct or array as the first argument&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.tokenizeAny" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tokenizeAny</span><a href="#src.zig-std.mem.tokenizeAny">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .any)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates over the slices of <code>buffer</code> that are not
any of the items in <code>delimiters</code>.</p>
<p><code>tokenizeAny(u8, &quot;   abc|def ||  ghi  &quot;, &quot; |&quot;)</code> will return slices
for &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, null, in that order.</p>
<p>If <code>buffer</code> is empty, the iterator will return null.
If none of <code>delimiters</code> exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.</p>
<p>See also: <code><a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a></code>, <code><a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a></code>,
<code><a href="std.mem.html#std.mem.splitSequence">splitSequence</a></code>,<code><a href="std.mem.html#std.mem.splitAny">splitAny</a></code>, <code><a href="std.mem.html#std.mem.splitScalar">splitScalar</a></code>,
<code><a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a></code>, and <code><a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a></code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiters: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> tokenizeAny {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a|b,c/d e&quot;</span>, <span class="tok-str">&quot; /,|&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.peek().?, <span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a|b,c/d e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot; /,|&quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.tokenizeAny">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .any) {
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiters,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.tokenizeSequence" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tokenizeSequence</span><a href="#src.zig-std.mem.tokenizeSequence">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .sequence)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates over the slices of <code>buffer</code> that are not
the sequence in <code>delimiter</code>.</p>
<p><code>tokenizeSequence(u8, &quot;&lt;&gt;abc&gt;&lt;def&lt;&gt;&lt;&gt;ghi&quot;, &quot;&lt;&gt;&quot;)</code> will return slices
for &quot;abc&gt;&lt;def&quot;, &quot;ghi&quot;, null, in that order.</p>
<p>If <code>buffer</code> is empty, the iterator will return null.
If <code>delimiter</code> does not exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.
The delimiter length must not be zero.</p>
<p>See also: <code><a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a></code>, <code><a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a></code>,
<code><a href="std.mem.html#std.mem.splitSequence">splitSequence</a></code>,<code><a href="std.mem.html#std.mem.splitAny">splitAny</a></code>, and <code><a href="std.mem.html#std.mem.splitScalar">splitScalar</a></code>
<code><a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a></code>, and <code><a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a></code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiter: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> tokenizeSequence {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&lt;&gt;b&lt;&gt;&lt;&gt;c&gt;&lt;&gt;d&gt;&lt;&quot;</span>, <span class="tok-str">&quot;&lt;&gt;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;a&quot;</span>, it.next().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;b&quot;</span>, it.peek().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;b&quot;</span>, it.next().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;c&gt;&quot;</span>, it.next().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;d&gt;&lt;&quot;</span>, it.next().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&lt;&gt;b&lt;&gt;&lt;&gt;c&gt;&lt;&gt;d&gt;&lt;&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;&lt;&gt;&quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&gt;&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&gt;&lt;&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.tokenizeSequence">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .sequence) {
    <a href="std.debug.html#std.debug.assert">assert</a>(delimiter.len != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.tokenizeScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tokenizeScalar</span><a href="#src.zig-std.mem.tokenizeScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .scalar)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates over the slices of <code>buffer</code> that are not
<code>delimiter</code>.</p>
<p><code>tokenizeScalar(u8, &quot;   abc def     ghi  &quot;, ' ')</code> will return slices
for &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, null, in that order.</p>
<p>If <code>buffer</code> is empty, the iterator will return null.
If <code>delimiter</code> does not exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.</p>
<p>See also: <code><a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a></code>, <code><a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a></code>,
<code><a href="std.mem.html#std.mem.splitSequence">splitSequence</a></code>,<code><a href="std.mem.html#std.mem.splitAny">splitAny</a></code>, and <code><a href="std.mem.html#std.mem.splitScalar">splitScalar</a></code>
<code><a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a></code>, and <code><a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a></code></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiter: T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> tokenizeScalar {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   abc def   ghi  &quot;</span>, <span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.peek().?, <span class="tok-str">&quot;def&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;..\\bob&quot;</span>, <span class="tok-str">'\\'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;..&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;..&quot;</span>, <span class="tok-str">&quot;..\\bob&quot;</span>[<span class="tok-number">0</span>..it.index]));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;bob&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;//a/b&quot;</span>, <span class="tok-str">'/'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;//a/b&quot;</span>, <span class="tok-str">&quot;//a/b&quot;</span>[<span class="tok-number">0</span>..it.index]));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;|&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>),
        <span class="tok-str">' '</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.tokenizeScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .scalar) {
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.splitSequence" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splitSequence</span><a href="#src.zig-std.mem.splitSequence">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .sequence)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates over the slices of <code>buffer</code> that
are separated by the byte sequence in <code>delimiter</code>.</p>
<p><code>splitSequence(u8, &quot;abc||def||||ghi&quot;, &quot;||&quot;)</code> will return slices
for &quot;abc&quot;, &quot;def&quot;, &quot;&quot;, &quot;ghi&quot;, null, in that order.</p>
<p>If <code>delimiter</code> does not exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.
The delimiter length must not be zero.</p>
<p>See also: <code><a href="std.mem.html#std.mem.splitAny">splitAny</a></code>, <code><a href="std.mem.html#std.mem.splitScalar">splitScalar</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a></code>,
<code><a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a></code>,<code><a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a></code>,
<code><a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a></code>, <code><a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a></code>, and <code><a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiter: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> splitSequence {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitSequence">splitSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>, <span class="tok-str">&quot;, &quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;b ,, c, d, e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b ,&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitSequence">splitSequence</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;, &quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b ,&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.splitSequence">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .sequence) {
    <a href="std.debug.html#std.debug.assert">assert</a>(delimiter.len != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.splitAny" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splitAny</span><a href="#src.zig-std.mem.splitAny">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .any)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates over the slices of <code>buffer</code> that
are separated by any item in <code>delimiters</code>.</p>
<p><code>splitAny(u8, &quot;abc,def||ghi&quot;, &quot;|,&quot;)</code> will return slices
for &quot;abc&quot;, &quot;def&quot;, &quot;&quot;, &quot;ghi&quot;, null, in that order.</p>
<p>If none of <code>delimiters</code> exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.</p>
<p>See also: <code><a href="std.mem.html#std.mem.splitSequence">splitSequence</a></code>, <code><a href="std.mem.html#std.mem.splitScalar">splitScalar</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a></code>,
<code><a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a></code>,<code><a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a></code>,
<code><a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a></code>, <code><a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a></code>, and <code><a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiters: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> splitAny {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitAny">splitAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a,b, c d e&quot;</span>, <span class="tok-str">&quot;, &quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;b, c d e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitAny">splitAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitAny">splitAny</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a,b, c d e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;, &quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.splitAny">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .any) {
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiters,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.splitScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splitScalar</span><a href="#src.zig-std.mem.splitScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .scalar)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates over the slices of <code>buffer</code> that
are separated by <code>delimiter</code>.</p>
<p><code>splitScalar(u8, &quot;abc|def||ghi&quot;, '|')</code> will return slices
for &quot;abc&quot;, &quot;def&quot;, &quot;&quot;, &quot;ghi&quot;, null, in that order.</p>
<p>If <code>delimiter</code> does not exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.</p>
<p>See also: <code><a href="std.mem.html#std.mem.splitSequence">splitSequence</a></code>, <code><a href="std.mem.html#std.mem.splitAny">splitAny</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a></code>,
<code><a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a></code>,<code><a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a></code>,
<code><a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a></code>, <code><a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a></code>, and <code><a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiter: T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> splitScalar {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc|def||ghi&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc|def||ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;def||ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.peek().?, <span class="tok-str">&quot;def&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;|ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.peek().?, <span class="tok-str">&quot;ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;|&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;hello&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>),
        <span class="tok-str">' '</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.splitScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .scalar) {
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.splitBackwardsSequence" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splitBackwardsSequence</span><a href="#src.zig-std.mem.splitBackwardsSequence">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .sequence)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates backwards over the slices of <code>buffer</code> that
are separated by the sequence in <code>delimiter</code>.</p>
<p><code>splitBackwardsSequence(u8, &quot;abc||def||||ghi&quot;, &quot;||&quot;)</code> will return slices
for &quot;ghi&quot;, &quot;&quot;, &quot;def&quot;, &quot;abc&quot;, null, in that order.</p>
<p>If <code>delimiter</code> does not exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.
The delimiter length must not be zero.</p>
<p>See also: <code><a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a></code>,
<code><a href="std.mem.html#std.mem.splitSequence">splitSequence</a></code>, <code><a href="std.mem.html#std.mem.splitAny">splitAny</a></code>,<code><a href="std.mem.html#std.mem.splitScalar">splitScalar</a></code>,
<code><a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a></code>, <code><a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a></code>, and <code><a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiter: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> splitBackwardsSequence {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>, <span class="tok-str">&quot;, &quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;e&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a, b ,, c, d&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a, b ,, c&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a, b ,&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b ,&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;, &quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b ,&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.splitBackwardsSequence">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .sequence) {
    <a href="std.debug.html#std.debug.assert">assert</a>(delimiter.len != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .index = buffer.len,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.splitBackwardsAny" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splitBackwardsAny</span><a href="#src.zig-std.mem.splitBackwardsAny">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .any)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates backwards over the slices of <code>buffer</code> that
are separated by any item in <code>delimiters</code>.</p>
<p><code>splitBackwardsAny(u8, &quot;abc,def||ghi&quot;, &quot;|,&quot;)</code> will return slices
for &quot;ghi&quot;, &quot;&quot;, &quot;def&quot;, &quot;abc&quot;, null, in that order.</p>
<p>If none of <code>delimiters</code> exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.</p>
<p>See also: <code><a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a></code>,
<code><a href="std.mem.html#std.mem.splitSequence">splitSequence</a></code>, <code><a href="std.mem.html#std.mem.splitAny">splitAny</a></code>,<code><a href="std.mem.html#std.mem.splitScalar">splitScalar</a></code>,
<code><a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a></code>, <code><a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a></code>, and <code><a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiters: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> splitBackwardsAny {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a,b, c d e&quot;</span>, <span class="tok-str">&quot;, &quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b, c d e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;e&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b, c d&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b, c&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b,&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a,b, c d e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;, &quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.splitBackwardsAny">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .any) {
    <span class="tok-kw">return</span> .{
        .index = buffer.len,
        .buffer = buffer,
        .delimiter = delimiters,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.splitBackwardsScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splitBackwardsScalar</span><a href="#src.zig-std.mem.splitBackwardsScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .scalar)</code></pre></div><div class="tldDocs"><p>Returns an iterator that iterates backwards over the slices of <code>buffer</code> that
are separated by <code>delimiter</code>.</p>
<p><code>splitBackwardsScalar(u8, &quot;abc|def||ghi&quot;, '|')</code> will return slices
for &quot;ghi&quot;, &quot;&quot;, &quot;def&quot;, &quot;abc&quot;, null, in that order.</p>
<p>If <code>delimiter</code> does not exist in buffer,
the iterator will return <code>buffer</code>, null, in that order.</p>
<p>See also: <code><a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a></code>, <code><a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a></code>,
<code><a href="std.mem.html#std.mem.splitSequence">splitSequence</a></code>, <code><a href="std.mem.html#std.mem.splitAny">splitAny</a></code>,<code><a href="std.mem.html#std.mem.splitScalar">splitScalar</a></code>,
<code><a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a></code>, <code><a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a></code>, and <code><a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>delimiter: T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> splitBackwardsScalar {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc|def||ghi&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc|def||ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;ghi&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc|def|&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc|def&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;|&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;hello&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>),
        <span class="tok-str">' '</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.splitBackwardsScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .scalar) {
    <span class="tok-kw">return</span> .{
        .index = buffer.len,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.window" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">window</span><a href="#src.zig-std.mem.window">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">window</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, size: <span class="tok-type">usize</span>, advance: <span class="tok-type">usize</span>) <a href="std.mem.html#std.mem.WindowIterator">WindowIterator</a>(T)</code></pre></div><div class="tldDocs"><p>Returns an iterator with a sliding window of slices for <code>buffer</code>.
The sliding window has length <code>size</code> and on every iteration moves
forward by <code>advance</code>.</p>
<p>Extract data for moving average with:
<code>window(u8, &quot;abcdefg&quot;, 3, 1)</code> will return slices
&quot;abc&quot;, &quot;bcd&quot;, &quot;cde&quot;, &quot;def&quot;, &quot;efg&quot;, null, in that order.</p>
<p>Chunk or split every N items with:
<code>window(u8, &quot;abcdefg&quot;, 3, 3)</code> will return slices
&quot;abc&quot;, &quot;def&quot;, &quot;g&quot;, null, in that order.</p>
<p>Pick every even index with:
<code>window(u8, &quot;abcdefg&quot;, 1, 2)</code> will return slices
&quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;g&quot; null, in that order.</p>
<p>The <code>size</code> and <code>advance</code> must be not be zero.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>size: <span class="tok-type">usize</span></code></pre></div><div><pre><code>advance: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> window {
    {<span class="tok-comment">
        // moving average size 3
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;bcd&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;cde&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;efg&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);<span class="tok-comment">

        // multibyte
        </span><span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u16</span>, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-number">3</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;bcd&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;cde&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;efg&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it16.next(), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // chunk/split every 3
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;g&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // pick even
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;e&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;g&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // empty
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);

        it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">10</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);

        it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);

        it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">10</span>, <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // first
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>);
        it.reset();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
    }

    {<span class="tok-comment">
        // reset
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;g&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);

        it.reset();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;g&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.window">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">window</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, size: <span class="tok-type">usize</span>, advance: <span class="tok-type">usize</span>) <a href="std.mem.html#std.mem.WindowIterator">WindowIterator</a>(T) {
    <a href="std.debug.html#std.debug.assert">assert</a>(size != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(advance != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .size = size,
        .advance = advance,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.startsWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">startsWith</span><a href="#src.zig-std.mem.startsWith">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startsWith</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> startsWith {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Bob&quot;</span>, <span class="tok-str">&quot;Bo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Needle in haystack&quot;</span>, <span class="tok-str">&quot;haystack&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.startsWith">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startsWith</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-null">false</span> <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.eql">eql</a>(T, haystack[<span class="tok-number">0</span>..needle.len], needle);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.endsWith" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">endsWith</span><a href="#src.zig-std.mem.endsWith">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endsWith</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>haystack: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> endsWith {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Needle in haystack&quot;</span>, <span class="tok-str">&quot;haystack&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Bob&quot;</span>, <span class="tok-str">&quot;Bo&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.endsWith">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endsWith</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-null">false</span> <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.eql">eql</a>(T, haystack[haystack.len - needle.len ..], needle);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.join" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">join</span><a href="#src.zig-std.mem.join">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Naively combines a series of slices with a separator.
Allocates memory for the result, which must be freed by the caller.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> join {
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.join">join</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;&quot;</span>));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.join">join</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a,b,c&quot;</span>));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.join">join</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;a&quot;</span>});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a&quot;</span>));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.join">join</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;c&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a,,b,,c&quot;</span>));
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.join">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.joinMaybeZ">joinMaybeZ</a>(allocator, separator, slices, <span class="tok-null">false</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.joinZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">joinZ</span><a href="#src.zig-std.mem.joinZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">joinZ</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Naively combines a series of slices with a separator and null terminator.
Allocates memory for the result, which must be freed by the caller.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> joinZ {
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinZ">joinZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(str[str.len], <span class="tok-number">0</span>);
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinZ">joinZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a,b,c&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(str[str.len], <span class="tok-number">0</span>);
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinZ">joinZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;a&quot;</span>});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(str[str.len], <span class="tok-number">0</span>);
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinZ">joinZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;c&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a,,b,,c&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(str[str.len], <span class="tok-number">0</span>);
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.joinZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">joinZ</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> out = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinMaybeZ">joinMaybeZ</a>(allocator, separator, slices, <span class="tok-null">true</span>);
    <span class="tok-kw">return</span> out[<span class="tok-number">0</span> .. out.len - <span class="tok-number">1</span> :<span class="tok-number">0</span>];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.concat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">concat</span><a href="#src.zig-std.mem.concat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concat</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Copies each T from slices into a new slice that exactly holds all the elements.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> concat {
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concat">concat</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;def&quot;</span>, <span class="tok-str">&quot;ghi&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;abcdefghi&quot;</span>));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concat">concat</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u32</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u32</span>{
            &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
            &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> },
            &amp;[_]<span class="tok-type">u32</span>{},
            &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">5</span>},
        });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u32</span>, str, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concatWithSentinel">concatWithSentinel</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;def&quot;</span>, <span class="tok-str">&quot;ghi&quot;</span> }, <span class="tok-number">0</span>);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSentinel">expectEqualSentinel</a>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>, str, <span class="tok-str">&quot;abcdefghi&quot;</span>);
    }
    {
        <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concatWithSentinel">concatWithSentinel</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{}, <span class="tok-number">0</span>);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(slice);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSentinel">expectEqualSentinel</a>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>, slice, &amp;[_:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{});
    }
    {
        <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concatWithSentinel">concatWithSentinel</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u32</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u32</span>{
            &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
            &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> },
            &amp;[_]<span class="tok-type">u32</span>{},
            &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">5</span>},
        }, <span class="tok-number">2</span>);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(slice);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSentinel">expectEqualSentinel</a>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>, slice, &amp;[_:<span class="tok-number">2</span>]<span class="tok-type">u32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> });
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.concat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concat</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.concatMaybeSentinel">concatMaybeSentinel</a>(allocator, T, slices, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.concatWithSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">concatWithSentinel</span><a href="#src.zig-std.mem.concatWithSentinel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatWithSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> s: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:s]T</code></pre></div><div class="tldDocs"><p>Copies each T from slices into a new slice that exactly holds all the elements.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>s: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.concatWithSentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatWithSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> s: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:s]T {
    <span class="tok-kw">const</span> ret = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concatMaybeSentinel">concatMaybeSentinel</a>(allocator, T, slices, s);
    <span class="tok-kw">return</span> ret[<span class="tok-number">0</span> .. ret.len - <span class="tok-number">1</span> :s];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.concatMaybeSentinel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">concatMaybeSentinel</span><a href="#src.zig-std.mem.concatMaybeSentinel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatMaybeSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> s: ?T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Copies each T from slices into a new slice that exactly holds all the elements as well as the sentinel.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>s: ?T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.concatMaybeSentinel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatMaybeSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> s: ?T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">if</span> (slices.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">if</span> (s) |sentinel| <span class="tok-kw">try</span> allocator.dupe(T, &amp;[<span class="tok-number">1</span>]T{sentinel}) <span class="tok-kw">else</span> &amp;[<span class="tok-number">0</span>]T{};

    <span class="tok-kw">const</span> total_len = blk: {
        <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (slices) |slice| {
            sum += slice.len;
        }

        <span class="tok-kw">if</span> (s) |_| {
            sum += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">break</span> :blk sum;
    };

    <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> allocator.alloc(T, total_len);
    <span class="tok-kw">errdefer</span> allocator.free(buf);

    <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slices) |slice| {
        <span class="tok-builtin">@memcpy</span>(buf[buf_index .. buf_index + slice.len], slice);
        buf_index += slice.len;
    }

    <span class="tok-kw">if</span> (s) |sentinel| {
        buf[buf.len - <span class="tok-number">1</span>] = sentinel;
    }<span class="tok-comment">

    // No need for shrink since buf is exactly the correct size.
    </span><span class="tok-kw">return</span> buf;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.min" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">min</span><a href="#src.zig-std.mem.min">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">min</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) T</code></pre></div><div class="tldDocs"><p>Returns the smallest number in a slice. O(n).
<code>slice</code> must not be empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> min {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.min">min</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-str">'a'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.min">min</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;bcdefga&quot;</span>), <span class="tok-str">'a'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.min">min</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>), <span class="tok-str">'a'</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.min">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">min</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> best = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..]) |item| {
        best = <span class="tok-builtin">@min</span>(best, item);
    }
    <span class="tok-kw">return</span> best;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.max" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">max</span><a href="#src.zig-std.mem.max">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) T</code></pre></div><div class="tldDocs"><p>Returns the largest number in a slice. O(n).
<code>slice</code> must not be empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> max {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.max">max</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-str">'g'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.max">max</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;gabcdef&quot;</span>), <span class="tok-str">'g'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.max">max</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;g&quot;</span>), <span class="tok-str">'g'</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.max">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> best = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..]) |item| {
        best = <span class="tok-builtin">@max</span>(best, item);
    }
    <span class="tok-kw">return</span> best;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfMin" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfMin</span><a href="#src.zig-std.mem.indexOfMin">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfMin</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the index of the smallest number in a slice. O(n).
<code>slice</code> must not be empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> indexOfMin {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMin">indexOfMin</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMin">indexOfMin</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;bcdefga&quot;</span>), <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMin">indexOfMin</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>), <span class="tok-number">0</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfMin">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfMin</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> best = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (item &lt; best) {
            best = item;
            index = i + <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.indexOfMax" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">indexOfMax</span><a href="#src.zig-std.mem.indexOfMax">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfMax</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the index of the largest number in a slice. O(n).
<code>slice</code> must not be empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> indexOfMax {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMax">indexOfMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMax">indexOfMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;gabcdef&quot;</span>), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMax">indexOfMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>), <span class="tok-number">0</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.indexOfMax">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfMax</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> best = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (item &gt; best) {
            best = item;
            index = i + <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.swap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swap</span><a href="#src.zig-std.mem.swap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: *T, b: *T) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>a: *T</code></pre></div><div><pre><code>b: *T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.swap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: *T, b: *T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tmp = a.*;
    a.* = b.*;
    b.* = tmp;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.reverse" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reverse</span><a href="#src.zig-std.mem.reverse">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverse</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>In-place order reversal of a slice</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> reverse {
    {
        <span class="tok-kw">var</span> arr = [_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span> };
        <a href="std.mem.html#std.mem.reverse">reverse</a>(<span class="tok-type">i32</span>, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">i32</span>, &amp;arr, &amp;.{ <span class="tok-number">4</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span> });
    }
    {
        <span class="tok-kw">var</span> arr = [_]<span class="tok-type">u0</span>{};
        <a href="std.mem.html#std.mem.reverse">reverse</a>(<span class="tok-type">u0</span>, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u0</span>, &amp;arr, &amp;.{});
    }
    {
        <span class="tok-kw">var</span> arr = [_]<span class="tok-type">i64</span>{ <span class="tok-number">19</span>, <span class="tok-number">17</span>, <span class="tok-number">15</span>, <span class="tok-number">13</span>, <span class="tok-number">11</span>, <span class="tok-number">9</span>, <span class="tok-number">7</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">6</span>, <span class="tok-number">8</span>, <span class="tok-number">10</span>, <span class="tok-number">12</span>, <span class="tok-number">14</span>, <span class="tok-number">16</span>, <span class="tok-number">18</span> };
        <a href="std.mem.html#std.mem.reverse">reverse</a>(<span class="tok-type">i64</span>, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">i64</span>, &amp;arr, &amp;.{ <span class="tok-number">18</span>, <span class="tok-number">16</span>, <span class="tok-number">14</span>, <span class="tok-number">12</span>, <span class="tok-number">10</span>, <span class="tok-number">8</span>, <span class="tok-number">6</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">9</span>, <span class="tok-number">11</span>, <span class="tok-number">13</span>, <span class="tok-number">15</span>, <span class="tok-number">17</span>, <span class="tok-number">19</span> });
    }
    {
        <span class="tok-kw">var</span> arr = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;d&quot;</span> };
        <a href="std.mem.html#std.mem.reverse">reverse</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;arr, &amp;.{ <span class="tok-str">&quot;d&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;a&quot;</span> });
    }
    {
        <span class="tok-kw">const</span> MyType = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            a: [<span class="tok-number">3</span>]<span class="tok-type">u8</span>,
            b: <span class="tok-type">u24</span>,
            c,
        };
        <span class="tok-kw">var</span> arr = [_]MyType{ .{ .a = .{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> } }, .{ .b = <span class="tok-number">0</span> }, .c };
        <a href="std.mem.html#std.mem.reverse">reverse</a>(MyType, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(MyType, &amp;arr, &amp;([_]MyType{ .c, .{ .b = <span class="tok-number">0</span> }, .{ .a = .{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> } } }));
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.reverse">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverse</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> end = items.len / <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.backend_supports_vectors">backend_supports_vectors</a> <span class="tok-kw">and</span>
        !<span class="tok-builtin">@inComptime</span>() <span class="tok-kw">and</span>
        <span class="tok-builtin">@bitSizeOf</span>(T) &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span>
        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(<span class="tok-builtin">@bitSizeOf</span>(T)))
    {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(T)) |simd_size| {
            <span class="tok-kw">if</span> (simd_size &lt;= end) {
                <span class="tok-kw">const</span> simd_end = end - (simd_size - <span class="tok-number">1</span>);
                <span class="tok-kw">while</span> (i &lt; simd_end) : (i += simd_size) {
                    <span class="tok-kw">const</span> left_slice = items[i .. i + simd_size];
                    <span class="tok-kw">const</span> right_slice = items[items.len - i - simd_size .. items.len - i];

                    <span class="tok-kw">const</span> left_shuffled: [simd_size]T = <a href="std.mem.html#std.mem.reverseVector">reverseVector</a>(simd_size, T, left_slice);
                    <span class="tok-kw">const</span> right_shuffled: [simd_size]T = <a href="std.mem.html#std.mem.reverseVector">reverseVector</a>(simd_size, T, right_slice);

                    <span class="tok-builtin">@memcpy</span>(right_slice, &amp;left_shuffled);
                    <span class="tok-builtin">@memcpy</span>(left_slice, &amp;right_shuffled);
                }
            }
        }
    }

    <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {
        <a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;items[i], &amp;items[items.len - i - <span class="tok-number">1</span>]);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.reverseIterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reverseIterator</span><a href="#src.zig-std.mem.reverseIterator">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseIterator</span>(slice: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.ReverseIterator">ReverseIterator</a>(<span class="tok-builtin">@TypeOf</span>(slice))</code></pre></div><div class="tldDocs"><p>Iterates over a slice in reverse.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> reverseIterator {
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(<span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-str">'c'</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-str">'b'</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), it.next());
    }
    {
        <span class="tok-kw">var</span> array = [<span class="tok-number">2</span>]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">7</span> };
        <span class="tok-kw">const</span> slice: []<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;array;
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(slice);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), it.next());

        it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(slice);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(*<span class="tok-kw">const</span> <span class="tok-type">i32</span> == <span class="tok-builtin">@TypeOf</span>(it.nextPtr().?));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), it.nextPtr().?.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), it.nextPtr().?.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">i32</span>, <span class="tok-null">null</span>), it.nextPtr());

        <span class="tok-kw">const</span> mut_slice: []<span class="tok-type">i32</span> = &amp;array;
        <span class="tok-kw">var</span> mut_it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(mut_slice);
        mut_it.nextPtr().?.* += <span class="tok-number">1</span>;
        mut_it.nextPtr().?.* += <span class="tok-number">2</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">2</span>]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">8</span> }, array);
    }
    {
        <span class="tok-kw">var</span> array = [<span class="tok-number">2</span>]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">7</span> };
        <span class="tok-kw">const</span> ptr_to_array: *<span class="tok-kw">const</span> [<span class="tok-number">2</span>]<span class="tok-type">i32</span> = &amp;array;
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(ptr_to_array);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), it.next());

        it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(ptr_to_array);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(*<span class="tok-kw">const</span> <span class="tok-type">i32</span> == <span class="tok-builtin">@TypeOf</span>(it.nextPtr().?));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), it.nextPtr().?.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), it.nextPtr().?.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">i32</span>, <span class="tok-null">null</span>), it.nextPtr());

        <span class="tok-kw">const</span> mut_ptr_to_array: *[<span class="tok-number">2</span>]<span class="tok-type">i32</span> = &amp;array;
        <span class="tok-kw">var</span> mut_it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(mut_ptr_to_array);
        mut_it.nextPtr().?.* += <span class="tok-number">1</span>;
        mut_it.nextPtr().?.* += <span class="tok-number">2</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">2</span>]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">8</span> }, array);
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.reverseIterator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseIterator</span>(slice: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.ReverseIterator">ReverseIterator</a>(<span class="tok-builtin">@TypeOf</span>(slice)) {
    <span class="tok-kw">return</span> .{ .ptr = slice.ptr, .index = slice.len };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.rotate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rotate</span><a href="#src.zig-std.mem.rotate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotate</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, amount: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>In-place rotation of the values in an array ([0 1 2 3] becomes [1 2 3 0] if we rotate by 1)
Assumes 0 &lt;= amount &lt;= items.len</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>items: []T</code></pre></div><div><pre><code>amount: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> rotate {
    <span class="tok-kw">var</span> arr = [_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span> };
    <a href="std.mem.html#std.mem.rotate">rotate</a>(<span class="tok-type">i32</span>, arr[<span class="tok-number">0</span>..], <span class="tok-number">2</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">i32</span>, &amp;arr, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span> }));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.rotate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotate</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, amount: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.mem.html#std.mem.reverse">reverse</a>(T, items[<span class="tok-number">0</span>..amount]);
    <a href="std.mem.html#std.mem.reverse">reverse</a>(T, items[amount..]);
    <a href="std.mem.html#std.mem.reverse">reverse</a>(T, items);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.replace" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replace</span><a href="#src.zig-std.mem.replace">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replace</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T, output: []T) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Replace needle with replacement as many times as possible, writing to an output buffer which is assumed to be of
appropriate size. Use replacementSize to calculate an appropriate buffer size.
The needle must not be empty.
Returns the number of replacements made.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>input: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>replacement: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>output: []T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> replace {
    <span class="tok-kw">var</span> output: [<span class="tok-number">29</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;All your base are belong to us&quot;</span>, <span class="tok-str">&quot;base&quot;</span>, <span class="tok-str">&quot;Zig&quot;</span>, output[<span class="tok-number">0</span>..]);
    <span class="tok-kw">var</span> expected: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;All your Zig are belong to us&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);

    replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Favor reading code over writing code.&quot;</span>, <span class="tok-str">&quot;code&quot;</span>, <span class="tok-str">&quot;&quot;</span>, output[<span class="tok-number">0</span>..]);
    expected = <span class="tok-str">&quot;Favor reading  over writing .&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);<span class="tok-comment">

    // Empty needle is not allowed but input may be empty.
    </span>replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;x&quot;</span>, <span class="tok-str">&quot;y&quot;</span>, output[<span class="tok-number">0</span>..<span class="tok-number">0</span>]);
    expected = <span class="tok-str">&quot;&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);<span class="tok-comment">

    // Adjacent replacements.

    </span>replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;\\n\\n&quot;</span>, <span class="tok-str">&quot;\\n&quot;</span>, <span class="tok-str">&quot;\n&quot;</span>, output[<span class="tok-number">0</span>..]);
    expected = <span class="tok-str">&quot;\n\n&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);

    replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abbba&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;cd&quot;</span>, output[<span class="tok-number">0</span>..]);
    expected = <span class="tok-str">&quot;acdcdcda&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.replace">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replace</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T, output: []T) <span class="tok-type">usize</span> {<span class="tok-comment">
    // Empty needle will loop until output buffer overflows.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(needle.len &gt; <span class="tok-number">0</span>);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> slide: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> replacements: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (slide &lt; input.len) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(T, input[slide..], needle)) {
            <span class="tok-builtin">@memcpy</span>(output[i..][<span class="tok-number">0</span>..replacement.len], replacement);
            i += replacement.len;
            slide += needle.len;
            replacements += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            output[i] = input[slide];
            i += <span class="tok-number">1</span>;
            slide += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> replacements;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.replaceScalar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceScalar</span><a href="#src.zig-std.mem.replaceScalar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, match: T, replacement: T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Replace all occurrences of <code>match</code> with <code>replacement</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []T</code></pre></div><div><pre><code>match: T</code></pre></div><div><pre><code>replacement: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.replaceScalar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, match: T, replacement: T) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (slice) |*e| {
        <span class="tok-kw">if</span> (e.* == match)
            e.* = replacement;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.collapseRepeatsLen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">collapseRepeatsLen</span><a href="#src.zig-std.mem.collapseRepeatsLen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collapseRepeatsLen</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, elem: T) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Collapse consecutive duplicate elements into one entry.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []T</code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.collapseRepeatsLen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collapseRepeatsLen</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, elem: T) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> write_idx: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> read_idx: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (read_idx &lt; slice.len) : (read_idx += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (slice[read_idx - <span class="tok-number">1</span>] != elem <span class="tok-kw">or</span> slice[read_idx] != elem) {
            slice[write_idx] = slice[read_idx];
            write_idx += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> write_idx;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.collapseRepeats" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">collapseRepeats</span><a href="#src.zig-std.mem.collapseRepeats">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collapseRepeats</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, elem: T) []T</code></pre></div><div class="tldDocs"><p>Collapse consecutive duplicate elements into one entry.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>slice: []T</code></pre></div><div><pre><code>elem: T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> collapseRepeats {
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;/&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;//&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;/a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;//a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a/&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a/&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a//&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a/&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a/a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a/a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a//a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a/a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;//a///a////&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/a/a/&quot;</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.collapseRepeats">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collapseRepeats</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, elem: T) []T {
    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<a href="std.mem.html#std.mem.collapseRepeatsLen">collapseRepeatsLen</a>(T, slice, elem)];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.replacementSize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replacementSize</span><a href="#src.zig-std.mem.replacementSize">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replacementSize</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Calculate the size needed in an output buffer to perform a replacement.
The needle must not be empty.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>input: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>replacement: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> replacementSize {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;All your base are belong to us&quot;</span>, <span class="tok-str">&quot;base&quot;</span>, <span class="tok-str">&quot;Zig&quot;</span>) == <span class="tok-number">29</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Favor reading code over writing code.&quot;</span>, <span class="tok-str">&quot;code&quot;</span>, <span class="tok-str">&quot;&quot;</span>) == <span class="tok-number">29</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Only one obvious way to do things.&quot;</span>, <span class="tok-str">&quot;things.&quot;</span>, <span class="tok-str">&quot;things in Zig.&quot;</span>) == <span class="tok-number">41</span>);<span class="tok-comment">

    // Empty needle is not allowed but input may be empty.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;x&quot;</span>, <span class="tok-str">&quot;y&quot;</span>) == <span class="tok-number">0</span>);<span class="tok-comment">

    // Adjacent replacements.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;\\n\\n&quot;</span>, <span class="tok-str">&quot;\\n&quot;</span>, <span class="tok-str">&quot;\n&quot;</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abbba&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;cd&quot;</span>) == <span class="tok-number">8</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.replacementSize">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replacementSize</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {<span class="tok-comment">
    // Empty needle will loop forever.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(needle.len &gt; <span class="tok-number">0</span>);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> size: <span class="tok-type">usize</span> = input.len;
    <span class="tok-kw">while</span> (i &lt; input.len) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(T, input[i..], needle)) {
            size = size - needle.len + replacement.len;
            i += needle.len;
        } <span class="tok-kw">else</span> {
            i += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> size;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.replaceOwned" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">replaceOwned</span><a href="#src.zig-std.mem.replaceOwned">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceOwned</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T</code></pre></div><div class="tldDocs"><p>Perform a replacement on an allocated buffer of pre-determined size. Caller must free returned memory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>input: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>needle: []<span class="tok-kw">const</span> T</code></pre></div><div><pre><code>replacement: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> replaceOwned {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;

    <span class="tok-kw">const</span> base_replace = <a href="std.mem.html#std.mem.replaceOwned">replaceOwned</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;All your base are belong to us&quot;</span>, <span class="tok-str">&quot;base&quot;</span>, <span class="tok-str">&quot;Zig&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;out of memory&quot;</span>);
    <span class="tok-kw">defer</span> gpa.free(base_replace);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, base_replace, <span class="tok-str">&quot;All your Zig are belong to us&quot;</span>));

    <span class="tok-kw">const</span> zen_replace = <a href="std.mem.html#std.mem.replaceOwned">replaceOwned</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;Favor reading code over writing code.&quot;</span>, <span class="tok-str">&quot; code&quot;</span>, <span class="tok-str">&quot;&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;out of memory&quot;</span>);
    <span class="tok-kw">defer</span> gpa.free(zen_replace);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, zen_replace, <span class="tok-str">&quot;Favor reading over writing.&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.replaceOwned">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceOwned</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> output = <span class="tok-kw">try</span> allocator.alloc(T, <a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(T, input, needle, replacement));
    _ = <a href="std.mem.html#std.mem.replace">replace</a>(T, input, needle, replacement, output);
    <span class="tok-kw">return</span> output;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.littleToNative" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">littleToNative</span><a href="#src.zig-std.mem.littleToNative">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">littleToNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T</code></pre></div><div class="tldDocs"><p>Converts a little-endian integer to host endianness.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>x: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.littleToNative">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">littleToNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; x,
        .big =&gt; <span class="tok-builtin">@byteSwap</span>(x),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.bigToNative" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bigToNative</span><a href="#src.zig-std.mem.bigToNative">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigToNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T</code></pre></div><div class="tldDocs"><p>Converts a big-endian integer to host endianness.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>x: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.bigToNative">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigToNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; <span class="tok-builtin">@byteSwap</span>(x),
        .big =&gt; x,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.toNative" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toNative</span><a href="#src.zig-std.mem.toNative">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T, endianness_of_x: <a href="std.builtin.Endian.html">Endian</a>) T</code></pre></div><div class="tldDocs"><p>Converts an integer from specified endianness to host endianness.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>x: T</code></pre></div><div><pre><code>endianness_of_x: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.toNative">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T, endianness_of_x: <a href="std.builtin.Endian.html">Endian</a>) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (endianness_of_x) {
        .little =&gt; <a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(T, x),
        .big =&gt; <a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(T, x),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.nativeTo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nativeTo</span><a href="#src.zig-std.mem.nativeTo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeTo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T, desired_endianness: <a href="std.builtin.Endian.html">Endian</a>) T</code></pre></div><div class="tldDocs"><p>Converts an integer which has host endianness to the desired endianness.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>x: T</code></pre></div><div><pre><code>desired_endianness: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.nativeTo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeTo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T, desired_endianness: <a href="std.builtin.Endian.html">Endian</a>) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (desired_endianness) {
        .little =&gt; <a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(T, x),
        .big =&gt; <a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(T, x),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.nativeToLittle" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nativeToLittle</span><a href="#src.zig-std.mem.nativeToLittle">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeToLittle</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T</code></pre></div><div class="tldDocs"><p>Converts an integer which has host endianness to little endian.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>x: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.nativeToLittle">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeToLittle</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; x,
        .big =&gt; <span class="tok-builtin">@byteSwap</span>(x),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.nativeToBig" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nativeToBig</span><a href="#src.zig-std.mem.nativeToBig">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeToBig</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T</code></pre></div><div class="tldDocs"><p>Converts an integer which has host endianness to big endian.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>x: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.nativeToBig">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeToBig</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; <span class="tok-builtin">@byteSwap</span>(x),
        .big =&gt; x,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignPointerOffset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignPointerOffset</span><a href="#src.zig-std.mem.alignPointerOffset">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignPointerOffset</span>(ptr: <span class="tok-kw">anytype</span>, align_to: <span class="tok-type">usize</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of elements that, if added to the given pointer, align it
to a multiple of the given quantity, or <code>null</code> if one of the following
conditions is met:</p>
<ul>
<li>The aligned pointer would not fit the address space,</li>
<li>The delta required to align the pointer is not a multiple of the pointee's
type.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>align_to: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignPointerOffset">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignPointerOffset</span>(ptr: <span class="tok-kw">anytype</span>, align_to: <span class="tok-type">usize</span>) ?<span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html#std.mem.isValidAlign">isValidAlign</a>(align_to));

    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(ptr);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T);
    <span class="tok-kw">if</span> (info != .pointer <span class="tok-kw">or</span> info.pointer.size != .many)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected many item pointer, got &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));<span class="tok-comment">

    // Do nothing if the pointer is already well-aligned.
    </span><span class="tok-kw">if</span> (align_to &lt;= info.pointer.alignment)
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // Calculate the aligned base address with an eye out for overflow.
    </span><span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
    <span class="tok-kw">var</span> ov = <span class="tok-builtin">@addWithOverflow</span>(addr, align_to - <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    ov[<span class="tok-number">0</span>] &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, align_to - <span class="tok-number">1</span>);<span class="tok-comment">

    // The delta is expressed in terms of bytes, turn it into a number of child
    // type elements.
    </span><span class="tok-kw">const</span> delta = ov[<span class="tok-number">0</span>] - addr;
    <span class="tok-kw">const</span> pointee_size = <span class="tok-builtin">@sizeOf</span>(info.pointer.child);
    <span class="tok-kw">if</span> (delta % pointee_size != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> delta / pointee_size;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignPointer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignPointer</span><a href="#src.zig-std.mem.alignPointer">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignPointer</span>(ptr: <span class="tok-kw">anytype</span>, align_to: <span class="tok-type">usize</span>) ?<span class="tok-builtin">@TypeOf</span>(ptr)</code></pre></div><div class="tldDocs"><p>Aligns a given pointer value to a specified alignment factor.
Returns an aligned pointer or null if one of the following conditions is
met:</p>
<ul>
<li>The aligned pointer would not fit the address space,</li>
<li>The delta required to align the pointer is not a multiple of the pointee's
type.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>align_to: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> alignPointer {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">checkAlign</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, base: <span class="tok-type">usize</span>, align_to: <span class="tok-type">usize</span>, expected: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> ptr: T = <span class="tok-builtin">@ptrFromInt</span>(base);
            <span class="tok-kw">const</span> aligned = <a href="std.mem.html#std.mem.alignPointer">alignPointer</a>(ptr, align_to);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(expected, <span class="tok-builtin">@intFromPtr</span>(aligned));
        }
    };

    <span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-type">u8</span>, <span class="tok-number">0x123</span>, <span class="tok-number">0x200</span>, <span class="tok-number">0x200</span>);
    <span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-number">0x10</span>, <span class="tok-number">2</span>, <span class="tok-number">0x10</span>);
    <span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-type">u32</span>, <span class="tok-number">0x10</span>, <span class="tok-number">2</span>, <span class="tok-number">0x10</span>);
    <span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-type">u32</span>, <span class="tok-number">0x4</span>, <span class="tok-number">16</span>, <span class="tok-number">0x10</span>);<span class="tok-comment">
    // Misaligned.
    </span><span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">u32</span>, <span class="tok-number">0x3</span>, <span class="tok-number">2</span>, <span class="tok-number">0</span>);<span class="tok-comment">
    // Overflow.
    </span><span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-type">u32</span>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>) - <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">0</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignPointer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignPointer</span>(ptr: <span class="tok-kw">anytype</span>, align_to: <span class="tok-type">usize</span>) ?<span class="tok-builtin">@TypeOf</span>(ptr) {
    <span class="tok-kw">const</span> adjust_off = <a href="std.mem.html#std.mem.alignPointerOffset">alignPointerOffset</a>(ptr, align_to) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // Avoid the use of ptrFromInt to avoid losing the pointer provenance info.
    </span><span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(ptr + adjust_off);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.asBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">asBytes</span><a href="#src.zig-std.mem.asBytes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asBytes</span>(ptr: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.AsBytesReturnType">AsBytesReturnType</a>(<span class="tok-builtin">@TypeOf</span>(ptr))</code></pre></div><div class="tldDocs"><p>Given a pointer to a single item, returns a slice of the underlying bytes, preserving pointer attributes.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> asBytes {
    <span class="tok-kw">const</span> deadbeef = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xDEADBEEF</span>);
    <span class="tok-kw">const</span> deadbeef_bytes = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xDE\xAD\xBE\xEF&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xEF\xBE\xAD\xDE&quot;</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;deadbeef), deadbeef_bytes));

    <span class="tok-kw">var</span> codeface = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xC0DEFACE</span>);
    <span class="tok-kw">for</span> (<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;codeface)) |*b|
        b.* = <span class="tok-number">0</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(codeface == <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u8</span>,
        c: <span class="tok-type">u8</span>,
        d: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> inst = S{
        .a = <span class="tok-number">0xBE</span>,
        .b = <span class="tok-number">0xEF</span>,
        .c = <span class="tok-number">0xDE</span>,
        .d = <span class="tok-number">0xA1</span>,
    };
    <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;inst), <span class="tok-str">&quot;\xBE\xEF\xDE\xA1&quot;</span>));
        },
        .big =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;inst), <span class="tok-str">&quot;\xA1\xDE\xEF\xBE&quot;</span>));
        },
    }

    <span class="tok-kw">const</span> ZST = <span class="tok-kw">struct</span> {};
    <span class="tok-kw">const</span> zero = ZST{};
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;zero), <span class="tok-str">&quot;&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.asBytes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asBytes</span>(ptr: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.AsBytesReturnType">AsBytesReturnType</a>(<span class="tok-builtin">@TypeOf</span>(ptr)) {
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr));
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.toBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toBytes</span><a href="#src.zig-std.mem.toBytes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(value: <span class="tok-kw">anytype</span>) [<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value))]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Given any value, returns a copy of its bytes in an array.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> toBytes {
    <span class="tok-kw">var</span> my_bytes = <a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x12345678</span>));
    <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;my_bytes, <span class="tok-str">&quot;\x12\x34\x56\x78&quot;</span>)),
        .little =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;my_bytes, <span class="tok-str">&quot;\x78\x56\x34\x12&quot;</span>)),
    }

    my_bytes[<span class="tok-number">0</span>] = <span class="tok-str">'\x99'</span>;
    <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;my_bytes, <span class="tok-str">&quot;\x99\x34\x56\x78&quot;</span>)),
        .little =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;my_bytes, <span class="tok-str">&quot;\x99\x56\x34\x12&quot;</span>)),
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.toBytes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(value: <span class="tok-kw">anytype</span>) [<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value))]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value).*;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.bytesAsValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bytesAsValue</span><a href="#src.zig-std.mem.bytesAsValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesAsValue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.BytesAsValueReturnType">BytesAsValueReturnType</a>(T, <span class="tok-builtin">@TypeOf</span>(bytes))</code></pre></div><div class="tldDocs"><p>Given a pointer to an array of bytes, returns a pointer to a value of the specified type
backed by those bytes, preserving pointer attributes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> bytesAsValue {
    <span class="tok-kw">const</span> deadbeef = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xDEADBEEF</span>);
    <span class="tok-kw">const</span> deadbeef_bytes = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xDE\xAD\xBE\xEF&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xEF\xBE\xAD\xDE&quot;</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(deadbeef == <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(<span class="tok-type">u32</span>, deadbeef_bytes).*);

    <span class="tok-kw">var</span> codeface_bytes: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xC0\xDE\xFA\xCE&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xCE\xFA\xDE\xC0&quot;</span>,
    }.*;
    <span class="tok-kw">const</span> codeface = <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(<span class="tok-type">u32</span>, &amp;codeface_bytes);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(codeface.* == <span class="tok-number">0xC0DEFACE</span>);
    codeface.* = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (codeface_bytes) |b|
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(b == <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u8</span>,
        c: <span class="tok-type">u8</span>,
        d: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> inst = S{
        .a = <span class="tok-number">0xBE</span>,
        .b = <span class="tok-number">0xEF</span>,
        .c = <span class="tok-number">0xDE</span>,
        .d = <span class="tok-number">0xA1</span>,
    };
    <span class="tok-kw">const</span> inst_bytes = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; <span class="tok-str">&quot;\xBE\xEF\xDE\xA1&quot;</span>,
        .big =&gt; <span class="tok-str">&quot;\xA1\xDE\xEF\xBE&quot;</span>,
    };
    <span class="tok-kw">const</span> inst2 = <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(S, inst_bytes);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(inst, inst2.*));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.bytesAsValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesAsValue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.BytesAsValueReturnType">BytesAsValueReturnType</a>(T, <span class="tok-builtin">@TypeOf</span>(bytes)) {
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(bytes);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.bytesToValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bytesToValue</span><a href="#src.zig-std.mem.bytesToValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesToValue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) T</code></pre></div><div class="tldDocs"><p>Given a pointer to an array of bytes, returns a value of the specified type backed by a
copy of those bytes.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> bytesToValue {
    <span class="tok-kw">const</span> deadbeef_bytes = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xDE\xAD\xBE\xEF&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xEF\xBE\xAD\xDE&quot;</span>,
    };

    <span class="tok-kw">const</span> deadbeef = <a href="std.mem.html#std.mem.bytesToValue">bytesToValue</a>(<span class="tok-type">u32</span>, deadbeef_bytes);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(deadbeef == <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xDEADBEEF</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.bytesToValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesToValue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) T {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(T, bytes).*;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.bytesAsSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bytesAsSlice</span><a href="#src.zig-std.mem.bytesAsSlice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesAsSlice</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.BytesAsSliceReturnType">BytesAsSliceReturnType</a>(T, <span class="tok-builtin">@TypeOf</span>(bytes))</code></pre></div><div class="tldDocs"><p>Given a slice of bytes, returns a slice of the specified type
backed by those bytes, preserving pointer attributes.
If <code>T</code> is zero-bytes sized, the returned slice has a len of zero.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> bytesAsSlice {
    {
        <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0xDE</span>, <span class="tok-number">0xAD</span>, <span class="tok-number">0xBE</span>, <span class="tok-number">0xEF</span> };
        <span class="tok-kw">const</span> slice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u16</span>, bytes[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(slice.len == <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, slice[<span class="tok-number">0</span>]) == <span class="tok-number">0xDEAD</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, slice[<span class="tok-number">1</span>]) == <span class="tok-number">0xBEEF</span>);
    }
    {
        <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0xDE</span>, <span class="tok-number">0xAD</span>, <span class="tok-number">0xBE</span>, <span class="tok-number">0xEF</span> };
        <span class="tok-kw">var</span> runtime_zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        _ = &amp;runtime_zero;
        <span class="tok-kw">const</span> slice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u16</span>, bytes[runtime_zero..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(slice.len == <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, slice[<span class="tok-number">0</span>]) == <span class="tok-number">0xDEAD</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, slice[<span class="tok-number">1</span>]) == <span class="tok-number">0xBEEF</span>);
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.bytesAsSlice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesAsSlice</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.BytesAsSliceReturnType">BytesAsSliceReturnType</a>(T, <span class="tok-builtin">@TypeOf</span>(bytes)) {<span class="tok-comment">
    // let's not give an undefined pointer to @ptrCast
    // it may be equal to zero and fail a null check
    </span><span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> <span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> &amp;[<span class="tok-number">0</span>]T{};
    }

    <span class="tok-kw">const</span> cast_target = <a href="std.mem.html#std.mem.CopyPtrAttrs">CopyPtrAttrs</a>(<span class="tok-builtin">@TypeOf</span>(bytes), .many, T);

    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(cast_target, <span class="tok-builtin">@ptrCast</span>(bytes))[<span class="tok-number">0</span>..<span class="tok-builtin">@divExact</span>(bytes.len, <span class="tok-builtin">@sizeOf</span>(T))];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.sliceAsBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sliceAsBytes</span><a href="#src.zig-std.mem.sliceAsBytes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceAsBytes</span>(slice: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.SliceAsBytesReturnType">SliceAsBytesReturnType</a>(<span class="tok-builtin">@TypeOf</span>(slice))</code></pre></div><div class="tldDocs"><p>Given a slice, returns a slice of the underlying bytes, preserving pointer attributes.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> sliceAsBytes {
    <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xDEAD</span>, <span class="tok-number">0xBEEF</span> };
    <span class="tok-kw">const</span> slice = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(bytes[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(slice.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, slice, <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xDE\xAD\xBE\xEF&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xAD\xDE\xEF\xBE&quot;</span>,
    }));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.sliceAsBytes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceAsBytes</span>(slice: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.SliceAsBytesReturnType">SliceAsBytesReturnType</a>(<span class="tok-builtin">@TypeOf</span>(slice)) {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@TypeOf</span>(slice);<span class="tok-comment">

    // a slice of zero-bit values always occupies zero bytes
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(Slice)) == <span class="tok-number">0</span>) <span class="tok-kw">return</span> &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};<span class="tok-comment">

    // let's not give an undefined pointer to @ptrCast
    // it may be equal to zero and fail a null check
    </span><span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.sentinel">sentinel</a>(Slice) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};

    <span class="tok-kw">const</span> cast_target = <a href="std.mem.html#std.mem.CopyPtrAttrs">CopyPtrAttrs</a>(Slice, .many, <span class="tok-type">u8</span>);

    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(cast_target, <span class="tok-builtin">@ptrCast</span>(slice))[<span class="tok-number">0</span> .. slice.len * <span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(Slice))];
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignForwardAnyAlign" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignForwardAnyAlign</span><a href="#src.zig-std.mem.alignForwardAnyAlign">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForwardAnyAlign</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T</code></pre></div><div class="tldDocs"><p>Round an address down to the next (or current) aligned address.
Unlike <code><a href="std.mem.html#std.mem.alignForward">alignForward</a></code>, <code>alignment</code> can be any positive number, not just a power of 2.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>addr: T</code></pre></div><div><pre><code>alignment: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignForwardAnyAlign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForwardAnyAlign</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T {
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(T, alignment))
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignForward">alignForward</a>(T, addr, alignment);
    <a href="std.debug.html#std.debug.assert">assert</a>(alignment != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignBackwardAnyAlign">alignBackwardAnyAlign</a>(T, addr + (alignment - <span class="tok-number">1</span>), alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignForward" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignForward</span><a href="#src.zig-std.mem.alignForward">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForward</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T</code></pre></div><div class="tldDocs"><p>Round an address up to the next (or current) aligned address.
The alignment must be a power of 2 and greater than 0.
Asserts that rounding up the address does not cause integer overflow.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>addr: T</code></pre></div><div><pre><code>alignment: T</code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> alignForward {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span>) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>) == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>) == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">9</span>, <span class="tok-number">8</span>) == <span class="tok-number">16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">15</span>, <span class="tok-number">8</span>) == <span class="tok-number">16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">16</span>, <span class="tok-number">8</span>) == <span class="tok-number">16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">17</span>, <span class="tok-number">8</span>) == <span class="tok-number">24</span>);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignForward">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForward</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(T, alignment));
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(T, addr + (alignment - <span class="tok-number">1</span>), alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignForwardLog2" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignForwardLog2</span><a href="#src.zig-std.mem.alignForwardLog2">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForwardLog2</span>(addr: <span class="tok-type">usize</span>, log2_alignment: <span class="tok-type">u8</span>) <span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>addr: <span class="tok-type">usize</span></code></pre></div><div><pre><code>log2_alignment: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignForwardLog2">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForwardLog2</span>(addr: <span class="tok-type">usize</span>, log2_alignment: <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> alignment = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<span class="tok-type">usize</span>), <span class="tok-builtin">@intCast</span>(log2_alignment));
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, addr, alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.doNotOptimizeAway" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">doNotOptimizeAway</span><a href="#src.zig-std.mem.doNotOptimizeAway">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doNotOptimizeAway</span>(val: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Force an evaluation of the expression; this tries to prevent
the compiler from optimizing the computation away even if the
result eventually gets discarded.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> doNotOptimizeAway {
    <span class="tok-kw">comptime</span> <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-str">&quot;test&quot;</span>);

    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-null">null</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-null">true</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-number">0</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-number">0.0</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u13</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u37</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u96</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u200</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">0.0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">0.0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">4</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">100</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>, .little));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.doNotOptimizeAway">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doNotOptimizeAway</span>(val: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@inComptime</span>()) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> max_gp_register_bits = <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">c_long</span>);
    <span class="tok-kw">const</span> t = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(val));
    <span class="tok-kw">switch</span> (t) {
        .<span class="tok-type">void</span>, .<span class="tok-null">null</span>, .<span class="tok-type">comptime_int</span>, .<span class="tok-type">comptime_float</span> =&gt; <span class="tok-kw">return</span>,
        .@&quot;enum&quot; =&gt; <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@intFromEnum</span>(val)),
        .<span class="tok-type">bool</span> =&gt; <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@intFromBool</span>(val)),
        .int =&gt; {
            <span class="tok-kw">const</span> bits = t.int.bits;
            <span class="tok-kw">if</span> (bits &lt;= max_gp_register_bits <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> != .stage2_c) {
                <span class="tok-kw">const</span> val2 = <span class="tok-builtin">@as</span>(
                    <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(t.int.signedness, <span class="tok-builtin">@max</span>(<span class="tok-number">8</span>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwoAssert">ceilPowerOfTwoAssert</a>(<span class="tok-type">u16</span>, bits))),
                    val,
                );
                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;&quot;</span>
                    :
                    : [val2] <span class="tok-str">&quot;r&quot;</span> (val2),
                );
            } <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(&amp;val);
        },
        .float =&gt; {
            <span class="tok-kw">if</span> ((t.float.bits == <span class="tok-number">32</span> <span class="tok-kw">or</span> t.float.bits == <span class="tok-number">64</span>) <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> != .stage2_c) {
                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;&quot;</span>
                    :
                    : [val] <span class="tok-str">&quot;rm&quot;</span> (val),
                );
            } <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(&amp;val);
        },
        .pointer =&gt; {
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) {
                <a href="std.mem.html#std.mem.doNotOptimizeAwayC">doNotOptimizeAwayC</a>(val);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;&quot;</span>
                    :
                    : [val] <span class="tok-str">&quot;m&quot;</span> (val),
                    : <span class="tok-str">&quot;memory&quot;</span>
                );
            }
        },
        .array =&gt; {
            <span class="tok-kw">if</span> (t.array.len * <span class="tok-builtin">@sizeOf</span>(t.array.child) &lt;= <span class="tok-number">64</span>) {
                <span class="tok-kw">for</span> (val) |v| <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(v);
            } <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(&amp;val);
        },
        <span class="tok-kw">else</span> =&gt; <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(&amp;val),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignBackwardAnyAlign" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignBackwardAnyAlign</span><a href="#src.zig-std.mem.alignBackwardAnyAlign">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignBackwardAnyAlign</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T</code></pre></div><div class="tldDocs"><p>Round an address down to the previous (or current) aligned address.
Unlike <code><a href="std.mem.html#std.mem.alignBackward">alignBackward</a></code>, <code>alignment</code> can be any positive number, not just a power of 2.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>addr: T</code></pre></div><div><pre><code>alignment: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignBackwardAnyAlign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignBackwardAnyAlign</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T {
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(T, alignment))
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(T, addr, alignment);
    <a href="std.debug.html#std.debug.assert">assert</a>(alignment != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> addr - <span class="tok-builtin">@mod</span>(addr, alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignBackward" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignBackward</span><a href="#src.zig-std.mem.alignBackward">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignBackward</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T</code></pre></div><div class="tldDocs"><p>Round an address down to the previous (or current) aligned address.
The alignment must be a power of 2 and greater than 0.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>addr: T</code></pre></div><div><pre><code>alignment: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignBackward">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignBackward</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(T, alignment));<span class="tok-comment">
    // 000010000 // example alignment
    // 000001111 // subtract 1
    // 111110000 // binary not
    </span><span class="tok-kw">return</span> addr &amp; ~(alignment - <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.isValidAlign" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isValidAlign</span><a href="#src.zig-std.mem.isValidAlign">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidAlign</span>(alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns whether <code>alignment</code> is a valid alignment, meaning it is
a positive power of 2.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>alignment: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.isValidAlign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidAlign</span>(alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(<span class="tok-type">usize</span>, alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.isValidAlignGeneric" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isValidAlignGeneric</span><a href="#src.zig-std.mem.isValidAlignGeneric">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidAlignGeneric</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, alignment: T) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns whether <code>alignment</code> is a valid alignment, meaning it is
a positive power of 2.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>alignment: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.isValidAlignGeneric">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidAlignGeneric</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, alignment: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> alignment &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.isAlignedAnyAlign" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isAlignedAnyAlign</span><a href="#src.zig-std.mem.isAlignedAnyAlign">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedAnyAlign</span>(i: <span class="tok-type">usize</span>, alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>i: <span class="tok-type">usize</span></code></pre></div><div><pre><code>alignment: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.isAlignedAnyAlign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedAnyAlign</span>(i: <span class="tok-type">usize</span>, alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.isValidAlign">isValidAlign</a>(alignment))
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.isAligned">isAligned</a>(i, alignment);
    <a href="std.debug.html#std.debug.assert">assert</a>(alignment != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <span class="tok-number">0</span> == <span class="tok-builtin">@mod</span>(i, alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.isAlignedLog2" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isAlignedLog2</span><a href="#src.zig-std.mem.isAlignedLog2">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedLog2</span>(addr: <span class="tok-type">usize</span>, log2_alignment: <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>addr: <span class="tok-type">usize</span></code></pre></div><div><pre><code>log2_alignment: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.isAlignedLog2">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedLog2</span>(addr: <span class="tok-type">usize</span>, log2_alignment: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@ctz</span>(addr) &gt;= log2_alignment;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.isAligned" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isAligned</span><a href="#src.zig-std.mem.isAligned">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAligned</span>(addr: <span class="tok-type">usize</span>, alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Given an address and an alignment, return true if the address is a multiple of the alignment
The alignment must be a power of 2 and greater than 0.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>addr: <span class="tok-type">usize</span></code></pre></div><div><pre><code>alignment: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> isAligned {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">0</span>, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">1</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">2</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">2</span>, <span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">2</span>, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">3</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">3</span>, <span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">3</span>, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">16</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.isAligned">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAligned</span>(addr: <span class="tok-type">usize</span>, alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.isAlignedGeneric">isAlignedGeneric</a>(<span class="tok-type">u64</span>, addr, alignment);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.isAlignedGeneric" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isAlignedGeneric</span><a href="#src.zig-std.mem.isAlignedGeneric">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedGeneric</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>addr: T</code></pre></div><div><pre><code>alignment: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.isAlignedGeneric">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedGeneric</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(T, addr, alignment) == addr;
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignInBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignInBytes</span><a href="#src.zig-std.mem.alignInBytes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignInBytes</span>(bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> new_alignment: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">align</span>(new_alignment) <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Returns the largest slice in the given bytes that conforms to the new alignment,
or <code>null</code> if the given bytes contain no conforming address.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bytes: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>new_alignment: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignInBytes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignInBytes</span>(bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> new_alignment: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">align</span>(new_alignment) <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> begin_address = <span class="tok-builtin">@intFromPtr</span>(bytes.ptr);
    <span class="tok-kw">const</span> end_address = begin_address + bytes.len;

    <span class="tok-kw">const</span> begin_address_aligned = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, begin_address, new_alignment);
    <span class="tok-kw">const</span> new_length = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">usize</span>, end_address, begin_address_aligned) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
        <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
    };
    <span class="tok-kw">const</span> alignment_offset = begin_address_aligned - begin_address;
    <span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(bytes[alignment_offset .. alignment_offset + new_length]);
}</code></pre></details></div></div><div class="decl"><h2 id="std.mem.alignInSlice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">alignInSlice</span><a href="#src.zig-std.mem.alignInSlice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignInSlice</span>(slice: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> new_alignment: <span class="tok-type">usize</span>) ?<a href="std.mem.html#std.mem.AlignedSlice">AlignedSlice</a>(<span class="tok-builtin">@TypeOf</span>(slice), new_alignment)</code></pre></div><div class="tldDocs"><p>Returns the largest sub-slice within the given slice that conforms to the new alignment,
or <code>null</code> if the given slice contains no conforming address.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>new_alignment: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.mem.alignInSlice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignInSlice</span>(slice: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> new_alignment: <span class="tok-type">usize</span>) ?<a href="std.mem.html#std.mem.AlignedSlice">AlignedSlice</a>(<span class="tok-builtin">@TypeOf</span>(slice), new_alignment) {
    <span class="tok-kw">const</span> bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(slice);
    <span class="tok-kw">const</span> aligned_bytes = <a href="std.mem.html#std.mem.alignInBytes">alignInBytes</a>(bytes, new_alignment) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> Element = <span class="tok-builtin">@TypeOf</span>(slice[<span class="tok-number">0</span>]);
    <span class="tok-kw">const</span> slice_length_bytes = aligned_bytes.len - (aligned_bytes.len % <span class="tok-builtin">@sizeOf</span>(Element));
    <span class="tok-kw">const</span> aligned_slice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(Element, aligned_bytes[<span class="tok-number">0</span>..slice_length_bytes]);
    <span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(aligned_slice);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.mem">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> debug = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>;
<span class="tok-kw">const</span> assert = <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> Endian = <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>;
<span class="tok-kw">const</span> native_endian = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>();

<span class="tok-comment">/// The standard library currently thoroughly depends on byte size</span>
<span class="tok-comment">/// being 8 bits.  (see the use of u8 throughout allocation code as</span>
<span class="tok-comment">/// the &quot;byte&quot; type.)  Code which depends on this can reference this</span>
<span class="tok-comment">/// declaration.  If we ever try to port the standard library to a</span>
<span class="tok-comment">/// non-8-bit-byte platform, this will allow us to search for things</span>
<span class="tok-comment">/// which need to be updated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> byte_size_in_bits = <span class="tok-number">8</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Allocator = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;mem/Allocator.zig&quot;</span>);

<span class="tok-comment">/// Stored as a power-of-two.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Alignment = <span class="tok-kw">enum</span>(math.Log2Int(<span class="tok-type">usize</span>)) {
    @&quot;1&quot; = <span class="tok-number">0</span>,
    @&quot;2&quot; = <span class="tok-number">1</span>,
    @&quot;4&quot; = <span class="tok-number">2</span>,
    @&quot;8&quot; = <span class="tok-number">3</span>,
    @&quot;16&quot; = <span class="tok-number">4</span>,
    @&quot;32&quot; = <span class="tok-number">5</span>,
    @&quot;64&quot; = <span class="tok-number">6</span>,
    _,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toByteUnits</span>(a: <a href="std.mem.Alignment.html">Alignment</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@intFromEnum</span>(a);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromByteUnits</span>(n: <span class="tok-type">usize</span>) <a href="std.mem.Alignment.html">Alignment</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(n));
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@ctz</span>(n));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(lhs: <a href="std.mem.Alignment.html">Alignment</a>, rhs: <a href="std.mem.Alignment.html">Alignment</a>) <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(<span class="tok-builtin">@intFromEnum</span>(lhs), <span class="tok-builtin">@intFromEnum</span>(rhs));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compare</span>(lhs: <a href="std.mem.Alignment.html">Alignment</a>, op: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.CompareOperator.html">CompareOperator</a>, rhs: <a href="std.mem.Alignment.html">Alignment</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.compare">compare</a>(<span class="tok-builtin">@intFromEnum</span>(lhs), op, <span class="tok-builtin">@intFromEnum</span>(rhs));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">max</span>(lhs: <a href="std.mem.Alignment.html">Alignment</a>, rhs: <a href="std.mem.Alignment.html">Alignment</a>) <a href="std.mem.Alignment.html">Alignment</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@max</span>(<span class="tok-builtin">@intFromEnum</span>(lhs), <span class="tok-builtin">@intFromEnum</span>(rhs)));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">min</span>(lhs: <a href="std.mem.Alignment.html">Alignment</a>, rhs: <a href="std.mem.Alignment.html">Alignment</a>) <a href="std.mem.Alignment.html">Alignment</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@min</span>(<span class="tok-builtin">@intFromEnum</span>(lhs), <span class="tok-builtin">@intFromEnum</span>(rhs)));
    }

    <span class="tok-comment">/// Return next address with this alignment.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">forward</span>(a: <a href="std.mem.Alignment.html">Alignment</a>, address: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> x = (<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@intFromEnum</span>(a)) - <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> (address + x) &amp; ~x;
    }

    <span class="tok-comment">/// Return previous address with this alignment.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">backward</span>(a: <a href="std.mem.Alignment.html">Alignment</a>, address: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> x = (<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@intFromEnum</span>(a)) - <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> address &amp; ~x;
    }

    <span class="tok-comment">/// Return whether address is aligned to this amount.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">check</span>(a: <a href="std.mem.Alignment.html">Alignment</a>, address: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@ctz</span>(address) &gt;= <span class="tok-builtin">@intFromEnum</span>(a);
    }
};

<span class="tok-comment">/// Detects and asserts if the std.mem.Allocator interface is violated by the caller</span>
<span class="tok-comment">/// or the allocator.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ValidationAllocator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        underlying_allocator: T,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(underlying_allocator: T) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{
                .underlying_allocator = underlying_allocator,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <a href="std.mem.Allocator.html">Allocator</a> {
            <span class="tok-kw">return</span> .{
                .ptr = self,
                .vtable = &amp;.{
                    .alloc = <a href="std.mem.html#std.mem.ValidationAllocator.alloc">alloc</a>,
                    .resize = <a href="std.mem.html#std.mem.ValidationAllocator.resize">resize</a>,
                    .remap = <a href="std.mem.html#std.mem.ValidationAllocator.remap">remap</a>,
                    .free = <a href="std.mem.html#std.mem.ValidationAllocator.free">free</a>,
                },
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getUnderlyingAllocatorPtr</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <a href="std.mem.Allocator.html">Allocator</a> {
            <span class="tok-kw">if</span> (T == <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-kw">return</span> self.underlying_allocator;
            <span class="tok-kw">return</span> self.underlying_allocator.allocator();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(
            ctx: *<span class="tok-type">anyopaque</span>,
            n: <span class="tok-type">usize</span>,
            alignment: <a href="std.mem.html">mem</a>.<a href="std.mem.Alignment.html">Alignment</a>,
            ret_addr: <span class="tok-type">usize</span>,
        ) ?[*]<span class="tok-type">u8</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(n &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
            <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
            <span class="tok-kw">const</span> result = underlying.rawAlloc(n, alignment, ret_addr) <span class="tok-kw">orelse</span>
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(alignment.check(<span class="tok-builtin">@intFromPtr</span>(result)));
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(
            ctx: *<span class="tok-type">anyopaque</span>,
            buf: []<span class="tok-type">u8</span>,
            alignment: <a href="std.mem.Alignment.html">Alignment</a>,
            new_len: <span class="tok-type">usize</span>,
            ret_addr: <span class="tok-type">usize</span>,
        ) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
            <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
            <span class="tok-kw">return</span> underlying.rawResize(buf, alignment, new_len, ret_addr);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remap</span>(
            ctx: *<span class="tok-type">anyopaque</span>,
            buf: []<span class="tok-type">u8</span>,
            alignment: <a href="std.mem.Alignment.html">Alignment</a>,
            new_len: <span class="tok-type">usize</span>,
            ret_addr: <span class="tok-type">usize</span>,
        ) ?[*]<span class="tok-type">u8</span> {
            <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
            <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
            <span class="tok-kw">return</span> underlying.rawRemap(buf, alignment, new_len, ret_addr);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(
            ctx: *<span class="tok-type">anyopaque</span>,
            buf: []<span class="tok-type">u8</span>,
            alignment: <a href="std.mem.Alignment.html">Alignment</a>,
            ret_addr: <span class="tok-type">usize</span>,
        ) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));
            <a href="std.debug.html#std.debug.assert">assert</a>(buf.len &gt; <span class="tok-number">0</span>);
            <span class="tok-kw">const</span> underlying = self.getUnderlyingAllocatorPtr();
            underlying.rawFree(buf, alignment, ret_addr);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.ValidationAllocator">Self</a>) <span class="tok-type">void</span> {
            self.underlying_allocator.reset();
        }
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">validationWrap</span>(allocator: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.ValidationAllocator">ValidationAllocator</a>(<span class="tok-builtin">@TypeOf</span>(allocator)) {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.ValidationAllocator">ValidationAllocator</a>(<span class="tok-builtin">@TypeOf</span>(allocator)).init(allocator);
}

<span class="tok-comment">/// An allocator helper function.  Adjusts an allocation length satisfy `len_align`.</span>
<span class="tok-comment">/// `full_len` should be the full capacity of the allocation which may be greater</span>
<span class="tok-comment">/// than the `len` that was requested.  This function should only be used by allocators</span>
<span class="tok-comment">/// that are unaffected by `len_align`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignAllocLen</span>(full_len: <span class="tok-type">usize</span>, alloc_len: <span class="tok-type">usize</span>, len_align: <span class="tok-type">u29</span>) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(alloc_len &gt; <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(alloc_len &gt;= len_align);
    <a href="std.debug.html#std.debug.assert">assert</a>(full_len &gt;= alloc_len);
    <span class="tok-kw">if</span> (len_align == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> alloc_len;
    <span class="tok-kw">const</span> adjusted = <a href="std.mem.html#std.mem.alignBackwardAnyAlign">alignBackwardAnyAlign</a>(<span class="tok-type">usize</span>, full_len, len_align);
    <a href="std.debug.html#std.debug.assert">assert</a>(adjusted &gt;= alloc_len);
    <span class="tok-kw">return</span> adjusted;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;Allocator basics&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.OutOfMemory, <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.failing_allocator">failing_allocator</a>.<a href="#">alloc</a>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.OutOfMemory, <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.failing_allocator">failing_allocator</a>.<a href="#">allocSentinel</a>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;Allocator.resize&quot;</span> {
    <span class="tok-kw">const</span> primitiveIntTypes = .{
        <span class="tok-type">i8</span>,
        <span class="tok-type">u8</span>,
        <span class="tok-type">i16</span>,
        <span class="tok-type">u16</span>,
        <span class="tok-type">i32</span>,
        <span class="tok-type">u32</span>,
        <span class="tok-type">i64</span>,
        <span class="tok-type">u64</span>,
        <span class="tok-type">i128</span>,
        <span class="tok-type">u128</span>,
        <span class="tok-type">isize</span>,
        <span class="tok-type">usize</span>,
    };
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (primitiveIntTypes) |T| {
        <span class="tok-kw">var</span> values = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alloc</a>(T, <span class="tok-number">100</span>);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(values);

        <span class="tok-kw">for</span> (values, <span class="tok-number">0</span>..) |*v, i| v.* = <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>(i));
        <span class="tok-kw">if</span> (!<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">resize</a>(values, values.len + <span class="tok-number">10</span>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        values = values.ptr[<span class="tok-number">0</span> .. values.len + <span class="tok-number">10</span>];
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(values.len == <span class="tok-number">110</span>);
    }

    <span class="tok-kw">const</span> primitiveFloatTypes = .{
        <span class="tok-type">f16</span>,
        <span class="tok-type">f32</span>,
        <span class="tok-type">f64</span>,
        <span class="tok-type">f128</span>,
    };
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (primitiveFloatTypes) |T| {
        <span class="tok-kw">var</span> values = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alloc</a>(T, <span class="tok-number">100</span>);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(values);

        <span class="tok-kw">for</span> (values, <span class="tok-number">0</span>..) |*v, i| v.* = <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@floatFromInt</span>(i));
        <span class="tok-kw">if</span> (!<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">resize</a>(values, values.len + <span class="tok-number">10</span>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        values = values.ptr[<span class="tok-number">0</span> .. values.len + <span class="tok-number">10</span>];
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(values.len == <span class="tok-number">110</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;Allocator alloc and remap with zero-bit type&quot;</span> {
    <span class="tok-kw">var</span> values = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alloc</a>(<span class="tok-type">void</span>, <span class="tok-number">10</span>);
    <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(values);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">10</span>, values.len);
    <span class="tok-kw">const</span> remaped = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">remap</a>(values, <span class="tok-number">200</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(remaped != <span class="tok-null">null</span>);

    values = remaped.?;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">200</span>, values.len);
}

<span class="tok-comment">/// Copy all of source into dest at position 0.</span>
<span class="tok-comment">/// dest.len must be &gt;= source.len.</span>
<span class="tok-comment">/// If the slices overlap, dest.ptr must be &lt;= src.ptr.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyForwards</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, dest: []T, source: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (dest[<span class="tok-number">0</span>..source.len], source) |*d, s| d.* = s;
}

<span class="tok-comment">/// Copy all of source into dest at position 0.</span>
<span class="tok-comment">/// dest.len must be &gt;= source.len.</span>
<span class="tok-comment">/// If the slices overlap, dest.ptr must be &gt;= src.ptr.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyBackwards</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, dest: []T, source: []<span class="tok-kw">const</span> T) <span class="tok-type">void</span> {<span class="tok-comment">
    // TODO instead of manually doing this check for the whole array
    // and turning off runtime safety, the compiler should detect loops like
    // this and automatically omit safety checks for loops
    </span><span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(dest.len &gt;= source.len);
    <span class="tok-kw">var</span> i = source.len;
    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        dest[i] = source[i];
    }
}

<span class="tok-comment">/// Generally, Zig users are encouraged to explicitly initialize all fields of a struct explicitly rather than using this function.</span>
<span class="tok-comment">/// However, it is recognized that there are sometimes use cases for initializing all fields to a &quot;zero&quot; value. For example, when</span>
<span class="tok-comment">/// interfacing with a C API where this practice is more common and relied upon. If you are performing code review and see this</span>
<span class="tok-comment">/// function used, examine closely - it may be a code smell.</span>
<span class="tok-comment">/// Zero initializes the type.</span>
<span class="tok-comment">/// This can be used to zero-initialize any type for which it makes sense. Structs will be initialized recursively.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroes</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .<span class="tok-type">comptime_int</span>, .int, .<span class="tok-type">comptime_float</span>, .float =&gt; {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-number">0</span>);
        },
        .@&quot;enum&quot; =&gt; {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>));
        },
        .<span class="tok-type">void</span> =&gt; {
            <span class="tok-kw">return</span> {};
        },
        .<span class="tok-type">bool</span> =&gt; {
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        },
        .optional, .<span class="tok-null">null</span> =&gt; {
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        },
        .@&quot;struct&quot; =&gt; |struct_info| {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">undefined</span>;
            <span class="tok-kw">if</span> (struct_info.layout == .@&quot;extern&quot;) {
                <span class="tok-kw">var</span> item: T = <span class="tok-null">undefined</span>;
                <span class="tok-builtin">@memset</span>(<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;item), <span class="tok-number">0</span>);
                <span class="tok-kw">return</span> item;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> structure: T = <span class="tok-null">undefined</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (struct_info.fields) |field| {
                    <span class="tok-kw">if</span> (!field.is_comptime) {
                        <span class="tok-builtin">@field</span>(structure, field.name) = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(field.<span class="tok-type">type</span>);
                    }
                }
                <span class="tok-kw">return</span> structure;
            }
        },
        .pointer =&gt; |ptr_info| {
            <span class="tok-kw">switch</span> (ptr_info.size) {
                .slice =&gt; {
                    <span class="tok-kw">if</span> (ptr_info.sentinel()) |sentinel| {
                        <span class="tok-kw">if</span> (ptr_info.child == <span class="tok-type">u8</span> <span class="tok-kw">and</span> sentinel == <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> <span class="tok-str">&quot;&quot;</span>;<span class="tok-comment"> // A special case for the most common use-case: null-terminated strings.
                        </span>}
                        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't set a sentinel slice to zero. This would require allocating memory.&quot;</span>);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> &amp;[_]ptr_info.child{};
                    }
                },
                .c =&gt; {
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                },
                .one, .many =&gt; {
                    <span class="tok-kw">if</span> (ptr_info.is_allowzero) <span class="tok-kw">return</span> <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0</span>);
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Only nullable and allowzero pointers can be set to zero.&quot;</span>);
                },
            }
        },
        .array =&gt; |info| {
            <span class="tok-kw">return</span> <span class="tok-builtin">@splat</span>(<a href="std.mem.html#std.mem.zeroes">zeroes</a>(info.child));
        },
        .vector =&gt; |info| {
            <span class="tok-kw">return</span> <span class="tok-builtin">@splat</span>(<a href="std.mem.html#std.mem.zeroes">zeroes</a>(info.child));
        },
        .@&quot;union&quot; =&gt; |info| {
            <span class="tok-kw">if</span> (info.layout == .@&quot;extern&quot;) {
                <span class="tok-kw">var</span> item: T = <span class="tok-null">undefined</span>;
                <span class="tok-builtin">@memset</span>(<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;item), <span class="tok-number">0</span>);
                <span class="tok-kw">return</span> item;
            }
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't set a &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot; to zero.&quot;</span>);
        },
        .enum_literal,
        .error_union,
        .error_set,
        .@&quot;fn&quot;,
        .<span class="tok-type">type</span>,
        .<span class="tok-type">noreturn</span>,
        .<span class="tok-null">undefined</span>,
        .@&quot;opaque&quot;,
        .frame,
        .@&quot;anyframe&quot;,
        =&gt; {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't set a &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot; to zero.&quot;</span>);
        },
    }
}

<span class="tok-kw">test</span> zeroes {
    <span class="tok-kw">const</span> C_struct = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        x: <span class="tok-type">u32</span>,
        y: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">128</span>),
    };

    <span class="tok-kw">var</span> a = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(C_struct);<span class="tok-comment">

    // Extern structs should have padding zeroed out.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(a)), <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;a));

    a.y += <span class="tok-number">10</span>;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.x == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(a.y == <span class="tok-number">10</span>);

    <span class="tok-kw">const</span> ZigStruct = <span class="tok-kw">struct</span> {
        <span class="tok-kw">comptime</span> comptime_field: <span class="tok-type">u8</span> = <span class="tok-number">5</span>,

        integral_types: <span class="tok-kw">struct</span> {
            integer_0: <span class="tok-type">i0</span>,
            integer_8: <span class="tok-type">i8</span>,
            integer_16: <span class="tok-type">i16</span>,
            integer_32: <span class="tok-type">i32</span>,
            integer_64: <span class="tok-type">i64</span>,
            integer_128: <span class="tok-type">i128</span>,
            unsigned_0: <span class="tok-type">u0</span>,
            unsigned_8: <span class="tok-type">u8</span>,
            unsigned_16: <span class="tok-type">u16</span>,
            unsigned_32: <span class="tok-type">u32</span>,
            unsigned_64: <span class="tok-type">u64</span>,
            unsigned_128: <span class="tok-type">u128</span>,

            float_32: <span class="tok-type">f32</span>,
            float_64: <span class="tok-type">f64</span>,
        },

        pointers: <span class="tok-kw">struct</span> {
            optional: ?*<span class="tok-type">u8</span>,
            c_pointer: [*c]<span class="tok-type">u8</span>,
            slice: []<span class="tok-type">u8</span>,
            nullTerminatedString: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        },

        array: [<span class="tok-number">2</span>]<span class="tok-type">u32</span>,
        vector_u32: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">u32</span>),
        vector_f32: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>),
        vector_bool: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">bool</span>),
        optional_int: ?<span class="tok-type">u8</span>,
        empty: <span class="tok-type">void</span>,
        sentinel: [<span class="tok-number">3</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> b = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(ZigStruct);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">5</span>), b.comptime_field);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-number">0</span>), b.integral_types.integer_0);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-number">0</span>), b.integral_types.integer_8);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i16</span>, <span class="tok-number">0</span>), b.integral_types.integer_16);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>), b.integral_types.integer_32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i64</span>, <span class="tok-number">0</span>), b.integral_types.integer_64);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, <span class="tok-number">0</span>), b.integral_types.integer_128);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_0);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_8);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_16);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_64);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-number">0</span>), b.integral_types.unsigned_128);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">0</span>), b.integral_types.float_32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">0</span>), b.integral_types.float_64);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?*<span class="tok-type">u8</span>, <span class="tok-null">null</span>), b.pointers.optional);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>([*c]<span class="tok-type">u8</span>, <span class="tok-null">null</span>), b.pointers.c_pointer);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>([]<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{}), b.pointers.slice);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>([:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>), b.pointers.nullTerminatedString);
    <span class="tok-kw">for</span> (b.array) |e| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), e);
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@TypeOf</span>(b.vector_u32), <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>)), b.vector_u32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@TypeOf</span>(b.vector_f32), <span class="tok-builtin">@splat</span>(<span class="tok-number">0.0</span>)), b.vector_f32);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-builtin">@TypeOf</span>(b.vector_bool), <span class="tok-builtin">@splat</span>(<span class="tok-null">false</span>)), b.vector_bool);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), b.optional_int);
    <span class="tok-kw">for</span> (b.sentinel) |e| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), e);
    }

    <span class="tok-kw">const</span> C_union = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">const</span> c = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(C_union);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), c.a);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), c.b);

    <span class="tok-kw">const</span> comptime_union = <span class="tok-kw">comptime</span> <a href="std.mem.html#std.mem.zeroes">zeroes</a>(C_union);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), comptime_union.a);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), comptime_union.b);<span class="tok-comment">

    // Ensure zero sized struct with fields is initialized correctly.
    </span>_ = <a href="std.mem.html#std.mem.zeroes">zeroes</a>(<span class="tok-kw">struct</span> { handle: <span class="tok-type">void</span> });
}

<span class="tok-comment">/// Initializes all fields of the struct with their default value, or zero values if no default value is present.</span>
<span class="tok-comment">/// If the field is present in the provided initial values, it will have that value instead.</span>
<span class="tok-comment">/// Structs are initialized recursively.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInit</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, init: <span class="tok-kw">anytype</span>) T {
    <span class="tok-kw">const</span> Init = <span class="tok-builtin">@TypeOf</span>(init);

    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .@&quot;struct&quot; =&gt; |struct_info| {
            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Init)) {
                .@&quot;struct&quot; =&gt; |init_info| {
                    <span class="tok-kw">if</span> (init_info.is_tuple) {
                        <span class="tok-kw">if</span> (init_info.fields.len &gt; struct_info.fields.len) {
                            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Tuple initializer has more elements than there are fields in `&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;`&quot;</span>);
                        }
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (init_info.fields) |field| {
                            <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasField</span>(T, field.name)) {
                                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Encountered an initializer for `&quot;</span> ++ field.name ++ <span class="tok-str">&quot;`, but it is not a field of &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
                            }
                        }
                    }

                    <span class="tok-kw">var</span> value: T = <span class="tok-kw">if</span> (struct_info.layout == .@&quot;extern&quot;) <a href="std.mem.html#std.mem.zeroes">zeroes</a>(T) <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;

                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (struct_info.fields, <span class="tok-number">0</span>..) |field, i| {
                        <span class="tok-kw">if</span> (field.is_comptime) {
                            <span class="tok-kw">continue</span>;
                        }

                        <span class="tok-kw">if</span> (init_info.is_tuple <span class="tok-kw">and</span> init_info.fields.len &gt; i) {
                            <span class="tok-builtin">@field</span>(value, field.name) = <span class="tok-builtin">@field</span>(init, init_info.fields[i].name);
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@hasField</span>(<span class="tok-builtin">@TypeOf</span>(init), field.name)) {
                            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(field.<span class="tok-type">type</span>)) {
                                .@&quot;struct&quot; =&gt; {
                                    <span class="tok-builtin">@field</span>(value, field.name) = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(field.<span class="tok-type">type</span>, <span class="tok-builtin">@field</span>(init, field.name));
                                },
                                <span class="tok-kw">else</span> =&gt; {
                                    <span class="tok-builtin">@field</span>(value, field.name) = <span class="tok-builtin">@field</span>(init, field.name);
                                },
                            }
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (field.defaultValue()) |val| {
                            <span class="tok-builtin">@field</span>(value, field.name) = val;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(field.<span class="tok-type">type</span>)) {
                                .@&quot;struct&quot; =&gt; {
                                    <span class="tok-builtin">@field</span>(value, field.name) = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(field.<span class="tok-type">type</span>, .{});
                                },
                                <span class="tok-kw">else</span> =&gt; {
                                    <span class="tok-builtin">@field</span>(value, field.name) = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@field</span>(value, field.name)));
                                },
                            }
                        }
                    }

                    <span class="tok-kw">return</span> value;
                },
                <span class="tok-kw">else</span> =&gt; {
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The initializer must be a struct&quot;</span>);
                },
            }
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Can't default init a &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
        },
    }
}

<span class="tok-kw">test</span> zeroInit {
    <span class="tok-kw">const</span> I = <span class="tok-kw">struct</span> {
        d: <span class="tok-type">f64</span>,
    };

    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span>,
        b: ?<span class="tok-type">bool</span>,
        c: I,
        e: [<span class="tok-number">3</span>]<span class="tok-type">u8</span>,
        f: <span class="tok-type">i64</span> = -<span class="tok-number">1</span>,
    };

    <span class="tok-kw">const</span> s = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(S, .{
        .a = <span class="tok-number">42</span>,
    });

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(S{
        .a = <span class="tok-number">42</span>,
        .b = <span class="tok-null">null</span>,
        .c = .{
            .d = <span class="tok-number">0</span>,
        },
        .e = [<span class="tok-number">3</span>]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> },
        .f = -<span class="tok-number">1</span>,
    }, s);

    <span class="tok-kw">const</span> Color = <span class="tok-kw">struct</span> {
        r: <span class="tok-type">u8</span>,
        g: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u8</span>,
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> c = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Color, .{ <span class="tok-number">255</span>, <span class="tok-number">255</span> });
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Color{
        .r = <span class="tok-number">255</span>,
        .g = <span class="tok-number">255</span>,
        .b = <span class="tok-number">0</span>,
        .a = <span class="tok-number">0</span>,
    }, c);

    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
        foo: <span class="tok-type">u8</span> = <span class="tok-number">69</span>,
        bar: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> f = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Foo, .{});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Foo{
        .foo = <span class="tok-number">69</span>,
        .bar = <span class="tok-number">0</span>,
    }, f);

    <span class="tok-kw">const</span> Bar = <span class="tok-kw">struct</span> {
        foo: <span class="tok-type">u32</span> = <span class="tok-number">666</span>,
        bar: <span class="tok-type">u32</span> = <span class="tok-number">420</span>,
    };

    <span class="tok-kw">const</span> b = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Bar, .{<span class="tok-number">69</span>});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Bar{
        .foo = <span class="tok-number">69</span>,
        .bar = <span class="tok-number">420</span>,
    }, b);

    <span class="tok-kw">const</span> Baz = <span class="tok-kw">struct</span> {
        foo: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;bar&quot;</span>,
    };

    <span class="tok-kw">const</span> baz1 = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Baz, .{});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(Baz{}, baz1);

    <span class="tok-kw">const</span> baz2 = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(Baz, .{ .foo = <span class="tok-str">&quot;zab&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;zab&quot;</span>, baz2.foo);

    <span class="tok-kw">const</span> NestedBaz = <span class="tok-kw">struct</span> {
        bbb: Baz,
    };
    <span class="tok-kw">const</span> nested_baz = <a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(NestedBaz, .{});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(NestedBaz{
        .bbb = Baz{},
    }, nested_baz);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.block.html#std.sort.block.block">block</a>(T, items, context, lessThanFn);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    items: []T,
    context: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> lessThanFn: <span class="tok-kw">fn</span> (<span class="tok-builtin">@TypeOf</span>(context), lhs: T, rhs: T) <span class="tok-type">bool</span>,
) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.pdq.html#std.sort.pdq.pdq">pdq</a>(T, items, context, lessThanFn);
}

<span class="tok-comment">/// TODO: currently this just calls `insertionSortContext`. The block sort implementation</span>
<span class="tok-comment">/// in this file needs to be adapted to use the sort context.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.insertionContext">insertionContext</a>(a, b, context);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(a: <span class="tok-type">usize</span>, b: <span class="tok-type">usize</span>, context: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.pdq.html#std.sort.pdq.pdqContext">pdqContext</a>(a, b, context);
}

<span class="tok-comment">/// Compares two slices of numbers lexicographically. O(n).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">order</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: []<span class="tok-kw">const</span> T, rhs: []<span class="tok-kw">const</span> T) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
    <span class="tok-kw">const</span> n = <span class="tok-builtin">@min</span>(lhs.len, rhs.len);
    <span class="tok-kw">for</span> (lhs[<span class="tok-number">0</span>..n], rhs[<span class="tok-number">0</span>..n]) |lhs_elem, rhs_elem| {
        <span class="tok-kw">switch</span> (<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(lhs_elem, rhs_elem)) {
            .eq =&gt; <span class="tok-kw">continue</span>,
            .lt =&gt; <span class="tok-kw">return</span> .lt,
            .gt =&gt; <span class="tok-kw">return</span> .gt,
        }
    }
    <span class="tok-kw">return</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(lhs.len, rhs.len);
}

<span class="tok-comment">/// Compares two many-item pointers with NUL-termination lexicographically.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderZ</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> T, rhs: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> T) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (lhs[i] == rhs[i] <span class="tok-kw">and</span> lhs[i] != <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(lhs[i], rhs[i]);
}

<span class="tok-kw">test</span> order {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, <span class="tok-str">&quot;bee&quot;</span>) == .lt);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>) == .eq);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc0&quot;</span>) == .lt);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;&quot;</span>) == .eq);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.order">order</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;a&quot;</span>) == .lt);
}

<span class="tok-kw">test</span> orderZ {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, <span class="tok-str">&quot;bee&quot;</span>) == .lt);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>) == .eq);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc0&quot;</span>) == .lt);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;&quot;</span>) == .eq);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.orderZ">orderZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;a&quot;</span>) == .lt);
}

<span class="tok-comment">/// Returns true if lhs &lt; rhs, false otherwise</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, lhs: []<span class="tok-kw">const</span> T, rhs: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.order">order</a>(T, lhs, rhs) == .lt;
}

<span class="tok-kw">test</span> lessThan {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, <span class="tok-str">&quot;bee&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;abc0&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lessThan">lessThan</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;a&quot;</span>));
}

<span class="tok-kw">const</span> eqlBytes_allowed = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a>) {<span class="tok-comment">
    // The SPIR-V backend does not support the optimized path yet.
    </span>.stage2_spirv64 =&gt; <span class="tok-null">false</span>,<span class="tok-comment">
    // The RISC-V does not support vectors.
    </span>.stage2_riscv64 =&gt; <span class="tok-null">false</span>,<span class="tok-comment">
    // The naive memory comparison implementation is more useful for fuzzers to
    // find interesting inputs.
    </span><span class="tok-kw">else</span> =&gt; !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.fuzz">fuzz</a>,
};

<span class="tok-comment">/// Returns true if and only if the slices have the same length and all elements</span>
<span class="tok-comment">/// compare true using equality operator.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: []<span class="tok-kw">const</span> T, b: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (!<span class="tok-builtin">@inComptime</span>() <span class="tok-kw">and</span> <span class="tok-builtin">@sizeOf</span>(T) != <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T) <span class="tok-kw">and</span>
        <a href="std.mem.html#std.mem.eqlBytes_allowed">eqlBytes_allowed</a>)
    {
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.eqlBytes">eqlBytes</a>(<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(a), <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(b));
    }

    <span class="tok-kw">if</span> (a.len != b.len) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (a.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> a.ptr == b.ptr) <span class="tok-kw">return</span> <span class="tok-null">true</span>;

    <span class="tok-kw">for</span> (a, b) |a_elem, b_elem| {
        <span class="tok-kw">if</span> (a_elem != b_elem) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-kw">test</span> eql {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcd&quot;</span>, <span class="tok-str">&quot;abcd&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdef&quot;</span>, <span class="tok-str">&quot;abZdef&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-str">&quot;abcdef&quot;</span>));

    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">type</span>, &amp;.{ <span class="tok-type">bool</span>, <span class="tok-type">f32</span> }, &amp;.{ <span class="tok-type">bool</span>, <span class="tok-type">f32</span> }));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">type</span>, &amp;.{ <span class="tok-type">bool</span>, <span class="tok-type">f32</span> }, &amp;.{ <span class="tok-type">f32</span>, <span class="tok-type">bool</span> }));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">type</span>, &amp;.{ <span class="tok-type">bool</span>, <span class="tok-type">f32</span> }, &amp;.{<span class="tok-type">bool</span>}));

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">comptime_int</span>, &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> }, &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> }));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">comptime_int</span>, &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> }, &amp;.{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span> }));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">comptime_int</span>, &amp;.{<span class="tok-number">1</span>}, &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span> }));
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">void</span>, &amp;.{ {}, {} }, &amp;.{ {}, {} }));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">void</span>, &amp;.{{}}, &amp;.{ {}, {} }));
}

<span class="tok-comment">/// std.mem.eql heavily optimized for slices of bytes.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">eqlBytes</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html#std.mem.eqlBytes_allowed">eqlBytes_allowed</a>);

    <span class="tok-kw">if</span> (a.len != b.len) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    <span class="tok-kw">if</span> (a.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> a.ptr == b.ptr) <span class="tok-kw">return</span> <span class="tok-null">true</span>;

    <span class="tok-kw">if</span> (a.len &lt;= <span class="tok-number">16</span>) {
        <span class="tok-kw">if</span> (a.len &lt; <span class="tok-number">4</span>) {
            <span class="tok-kw">const</span> x = (a[<span class="tok-number">0</span>] ^ b[<span class="tok-number">0</span>]) | (a[a.len - <span class="tok-number">1</span>] ^ b[a.len - <span class="tok-number">1</span>]) | (a[a.len / <span class="tok-number">2</span>] ^ b[a.len / <span class="tok-number">2</span>]);
            <span class="tok-kw">return</span> x == <span class="tok-number">0</span>;
        }
        <span class="tok-kw">var</span> x: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> ([_]<span class="tok-type">usize</span>{ <span class="tok-number">0</span>, a.len - <span class="tok-number">4</span>, (a.len / <span class="tok-number">8</span>) * <span class="tok-number">4</span>, a.len - <span class="tok-number">4</span> - ((a.len / <span class="tok-number">8</span>) * <span class="tok-number">4</span>) }) |n| {
            x |= <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(a[n..][<span class="tok-number">0</span>..<span class="tok-number">4</span>].*)) ^ <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(b[n..][<span class="tok-number">0</span>..<span class="tok-number">4</span>].*));
        }
        <span class="tok-kw">return</span> x == <span class="tok-number">0</span>;
    }<span class="tok-comment">

    // Figure out the fastest way to scan through the input in chunks.
    // Uses vectors when supported and falls back to usize/words when not.
    </span><span class="tok-kw">const</span> Scan = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(<span class="tok-type">u8</span>)) |vec_size|
        <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> size = vec_size;
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Chunk = <span class="tok-builtin">@Vector</span>(<a href="std.mem.html#std.mem.eqlBytes.size">size</a>, <span class="tok-type">u8</span>);
            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNotEqual</span>(chunk_a: <a href="std.mem.html#std.mem.eqlBytes.Chunk">Chunk</a>, chunk_b: <a href="std.mem.html#std.mem.eqlBytes.Chunk">Chunk</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@reduce</span>(.Or, chunk_a != chunk_b);
            }
        }
    <span class="tok-kw">else</span>
        <span class="tok-kw">struct</span> {
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> size = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>);
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Chunk = <span class="tok-type">usize</span>;
            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">isNotEqual</span>(chunk_a: <a href="std.mem.html#std.mem.eqlBytes.Chunk">Chunk</a>, chunk_b: <a href="std.mem.html#std.mem.eqlBytes.Chunk">Chunk</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> chunk_a != chunk_b;
            }
        };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">6</span>) |s| {
        <span class="tok-kw">const</span> n = <span class="tok-number">16</span> &lt;&lt; s;
        <span class="tok-kw">if</span> (n &lt;= Scan.size <span class="tok-kw">and</span> a.len &lt;= n) {
            <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(n / <span class="tok-number">2</span>, <span class="tok-type">u8</span>);
            <span class="tok-kw">var</span> x = <span class="tok-builtin">@as</span>(V, a[<span class="tok-number">0</span> .. n / <span class="tok-number">2</span>].*) ^ <span class="tok-builtin">@as</span>(V, b[<span class="tok-number">0</span> .. n / <span class="tok-number">2</span>].*);
            x |= <span class="tok-builtin">@as</span>(V, a[a.len - n / <span class="tok-number">2</span> ..][<span class="tok-number">0</span> .. n / <span class="tok-number">2</span>].*) ^ <span class="tok-builtin">@as</span>(V, b[a.len - n / <span class="tok-number">2</span> ..][<span class="tok-number">0</span> .. n / <span class="tok-number">2</span>].*);
            <span class="tok-kw">const</span> zero: V = <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>);
            <span class="tok-kw">return</span> !<span class="tok-builtin">@reduce</span>(.Or, x != zero);
        }
    }<span class="tok-comment">
    // Compare inputs in chunks at a time (excluding the last chunk).
    </span><span class="tok-kw">for</span> (<span class="tok-number">0</span>..(a.len - <span class="tok-number">1</span>) / Scan.size) |i| {
        <span class="tok-kw">const</span> a_chunk: Scan.Chunk = <span class="tok-builtin">@bitCast</span>(a[i * Scan.size ..][<span class="tok-number">0</span>..Scan.size].*);
        <span class="tok-kw">const</span> b_chunk: Scan.Chunk = <span class="tok-builtin">@bitCast</span>(b[i * Scan.size ..][<span class="tok-number">0</span>..Scan.size].*);
        <span class="tok-kw">if</span> (Scan.isNotEqual(a_chunk, b_chunk)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }<span class="tok-comment">

    // Compare the last chunk using an overlapping read (similar to the previous size strategies).
    </span><span class="tok-kw">const</span> last_a_chunk: Scan.Chunk = <span class="tok-builtin">@bitCast</span>(a[a.len - Scan.size ..][<span class="tok-number">0</span>..Scan.size].*);
    <span class="tok-kw">const</span> last_b_chunk: Scan.Chunk = <span class="tok-builtin">@bitCast</span>(b[a.len - Scan.size ..][<span class="tok-number">0</span>..Scan.size].*);
    <span class="tok-kw">return</span> !Scan.isNotEqual(last_a_chunk, last_b_chunk);
}

<span class="tok-comment">/// Compares two slices and returns the index of the first inequality.</span>
<span class="tok-comment">/// Returns null if the slices are equal.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfDiff</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: []<span class="tok-kw">const</span> T, b: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> shortest = <span class="tok-builtin">@min</span>(a.len, b.len);
    <span class="tok-kw">if</span> (a.ptr == b.ptr)
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a.len == b.len) <span class="tok-null">null</span> <span class="tok-kw">else</span> shortest;
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; shortest) : (index += <span class="tok-number">1</span>) <span class="tok-kw">if</span> (a[index] != b[index]) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a.len == b.len) <span class="tok-null">null</span> <span class="tok-kw">else</span> shortest;
}

<span class="tok-kw">test</span> indexOfDiff {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one&quot;</span>, <span class="tok-str">&quot;one&quot;</span>), <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two&quot;</span>, <span class="tok-str">&quot;one&quot;</span>), <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one&quot;</span>, <span class="tok-str">&quot;one two&quot;</span>), <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one twx&quot;</span>, <span class="tok-str">&quot;one two&quot;</span>), <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfDiff">indexOfDiff</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;xne&quot;</span>, <span class="tok-str">&quot;one&quot;</span>), <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Takes a sentinel-terminated pointer and returns a slice preserving pointer attributes.</span>
<span class="tok-comment">/// `[*c]` pointers are assumed to be 0-terminated and assumed to not be allowzero.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">Span</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .optional =&gt; |optional_info| {
            <span class="tok-kw">return</span> ?<a href="std.mem.html#std.mem.Span">Span</a>(optional_info.child);
        },
        .pointer =&gt; |ptr_info| {
            <span class="tok-kw">var</span> new_ptr_info = ptr_info;
            <span class="tok-kw">switch</span> (ptr_info.size) {
                .c =&gt; {
                    new_ptr_info.sentinel_ptr = &amp;<span class="tok-builtin">@as</span>(ptr_info.child, <span class="tok-number">0</span>);
                    new_ptr_info.is_allowzero = <span class="tok-null">false</span>;
                },
                .many =&gt; <span class="tok-kw">if</span> (ptr_info.sentinel() == <span class="tok-null">null</span>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.span: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),
                .one, .slice =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.span: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T)),
            }
            new_ptr_info.size = .slice;
            <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{ .pointer = new_ptr_info });
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.span: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
}

<span class="tok-kw">test</span> Span {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.Span">Span</a>([*:<span class="tok-number">1</span>]<span class="tok-type">u16</span>) == [:<span class="tok-number">1</span>]<span class="tok-type">u16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.Span">Span</a>(?[*:<span class="tok-number">1</span>]<span class="tok-type">u16</span>) == ?[:<span class="tok-number">1</span>]<span class="tok-type">u16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.Span">Span</a>([*:<span class="tok-number">1</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) == [:<span class="tok-number">1</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.Span">Span</a>(?[*:<span class="tok-number">1</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) == ?[:<span class="tok-number">1</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.Span">Span</a>([*c]<span class="tok-type">u16</span>) == [:<span class="tok-number">0</span>]<span class="tok-type">u16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.Span">Span</a>(?[*c]<span class="tok-type">u16</span>) == ?[:<span class="tok-number">0</span>]<span class="tok-type">u16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.Span">Span</a>([*c]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) == [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.Span">Span</a>(?[*c]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) == ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>);
}

<span class="tok-comment">/// Takes a sentinel-terminated pointer and returns a slice, iterating over the</span>
<span class="tok-comment">/// memory to find the sentinel and determine the length.</span>
<span class="tok-comment">/// Pointer attributes such as const are preserved.</span>
<span class="tok-comment">/// `[*c]` pointers are assumed to be non-null and 0-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">span</span>(ptr: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.Span">Span</a>(<span class="tok-builtin">@TypeOf</span>(ptr)) {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)) == .optional) {
        <span class="tok-kw">if</span> (ptr) |non_null| {
            <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.span">span</a>(non_null);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        }
    }
    <span class="tok-kw">const</span> Result = <a href="std.mem.html#std.mem.Span">Span</a>(<span class="tok-builtin">@TypeOf</span>(ptr));
    <span class="tok-kw">const</span> l = <a href="std.mem.html#std.mem.len">len</a>(ptr);
    <span class="tok-kw">const</span> ptr_info = <span class="tok-builtin">@typeInfo</span>(Result).pointer;
    <span class="tok-kw">if</span> (ptr_info.sentinel()) |s| {
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..l :s];
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..l];
    }
}

<span class="tok-kw">test</span> span {
    <span class="tok-kw">var</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u16</span> = [_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@as</span>([*:<span class="tok-number">3</span>]<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span> :<span class="tok-number">3</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, <a href="std.mem.html#std.mem.span">span</a>(ptr), &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span> }));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?[:<span class="tok-number">0</span>]<span class="tok-type">u16</span>, <span class="tok-null">null</span>), <a href="std.mem.html#std.mem.span">span</a>(<span class="tok-builtin">@as</span>(?[*:<span class="tok-number">0</span>]<span class="tok-type">u16</span>, <span class="tok-null">null</span>)));
}

<span class="tok-comment">/// Helper for the return type of sliceTo()</span>
<span class="tok-kw">fn</span> <span class="tok-fn">SliceTo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> end: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(T)) <span class="tok-type">type</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .optional =&gt; |optional_info| {
            <span class="tok-kw">return</span> ?<a href="std.mem.html#std.mem.SliceTo">SliceTo</a>(optional_info.child, end);
        },
        .pointer =&gt; |ptr_info| {
            <span class="tok-kw">var</span> new_ptr_info = ptr_info;
            new_ptr_info.size = .slice;
            <span class="tok-kw">switch</span> (ptr_info.size) {
                .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(ptr_info.child)) {
                    .array =&gt; |array_info| {
                        new_ptr_info.child = array_info.child;<span class="tok-comment">
                        // The return type must only be sentinel terminated if we are guaranteed
                        // to find the value searched for, which is only the case if it matches
                        // the sentinel of the type passed.
                        </span><span class="tok-kw">if</span> (array_info.sentinel()) |s| {
                            <span class="tok-kw">if</span> (end == s) {
                                new_ptr_info.sentinel_ptr = &amp;end;
                            } <span class="tok-kw">else</span> {
                                new_ptr_info.sentinel_ptr = <span class="tok-null">null</span>;
                            }
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                },
                .many, .slice =&gt; {<span class="tok-comment">
                    // The return type must only be sentinel terminated if we are guaranteed
                    // to find the value searched for, which is only the case if it matches
                    // the sentinel of the type passed.
                    </span><span class="tok-kw">if</span> (ptr_info.sentinel()) |s| {
                        <span class="tok-kw">if</span> (end == s) {
                            new_ptr_info.sentinel_ptr = &amp;end;
                        } <span class="tok-kw">else</span> {
                            new_ptr_info.sentinel_ptr = <span class="tok-null">null</span>;
                        }
                    }
                },
                .c =&gt; {
                    new_ptr_info.sentinel_ptr = &amp;end;<span class="tok-comment">
                    // C pointers are always allowzero, but we don't want the return type to be.
                    </span><a href="std.debug.html#std.debug.assert">assert</a>(new_ptr_info.is_allowzero);
                    new_ptr_info.is_allowzero = <span class="tok-null">false</span>;
                },
            }
            <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{ .pointer = new_ptr_info });
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.sliceTo: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));
}

<span class="tok-comment">/// Takes a pointer to an array, a sentinel-terminated pointer, or a slice and iterates searching for</span>
<span class="tok-comment">/// the first occurrence of `end`, returning the scanned slice.</span>
<span class="tok-comment">/// If `end` is not found, the full length of the array/slice/sentinel terminated pointer is returned.</span>
<span class="tok-comment">/// If the pointer type is sentinel terminated and `end` matches that terminator, the</span>
<span class="tok-comment">/// resulting slice is also sentinel terminated.</span>
<span class="tok-comment">/// Pointer properties such as mutability and alignment are preserved.</span>
<span class="tok-comment">/// C pointers are assumed to be non-null.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceTo</span>(ptr: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> end: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(<span class="tok-builtin">@TypeOf</span>(ptr))) <a href="std.mem.html#std.mem.SliceTo">SliceTo</a>(<span class="tok-builtin">@TypeOf</span>(ptr), end) {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)) == .optional) {
        <span class="tok-kw">const</span> non_null = ptr <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(non_null, end);
    }
    <span class="tok-kw">const</span> Result = <a href="std.mem.html#std.mem.SliceTo">SliceTo</a>(<span class="tok-builtin">@TypeOf</span>(ptr), end);
    <span class="tok-kw">const</span> length = <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(ptr, end);
    <span class="tok-kw">const</span> ptr_info = <span class="tok-builtin">@typeInfo</span>(Result).pointer;
    <span class="tok-kw">if</span> (ptr_info.sentinel()) |s| {
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..length :s];
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> ptr[<span class="tok-number">0</span>..length];
    }
}

<span class="tok-kw">test</span> sliceTo {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aoeu&quot;</span>, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-str">&quot;aoeu&quot;</span>, <span class="tok-number">0</span>));

    {
        <span class="tok-kw">var</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u16</span> = [_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, &amp;array, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;array, <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">3</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(array[<span class="tok-number">0</span>..<span class="tok-number">3</span>], <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;array, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(array[<span class="tok-number">0</span>..<span class="tok-number">3</span>], <span class="tok-number">3</span>));

        <span class="tok-kw">const</span> sentinel_ptr = <span class="tok-builtin">@as</span>([*:<span class="tok-number">5</span>]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;array));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sentinel_ptr, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sentinel_ptr, <span class="tok-number">99</span>));

        <span class="tok-kw">const</span> optional_sentinel_ptr = <span class="tok-builtin">@as</span>(?[*:<span class="tok-number">5</span>]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;array));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(optional_sentinel_ptr, <span class="tok-number">3</span>).?);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(optional_sentinel_ptr, <span class="tok-number">99</span>).?);

        <span class="tok-kw">const</span> c_ptr = <span class="tok-builtin">@as</span>([*c]<span class="tok-type">u16</span>, &amp;array);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(c_ptr, <span class="tok-number">3</span>));

        <span class="tok-kw">const</span> slice: []<span class="tok-type">u16</span> = &amp;array;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(slice, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, &amp;array, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(slice, <span class="tok-number">99</span>));

        <span class="tok-kw">const</span> sentinel_slice: [:<span class="tok-number">5</span>]<span class="tok-type">u16</span> = array[<span class="tok-number">0</span>..<span class="tok-number">4</span> :<span class="tok-number">5</span>];
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sentinel_slice, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(sentinel_slice, <span class="tok-number">99</span>));
    }
    {
        <span class="tok-kw">var</span> sentinel_array: [<span class="tok-number">5</span>:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = [_:<span class="tok-number">0</span>]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, sentinel_array[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;sentinel_array, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, &amp;sentinel_array, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;sentinel_array, <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, &amp;sentinel_array, <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;sentinel_array, <span class="tok-number">99</span>));
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?[]<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(<span class="tok-builtin">@as</span>(?[]<span class="tok-type">u8</span>, <span class="tok-null">null</span>), <span class="tok-number">0</span>));
}

<span class="tok-comment">/// Private helper for sliceTo(). If you want the length, use sliceTo(foo, x).len</span>
<span class="tok-kw">fn</span> <span class="tok-fn">lenSliceTo</span>(ptr: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> end: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(<span class="tok-builtin">@TypeOf</span>(ptr))) <span class="tok-type">usize</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr))) {
        .pointer =&gt; |ptr_info| <span class="tok-kw">switch</span> (ptr_info.size) {
            .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(ptr_info.child)) {
                .array =&gt; |array_info| {
                    <span class="tok-kw">if</span> (array_info.sentinel()) |s| {
                        <span class="tok-kw">if</span> (s == end) {
                            <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(array_info.child, end, ptr);
                        }
                    }
                    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(array_info.child, ptr, end) <span class="tok-kw">orelse</span> array_info.len;
                },
                <span class="tok-kw">else</span> =&gt; {},
            },
            .many =&gt; <span class="tok-kw">if</span> (ptr_info.sentinel()) |s| {
                <span class="tok-kw">if</span> (s == end) {
                    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(ptr_info.child, end, ptr);
                }<span class="tok-comment">
                // We're looking for something other than the sentinel,
                // but iterating past the sentinel would be a bug so we need
                // to check for both.
                </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (ptr[i] != end <span class="tok-kw">and</span> ptr[i] != s) i += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> i;
            },
            .c =&gt; {
                <a href="std.debug.html#std.debug.assert">assert</a>(ptr != <span class="tok-null">null</span>);
                <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(ptr_info.child, end, ptr);
            },
            .slice =&gt; {
                <span class="tok-kw">if</span> (ptr_info.sentinel()) |s| {
                    <span class="tok-kw">if</span> (s == end) {
                        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(ptr_info.child, s, ptr);
                    }
                }
                <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(ptr_info.child, ptr, end) <span class="tok-kw">orelse</span> ptr.len;
            },
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.sliceTo: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(ptr)));
}

<span class="tok-kw">test</span> lenSliceTo {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(<span class="tok-str">&quot;aoeu&quot;</span>, <span class="tok-number">0</span>) == <span class="tok-number">4</span>);

    {
        <span class="tok-kw">var</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u16</span> = [_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(&amp;array, <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(array[<span class="tok-number">0</span>..<span class="tok-number">3</span>], <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(&amp;array, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(array[<span class="tok-number">0</span>..<span class="tok-number">3</span>], <span class="tok-number">3</span>));

        <span class="tok-kw">const</span> sentinel_ptr = <span class="tok-builtin">@as</span>([*:<span class="tok-number">5</span>]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;array));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(sentinel_ptr, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(sentinel_ptr, <span class="tok-number">99</span>));

        <span class="tok-kw">const</span> c_ptr = <span class="tok-builtin">@as</span>([*c]<span class="tok-type">u16</span>, &amp;array);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(c_ptr, <span class="tok-number">3</span>));

        <span class="tok-kw">const</span> slice: []<span class="tok-type">u16</span> = &amp;array;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(slice, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(slice, <span class="tok-number">99</span>));

        <span class="tok-kw">const</span> sentinel_slice: [:<span class="tok-number">5</span>]<span class="tok-type">u16</span> = array[<span class="tok-number">0</span>..<span class="tok-number">4</span> :<span class="tok-number">5</span>];
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(sentinel_slice, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(sentinel_slice, <span class="tok-number">99</span>));
    }
    {
        <span class="tok-kw">var</span> sentinel_array: [<span class="tok-number">5</span>:<span class="tok-number">0</span>]<span class="tok-type">u16</span> = [_:<span class="tok-number">0</span>]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(&amp;sentinel_array, <span class="tok-number">3</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(&amp;sentinel_array, <span class="tok-number">0</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), <a href="std.mem.html#std.mem.lenSliceTo">lenSliceTo</a>(&amp;sentinel_array, <span class="tok-number">99</span>));
    }
}

<span class="tok-comment">/// Takes a sentinel-terminated pointer and iterates over the memory to find the</span>
<span class="tok-comment">/// sentinel and determine the length.</span>
<span class="tok-comment">/// `[*c]` pointers are assumed to be non-null and 0-terminated.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value))) {
        .pointer =&gt; |info| <span class="tok-kw">switch</span> (info.size) {
            .many =&gt; {
                <span class="tok-kw">const</span> sentinel = info.sentinel() <span class="tok-kw">orelse</span>
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.len: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value)));
                <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(info.child, sentinel, value);
            },
            .c =&gt; {
                <a href="std.debug.html#std.debug.assert">assert</a>(value != <span class="tok-null">null</span>);
                <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(info.child, <span class="tok-number">0</span>, value);
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.len: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value))),
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid type given to std.mem.len: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value))),
    }
}

<span class="tok-kw">test</span> len {
    <span class="tok-kw">var</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u16</span> = [_]<span class="tok-type">u16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">0</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@as</span>([*:<span class="tok-number">4</span>]<span class="tok-type">u16</span>, array[<span class="tok-number">0</span>..<span class="tok-number">3</span> :<span class="tok-number">4</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.len">len</a>(ptr) == <span class="tok-number">3</span>);
    <span class="tok-kw">const</span> c_ptr = <span class="tok-builtin">@as</span>([*c]<span class="tok-type">u16</span>, ptr);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.len">len</a>(c_ptr) == <span class="tok-number">2</span>);
}

<span class="tok-kw">const</span> backend_supports_vectors = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a>) {
    .stage2_llvm, .stage2_c =&gt; <span class="tok-null">true</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfSentinel</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> sentinel: T, p: [*:sentinel]<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.backend_supports_vectors">backend_supports_vectors</a> <span class="tok-kw">and</span>
        !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.inValgrind">inValgrind</a>() <span class="tok-kw">and</span><span class="tok-comment"> // https://github.com/ziglang/zig/issues/17717
        </span>!<span class="tok-builtin">@inComptime</span>() <span class="tok-kw">and</span>
        (<span class="tok-builtin">@typeInfo</span>(T) == .int <span class="tok-kw">or</span> <span class="tok-builtin">@typeInfo</span>(T) == .float) <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(<span class="tok-builtin">@bitSizeOf</span>(T)))
    {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).cpu.arch) {<span class="tok-comment">
            // The below branch assumes that reading past the end of the buffer is valid, as long
            // as we don't read into a new page. This should be the case for most architectures
            // which use paged memory, however should be confirmed before adding a new arch below.
            </span>.aarch64, .x86, .x86_64 =&gt; <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(T)) |block_len| {
                <span class="tok-kw">const</span> page_size = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>;
                <span class="tok-kw">const</span> block_size = <span class="tok-builtin">@sizeOf</span>(T) * block_len;
                <span class="tok-kw">const</span> Block = <span class="tok-builtin">@Vector</span>(block_len, T);
                <span class="tok-kw">const</span> mask: Block = <span class="tok-builtin">@splat</span>(sentinel);

                <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a> % <span class="tok-builtin">@sizeOf</span>(Block) == <span class="tok-number">0</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(page_size % <span class="tok-builtin">@sizeOf</span>(Block) == <span class="tok-number">0</span>);<span class="tok-comment">

                // First block may be unaligned
                </span><span class="tok-kw">const</span> start_addr = <span class="tok-builtin">@intFromPtr</span>(&amp;p[i]);
                <span class="tok-kw">const</span> offset_in_page = start_addr &amp; (page_size - <span class="tok-number">1</span>);
                <span class="tok-kw">if</span> (offset_in_page &lt;= page_size - <span class="tok-builtin">@sizeOf</span>(Block)) {<span class="tok-comment">
                    // Will not read past the end of a page, full block.
                    </span><span class="tok-kw">const</span> block: Block = p[i..][<span class="tok-number">0</span>..block_len].*;
                    <span class="tok-kw">const</span> matches = block == mask;
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@reduce</span>(.Or, matches)) {
                        <span class="tok-kw">return</span> i + <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(matches).?;
                    }

                    i += <span class="tok-builtin">@divExact</span>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, start_addr, block_size) - start_addr, <span class="tok-builtin">@sizeOf</span>(T));
                } <span class="tok-kw">else</span> {
                    <span class="tok-builtin">@branchHint</span>(.unlikely);<span class="tok-comment">
                    // Would read over a page boundary. Per-byte at a time until aligned or found.
                    // 0.39% chance this branch is taken for 4K pages at 16b block length.
                    //
                    // An alternate strategy is to do read a full block (the last in the page) and
                    // mask the entries before the pointer.
                    </span><span class="tok-kw">while</span> ((<span class="tok-builtin">@intFromPtr</span>(&amp;p[i]) &amp; (block_size - <span class="tok-number">1</span>)) != <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {
                        <span class="tok-kw">if</span> (p[i] == sentinel) <span class="tok-kw">return</span> i;
                    }
                }

                <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-builtin">@intFromPtr</span>(&amp;p[i]), block_size));
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> block: *<span class="tok-kw">const</span> Block = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(p[i..][<span class="tok-number">0</span>..block_len]));
                    <span class="tok-kw">const</span> matches = block.* == mask;
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@reduce</span>(.Or, matches)) {
                        <span class="tok-kw">return</span> i + <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(matches).?;
                    }
                    i += block_len;
                }
            },
            <span class="tok-kw">else</span> =&gt; {},
        }
    }

    <span class="tok-kw">while</span> (p[i] != sentinel) {
        i += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">return</span> i;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;indexOfSentinel vector paths&quot;</span> {
    <span class="tok-kw">const</span> Types = [_]<span class="tok-type">type</span>{ <span class="tok-type">u8</span>, <span class="tok-type">u16</span>, <span class="tok-type">u32</span>, <span class="tok-type">u64</span> };
    <span class="tok-kw">const</span> allocator = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;
    <span class="tok-kw">const</span> page_size = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>;

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (Types) |T| {
        <span class="tok-kw">const</span> block_len = <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(T) <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>;<span class="tok-comment">

        // Allocate three pages so we guarantee a page-crossing address with a full page after
        </span><span class="tok-kw">const</span> memory = <span class="tok-kw">try</span> allocator.alloc(T, <span class="tok-number">3</span> * page_size / <span class="tok-builtin">@sizeOf</span>(T));
        <span class="tok-kw">defer</span> allocator.free(memory);
        <span class="tok-builtin">@memset</span>(memory, <span class="tok-number">0xaa</span>);<span class="tok-comment">

        // Find starting page-alignment = 0
        </span><span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> start_addr = <span class="tok-builtin">@intFromPtr</span>(&amp;memory);
        start += (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, start_addr, page_size) - start_addr) / <span class="tok-builtin">@sizeOf</span>(T);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(start &lt; page_size / <span class="tok-builtin">@sizeOf</span>(T));<span class="tok-comment">

        // Validate all sub-block alignments
        </span><span class="tok-kw">const</span> search_len = page_size / <span class="tok-builtin">@sizeOf</span>(T);
        memory[start + search_len] = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..block_len) |offset| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(search_len - offset, <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(T, <span class="tok-number">0</span>, <span class="tok-builtin">@ptrCast</span>(&amp;memory[start + offset])));
        }
        memory[start + search_len] = <span class="tok-number">0xaa</span>;<span class="tok-comment">

        // Validate page boundary crossing
        </span><span class="tok-kw">const</span> start_page_boundary = start + (page_size / <span class="tok-builtin">@sizeOf</span>(T));
        memory[start_page_boundary + block_len] = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..block_len) |offset| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span> * block_len - offset, <a href="std.mem.html#std.mem.indexOfSentinel">indexOfSentinel</a>(T, <span class="tok-number">0</span>, <span class="tok-builtin">@ptrCast</span>(&amp;memory[start_page_boundary - block_len + offset])));
        }
    }
}

<span class="tok-comment">/// Returns true if all elements in a slice are equal to the scalar value provided</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allEqual</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, scalar: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">for</span> (slice) |item| {
        <span class="tok-kw">if</span> (item != scalar) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-comment">/// Remove a set of values from the beginning of a slice.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimLeft</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T {
    <span class="tok-kw">var</span> begin: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (begin &lt; slice.len <span class="tok-kw">and</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(T, values_to_strip, slice[begin]) != <span class="tok-null">null</span>) : (begin += <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> slice[begin..];
}

<span class="tok-comment">/// Remove a set of values from the end of a slice.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimRight</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T {
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = slice.len;
    <span class="tok-kw">while</span> (end &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(T, values_to_strip, slice[end - <span class="tok-number">1</span>]) != <span class="tok-null">null</span>) : (end -= <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..end];
}

<span class="tok-comment">/// Remove a set of values from the beginning and end of a slice.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trim</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values_to_strip: []<span class="tok-kw">const</span> T) []<span class="tok-kw">const</span> T {
    <span class="tok-kw">var</span> begin: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = slice.len;
    <span class="tok-kw">while</span> (begin &lt; end <span class="tok-kw">and</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(T, values_to_strip, slice[begin]) != <span class="tok-null">null</span>) : (begin += <span class="tok-number">1</span>) {}
    <span class="tok-kw">while</span> (end &gt; begin <span class="tok-kw">and</span> <a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(T, values_to_strip, slice[end - <span class="tok-number">1</span>]) != <span class="tok-null">null</span>) : (end -= <span class="tok-number">1</span>) {}
    <span class="tok-kw">return</span> slice[begin..end];
}

<span class="tok-kw">test</span> trim {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo\n &quot;</span>, <a href="std.mem.html#std.mem.trimLeft">trimLeft</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot; foo\n &quot;</span>, <span class="tok-str">&quot; \n&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot; foo&quot;</span>, <a href="std.mem.html#std.mem.trimRight">trimRight</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot; foo\n &quot;</span>, <span class="tok-str">&quot; \n&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot; foo\n &quot;</span>, <span class="tok-str">&quot; \n&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot; \n&quot;</span>));
}

<span class="tok-comment">/// Linear search for the index of a scalar value inside a slice.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, value: T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, slice, <span class="tok-number">0</span>, value);
}

<span class="tok-comment">/// Linear search for the last index of a scalar value inside a slice.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, value: T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = slice.len;
    <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (slice[i] == value) <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfScalarPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, value: T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (start_index &gt;= slice.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = start_index;
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.backend_supports_vectors">backend_supports_vectors</a> <span class="tok-kw">and</span>
        !<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.inValgrind">inValgrind</a>() <span class="tok-kw">and</span><span class="tok-comment"> // https://github.com/ziglang/zig/issues/17717
        </span>!<span class="tok-builtin">@inComptime</span>() <span class="tok-kw">and</span>
        (<span class="tok-builtin">@typeInfo</span>(T) == .int <span class="tok-kw">or</span> <span class="tok-builtin">@typeInfo</span>(T) == .float) <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(<span class="tok-builtin">@bitSizeOf</span>(T)))
    {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(T)) |block_len| {<span class="tok-comment">
            // For Intel Nehalem (2009) and AMD Bulldozer (2012) or later, unaligned loads on aligned data result
            // in the same execution as aligned loads. We ignore older arch's here and don't bother pre-aligning.
            //
            // Use `std.simd.suggestVectorLength(T)` to get the same alignment as used in this function
            // however this usually isn't necessary unless your arch has a performance penalty due to this.
            //
            // This may differ for other arch's. Arm for example costs a cycle when loading across a cache
            // line so explicit alignment prologues may be worth exploration.

            // Unrolling here is ~10% improvement. We can then do one bounds check every 2 blocks
            // instead of one which adds up.
            </span><span class="tok-kw">const</span> Block = <span class="tok-builtin">@Vector</span>(block_len, T);
            <span class="tok-kw">if</span> (i + <span class="tok-number">2</span> * block_len &lt; slice.len) {
                <span class="tok-kw">const</span> mask: Block = <span class="tok-builtin">@splat</span>(value);
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">2</span>) |_| {
                        <span class="tok-kw">const</span> block: Block = slice[i..][<span class="tok-number">0</span>..block_len].*;
                        <span class="tok-kw">const</span> matches = block == mask;
                        <span class="tok-kw">if</span> (<span class="tok-builtin">@reduce</span>(.Or, matches)) {
                            <span class="tok-kw">return</span> i + <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(matches).?;
                        }
                        i += block_len;
                    }
                    <span class="tok-kw">if</span> (i + <span class="tok-number">2</span> * block_len &gt;= slice.len) <span class="tok-kw">break</span>;
                }
            }<span class="tok-comment">

            // {block_len, block_len / 2} check
            </span><span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">2</span>) |j| {
                <span class="tok-kw">const</span> block_x_len = block_len / (<span class="tok-number">1</span> &lt;&lt; j);
                <span class="tok-kw">comptime</span> <span class="tok-kw">if</span> (block_x_len &lt; <span class="tok-number">4</span>) <span class="tok-kw">break</span>;

                <span class="tok-kw">const</span> BlockX = <span class="tok-builtin">@Vector</span>(block_x_len, T);
                <span class="tok-kw">if</span> (i + block_x_len &lt; slice.len) {
                    <span class="tok-kw">const</span> mask: BlockX = <span class="tok-builtin">@splat</span>(value);
                    <span class="tok-kw">const</span> block: BlockX = slice[i..][<span class="tok-number">0</span>..block_x_len].*;
                    <span class="tok-kw">const</span> matches = block == mask;
                    <span class="tok-kw">if</span> (<span class="tok-builtin">@reduce</span>(.Or, matches)) {
                        <span class="tok-kw">return</span> i + <a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.firstTrue">firstTrue</a>(matches).?;
                    }
                    i += block_x_len;
                }
            }
        }
    }

    <span class="tok-kw">for</span> (slice[i..], i..) |c, j| {
        <span class="tok-kw">if</span> (c == value) <span class="tok-kw">return</span> j;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> indexOfScalarPos {
    <span class="tok-kw">const</span> Types = [_]<span class="tok-type">type</span>{ <span class="tok-type">u8</span>, <span class="tok-type">u16</span>, <span class="tok-type">u32</span>, <span class="tok-type">u64</span> };

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (Types) |T| {
        <span class="tok-kw">var</span> memory: [<span class="tok-number">64</span> / <span class="tok-builtin">@sizeOf</span>(T)]T = <span class="tok-null">undefined</span>;
        <span class="tok-builtin">@memset</span>(&amp;memory, <span class="tok-number">0xaa</span>);
        memory[memory.len - <span class="tok-number">1</span>] = <span class="tok-number">0</span>;

        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..memory.len) |i| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(memory.len - i - <span class="tok-number">1</span>, <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, memory[i..], <span class="tok-number">0</span>, <span class="tok-number">0</span>).?);
        }
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfAnyPos">indexOfAnyPos</a>(T, slice, <span class="tok-number">0</span>, values);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = slice.len;
    <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        <span class="tok-kw">for</span> (values) |value| {
            <span class="tok-kw">if</span> (slice[i] == value) <span class="tok-kw">return</span> i;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfAnyPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (start_index &gt;= slice.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">for</span> (slice[start_index..], start_index..) |c, i| {
        <span class="tok-kw">for</span> (values) |value| {
            <span class="tok-kw">if</span> (c == value) <span class="tok-kw">return</span> i;
        }
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-comment">/// Find the first item in `slice` which is not contained in `values`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Comparable to `strspn` in the C standard library.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfNone</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfNonePos">indexOfNonePos</a>(T, slice, <span class="tok-number">0</span>, values);
}

<span class="tok-comment">/// Find the last item in `slice` which is not contained in `values`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Like `strspn` in the C standard library, but searches from the end.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfNone</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = slice.len;
    outer: <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
        i -= <span class="tok-number">1</span>;
        <span class="tok-kw">for</span> (values) |value| {
            <span class="tok-kw">if</span> (slice[i] == value) <span class="tok-kw">continue</span> :outer;
        }
        <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-comment">/// Find the first item in `slice[start_index..]` which is not contained in `values`.</span>
<span class="tok-comment">/// The returned index will be relative to the start of `slice`, and never less than `start_index`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Comparable to `strspn` in the C standard library.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfNonePos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, values: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (start_index &gt;= slice.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    outer: <span class="tok-kw">for</span> (slice[start_index..], start_index..) |c, i| {
        <span class="tok-kw">for</span> (values) |value| {
            <span class="tok-kw">if</span> (c == value) <span class="tok-kw">continue</span> :outer;
        }
        <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> indexOfNone {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc123&quot;</span>, <span class="tok-str">&quot;123&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOfNone">lastIndexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc123&quot;</span>, <span class="tok-str">&quot;123&quot;</span>).? == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123abc&quot;</span>, <span class="tok-str">&quot;123&quot;</span>).? == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOfNone">lastIndexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123abc&quot;</span>, <span class="tok-str">&quot;123&quot;</span>).? == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123123&quot;</span>, <span class="tok-str">&quot;123&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;333333&quot;</span>, <span class="tok-str">&quot;123&quot;</span>) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOfNonePos">indexOfNonePos</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc123&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">&quot;321&quot;</span>) == <span class="tok-null">null</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, haystack, <span class="tok-number">0</span>, needle);
}

<span class="tok-comment">/// Find the index in a slice of a sub-slice, searching from the end backwards.</span>
<span class="tok-comment">/// To start looking at a different index, slice the haystack first.</span>
<span class="tok-comment">/// Consider using `lastIndexOf` instead of this, which will automatically use a</span>
<span class="tok-comment">/// more sophisticated algorithm on larger inputs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOfLinear</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = haystack.len - needle.len;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(T, haystack[i..][<span class="tok-number">0</span>..needle.len], needle)) <span class="tok-kw">return</span> i;
        <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }
}

<span class="tok-comment">/// Consider using `indexOfPos` instead of this, which will automatically use a</span>
<span class="tok-comment">/// more sophisticated algorithm on larger inputs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfPosLinear</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = start_index;
    <span class="tok-kw">const</span> end = haystack.len - needle.len;
    <span class="tok-kw">while</span> (i &lt;= end) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.eql">eql</a>(T, haystack[i..][<span class="tok-number">0</span>..needle.len], needle)) <span class="tok-kw">return</span> i;
    }
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> indexOfPosLinear {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;123&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;1&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;2&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;21&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;222&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;1&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;1&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;2&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;12&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;21&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;212&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;122&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;212112&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;12&quot;</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">boyerMooreHorspoolPreprocessReverse</span>(pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, table: *[<span class="tok-number">256</span>]<span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (table) |*c| {
        c.* = pattern.len;
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = pattern.len - <span class="tok-number">1</span>;<span class="tok-comment">
    // The first item is intentionally ignored and the skip size will be pattern.len.
    // This is the standard way Boyer-Moore-Horspool is implemented.
    </span><span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) : (i -= <span class="tok-number">1</span>) {
        table[pattern[i]] = i;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">boyerMooreHorspoolPreprocess</span>(pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, table: *[<span class="tok-number">256</span>]<span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (table) |*c| {
        c.* = pattern.len;
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;<span class="tok-comment">
    // The last item is intentionally ignored and the skip size will be pattern.len.
    // This is the standard way Boyer-Moore-Horspool is implemented.
    </span><span class="tok-kw">while</span> (i &lt; pattern.len - <span class="tok-number">1</span>) : (i += <span class="tok-number">1</span>) {
        table[pattern[i]] = pattern.len - <span class="tok-number">1</span> - i;
    }
}

<span class="tok-comment">/// Find the index in a slice of a sub-slice, searching from the end backwards.</span>
<span class="tok-comment">/// To start looking at a different index, slice the haystack first.</span>
<span class="tok-comment">/// Uses the Reverse Boyer-Moore-Horspool algorithm on large inputs;</span>
<span class="tok-comment">/// `lastIndexOfLinear` on small inputs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (needle.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> haystack.len;

    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T) <span class="tok-kw">or</span> haystack.len &lt; <span class="tok-number">52</span> <span class="tok-kw">or</span> needle.len &lt;= <span class="tok-number">4</span>)
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.lastIndexOfLinear">lastIndexOfLinear</a>(T, haystack, needle);

    <span class="tok-kw">const</span> haystack_bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(haystack);
    <span class="tok-kw">const</span> needle_bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(needle);

    <span class="tok-kw">var</span> skip_table: [<span class="tok-number">256</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <a href="std.mem.html#std.mem.boyerMooreHorspoolPreprocessReverse">boyerMooreHorspoolPreprocessReverse</a>(needle_bytes, skip_table[<span class="tok-number">0</span>..]);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = haystack_bytes.len - needle_bytes.len;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (i % <span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, haystack_bytes[i .. i + needle_bytes.len], needle_bytes)) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@divExact</span>(i, <span class="tok-builtin">@sizeOf</span>(T));
        }
        <span class="tok-kw">const</span> skip = skip_table[haystack_bytes[i]];
        <span class="tok-kw">if</span> (skip &gt; i) <span class="tok-kw">break</span>;
        i -= skip;
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-comment">/// Uses Boyer-Moore-Horspool algorithm on large inputs; `indexOfPosLinear` on small inputs.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfPos</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, start_index: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (needle.len &lt; <span class="tok-number">2</span>) {
        <span class="tok-kw">if</span> (needle.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> start_index;<span class="tok-comment">
        // indexOfScalarPos is significantly faster than indexOfPosLinear
        </span><span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, haystack, start_index, needle[<span class="tok-number">0</span>]);
    }

    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(T) <span class="tok-kw">or</span> haystack.len &lt; <span class="tok-number">52</span> <span class="tok-kw">or</span> needle.len &lt;= <span class="tok-number">4</span>)
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(T, haystack, start_index, needle);

    <span class="tok-kw">const</span> haystack_bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(haystack);
    <span class="tok-kw">const</span> needle_bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(needle);

    <span class="tok-kw">var</span> skip_table: [<span class="tok-number">256</span>]<span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
    <a href="std.mem.html#std.mem.boyerMooreHorspoolPreprocess">boyerMooreHorspoolPreprocess</a>(needle_bytes, skip_table[<span class="tok-number">0</span>..]);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = start_index * <span class="tok-builtin">@sizeOf</span>(T);
    <span class="tok-kw">while</span> (i &lt;= haystack_bytes.len - needle_bytes.len) {
        <span class="tok-kw">if</span> (i % <span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, haystack_bytes[i .. i + needle_bytes.len], needle_bytes)) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@divExact</span>(i, <span class="tok-builtin">@sizeOf</span>(T));
        }
        i += skip_table[haystack_bytes[i + needle_bytes.len - <span class="tok-number">1</span>]];
    }

    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> indexOf {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten eleven&quot;</span>, <span class="tok-str">&quot;three four&quot;</span>).? == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten eleven&quot;</span>, <span class="tok-str">&quot;three four&quot;</span>).? == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten eleven&quot;</span>, <span class="tok-str">&quot;two two&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten eleven&quot;</span>, <span class="tok-str">&quot;two two&quot;</span>) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten&quot;</span>, <span class="tok-str">&quot;&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four five six seven eight nine ten&quot;</span>, <span class="tok-str">&quot;&quot;</span>).? == <span class="tok-number">48</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four&quot;</span>, <span class="tok-str">&quot;four&quot;</span>).? == <span class="tok-number">14</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three two four&quot;</span>, <span class="tok-str">&quot;two&quot;</span>).? == <span class="tok-number">14</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four&quot;</span>, <span class="tok-str">&quot;gour&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;one two three four&quot;</span>, <span class="tok-str">&quot;gour&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;fool&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;lfoo&quot;</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;fool&quot;</span>) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo foo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo foo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>).? == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOfAny">lastIndexOfAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;boo, cat&quot;</span>, <span class="tok-str">&quot;abo&quot;</span>).? == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;boo&quot;</span>, <span class="tok-str">'o'</span>).? == <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;indexOf multibyte&quot;</span> {
    {<span class="tok-comment">
        // make haystack and needle long enough to trigger Boyer-Moore-Horspool algorithm
        </span><span class="tok-kw">const</span> haystack = [<span class="tok-number">1</span>]<span class="tok-type">u16</span>{<span class="tok-number">0</span>} ** <span class="tok-number">100</span> ++ [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xbbaa</span>, <span class="tok-number">0xccbb</span>, <span class="tok-number">0xddcc</span>, <span class="tok-number">0xeedd</span>, <span class="tok-number">0xffee</span>, <span class="tok-number">0x00ff</span> };
        <span class="tok-kw">const</span> needle = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xbbaa</span>, <span class="tok-number">0xccbb</span>, <span class="tok-number">0xddcc</span>, <span class="tok-number">0xeedd</span>, <span class="tok-number">0xffee</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(<span class="tok-type">u16</span>, &amp;haystack, <span class="tok-number">0</span>, &amp;needle), <span class="tok-number">100</span>);<span class="tok-comment">

        // check for misaligned false positives (little and big endian)
        </span><span class="tok-kw">const</span> needleLE = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xbbbb</span>, <span class="tok-number">0xcccc</span>, <span class="tok-number">0xdddd</span>, <span class="tok-number">0xeeee</span>, <span class="tok-number">0xffff</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(<span class="tok-type">u16</span>, &amp;haystack, <span class="tok-number">0</span>, &amp;needleLE), <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> needleBE = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xaacc</span>, <span class="tok-number">0xbbdd</span>, <span class="tok-number">0xccee</span>, <span class="tok-number">0xddff</span>, <span class="tok-number">0xee00</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(<span class="tok-type">u16</span>, &amp;haystack, <span class="tok-number">0</span>, &amp;needleBE), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // make haystack and needle long enough to trigger Boyer-Moore-Horspool algorithm
        </span><span class="tok-kw">const</span> haystack = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xbbaa</span>, <span class="tok-number">0xccbb</span>, <span class="tok-number">0xddcc</span>, <span class="tok-number">0xeedd</span>, <span class="tok-number">0xffee</span>, <span class="tok-number">0x00ff</span> } ++ [<span class="tok-number">1</span>]<span class="tok-type">u16</span>{<span class="tok-number">0</span>} ** <span class="tok-number">100</span>;
        <span class="tok-kw">const</span> needle = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xbbaa</span>, <span class="tok-number">0xccbb</span>, <span class="tok-number">0xddcc</span>, <span class="tok-number">0xeedd</span>, <span class="tok-number">0xffee</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u16</span>, &amp;haystack, &amp;needle), <span class="tok-number">0</span>);<span class="tok-comment">

        // check for misaligned false positives (little and big endian)
        </span><span class="tok-kw">const</span> needleLE = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xbbbb</span>, <span class="tok-number">0xcccc</span>, <span class="tok-number">0xdddd</span>, <span class="tok-number">0xeeee</span>, <span class="tok-number">0xffff</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u16</span>, &amp;haystack, &amp;needleLE), <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> needleBE = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xaacc</span>, <span class="tok-number">0xbbdd</span>, <span class="tok-number">0xccee</span>, <span class="tok-number">0xddff</span>, <span class="tok-number">0xee00</span> };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(<span class="tok-type">u16</span>, &amp;haystack, &amp;needleBE), <span class="tok-null">null</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;indexOfPos empty needle&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abracadabra&quot;</span>, <span class="tok-number">5</span>, <span class="tok-str">&quot;&quot;</span>), <span class="tok-number">5</span>);
}

<span class="tok-comment">/// Returns the number of needles inside the haystack</span>
<span class="tok-comment">/// needle.len must be &gt; 0</span>
<span class="tok-comment">/// does not count overlapping needles</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(needle.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> found: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, haystack, i, needle)) |idx| {
        i = idx + needle.len;
        found += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">return</span> found;
}

<span class="tok-kw">test</span> count {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;h&quot;</span>) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;h&quot;</span>, <span class="tok-str">&quot;h&quot;</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hh&quot;</span>, <span class="tok-str">&quot;h&quot;</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;world!&quot;</span>, <span class="tok-str">&quot;hello&quot;</span>) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello world!&quot;</span>, <span class="tok-str">&quot;hello&quot;</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   abcabc   abc&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>) == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;udexdcbvbruhasdrw&quot;</span>, <span class="tok-str">&quot;bruh&quot;</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foo bar&quot;</span>, <span class="tok-str">&quot;o bar&quot;</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foofoofoo&quot;</span>, <span class="tok-str">&quot;foo&quot;</span>) == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;fffffff&quot;</span>, <span class="tok-str">&quot;ff&quot;</span>) == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.count">count</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;owowowu&quot;</span>, <span class="tok-str">&quot;owowu&quot;</span>) == <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Returns true if the haystack contains expected_count or more needles</span>
<span class="tok-comment">/// needle.len must be &gt; 0</span>
<span class="tok-comment">/// does not count overlapping needles</span><span class="tok-comment">
//
</span><span class="tok-comment">/// See also: `containsAtLeastScalar`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAtLeast</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, expected_count: <span class="tok-type">usize</span>, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(needle.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (expected_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> found: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (<a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, haystack, i, needle)) |idx| {
        i = idx + needle.len;
        found += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (found == expected_count) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">test</span> containsAtLeast {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">1</span>, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">2</span>, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">&quot;a&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;radaradar&quot;</span>, <span class="tok-number">1</span>, <span class="tok-str">&quot;radar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;radaradar&quot;</span>, <span class="tok-number">2</span>, <span class="tok-str">&quot;radar&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;radarradaradarradar&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">&quot;radar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;radarradaradarradar&quot;</span>, <span class="tok-number">4</span>, <span class="tok-str">&quot;radar&quot;</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   radar      radar   &quot;</span>, <span class="tok-number">2</span>, <span class="tok-str">&quot;radar&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeast">containsAtLeast</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   radar      radar   &quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">&quot;radar&quot;</span>));
}

<span class="tok-comment">/// Returns true if the haystack contains expected_count or more needles</span><span class="tok-comment">
//
</span><span class="tok-comment">/// See also: `containsAtLeast`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAtLeastScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, expected_count: <span class="tok-type">usize</span>, needle: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (expected_count == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;

    <span class="tok-kw">var</span> found: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (haystack) |item| {
        <span class="tok-kw">if</span> (item == needle) {
            found += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (found == expected_count) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }
    }

    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">test</span> containsAtLeastScalar {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">0</span>, <span class="tok-str">'a'</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">1</span>, <span class="tok-str">'a'</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">2</span>, <span class="tok-str">'a'</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">'a'</span>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;adadda&quot;</span>, <span class="tok-number">3</span>, <span class="tok-str">'d'</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.containsAtLeastScalar">containsAtLeastScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;adadda&quot;</span>, <span class="tok-number">4</span>, <span class="tok-str">'d'</span>));
}

<span class="tok-comment">/// Reads an integer from memory with size equal to bytes.len.</span>
<span class="tok-comment">/// T specifies the return type, which must be large enough to store</span>
<span class="tok-comment">/// the result.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readVarInt</span>(<span class="tok-kw">comptime</span> ReturnType: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) ReturnType {
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(ReturnType).int.bits &gt;= bytes.len * <span class="tok-number">8</span>);
    <span class="tok-kw">const</span> bits = <span class="tok-builtin">@typeInfo</span>(ReturnType).int.bits;
    <span class="tok-kw">const</span> signedness = <span class="tok-builtin">@typeInfo</span>(ReturnType).int.signedness;
    <span class="tok-kw">const</span> WorkType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(signedness, <span class="tok-builtin">@max</span>(<span class="tok-number">16</span>, bits));
    <span class="tok-kw">var</span> result: WorkType = <span class="tok-number">0</span>;
    <span class="tok-kw">switch</span> (endian) {
        .big =&gt; {
            <span class="tok-kw">for</span> (bytes) |b| {
                result = (result &lt;&lt; <span class="tok-number">8</span>) | b;
            }
        },
        .little =&gt; {
            <span class="tok-kw">const</span> ShiftType = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(WorkType);
            <span class="tok-kw">for</span> (bytes, <span class="tok-number">0</span>..) |b, index| {
                result = result | (<span class="tok-builtin">@as</span>(WorkType, b) &lt;&lt; <span class="tok-builtin">@as</span>(ShiftType, <span class="tok-builtin">@intCast</span>(index * <span class="tok-number">8</span>)));
            }
        },
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(ReturnType, <span class="tok-builtin">@truncate</span>(result));
}

<span class="tok-kw">test</span> readVarInt {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u0</span>, &amp;[_]<span class="tok-type">u8</span>{}, .big) == <span class="tok-number">0x0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u0</span>, &amp;[_]<span class="tok-type">u8</span>{}, .little) == <span class="tok-number">0x0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x12</span>}, .big) == <span class="tok-number">0x12</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xde</span>}, .little) == <span class="tok-number">0xde</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }, .big) == <span class="tok-number">0x1234</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }, .little) == <span class="tok-number">0x3412</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>}, .big) == -<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xfe</span>}, .little) == -<span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xff</span>, <span class="tok-number">0xfd</span> }, .big) == -<span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xfc</span>, <span class="tok-number">0xff</span> }, .little) == -<span class="tok-number">4</span>);<span class="tok-comment">

    // Return type can be oversized (bytes.len * 8 &lt; @typeInfo(ReturnType).int.bits)
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u9</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x12</span>}, .little) == <span class="tok-number">0x12</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u9</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xde</span>}, .big) == <span class="tok-number">0xde</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u80</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x78</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x24</span> }, .big) == <span class="tok-number">0x123456789abcdef024</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">u80</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xec</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x32</span>, <span class="tok-number">0x54</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x98</span>, <span class="tok-number">0xba</span>, <span class="tok-number">0xdc</span>, <span class="tok-number">0xfe</span> }, .little) == <span class="tok-number">0xfedcba9876543210ec</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i9</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>}, .big) == <span class="tok-number">0xff</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readVarInt">readVarInt</a>(<span class="tok-type">i9</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xfe</span>}, .little) == <span class="tok-number">0xfe</span>);
}

<span class="tok-comment">/// Loads an integer from packed memory with provided bit_count, bit_offset, and signedness.</span>
<span class="tok-comment">/// Asserts that T is large enough to store the read value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readVarPackedInt</span>(
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    bit_offset: <span class="tok-type">usize</span>,
    bit_count: <span class="tok-type">usize</span>,
    endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>,
    signedness: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Signedness.html">Signedness</a>,
) T {
    <span class="tok-kw">const</span> uN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> iN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> Log2N = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(T);

    <span class="tok-kw">const</span> read_size = (bit_count + (bit_offset % <span class="tok-number">8</span>) + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;
    <span class="tok-kw">const</span> bit_shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(bit_offset % <span class="tok-number">8</span>));
    <span class="tok-kw">const</span> pad = <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@bitSizeOf</span>(T) - bit_count));

    <span class="tok-kw">const</span> lowest_byte = <span class="tok-kw">switch</span> (endian) {
        .big =&gt; bytes.len - (bit_offset / <span class="tok-number">8</span>) - read_size,
        .little =&gt; bit_offset / <span class="tok-number">8</span>,
    };
    <span class="tok-kw">const</span> read_bytes = bytes[lowest_byte..][<span class="tok-number">0</span>..read_size];

    <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &lt;= <span class="tok-number">8</span>) {<span class="tok-comment">
        // These are the same shifts/masks we perform below, but adds `@truncate`/`@intCast`
        // where needed since int is smaller than a byte.
        </span><span class="tok-kw">const</span> value = <span class="tok-kw">if</span> (read_size == <span class="tok-number">1</span>) b: {
            <span class="tok-kw">break</span> :b <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(read_bytes[<span class="tok-number">0</span>] &gt;&gt; bit_shift));
        } <span class="tok-kw">else</span> b: {
            <span class="tok-kw">const</span> i: <span class="tok-type">u1</span> = <span class="tok-builtin">@intFromBool</span>(endian == .big);
            <span class="tok-kw">const</span> head = <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(read_bytes[i] &gt;&gt; bit_shift));
            <span class="tok-kw">const</span> tail_shift = <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">8</span>) - bit_shift));
            <span class="tok-kw">const</span> tail = <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(read_bytes[<span class="tok-number">1</span> - i]));
            <span class="tok-kw">break</span> :b (tail &lt;&lt; tail_shift) | head;
        };
        <span class="tok-kw">switch</span> (signedness) {
            .signed =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(iN, <span class="tok-builtin">@bitCast</span>(value)) &lt;&lt; pad) &gt;&gt; pad)),
            .unsigned =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(value)) &lt;&lt; pad) &gt;&gt; pad)),
        }
    }<span class="tok-comment">

    // Copy the value out (respecting endianness), accounting for bit_shift
    </span><span class="tok-kw">var</span> int: uN = <span class="tok-number">0</span>;
    <span class="tok-kw">switch</span> (endian) {
        .big =&gt; {
            <span class="tok-kw">for</span> (read_bytes[<span class="tok-number">0</span> .. read_size - <span class="tok-number">1</span>]) |elem| {
                int = elem | (int &lt;&lt; <span class="tok-number">8</span>);
            }
            int = (read_bytes[read_size - <span class="tok-number">1</span>] &gt;&gt; bit_shift) | (int &lt;&lt; (<span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">8</span>) - bit_shift));
        },
        .little =&gt; {
            int = read_bytes[<span class="tok-number">0</span>] &gt;&gt; bit_shift;
            <span class="tok-kw">for</span> (read_bytes[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |elem, i| {
                int |= (<span class="tok-builtin">@as</span>(uN, elem) &lt;&lt; <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>((<span class="tok-number">8</span> * (i + <span class="tok-number">1</span>) - bit_shift))));
            }
        },
    }
    <span class="tok-kw">switch</span> (signedness) {
        .signed =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(iN, <span class="tok-builtin">@bitCast</span>(int)) &lt;&lt; pad) &gt;&gt; pad)),
        .unsigned =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(int)) &lt;&lt; pad) &gt;&gt; pad)),
    }
}

<span class="tok-kw">test</span> readVarPackedInt {
    <span class="tok-kw">const</span> T = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u16</span>) { a: <span class="tok-type">u3</span>, b: <span class="tok-type">u7</span>, c: <span class="tok-type">u6</span> };
    <span class="tok-kw">var</span> st = T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span>, .c = <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> b_field = <a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(<span class="tok-type">u64</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;st), <span class="tok-builtin">@bitOffsetOf</span>(T, <span class="tok-str">&quot;b&quot;</span>), <span class="tok-number">7</span>, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>(), .unsigned);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(st.b, b_field);
}

<span class="tok-comment">/// Reads an integer from memory with bit count specified by T.</span>
<span class="tok-comment">/// The bit count of T must be evenly divisible by 8.</span>
<span class="tok-comment">/// This function cannot fail and cannot cause undefined behavior.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">readInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: *<span class="tok-kw">const</span> [<span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).int.bits, <span class="tok-number">8</span>)]<span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) T {
    <span class="tok-kw">const</span> value: T = <span class="tok-builtin">@bitCast</span>(buffer.*);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (endian == <a href="std.mem.html#std.mem.native_endian">native_endian</a>) value <span class="tok-kw">else</span> <span class="tok-builtin">@byteSwap</span>(value);
}

<span class="tok-kw">test</span> readInt {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u0</span>, &amp;[_]<span class="tok-type">u8</span>{}, .big) == <span class="tok-number">0x0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u0</span>, &amp;[_]<span class="tok-type">u8</span>{}, .little) == <span class="tok-number">0x0</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x32</span>}, .big) == <span class="tok-number">0x32</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x12</span>}, .little) == <span class="tok-number">0x12</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }, .big) == <span class="tok-number">0x1234</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }, .little) == <span class="tok-number">0x3412</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u72</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x78</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x24</span> }, .big) == <span class="tok-number">0x123456789abcdef024</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u72</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xec</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x32</span>, <span class="tok-number">0x54</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x98</span>, <span class="tok-number">0xba</span>, <span class="tok-number">0xdc</span>, <span class="tok-number">0xfe</span> }, .little) == <span class="tok-number">0xfedcba9876543210ec</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>}, .big) == -<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i8</span>, &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xfe</span>}, .little) == -<span class="tok-number">2</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xff</span>, <span class="tok-number">0xfd</span> }, .big) == -<span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i16</span>, &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xfc</span>, <span class="tok-number">0xff</span> }, .little) == -<span class="tok-number">4</span>);

    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.moreReadIntTests">moreReadIntTests</a>();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> <a href="std.mem.html#std.mem.moreReadIntTests">moreReadIntTests</a>();
}

<span class="tok-kw">fn</span> <span class="tok-fn">readPackedIntLittle</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">const</span> uN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> Log2N = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(T);

    <span class="tok-kw">const</span> bit_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> bit_shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(bit_offset % <span class="tok-number">8</span>));

    <span class="tok-kw">const</span> load_size = (bit_count + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;
    <span class="tok-kw">const</span> load_tail_bits = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>((load_size * <span class="tok-number">8</span>) - bit_count));
    <span class="tok-kw">const</span> LoadInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, load_size * <span class="tok-number">8</span>);

    <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // Read by loading a LoadInt, and then follow it up with a 1-byte read
    // of the tail if bit_offset pushed us over a byte boundary.
    </span><span class="tok-kw">const</span> read_bytes = bytes[bit_offset / <span class="tok-number">8</span> ..];
    <span class="tok-kw">const</span> val = <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(<a href="std.mem.html#std.mem.readInt">readInt</a>(LoadInt, read_bytes[<span class="tok-number">0</span>..load_size], .little) &gt;&gt; bit_shift));
    <span class="tok-kw">if</span> (bit_shift &gt; load_tail_bits) {
        <span class="tok-kw">const</span> tail_bits = <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>(bit_shift - load_tail_bits));
        <span class="tok-kw">const</span> tail_byte = read_bytes[load_size];
        <span class="tok-kw">const</span> tail_truncated = <span class="tok-kw">if</span> (bit_count &lt; <span class="tok-number">8</span>) <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(tail_byte)) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(uN, tail_byte);
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@bitCast</span>(val | (tail_truncated &lt;&lt; (<span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@truncate</span>(bit_count)) -% tail_bits))));
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@bitCast</span>(val));
}

<span class="tok-kw">fn</span> <span class="tok-fn">readPackedIntBig</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>) T {
    <span class="tok-kw">const</span> uN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> Log2N = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(T);

    <span class="tok-kw">const</span> bit_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> bit_shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(bit_offset % <span class="tok-number">8</span>));
    <span class="tok-kw">const</span> byte_count = (<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, bit_shift) + bit_count + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;

    <span class="tok-kw">const</span> load_size = (bit_count + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;
    <span class="tok-kw">const</span> load_tail_bits = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>((load_size * <span class="tok-number">8</span>) - bit_count));
    <span class="tok-kw">const</span> LoadInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, load_size * <span class="tok-number">8</span>);

    <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // Read by loading a LoadInt, and then follow it up with a 1-byte read
    // of the tail if bit_offset pushed us over a byte boundary.
    </span><span class="tok-kw">const</span> end = bytes.len - (bit_offset / <span class="tok-number">8</span>);
    <span class="tok-kw">const</span> read_bytes = bytes[(end - byte_count)..end];
    <span class="tok-kw">const</span> val = <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(<a href="std.mem.html#std.mem.readInt">readInt</a>(LoadInt, bytes[(end - load_size)..end][<span class="tok-number">0</span>..load_size], .big) &gt;&gt; bit_shift));
    <span class="tok-kw">if</span> (bit_shift &gt; load_tail_bits) {
        <span class="tok-kw">const</span> tail_bits = <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>(bit_shift - load_tail_bits));
        <span class="tok-kw">const</span> tail_byte = <span class="tok-kw">if</span> (bit_count &lt; <span class="tok-number">8</span>) <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@truncate</span>(read_bytes[<span class="tok-number">0</span>])) <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(uN, read_bytes[<span class="tok-number">0</span>]);
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@bitCast</span>(val | (tail_byte &lt;&lt; (<span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@truncate</span>(bit_count)) -% tail_bits))));
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@bitCast</span>(val));
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> readPackedIntNative = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
    .little =&gt; <a href="std.mem.html#std.mem.readPackedIntLittle">readPackedIntLittle</a>,
    .big =&gt; <a href="std.mem.html#std.mem.readPackedIntBig">readPackedIntBig</a>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> readPackedIntForeign = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
    .little =&gt; <a href="std.mem.html#std.mem.readPackedIntBig">readPackedIntBig</a>,
    .big =&gt; <a href="std.mem.html#std.mem.readPackedIntLittle">readPackedIntLittle</a>,
};

<span class="tok-comment">/// Loads an integer from packed memory.</span>
<span class="tok-comment">/// Asserts that buffer contains at least bit_offset + @bitSizeOf(T) bits.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readPackedInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) T {
    <span class="tok-kw">switch</span> (endian) {
        .little =&gt; <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.readPackedIntLittle">readPackedIntLittle</a>(T, bytes, bit_offset),
        .big =&gt; <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.readPackedIntBig">readPackedIntBig</a>(T, bytes, bit_offset),
    }
}

<span class="tok-kw">test</span> readPackedInt {
    <span class="tok-kw">const</span> T = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u16</span>) { a: <span class="tok-type">u3</span>, b: <span class="tok-type">u7</span>, c: <span class="tok-type">u6</span> };
    <span class="tok-kw">var</span> st = T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span>, .c = <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> b_field = <a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(<span class="tok-type">u7</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;st), <span class="tok-builtin">@bitOffsetOf</span>(T, <span class="tok-str">&quot;b&quot;</span>), <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>());
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(st.b, b_field);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;comptime read/write int&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> bytes: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u16</span>, &amp;bytes, <span class="tok-number">0x1234</span>, .little);
        <span class="tok-kw">const</span> result = <a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, &amp;bytes, .big);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(result == <span class="tok-number">0x3412</span>);
    }
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> bytes: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u16</span>, &amp;bytes, <span class="tok-number">0x1234</span>, .big);
        <span class="tok-kw">const</span> result = <a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, &amp;bytes, .little);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(result == <span class="tok-number">0x3412</span>);
    }
}

<span class="tok-comment">/// Writes an integer to memory, storing it in twos-complement.</span>
<span class="tok-comment">/// This function always succeeds, has defined behavior for all inputs, but</span>
<span class="tok-comment">/// the integer bit width must be divisible by 8.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: *[<span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@typeInfo</span>(T).int.bits, <span class="tok-number">8</span>)]<span class="tok-type">u8</span>, value: T, endian: <a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span> {
    buffer.* = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (endian == <a href="std.mem.html#std.mem.native_endian">native_endian</a>) value <span class="tok-kw">else</span> <span class="tok-builtin">@byteSwap</span>(value));
}

<span class="tok-kw">test</span> writeInt {
    <span class="tok-kw">var</span> buf0: [<span class="tok-number">0</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> buf1: [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> buf2: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> buf9: [<span class="tok-number">9</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u0</span>, &amp;buf0, <span class="tok-number">0x0</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf0[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{}));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u0</span>, &amp;buf0, <span class="tok-number">0x0</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf0[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{}));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u8</span>, &amp;buf1, <span class="tok-number">0x12</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf1[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x12</span>}));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u8</span>, &amp;buf1, <span class="tok-number">0x34</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf1[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0x34</span>}));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u16</span>, &amp;buf2, <span class="tok-number">0x1234</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf2[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span> }));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u16</span>, &amp;buf2, <span class="tok-number">0x5678</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf2[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x78</span>, <span class="tok-number">0x56</span> }));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u72</span>, &amp;buf9, <span class="tok-number">0x123456789abcdef024</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf9[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x34</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x78</span>, <span class="tok-number">0x9a</span>, <span class="tok-number">0xbc</span>, <span class="tok-number">0xde</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x24</span> }));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">u72</span>, &amp;buf9, <span class="tok-number">0xfedcba9876543210ec</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf9[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xec</span>, <span class="tok-number">0x10</span>, <span class="tok-number">0x32</span>, <span class="tok-number">0x54</span>, <span class="tok-number">0x76</span>, <span class="tok-number">0x98</span>, <span class="tok-number">0xba</span>, <span class="tok-number">0xdc</span>, <span class="tok-number">0xfe</span> }));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">i8</span>, &amp;buf1, -<span class="tok-number">1</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf1[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xff</span>}));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">i8</span>, &amp;buf1, -<span class="tok-number">2</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf1[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{<span class="tok-number">0xfe</span>}));

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">i16</span>, &amp;buf2, -<span class="tok-number">3</span>, .big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf2[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xff</span>, <span class="tok-number">0xfd</span> }));
    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">i16</span>, &amp;buf2, -<span class="tok-number">4</span>, .little);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, buf2[<span class="tok-number">0</span>..], &amp;[_]<span class="tok-type">u8</span>{ <span class="tok-number">0xfc</span>, <span class="tok-number">0xff</span> }));
}

<span class="tok-kw">fn</span> <span class="tok-fn">writePackedIntLittle</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, value: T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> uN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> Log2N = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(T);

    <span class="tok-kw">const</span> bit_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> bit_shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(bit_offset % <span class="tok-number">8</span>));

    <span class="tok-kw">const</span> store_size = (<span class="tok-builtin">@bitSizeOf</span>(T) + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;
    <span class="tok-kw">const</span> store_tail_bits = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>((store_size * <span class="tok-number">8</span>) - bit_count));
    <span class="tok-kw">const</span> StoreInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, store_size * <span class="tok-number">8</span>);

    <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span>;<span class="tok-comment">

    // Write by storing a StoreInt, and then follow it up with a 1-byte tail
    // if bit_offset pushed us over a byte boundary.
    </span><span class="tok-kw">const</span> write_bytes = bytes[bit_offset / <span class="tok-number">8</span> ..];
    <span class="tok-kw">const</span> head = write_bytes[<span class="tok-number">0</span>] &amp; ((<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt; bit_shift) - <span class="tok-number">1</span>);

    <span class="tok-kw">var</span> write_value = (<span class="tok-builtin">@as</span>(StoreInt, <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(value))) &lt;&lt; bit_shift) | <span class="tok-builtin">@as</span>(StoreInt, <span class="tok-builtin">@intCast</span>(head));
    <span class="tok-kw">if</span> (bit_shift &gt; store_tail_bits) {
        <span class="tok-kw">const</span> tail_len = <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>(bit_shift - store_tail_bits));
        write_bytes[store_size] &amp;= ~((<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(tail_len))) - <span class="tok-number">1</span>);
        write_bytes[store_size] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(value)) &gt;&gt; (<span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@truncate</span>(bit_count)) -% tail_len))));
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (bit_shift &lt; store_tail_bits) {
        <span class="tok-kw">const</span> tail_len = store_tail_bits - bit_shift;
        <span class="tok-kw">const</span> tail = write_bytes[store_size - <span class="tok-number">1</span>] &amp; (<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0xfe</span>) &lt;&lt; (<span class="tok-number">7</span> - tail_len));
        write_value |= <span class="tok-builtin">@as</span>(StoreInt, tail) &lt;&lt; (<span class="tok-number">8</span> * (store_size - <span class="tok-number">1</span>));
    }

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(StoreInt, write_bytes[<span class="tok-number">0</span>..store_size], write_value, .little);
}

<span class="tok-kw">fn</span> <span class="tok-fn">writePackedIntBig</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, value: T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> uN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> Log2N = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(T);

    <span class="tok-kw">const</span> bit_count = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitSizeOf</span>(T));
    <span class="tok-kw">const</span> bit_shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(bit_offset % <span class="tok-number">8</span>));
    <span class="tok-kw">const</span> byte_count = (bit_shift + bit_count + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;

    <span class="tok-kw">const</span> store_size = (<span class="tok-builtin">@bitSizeOf</span>(T) + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;
    <span class="tok-kw">const</span> store_tail_bits = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>((store_size * <span class="tok-number">8</span>) - bit_count));
    <span class="tok-kw">const</span> StoreInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, store_size * <span class="tok-number">8</span>);

    <span class="tok-kw">if</span> (bit_count == <span class="tok-number">0</span>)
        <span class="tok-kw">return</span>;<span class="tok-comment">

    // Write by storing a StoreInt, and then follow it up with a 1-byte tail
    // if bit_offset pushed us over a byte boundary.
    </span><span class="tok-kw">const</span> end = bytes.len - (bit_offset / <span class="tok-number">8</span>);
    <span class="tok-kw">const</span> write_bytes = bytes[(end - byte_count)..end];
    <span class="tok-kw">const</span> head = write_bytes[byte_count - <span class="tok-number">1</span>] &amp; ((<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt; bit_shift) - <span class="tok-number">1</span>);

    <span class="tok-kw">var</span> write_value = (<span class="tok-builtin">@as</span>(StoreInt, <span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(value))) &lt;&lt; bit_shift) | <span class="tok-builtin">@as</span>(StoreInt, <span class="tok-builtin">@intCast</span>(head));
    <span class="tok-kw">if</span> (bit_shift &gt; store_tail_bits) {
        <span class="tok-kw">const</span> tail_len = <span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@intCast</span>(bit_shift - store_tail_bits));
        write_bytes[<span class="tok-number">0</span>] &amp;= ~((<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(tail_len))) - <span class="tok-number">1</span>);
        write_bytes[<span class="tok-number">0</span>] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>((<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(value)) &gt;&gt; (<span class="tok-builtin">@as</span>(Log2N, <span class="tok-builtin">@truncate</span>(bit_count)) -% tail_len))));
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (bit_shift &lt; store_tail_bits) {
        <span class="tok-kw">const</span> tail_len = store_tail_bits - bit_shift;
        <span class="tok-kw">const</span> tail = write_bytes[<span class="tok-number">0</span>] &amp; (<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0xfe</span>) &lt;&lt; (<span class="tok-number">7</span> - tail_len));
        write_value |= <span class="tok-builtin">@as</span>(StoreInt, tail) &lt;&lt; (<span class="tok-number">8</span> * (store_size - <span class="tok-number">1</span>));
    }

    <a href="std.mem.html#std.mem.writeInt">writeInt</a>(StoreInt, write_bytes[(byte_count - store_size)..][<span class="tok-number">0</span>..store_size], write_value, .big);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> writePackedIntNative = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
    .little =&gt; <a href="std.mem.html#std.mem.writePackedIntLittle">writePackedIntLittle</a>,
    .big =&gt; <a href="std.mem.html#std.mem.writePackedIntBig">writePackedIntBig</a>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> writePackedIntForeign = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
    .little =&gt; <a href="std.mem.html#std.mem.writePackedIntBig">writePackedIntBig</a>,
    .big =&gt; <a href="std.mem.html#std.mem.writePackedIntLittle">writePackedIntLittle</a>,
};

<span class="tok-comment">/// Stores an integer to packed memory.</span>
<span class="tok-comment">/// Asserts that buffer contains at least bit_offset + @bitSizeOf(T) bits.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePackedInt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, value: T, endian: <a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (endian) {
        .little =&gt; <a href="std.mem.html#std.mem.writePackedIntLittle">writePackedIntLittle</a>(T, bytes, bit_offset, value),
        .big =&gt; <a href="std.mem.html#std.mem.writePackedIntBig">writePackedIntBig</a>(T, bytes, bit_offset, value),
    }
}

<span class="tok-kw">test</span> writePackedInt {
    <span class="tok-kw">const</span> T = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u16</span>) { a: <span class="tok-type">u3</span>, b: <span class="tok-type">u7</span>, c: <span class="tok-type">u6</span> };
    <span class="tok-kw">var</span> st = T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span>, .c = <span class="tok-number">4</span> };
    <a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(<span class="tok-type">u7</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;st), <span class="tok-builtin">@bitOffsetOf</span>(T, <span class="tok-str">&quot;b&quot;</span>), <span class="tok-number">0x7f</span>, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>());
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">0x7f</span>, .c = <span class="tok-number">4</span> }, st);
}

<span class="tok-comment">/// Stores an integer to packed memory with provided bit_offset, bit_count, and signedness.</span>
<span class="tok-comment">/// If negative, the written value is sign-extended.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeVarPackedInt</span>(bytes: []<span class="tok-type">u8</span>, bit_offset: <span class="tok-type">usize</span>, bit_count: <span class="tok-type">usize</span>, value: <span class="tok-kw">anytype</span>, endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(value);
    <span class="tok-kw">const</span> uN = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T));

    <span class="tok-kw">const</span> bit_shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(bit_offset % <span class="tok-number">8</span>));
    <span class="tok-kw">const</span> write_size = (bit_count + bit_shift + <span class="tok-number">7</span>) / <span class="tok-number">8</span>;
    <span class="tok-kw">const</span> lowest_byte = <span class="tok-kw">switch</span> (endian) {
        .big =&gt; bytes.len - (bit_offset / <span class="tok-number">8</span>) - write_size,
        .little =&gt; bit_offset / <span class="tok-number">8</span>,
    };
    <span class="tok-kw">const</span> write_bytes = bytes[lowest_byte..][<span class="tok-number">0</span>..write_size];

    <span class="tok-kw">if</span> (write_size == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (write_size == <span class="tok-number">1</span>) {<span class="tok-comment">
        // Single byte writes are handled specially, since we need to mask bits
        // on both ends of the byte.
        </span><span class="tok-kw">const</span> mask = (<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0xff</span>) &gt;&gt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-number">8</span> - bit_count)));
        <span class="tok-kw">const</span> new_bits = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(value)) &amp; mask)) &lt;&lt; bit_shift;
        write_bytes[<span class="tok-number">0</span>] = (write_bytes[<span class="tok-number">0</span>] &amp; ~(mask &lt;&lt; bit_shift)) | new_bits;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">var</span> remaining: T = value;<span class="tok-comment">

    // Iterate bytes forward for Little-endian, backward for Big-endian
    </span><span class="tok-kw">const</span> delta: <span class="tok-type">i2</span> = <span class="tok-kw">if</span> (endian == .big) -<span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> start = <span class="tok-kw">if</span> (endian == .big) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(write_bytes.len - <span class="tok-number">1</span>)) <span class="tok-kw">else</span> <span class="tok-number">0</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">isize</span> = start;<span class="tok-comment"> // isize for signed index arithmetic

    // Write first byte, using a mask to protects bits preceding bit_offset
    </span><span class="tok-kw">const</span> head_mask = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0xff</span>) &gt;&gt; bit_shift;
    write_bytes[<span class="tok-builtin">@intCast</span>(i)] &amp;= ~(head_mask &lt;&lt; bit_shift);
    write_bytes[<span class="tok-builtin">@intCast</span>(i)] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(remaining)) &amp; head_mask)) &lt;&lt; bit_shift;
    remaining = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(T, remaining, <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-number">8</span>) - bit_shift);
    i += delta;<span class="tok-comment">

    // Write bytes[1..bytes.len - 1]
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt; <span class="tok-number">8</span>) {
        <span class="tok-kw">const</span> loop_end = start + delta * (<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(write_size)) - <span class="tok-number">1</span>);
        <span class="tok-kw">while</span> (i != loop_end) : (i += delta) {
            write_bytes[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(i))] = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(remaining))));
            remaining &gt;&gt;= <span class="tok-number">8</span>;
        }
    }<span class="tok-comment">

    // Write last byte, using a mask to protect bits following bit_offset + bit_count
    </span><span class="tok-kw">const</span> following_bits = -%<span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@truncate</span>(bit_shift + bit_count));
    <span class="tok-kw">const</span> tail_mask = (<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0xff</span>) &lt;&lt; following_bits) &gt;&gt; following_bits;
    write_bytes[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(i))] &amp;= ~tail_mask;
    write_bytes[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(i))] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(uN, <span class="tok-builtin">@bitCast</span>(remaining)) &amp; tail_mask));
}

<span class="tok-kw">test</span> writeVarPackedInt {
    <span class="tok-kw">const</span> T = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u16</span>) { a: <span class="tok-type">u3</span>, b: <span class="tok-type">u7</span>, c: <span class="tok-type">u6</span> };
    <span class="tok-kw">var</span> st = T{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span>, .c = <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> value: <span class="tok-type">u64</span> = <span class="tok-number">0x7f</span>;
    <a href="std.mem.html#std.mem.writeVarPackedInt">writeVarPackedInt</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;st), <span class="tok-builtin">@bitOffsetOf</span>(T, <span class="tok-str">&quot;b&quot;</span>), <span class="tok-number">7</span>, value, <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(T{ .a = <span class="tok-number">1</span>, .b = value, .c = <span class="tok-number">4</span> }, st);
}

<span class="tok-comment">/// Swap the byte order of all the members of the fields of a struct</span>
<span class="tok-comment">/// (Changing their endianness)</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">byteSwapAllFields</span>(<span class="tok-kw">comptime</span> S: <span class="tok-type">type</span>, ptr: *S) <span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(S)) {
        .@&quot;struct&quot; =&gt; {
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(S)) |f| {
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(f.<span class="tok-type">type</span>)) {
                    .@&quot;struct&quot; =&gt; |struct_info| <span class="tok-kw">if</span> (struct_info.backing_integer) |Int| {
                        <span class="tok-builtin">@field</span>(ptr, f.name) = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@as</span>(Int, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@field</span>(ptr, f.name)))));
                    } <span class="tok-kw">else</span> {
                        <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(f.<span class="tok-type">type</span>, &amp;<span class="tok-builtin">@field</span>(ptr, f.name));
                    },
                    .array =&gt; <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(f.<span class="tok-type">type</span>, &amp;<span class="tok-builtin">@field</span>(ptr, f.name)),
                    .@&quot;enum&quot; =&gt; {
                        <span class="tok-builtin">@field</span>(ptr, f.name) = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@intFromEnum</span>(<span class="tok-builtin">@field</span>(ptr, f.name))));
                    },
                    .<span class="tok-type">bool</span> =&gt; {},
                    .float =&gt; |float_info| {
                        <span class="tok-builtin">@field</span>(ptr, f.name) = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, float_info.bits), <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@field</span>(ptr, f.name)))));
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-builtin">@field</span>(ptr, f.name) = <span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@field</span>(ptr, f.name));
                    },
                }
            }
        },
        .array =&gt; {
            <span class="tok-kw">for</span> (ptr) |*item| {
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(item.*))) {
                    .@&quot;struct&quot;, .array =&gt; <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(<span class="tok-builtin">@TypeOf</span>(item.*), item),
                    .@&quot;enum&quot; =&gt; {
                        item.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@intFromEnum</span>(item.*)));
                    },
                    .<span class="tok-type">bool</span> =&gt; {},
                    .float =&gt; |float_info| {
                        item.* = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@byteSwap</span>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, float_info.bits), <span class="tok-builtin">@bitCast</span>(item.*))));
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        item.* = <span class="tok-builtin">@byteSwap</span>(item.*);
                    },
                }
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;byteSwapAllFields expects a struct or array as the first argument&quot;</span>),
    }
}

<span class="tok-kw">test</span> byteSwapAllFields {
    <span class="tok-kw">const</span> T = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        f0: <span class="tok-type">u8</span>,
        f1: <span class="tok-type">u16</span>,
        f2: <span class="tok-type">u32</span>,
        f3: [<span class="tok-number">1</span>]<span class="tok-type">u8</span>,
        f4: <span class="tok-type">bool</span>,
        f5: <span class="tok-type">f32</span>,
    };
    <span class="tok-kw">const</span> K = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        f0: <span class="tok-type">u8</span>,
        f1: T,
        f2: <span class="tok-type">u16</span>,
        f3: [<span class="tok-number">1</span>]<span class="tok-type">u8</span>,
        f4: <span class="tok-type">bool</span>,
        f5: <span class="tok-type">f32</span>,
    };
    <span class="tok-kw">var</span> s = T{
        .f0 = <span class="tok-number">0x12</span>,
        .f1 = <span class="tok-number">0x1234</span>,
        .f2 = <span class="tok-number">0x12345678</span>,
        .f3 = .{<span class="tok-number">0x12</span>},
        .f4 = <span class="tok-null">true</span>,
        .f5 = <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x4640e400</span>))),
    };
    <span class="tok-kw">var</span> k = K{
        .f0 = <span class="tok-number">0x12</span>,
        .f1 = s,
        .f2 = <span class="tok-number">0x1234</span>,
        .f3 = .{<span class="tok-number">0x12</span>},
        .f4 = <span class="tok-null">false</span>,
        .f5 = <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x45d42800</span>))),
    };
    <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(T, &amp;s);
    <a href="std.mem.html#std.mem.byteSwapAllFields">byteSwapAllFields</a>(K, &amp;k);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(T{
        .f0 = <span class="tok-number">0x12</span>,
        .f1 = <span class="tok-number">0x3412</span>,
        .f2 = <span class="tok-number">0x78563412</span>,
        .f3 = .{<span class="tok-number">0x12</span>},
        .f4 = <span class="tok-null">true</span>,
        .f5 = <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x00e44046</span>))),
    }, s);
    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(K{
        .f0 = <span class="tok-number">0x12</span>,
        .f1 = s,
        .f2 = <span class="tok-number">0x3412</span>,
        .f3 = .{<span class="tok-number">0x12</span>},
        .f4 = <span class="tok-null">false</span>,
        .f5 = <span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x0028d445</span>))),
    }, k);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> tokenize = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; use tokenizeAny, tokenizeSequence, or tokenizeScalar&quot;</span>);

<span class="tok-comment">/// Returns an iterator that iterates over the slices of `buffer` that are not</span>
<span class="tok-comment">/// any of the items in `delimiters`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `tokenizeAny(u8, &quot;   abc|def ||  ghi  &quot;, &quot; |&quot;)` will return slices</span>
<span class="tok-comment">/// for &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `buffer` is empty, the iterator will return null.</span>
<span class="tok-comment">/// If none of `delimiters` exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `tokenizeSequence`, `tokenizeScalar`,</span>
<span class="tok-comment">///           `splitSequence`,`splitAny`, `splitScalar`,</span>
<span class="tok-comment">///           `splitBackwardsSequence`, `splitBackwardsAny`, and `splitBackwardsScalar`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .any) {
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiters,
    };
}

<span class="tok-comment">/// Returns an iterator that iterates over the slices of `buffer` that are not</span>
<span class="tok-comment">/// the sequence in `delimiter`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `tokenizeSequence(u8, &quot;&lt;&gt;abc&gt;&lt;def&lt;&gt;&lt;&gt;ghi&quot;, &quot;&lt;&gt;&quot;)` will return slices</span>
<span class="tok-comment">/// for &quot;abc&gt;&lt;def&quot;, &quot;ghi&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `buffer` is empty, the iterator will return null.</span>
<span class="tok-comment">/// If `delimiter` does not exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">/// The delimiter length must not be zero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `tokenizeAny`, `tokenizeScalar`,</span>
<span class="tok-comment">///           `splitSequence`,`splitAny`, and `splitScalar`</span>
<span class="tok-comment">///           `splitBackwardsSequence`, `splitBackwardsAny`, and `splitBackwardsScalar`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .sequence) {
    <a href="std.debug.html#std.debug.assert">assert</a>(delimiter.len != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}

<span class="tok-comment">/// Returns an iterator that iterates over the slices of `buffer` that are not</span>
<span class="tok-comment">/// `delimiter`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `tokenizeScalar(u8, &quot;   abc def     ghi  &quot;, ' ')` will return slices</span>
<span class="tok-comment">/// for &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `buffer` is empty, the iterator will return null.</span>
<span class="tok-comment">/// If `delimiter` does not exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `tokenizeAny`, `tokenizeSequence`,</span>
<span class="tok-comment">///           `splitSequence`,`splitAny`, and `splitScalar`</span>
<span class="tok-comment">///           `splitBackwardsSequence`, `splitBackwardsAny`, and `splitBackwardsScalar`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tokenizeScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.TokenIterator">TokenIterator</a>(T, .scalar) {
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}

<span class="tok-kw">test</span> tokenizeScalar {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   abc def   ghi  &quot;</span>, <span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.peek().?, <span class="tok-str">&quot;def&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;..\\bob&quot;</span>, <span class="tok-str">'\\'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;..&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;..&quot;</span>, <span class="tok-str">&quot;..\\bob&quot;</span>[<span class="tok-number">0</span>..it.index]));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;bob&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;//a/b&quot;</span>, <span class="tok-str">'/'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;//a/b&quot;</span>, <span class="tok-str">&quot;//a/b&quot;</span>[<span class="tok-number">0</span>..it.index]));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;|&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>),
        <span class="tok-str">' '</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> tokenizeAny {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a|b,c/d e&quot;</span>, <span class="tok-str">&quot; /,|&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.peek().?, <span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a|b,c/d e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot; /,|&quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> tokenizeSequence {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&lt;&gt;b&lt;&gt;&lt;&gt;c&gt;&lt;&gt;d&gt;&lt;&quot;</span>, <span class="tok-str">&quot;&lt;&gt;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;a&quot;</span>, it.next().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;b&quot;</span>, it.peek().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;b&quot;</span>, it.next().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;c&gt;&quot;</span>, it.next().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;d&gt;&lt;&quot;</span>, it.next().?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&lt;&gt;b&lt;&gt;&lt;&gt;c&gt;&lt;&gt;d&gt;&lt;&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;&lt;&gt;&quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&gt;&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&gt;&lt;&quot;</span>)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;tokenize (reset)&quot;</span> {
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   abc def   ghi  &quot;</span>, <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeSequence">tokenizeSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&lt;&gt;&lt;&gt;abc&lt;&gt;def&lt;&gt;&lt;&gt;ghi&lt;&gt;&quot;</span>, <span class="tok-str">&quot;&lt;&gt;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;   abc def   ghi  &quot;</span>, <span class="tok-str">' '</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> split = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; use splitSequence, splitAny, or splitScalar&quot;</span>);

<span class="tok-comment">/// Returns an iterator that iterates over the slices of `buffer` that</span>
<span class="tok-comment">/// are separated by the byte sequence in `delimiter`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `splitSequence(u8, &quot;abc||def||||ghi&quot;, &quot;||&quot;)` will return slices</span>
<span class="tok-comment">/// for &quot;abc&quot;, &quot;def&quot;, &quot;&quot;, &quot;ghi&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `delimiter` does not exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">/// The delimiter length must not be zero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `splitAny`, `splitScalar`, `splitBackwardsSequence`,</span>
<span class="tok-comment">///           `splitBackwardsAny`,`splitBackwardsScalar`,</span>
<span class="tok-comment">///           `tokenizeAny`, `tokenizeSequence`, and `tokenizeScalar`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .sequence) {
    <a href="std.debug.html#std.debug.assert">assert</a>(delimiter.len != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}

<span class="tok-comment">/// Returns an iterator that iterates over the slices of `buffer` that</span>
<span class="tok-comment">/// are separated by any item in `delimiters`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `splitAny(u8, &quot;abc,def||ghi&quot;, &quot;|,&quot;)` will return slices</span>
<span class="tok-comment">/// for &quot;abc&quot;, &quot;def&quot;, &quot;&quot;, &quot;ghi&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If none of `delimiters` exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `splitSequence`, `splitScalar`, `splitBackwardsSequence`,</span>
<span class="tok-comment">///           `splitBackwardsAny`,`splitBackwardsScalar`,</span>
<span class="tok-comment">///           `tokenizeAny`, `tokenizeSequence`, and `tokenizeScalar`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .any) {
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiters,
    };
}

<span class="tok-comment">/// Returns an iterator that iterates over the slices of `buffer` that</span>
<span class="tok-comment">/// are separated by `delimiter`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `splitScalar(u8, &quot;abc|def||ghi&quot;, '|')` will return slices</span>
<span class="tok-comment">/// for &quot;abc&quot;, &quot;def&quot;, &quot;&quot;, &quot;ghi&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `delimiter` does not exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `splitSequence`, `splitAny`, `splitBackwardsSequence`,</span>
<span class="tok-comment">///           `splitBackwardsAny`,`splitBackwardsScalar`,</span>
<span class="tok-comment">///           `tokenizeAny`, `tokenizeSequence`, and `tokenizeScalar`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.SplitIterator">SplitIterator</a>(T, .scalar) {
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}

<span class="tok-kw">test</span> splitScalar {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc|def||ghi&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc|def||ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;def||ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.peek().?, <span class="tok-str">&quot;def&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;|ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.peek().?, <span class="tok-str">&quot;ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;|&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.peek() == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;hello&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>),
        <span class="tok-str">' '</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> splitSequence {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitSequence">splitSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>, <span class="tok-str">&quot;, &quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;b ,, c, d, e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b ,&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitSequence">splitSequence</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;, &quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b ,&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> splitAny {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitAny">splitAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a,b, c d e&quot;</span>, <span class="tok-str">&quot;, &quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;b, c d e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitAny">splitAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitAny">splitAny</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a,b, c d e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;, &quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;split (reset)&quot;</span> {
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitSequence">splitSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc def ghi&quot;</span>, <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitAny">splitAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc def,ghi&quot;</span>, <span class="tok-str">&quot; ,&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc def ghi&quot;</span>, <span class="tok-str">' '</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> splitBackwards = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;deprecated; use splitBackwardsSequence, splitBackwardsAny, or splitBackwardsScalar&quot;</span>);

<span class="tok-comment">/// Returns an iterator that iterates backwards over the slices of `buffer` that</span>
<span class="tok-comment">/// are separated by the sequence in `delimiter`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `splitBackwardsSequence(u8, &quot;abc||def||||ghi&quot;, &quot;||&quot;)` will return slices</span>
<span class="tok-comment">/// for &quot;ghi&quot;, &quot;&quot;, &quot;def&quot;, &quot;abc&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `delimiter` does not exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">/// The delimiter length must not be zero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `splitBackwardsAny`, `splitBackwardsScalar`,</span>
<span class="tok-comment">///           `splitSequence`, `splitAny`,`splitScalar`,</span>
<span class="tok-comment">///           `tokenizeAny`, `tokenizeSequence`, and `tokenizeScalar`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsSequence</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .sequence) {
    <a href="std.debug.html#std.debug.assert">assert</a>(delimiter.len != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .index = buffer.len,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}

<span class="tok-comment">/// Returns an iterator that iterates backwards over the slices of `buffer` that</span>
<span class="tok-comment">/// are separated by any item in `delimiters`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `splitBackwardsAny(u8, &quot;abc,def||ghi&quot;, &quot;|,&quot;)` will return slices</span>
<span class="tok-comment">/// for &quot;ghi&quot;, &quot;&quot;, &quot;def&quot;, &quot;abc&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If none of `delimiters` exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `splitBackwardsSequence`, `splitBackwardsScalar`,</span>
<span class="tok-comment">///           `splitSequence`, `splitAny`,`splitScalar`,</span>
<span class="tok-comment">///           `tokenizeAny`, `tokenizeSequence`, and `tokenizeScalar`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsAny</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiters: []<span class="tok-kw">const</span> T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .any) {
    <span class="tok-kw">return</span> .{
        .index = buffer.len,
        .buffer = buffer,
        .delimiter = delimiters,
    };
}

<span class="tok-comment">/// Returns an iterator that iterates backwards over the slices of `buffer` that</span>
<span class="tok-comment">/// are separated by `delimiter`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `splitBackwardsScalar(u8, &quot;abc|def||ghi&quot;, '|')` will return slices</span>
<span class="tok-comment">/// for &quot;ghi&quot;, &quot;&quot;, &quot;def&quot;, &quot;abc&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If `delimiter` does not exist in buffer,</span>
<span class="tok-comment">/// the iterator will return `buffer`, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also: `splitBackwardsSequence`, `splitBackwardsAny`,</span>
<span class="tok-comment">///           `splitSequence`, `splitAny`,`splitScalar`,</span>
<span class="tok-comment">///           `tokenizeAny`, `tokenizeSequence`, and `tokenizeScalar`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitBackwardsScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, delimiter: T) <a href="std.mem.html#std.mem.SplitBackwardsIterator">SplitBackwardsIterator</a>(T, .scalar) {
    <span class="tok-kw">return</span> .{
        .index = buffer.len,
        .buffer = buffer,
        .delimiter = delimiter,
    };
}

<span class="tok-kw">test</span> splitBackwardsScalar {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc|def||ghi&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc|def||ghi&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;ghi&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc|def|&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc|def&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;abc&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;|&quot;</span>, <span class="tok-str">'|'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">' '</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;hello&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>),
        <span class="tok-str">' '</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;hello&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> splitBackwardsSequence {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>, <span class="tok-str">&quot;, &quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;e&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a, b ,, c, d&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a, b ,, c&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a, b ,&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b ,&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a, b ,, c, d, e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;, &quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b ,&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> splitBackwardsAny {
    <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a,b, c d e&quot;</span>, <span class="tok-str">&quot;, &quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b, c d e&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;e&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b, c d&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;d&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b, c&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b,&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a,b&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;b&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.rest(), <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a>(
        <span class="tok-type">u16</span>,
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a,b, c d e&quot;</span>),
        <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;, &quot;</span>),
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.first(), <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;e&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;d&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;c&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;b&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;a&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it16.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;splitBackwards (reset)&quot;</span> {
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsSequence">splitBackwardsSequence</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc def ghi&quot;</span>, <span class="tok-str">&quot; &quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsAny">splitBackwardsAny</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc def,ghi&quot;</span>, <span class="tok-str">&quot; ,&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abc def ghi&quot;</span>, <span class="tok-str">' '</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));

        it.reset();

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;ghi&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }
}

<span class="tok-comment">/// Returns an iterator with a sliding window of slices for `buffer`.</span>
<span class="tok-comment">/// The sliding window has length `size` and on every iteration moves</span>
<span class="tok-comment">/// forward by `advance`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Extract data for moving average with:</span>
<span class="tok-comment">/// `window(u8, &quot;abcdefg&quot;, 3, 1)` will return slices</span>
<span class="tok-comment">/// &quot;abc&quot;, &quot;bcd&quot;, &quot;cde&quot;, &quot;def&quot;, &quot;efg&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Chunk or split every N items with:</span>
<span class="tok-comment">/// `window(u8, &quot;abcdefg&quot;, 3, 3)` will return slices</span>
<span class="tok-comment">/// &quot;abc&quot;, &quot;def&quot;, &quot;g&quot;, null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Pick every even index with:</span>
<span class="tok-comment">/// `window(u8, &quot;abcdefg&quot;, 1, 2)` will return slices</span>
<span class="tok-comment">/// &quot;a&quot;, &quot;c&quot;, &quot;e&quot;, &quot;g&quot; null, in that order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The `size` and `advance` must be not be zero.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">window</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buffer: []<span class="tok-kw">const</span> T, size: <span class="tok-type">usize</span>, advance: <span class="tok-type">usize</span>) <a href="std.mem.html#std.mem.WindowIterator">WindowIterator</a>(T) {
    <a href="std.debug.html#std.debug.assert">assert</a>(size != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(advance != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> .{
        .index = <span class="tok-number">0</span>,
        .buffer = buffer,
        .size = size,
        .advance = advance,
    };
}

<span class="tok-kw">test</span> window {
    {<span class="tok-comment">
        // moving average size 3
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;bcd&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;cde&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;efg&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);<span class="tok-comment">

        // multibyte
        </span><span class="tok-kw">var</span> it16 = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u16</span>, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-number">3</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;abc&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;bcd&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;cde&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;def&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u16</span>, it16.next().?, <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(<span class="tok-str">&quot;efg&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it16.next(), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // chunk/split every 3
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;g&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // pick even
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;a&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;c&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;e&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;g&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // empty
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);

        it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">10</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);

        it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">1</span>, <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);

        it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">10</span>, <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }

    {<span class="tok-comment">
        // first
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.first(), <span class="tok-str">&quot;abc&quot;</span>);
        it.reset();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
    }

    {<span class="tok-comment">
        // reset
        </span><span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.window">window</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>, <span class="tok-number">3</span>, <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;g&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);

        it.reset();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;def&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, it.next().?, <span class="tok-str">&quot;g&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(it.next(), <span class="tok-null">null</span>);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">WindowIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        buffer: []<span class="tok-kw">const</span> T,
        index: ?<span class="tok-type">usize</span>,
        size: <span class="tok-type">usize</span>,
        advance: <span class="tok-type">usize</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Returns a slice of the first window.</span>
        <span class="tok-comment">/// Call this only to get the first window and then use `next` to get</span>
        <span class="tok-comment">/// all subsequent windows.</span>
        <span class="tok-comment">/// Asserts that iteration has not begun.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> self.next().?;
        }

        <span class="tok-comment">/// Returns a slice of the next window, or null if window is at end.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> next_index = start + self.advance;
            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (start + self.size &lt; self.buffer.len <span class="tok-kw">and</span> next_index &lt; self.buffer.len) blk: {
                self.index = next_index;
                <span class="tok-kw">break</span> :blk start + self.size;
            } <span class="tok-kw">else</span> blk: {
                self.index = <span class="tok-null">null</span>;
                <span class="tok-kw">break</span> :blk self.buffer.len;
            };

            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Resets the iterator to the initial window.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.WindowIterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
        }
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startsWith</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-null">false</span> <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.eql">eql</a>(T, haystack[<span class="tok-number">0</span>..needle.len], needle);
}

<span class="tok-kw">test</span> startsWith {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Bob&quot;</span>, <span class="tok-str">&quot;Bo&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Needle in haystack&quot;</span>, <span class="tok-str">&quot;haystack&quot;</span>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endsWith</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (needle.len &gt; haystack.len) <span class="tok-null">false</span> <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.eql">eql</a>(T, haystack[haystack.len - needle.len ..], needle);
}

<span class="tok-kw">test</span> endsWith {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Needle in haystack&quot;</span>, <span class="tok-str">&quot;haystack&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Bob&quot;</span>, <span class="tok-str">&quot;Bo&quot;</span>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DelimiterType = <span class="tok-kw">enum</span> { sequence, any, scalar };

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">TokenIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        buffer: []<span class="tok-kw">const</span> T,
        delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
            .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
            .scalar =&gt; T,
        },
        index: <span class="tok-type">usize</span>,

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Returns a slice of the current token, or null if tokenization is</span>
        <span class="tok-comment">/// complete, and advances to the next token.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> result = self.peek() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.index += result.len;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Returns a slice of the current token, or null if tokenization is</span>
        <span class="tok-comment">/// complete. Does not advance to the next token.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {<span class="tok-comment">
            // move to beginning of token
            </span><span class="tok-kw">while</span> (self.index &lt; self.buffer.len <span class="tok-kw">and</span> self.isDelimiter(self.index)) : (self.index += <span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; self.delimiter.len,
                .any, .scalar =&gt; <span class="tok-number">1</span>,
            }) {}
            <span class="tok-kw">const</span> start = self.index;
            <span class="tok-kw">if</span> (start == self.buffer.len) {
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }<span class="tok-comment">

            // move to end of token
            </span><span class="tok-kw">var</span> end = start;
            <span class="tok-kw">while</span> (end &lt; self.buffer.len <span class="tok-kw">and</span> !self.isDelimiter(end)) : (end += <span class="tok-number">1</span>) {}

            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Returns a slice of the remaining bytes. Does not affect iterator state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.TokenIterator">Self</a>) []<span class="tok-kw">const</span> T {<span class="tok-comment">
            // move to beginning of token
            </span><span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = self.index;
            <span class="tok-kw">while</span> (index &lt; self.buffer.len <span class="tok-kw">and</span> self.isDelimiter(index)) : (index += <span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; self.delimiter.len,
                .any, .scalar =&gt; <span class="tok-number">1</span>,
            }) {}
            <span class="tok-kw">return</span> self.buffer[index..];
        }

        <span class="tok-comment">/// Resets the iterator to the initial token.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.TokenIterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">isDelimiter</span>(self: <a href="std.mem.html#std.mem.TokenIterator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.startsWith">startsWith</a>(T, self.buffer[index..], self.delimiter),
                .any =&gt; {
                    <span class="tok-kw">const</span> item = self.buffer[index];
                    <span class="tok-kw">for</span> (self.delimiter) |delimiter_item| {
                        <span class="tok-kw">if</span> (item == delimiter_item) {
                            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                        }
                    }
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                },
                .scalar =&gt; <span class="tok-kw">return</span> self.buffer[index] == self.delimiter,
            }
        }
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SplitIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        buffer: []<span class="tok-kw">const</span> T,
        index: ?<span class="tok-type">usize</span>,
        delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
            .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
            .scalar =&gt; T,
        },

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Returns a slice of the first field.</span>
        <span class="tok-comment">/// Call this only to get the first field and then use `next` to get all subsequent fields.</span>
        <span class="tok-comment">/// Asserts that iteration has not begun.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> self.next().?;
        }

        <span class="tok-comment">/// Returns a slice of the next field, or null if splitting is complete.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; <a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, self.buffer, start, self.delimiter),
                .any =&gt; <a href="std.mem.html#std.mem.indexOfAnyPos">indexOfAnyPos</a>(T, self.buffer, start, self.delimiter),
                .scalar =&gt; <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, self.buffer, start, self.delimiter),
            }) |delim_start| blk: {
                self.index = delim_start + <span class="tok-kw">switch</span> (delimiter_type) {
                    .sequence =&gt; self.delimiter.len,
                    .any, .scalar =&gt; <span class="tok-number">1</span>,
                };
                <span class="tok-kw">break</span> :blk delim_start;
            } <span class="tok-kw">else</span> blk: {
                self.index = <span class="tok-null">null</span>;
                <span class="tok-kw">break</span> :blk self.buffer.len;
            };
            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Returns a slice of the next field, or null if splitting is complete.</span>
        <span class="tok-comment">/// This method does not alter self.index.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> end = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; <a href="std.mem.html#std.mem.indexOfPos">indexOfPos</a>(T, self.buffer, start, self.delimiter),
                .any =&gt; <a href="std.mem.html#std.mem.indexOfAnyPos">indexOfAnyPos</a>(T, self.buffer, start, self.delimiter),
                .scalar =&gt; <a href="std.mem.html#std.mem.indexOfScalarPos">indexOfScalarPos</a>(T, self.buffer, start, self.delimiter),
            }) |delim_start| delim_start <span class="tok-kw">else</span> self.buffer.len;
            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Returns a slice of the remaining bytes. Does not affect iterator state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.SplitIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> end = self.buffer.len;
            <span class="tok-kw">const</span> start = self.index <span class="tok-kw">orelse</span> end;
            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Resets the iterator to the initial slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.SplitIterator">Self</a>) <span class="tok-type">void</span> {
            self.index = <span class="tok-number">0</span>;
        }
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">SplitBackwardsIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> delimiter_type: <a href="std.mem.DelimiterType.html">DelimiterType</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        buffer: []<span class="tok-kw">const</span> T,
        index: ?<span class="tok-type">usize</span>,
        delimiter: <span class="tok-kw">switch</span> (delimiter_type) {
            .sequence, .any =&gt; []<span class="tok-kw">const</span> T,
            .scalar =&gt; T,
        },

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Returns a slice of the first field.</span>
        <span class="tok-comment">/// Call this only to get the first field and then use `next` to get all subsequent fields.</span>
        <span class="tok-comment">/// Asserts that iteration has not begun.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">first</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <a href="std.debug.html#std.debug.assert">assert</a>(self.index.? == self.buffer.len);
            <span class="tok-kw">return</span> self.next().?;
        }

        <span class="tok-comment">/// Returns a slice of the next field, or null if splitting is complete.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) ?[]<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> end = self.index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> start = <span class="tok-kw">if</span> (<span class="tok-kw">switch</span> (delimiter_type) {
                .sequence =&gt; <a href="std.mem.html#std.mem.lastIndexOf">lastIndexOf</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
                .any =&gt; <a href="std.mem.html#std.mem.lastIndexOfAny">lastIndexOfAny</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
                .scalar =&gt; <a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(T, self.buffer[<span class="tok-number">0</span>..end], self.delimiter),
            }) |delim_start| blk: {
                self.index = delim_start;
                <span class="tok-kw">break</span> :blk delim_start + <span class="tok-kw">switch</span> (delimiter_type) {
                    .sequence =&gt; self.delimiter.len,
                    .any, .scalar =&gt; <span class="tok-number">1</span>,
                };
            } <span class="tok-kw">else</span> blk: {
                self.index = <span class="tok-null">null</span>;
                <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
            };
            <span class="tok-kw">return</span> self.buffer[start..end];
        }

        <span class="tok-comment">/// Returns a slice of the remaining bytes. Does not affect iterator state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rest</span>(self: <a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) []<span class="tok-kw">const</span> T {
            <span class="tok-kw">const</span> end = self.index <span class="tok-kw">orelse</span> <span class="tok-number">0</span>;
            <span class="tok-kw">return</span> self.buffer[<span class="tok-number">0</span>..end];
        }

        <span class="tok-comment">/// Resets the iterator to the initial slice.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.mem.html#std.mem.SplitBackwardsIterator">Self</a>) <span class="tok-type">void</span> {
            self.index = self.buffer.len;
        }
    };
}

<span class="tok-comment">/// Naively combines a series of slices with a separator.</span>
<span class="tok-comment">/// Allocates memory for the result, which must be freed by the caller.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">join</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.joinMaybeZ">joinMaybeZ</a>(allocator, separator, slices, <span class="tok-null">false</span>);
}

<span class="tok-comment">/// Naively combines a series of slices with a separator and null terminator.</span>
<span class="tok-comment">/// Allocates memory for the result, which must be freed by the caller.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">joinZ</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> out = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinMaybeZ">joinMaybeZ</a>(allocator, separator, slices, <span class="tok-null">true</span>);
    <span class="tok-kw">return</span> out[<span class="tok-number">0</span> .. out.len - <span class="tok-number">1</span> :<span class="tok-number">0</span>];
}

<span class="tok-kw">fn</span> <span class="tok-fn">joinMaybeZ</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, separator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, zero: <span class="tok-type">bool</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (slices.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">if</span> (zero) <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, &amp;[<span class="tok-number">1</span>]<span class="tok-type">u8</span>{<span class="tok-number">0</span>}) <span class="tok-kw">else</span> &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};

    <span class="tok-kw">const</span> total_len = blk: {
        <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = separator.len * (slices.len - <span class="tok-number">1</span>);
        <span class="tok-kw">for</span> (slices) |slice| sum += slice.len;
        <span class="tok-kw">if</span> (zero) sum += <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk sum;
    };

    <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, total_len);
    <span class="tok-kw">errdefer</span> allocator.free(buf);

    <span class="tok-builtin">@memcpy</span>(buf[<span class="tok-number">0</span>..slices[<span class="tok-number">0</span>].len], slices[<span class="tok-number">0</span>]);
    <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = slices[<span class="tok-number">0</span>].len;
    <span class="tok-kw">for</span> (slices[<span class="tok-number">1</span>..]) |slice| {
        <span class="tok-builtin">@memcpy</span>(buf[buf_index .. buf_index + separator.len], separator);
        buf_index += separator.len;
        <span class="tok-builtin">@memcpy</span>(buf[buf_index .. buf_index + slice.len], slice);
        buf_index += slice.len;
    }

    <span class="tok-kw">if</span> (zero) buf[buf.len - <span class="tok-number">1</span>] = <span class="tok-number">0</span>;<span class="tok-comment">

    // No need for shrink since buf is exactly the correct size.
    </span><span class="tok-kw">return</span> buf;
}

<span class="tok-kw">test</span> join {
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.join">join</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;&quot;</span>));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.join">join</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a,b,c&quot;</span>));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.join">join</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;a&quot;</span>});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a&quot;</span>));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.join">join</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;c&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a,,b,,c&quot;</span>));
    }
}

<span class="tok-kw">test</span> joinZ {
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinZ">joinZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(str[str.len], <span class="tok-number">0</span>);
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinZ">joinZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a,b,c&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(str[str.len], <span class="tok-number">0</span>);
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinZ">joinZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;a&quot;</span>});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(str[str.len], <span class="tok-number">0</span>);
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.joinZ">joinZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;,&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;c&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;a,,b,,c&quot;</span>));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(str[str.len], <span class="tok-number">0</span>);
    }
}

<span class="tok-comment">/// Copies each T from slices into a new slice that exactly holds all the elements.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concat</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.concatMaybeSentinel">concatMaybeSentinel</a>(allocator, T, slices, <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Copies each T from slices into a new slice that exactly holds all the elements.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatWithSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> s: T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:s]T {
    <span class="tok-kw">const</span> ret = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concatMaybeSentinel">concatMaybeSentinel</a>(allocator, T, slices, s);
    <span class="tok-kw">return</span> ret[<span class="tok-number">0</span> .. ret.len - <span class="tok-number">1</span> :s];
}

<span class="tok-comment">/// Copies each T from slices into a new slice that exactly holds all the elements as well as the sentinel.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatMaybeSentinel</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> s: ?T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">if</span> (slices.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">if</span> (s) |sentinel| <span class="tok-kw">try</span> allocator.dupe(T, &amp;[<span class="tok-number">1</span>]T{sentinel}) <span class="tok-kw">else</span> &amp;[<span class="tok-number">0</span>]T{};

    <span class="tok-kw">const</span> total_len = blk: {
        <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (slices) |slice| {
            sum += slice.len;
        }

        <span class="tok-kw">if</span> (s) |_| {
            sum += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">break</span> :blk sum;
    };

    <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> allocator.alloc(T, total_len);
    <span class="tok-kw">errdefer</span> allocator.free(buf);

    <span class="tok-kw">var</span> buf_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slices) |slice| {
        <span class="tok-builtin">@memcpy</span>(buf[buf_index .. buf_index + slice.len], slice);
        buf_index += slice.len;
    }

    <span class="tok-kw">if</span> (s) |sentinel| {
        buf[buf.len - <span class="tok-number">1</span>] = sentinel;
    }<span class="tok-comment">

    // No need for shrink since buf is exactly the correct size.
    </span><span class="tok-kw">return</span> buf;
}

<span class="tok-kw">test</span> concat {
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concat">concat</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;def&quot;</span>, <span class="tok-str">&quot;ghi&quot;</span> });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, str, <span class="tok-str">&quot;abcdefghi&quot;</span>));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concat">concat</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u32</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u32</span>{
            &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
            &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> },
            &amp;[_]<span class="tok-type">u32</span>{},
            &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">5</span>},
        });
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u32</span>, str, &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }));
    }
    {
        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concatWithSentinel">concatWithSentinel</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;def&quot;</span>, <span class="tok-str">&quot;ghi&quot;</span> }, <span class="tok-number">0</span>);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(str);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSentinel">expectEqualSentinel</a>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>, str, <span class="tok-str">&quot;abcdefghi&quot;</span>);
    }
    {
        <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concatWithSentinel">concatWithSentinel</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u8</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{}, <span class="tok-number">0</span>);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(slice);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSentinel">expectEqualSentinel</a>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>, slice, &amp;[_:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{});
    }
    {
        <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.concatWithSentinel">concatWithSentinel</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-type">u32</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u32</span>{
            &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span> },
            &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> },
            &amp;[_]<span class="tok-type">u32</span>{},
            &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">5</span>},
        }, <span class="tok-number">2</span>);
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(slice);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSentinel">expectEqualSentinel</a>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>, slice, &amp;[_:<span class="tok-number">2</span>]<span class="tok-type">u32</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> });
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">moreReadIntTests</span>() !<span class="tok-type">void</span> {
    {
        <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u8</span>{
            <span class="tok-number">0x12</span>,
            <span class="tok-number">0x34</span>,
            <span class="tok-number">0x56</span>,
            <span class="tok-number">0x78</span>,
        };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, &amp;bytes, .big) == <span class="tok-number">0x12345678</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, &amp;bytes, .big) == <span class="tok-number">0x12345678</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i32</span>, &amp;bytes, .big) == <span class="tok-number">0x12345678</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, &amp;bytes, .little) == <span class="tok-number">0x78563412</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, &amp;bytes, .little) == <span class="tok-number">0x78563412</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i32</span>, &amp;bytes, .little) == <span class="tok-number">0x78563412</span>);
    }
    {
        <span class="tok-kw">const</span> buf = [_]<span class="tok-type">u8</span>{
            <span class="tok-number">0x00</span>,
            <span class="tok-number">0x00</span>,
            <span class="tok-number">0x12</span>,
            <span class="tok-number">0x34</span>,
        };
        <span class="tok-kw">const</span> answer = <a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, &amp;buf, .big);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(answer == <span class="tok-number">0x00001234</span>);
    }
    {
        <span class="tok-kw">const</span> buf = [_]<span class="tok-type">u8</span>{
            <span class="tok-number">0x12</span>,
            <span class="tok-number">0x34</span>,
            <span class="tok-number">0x00</span>,
            <span class="tok-number">0x00</span>,
        };
        <span class="tok-kw">const</span> answer = <a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, &amp;buf, .little);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(answer == <span class="tok-number">0x00003412</span>);
    }
    {
        <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u8</span>{
            <span class="tok-number">0xff</span>,
            <span class="tok-number">0xfe</span>,
        };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, &amp;bytes, .big) == <span class="tok-number">0xfffe</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i16</span>, &amp;bytes, .big) == -<span class="tok-number">0x0002</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, &amp;bytes, .little) == <span class="tok-number">0xfeff</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">i16</span>, &amp;bytes, .little) == -<span class="tok-number">0x0101</span>);
    }
}

<span class="tok-comment">/// Returns the smallest number in a slice. O(n).</span>
<span class="tok-comment">/// `slice` must not be empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">min</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> best = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..]) |item| {
        best = <span class="tok-builtin">@min</span>(best, item);
    }
    <span class="tok-kw">return</span> best;
}

<span class="tok-kw">test</span> min {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.min">min</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-str">'a'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.min">min</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;bcdefga&quot;</span>), <span class="tok-str">'a'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.min">min</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>), <span class="tok-str">'a'</span>);
}

<span class="tok-comment">/// Returns the largest number in a slice. O(n).</span>
<span class="tok-comment">/// `slice` must not be empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> best = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..]) |item| {
        best = <span class="tok-builtin">@max</span>(best, item);
    }
    <span class="tok-kw">return</span> best;
}

<span class="tok-kw">test</span> max {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.max">max</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-str">'g'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.max">max</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;gabcdef&quot;</span>), <span class="tok-str">'g'</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.max">max</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;g&quot;</span>), <span class="tok-str">'g'</span>);
}

<span class="tok-comment">/// Finds the smallest and largest number in a slice. O(n).</span>
<span class="tok-comment">/// Returns an anonymous struct with the fields `min` and `max`.</span>
<span class="tok-comment">/// `slice` must not be empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">minMax</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-kw">struct</span> { T, T } {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> running_minimum = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> running_maximum = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..]) |item| {
        running_minimum = <span class="tok-builtin">@min</span>(running_minimum, item);
        running_maximum = <span class="tok-builtin">@max</span>(running_maximum, item);
    }
    <span class="tok-kw">return</span> .{ running_minimum, running_maximum };
}

<span class="tok-kw">test</span> minMax {
    {
        <span class="tok-kw">const</span> actual_min, <span class="tok-kw">const</span> actual_max = minMax(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), actual_min);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'g'</span>), actual_max);
    }
    {
        <span class="tok-kw">const</span> actual_min, <span class="tok-kw">const</span> actual_max = minMax(<span class="tok-type">u8</span>, <span class="tok-str">&quot;bcdefga&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), actual_min);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'g'</span>), actual_max);
    }
    {
        <span class="tok-kw">const</span> actual_min, <span class="tok-kw">const</span> actual_max = minMax(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), actual_min);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), actual_max);
    }
}

<span class="tok-comment">/// Returns the index of the smallest number in a slice. O(n).</span>
<span class="tok-comment">/// `slice` must not be empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfMin</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> best = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (item &lt; best) {
            best = item;
            index = i + <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> index;
}

<span class="tok-kw">test</span> indexOfMin {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMin">indexOfMin</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMin">indexOfMin</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;bcdefga&quot;</span>), <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMin">indexOfMin</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>), <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Returns the index of the largest number in a slice. O(n).</span>
<span class="tok-comment">/// `slice` must not be empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfMax</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> best = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (item &gt; best) {
            best = item;
            index = i + <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> index;
}

<span class="tok-kw">test</span> indexOfMax {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMax">indexOfMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>), <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMax">indexOfMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;gabcdef&quot;</span>), <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.mem.html#std.mem.indexOfMax">indexOfMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>), <span class="tok-number">0</span>);
}

<span class="tok-comment">/// Finds the indices of the smallest and largest number in a slice. O(n).</span>
<span class="tok-comment">/// Returns the indices of the smallest and largest numbers in that order.</span>
<span class="tok-comment">/// `slice` must not be empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOfMinMax</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []<span class="tok-kw">const</span> T) <span class="tok-kw">struct</span> { <span class="tok-type">usize</span>, <span class="tok-type">usize</span> } {
    <a href="std.debug.html#std.debug.assert">assert</a>(slice.len &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> minVal = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> maxVal = slice[<span class="tok-number">0</span>];
    <span class="tok-kw">var</span> minIdx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> maxIdx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slice[<span class="tok-number">1</span>..], <span class="tok-number">0</span>..) |item, i| {
        <span class="tok-kw">if</span> (item &lt; minVal) {
            minVal = item;
            minIdx = i + <span class="tok-number">1</span>;
        }
        <span class="tok-kw">if</span> (item &gt; maxVal) {
            maxVal = item;
            maxIdx = i + <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> .{ minIdx, maxIdx };
}

<span class="tok-kw">test</span> indexOfMinMax {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">6</span> }, <a href="std.mem.html#std.mem.indexOfMinMax">indexOfMinMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abcdefg&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">1</span>, <span class="tok-number">0</span> }, <a href="std.mem.html#std.mem.indexOfMinMax">indexOfMinMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;gabcdef&quot;</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.{ <span class="tok-number">0</span>, <span class="tok-number">0</span> }, <a href="std.mem.html#std.mem.indexOfMinMax">indexOfMinMax</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;a&quot;</span>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swap</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: *T, b: *T) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tmp = a.*;
    a.* = b.*;
    b.* = tmp;
}

<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseVector</span>(<span class="tok-kw">comptime</span> N: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: []T) [N]T {
    <span class="tok-kw">var</span> res: [N]T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..N) |i| {
        res[i] = a[N - i - <span class="tok-number">1</span>];
    }
    <span class="tok-kw">return</span> res;
}

<span class="tok-comment">/// In-place order reversal of a slice</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverse</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> end = items.len / <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.backend_supports_vectors">backend_supports_vectors</a> <span class="tok-kw">and</span>
        !<span class="tok-builtin">@inComptime</span>() <span class="tok-kw">and</span>
        <span class="tok-builtin">@bitSizeOf</span>(T) &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span>
        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(<span class="tok-builtin">@bitSizeOf</span>(T)))
    {
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.simd.html">simd</a>.<a href="std.simd.html#std.simd.suggestVectorLength">suggestVectorLength</a>(T)) |simd_size| {
            <span class="tok-kw">if</span> (simd_size &lt;= end) {
                <span class="tok-kw">const</span> simd_end = end - (simd_size - <span class="tok-number">1</span>);
                <span class="tok-kw">while</span> (i &lt; simd_end) : (i += simd_size) {
                    <span class="tok-kw">const</span> left_slice = items[i .. i + simd_size];
                    <span class="tok-kw">const</span> right_slice = items[items.len - i - simd_size .. items.len - i];

                    <span class="tok-kw">const</span> left_shuffled: [simd_size]T = <a href="std.mem.html#std.mem.reverseVector">reverseVector</a>(simd_size, T, left_slice);
                    <span class="tok-kw">const</span> right_shuffled: [simd_size]T = <a href="std.mem.html#std.mem.reverseVector">reverseVector</a>(simd_size, T, right_slice);

                    <span class="tok-builtin">@memcpy</span>(right_slice, &amp;left_shuffled);
                    <span class="tok-builtin">@memcpy</span>(left_slice, &amp;right_shuffled);
                }
            }
        }
    }

    <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {
        <a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;items[i], &amp;items[items.len - i - <span class="tok-number">1</span>]);
    }
}

<span class="tok-kw">test</span> reverse {
    {
        <span class="tok-kw">var</span> arr = [_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span> };
        <a href="std.mem.html#std.mem.reverse">reverse</a>(<span class="tok-type">i32</span>, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">i32</span>, &amp;arr, &amp;.{ <span class="tok-number">4</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span> });
    }
    {
        <span class="tok-kw">var</span> arr = [_]<span class="tok-type">u0</span>{};
        <a href="std.mem.html#std.mem.reverse">reverse</a>(<span class="tok-type">u0</span>, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u0</span>, &amp;arr, &amp;.{});
    }
    {
        <span class="tok-kw">var</span> arr = [_]<span class="tok-type">i64</span>{ <span class="tok-number">19</span>, <span class="tok-number">17</span>, <span class="tok-number">15</span>, <span class="tok-number">13</span>, <span class="tok-number">11</span>, <span class="tok-number">9</span>, <span class="tok-number">7</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">6</span>, <span class="tok-number">8</span>, <span class="tok-number">10</span>, <span class="tok-number">12</span>, <span class="tok-number">14</span>, <span class="tok-number">16</span>, <span class="tok-number">18</span> };
        <a href="std.mem.html#std.mem.reverse">reverse</a>(<span class="tok-type">i64</span>, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">i64</span>, &amp;arr, &amp;.{ <span class="tok-number">18</span>, <span class="tok-number">16</span>, <span class="tok-number">14</span>, <span class="tok-number">12</span>, <span class="tok-number">10</span>, <span class="tok-number">8</span>, <span class="tok-number">6</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>, <span class="tok-number">7</span>, <span class="tok-number">9</span>, <span class="tok-number">11</span>, <span class="tok-number">13</span>, <span class="tok-number">15</span>, <span class="tok-number">17</span>, <span class="tok-number">19</span> });
    }
    {
        <span class="tok-kw">var</span> arr = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;d&quot;</span> };
        <a href="std.mem.html#std.mem.reverse">reverse</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, &amp;arr, &amp;.{ <span class="tok-str">&quot;d&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;a&quot;</span> });
    }
    {
        <span class="tok-kw">const</span> MyType = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            a: [<span class="tok-number">3</span>]<span class="tok-type">u8</span>,
            b: <span class="tok-type">u24</span>,
            c,
        };
        <span class="tok-kw">var</span> arr = [_]MyType{ .{ .a = .{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> } }, .{ .b = <span class="tok-number">0</span> }, .c };
        <a href="std.mem.html#std.mem.reverse">reverse</a>(MyType, arr[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(MyType, &amp;arr, &amp;([_]MyType{ .c, .{ .b = <span class="tok-number">0</span> }, .{ .a = .{ <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> } } }));
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">ReverseIterator</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> Pointer = blk: {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
            .pointer =&gt; |ptr_info| <span class="tok-kw">switch</span> (ptr_info.size) {
                .one =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(ptr_info.child)) {
                    .array =&gt; |array_info| {
                        <span class="tok-kw">var</span> new_ptr_info = ptr_info;
                        new_ptr_info.size = .many;
                        new_ptr_info.child = array_info.child;
                        new_ptr_info.sentinel_ptr = array_info.sentinel_ptr;
                        <span class="tok-kw">break</span> :blk <span class="tok-builtin">@Type</span>(.{ .pointer = new_ptr_info });
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                },
                .slice =&gt; {
                    <span class="tok-kw">var</span> new_ptr_info = ptr_info;
                    new_ptr_info.size = .many;
                    <span class="tok-kw">break</span> :blk <span class="tok-builtin">@Type</span>(.{ .pointer = new_ptr_info });
                },
                <span class="tok-kw">else</span> =&gt; {},
            },
            <span class="tok-kw">else</span> =&gt; {},
        }
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected slice or pointer to array, found '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);
    };
    <span class="tok-kw">const</span> Element = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(Pointer);
    <span class="tok-kw">const</span> ElementPointer = <span class="tok-builtin">@Type</span>(.{ .pointer = ptr: {
        <span class="tok-kw">var</span> ptr = <span class="tok-builtin">@typeInfo</span>(Pointer).pointer;
        ptr.size = .one;
        ptr.child = Element;
        ptr.sentinel_ptr = <span class="tok-null">null</span>;
        <span class="tok-kw">break</span> :ptr ptr;
    } });
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        ptr: Pointer,
        index: <span class="tok-type">usize</span>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<span class="tok-builtin">@This</span>()) ?Element {
            <span class="tok-kw">if</span> (self.index == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.index -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> self.ptr[self.index];
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextPtr</span>(self: *<span class="tok-builtin">@This</span>()) ?ElementPointer {
            <span class="tok-kw">if</span> (self.index == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.index -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> &amp;self.ptr[self.index];
        }
    };
}

<span class="tok-comment">/// Iterates over a slice in reverse.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseIterator</span>(slice: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.ReverseIterator">ReverseIterator</a>(<span class="tok-builtin">@TypeOf</span>(slice)) {
    <span class="tok-kw">return</span> .{ .ptr = slice.ptr, .index = slice.len };
}

<span class="tok-kw">test</span> reverseIterator {
    {
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(<span class="tok-str">&quot;abc&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-str">'c'</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-str">'b'</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-str">'a'</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">u8</span>, <span class="tok-null">null</span>), it.next());
    }
    {
        <span class="tok-kw">var</span> array = [<span class="tok-number">2</span>]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">7</span> };
        <span class="tok-kw">const</span> slice: []<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;array;
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(slice);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), it.next());

        it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(slice);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(*<span class="tok-kw">const</span> <span class="tok-type">i32</span> == <span class="tok-builtin">@TypeOf</span>(it.nextPtr().?));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), it.nextPtr().?.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), it.nextPtr().?.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">i32</span>, <span class="tok-null">null</span>), it.nextPtr());

        <span class="tok-kw">const</span> mut_slice: []<span class="tok-type">i32</span> = &amp;array;
        <span class="tok-kw">var</span> mut_it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(mut_slice);
        mut_it.nextPtr().?.* += <span class="tok-number">1</span>;
        mut_it.nextPtr().?.* += <span class="tok-number">2</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">2</span>]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">8</span> }, array);
    }
    {
        <span class="tok-kw">var</span> array = [<span class="tok-number">2</span>]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">7</span> };
        <span class="tok-kw">const</span> ptr_to_array: *<span class="tok-kw">const</span> [<span class="tok-number">2</span>]<span class="tok-type">i32</span> = &amp;array;
        <span class="tok-kw">var</span> it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(ptr_to_array);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), it.next());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), it.next());

        it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(ptr_to_array);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(*<span class="tok-kw">const</span> <span class="tok-type">i32</span> == <span class="tok-builtin">@TypeOf</span>(it.nextPtr().?));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">7</span>), it.nextPtr().?.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-number">3</span>), it.nextPtr().?.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?*<span class="tok-kw">const</span> <span class="tok-type">i32</span>, <span class="tok-null">null</span>), it.nextPtr());

        <span class="tok-kw">const</span> mut_ptr_to_array: *[<span class="tok-number">2</span>]<span class="tok-type">i32</span> = &amp;array;
        <span class="tok-kw">var</span> mut_it = <a href="std.mem.html#std.mem.reverseIterator">reverseIterator</a>(mut_ptr_to_array);
        mut_it.nextPtr().?.* += <span class="tok-number">1</span>;
        mut_it.nextPtr().?.* += <span class="tok-number">2</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>([<span class="tok-number">2</span>]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">8</span> }, array);
    }
}

<span class="tok-comment">/// In-place rotation of the values in an array ([0 1 2 3] becomes [1 2 3 0] if we rotate by 1)</span>
<span class="tok-comment">/// Assumes 0 &lt;= amount &lt;= items.len</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rotate</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, items: []T, amount: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <a href="std.mem.html#std.mem.reverse">reverse</a>(T, items[<span class="tok-number">0</span>..amount]);
    <a href="std.mem.html#std.mem.reverse">reverse</a>(T, items[amount..]);
    <a href="std.mem.html#std.mem.reverse">reverse</a>(T, items);
}

<span class="tok-kw">test</span> rotate {
    <span class="tok-kw">var</span> arr = [_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span> };
    <a href="std.mem.html#std.mem.rotate">rotate</a>(<span class="tok-type">i32</span>, arr[<span class="tok-number">0</span>..], <span class="tok-number">2</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">i32</span>, &amp;arr, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span> }));
}

<span class="tok-comment">/// Replace needle with replacement as many times as possible, writing to an output buffer which is assumed to be of</span>
<span class="tok-comment">/// appropriate size. Use replacementSize to calculate an appropriate buffer size.</span>
<span class="tok-comment">/// The needle must not be empty.</span>
<span class="tok-comment">/// Returns the number of replacements made.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replace</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T, output: []T) <span class="tok-type">usize</span> {<span class="tok-comment">
    // Empty needle will loop until output buffer overflows.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(needle.len &gt; <span class="tok-number">0</span>);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> slide: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> replacements: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (slide &lt; input.len) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(T, input[slide..], needle)) {
            <span class="tok-builtin">@memcpy</span>(output[i..][<span class="tok-number">0</span>..replacement.len], replacement);
            i += replacement.len;
            slide += needle.len;
            replacements += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> {
            output[i] = input[slide];
            i += <span class="tok-number">1</span>;
            slide += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> replacements;
}

<span class="tok-kw">test</span> replace {
    <span class="tok-kw">var</span> output: [<span class="tok-number">29</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;All your base are belong to us&quot;</span>, <span class="tok-str">&quot;base&quot;</span>, <span class="tok-str">&quot;Zig&quot;</span>, output[<span class="tok-number">0</span>..]);
    <span class="tok-kw">var</span> expected: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;All your Zig are belong to us&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);

    replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Favor reading code over writing code.&quot;</span>, <span class="tok-str">&quot;code&quot;</span>, <span class="tok-str">&quot;&quot;</span>, output[<span class="tok-number">0</span>..]);
    expected = <span class="tok-str">&quot;Favor reading  over writing .&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);<span class="tok-comment">

    // Empty needle is not allowed but input may be empty.
    </span>replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;x&quot;</span>, <span class="tok-str">&quot;y&quot;</span>, output[<span class="tok-number">0</span>..<span class="tok-number">0</span>]);
    expected = <span class="tok-str">&quot;&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);<span class="tok-comment">

    // Adjacent replacements.

    </span>replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;\\n\\n&quot;</span>, <span class="tok-str">&quot;\\n&quot;</span>, <span class="tok-str">&quot;\n&quot;</span>, output[<span class="tok-number">0</span>..]);
    expected = <span class="tok-str">&quot;\n\n&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);

    replacements = <a href="std.mem.html#std.mem.replace">replace</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abbba&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;cd&quot;</span>, output[<span class="tok-number">0</span>..]);
    expected = <span class="tok-str">&quot;acdcdcda&quot;</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(replacements == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, output[<span class="tok-number">0</span>..expected.len]);
}

<span class="tok-comment">/// Replace all occurrences of `match` with `replacement`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceScalar</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, match: T, replacement: T) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (slice) |*e| {
        <span class="tok-kw">if</span> (e.* == match)
            e.* = replacement;
    }
}

<span class="tok-comment">/// Collapse consecutive duplicate elements into one entry.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collapseRepeatsLen</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, elem: T) <span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> write_idx: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> read_idx: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (read_idx &lt; slice.len) : (read_idx += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (slice[read_idx - <span class="tok-number">1</span>] != elem <span class="tok-kw">or</span> slice[read_idx] != elem) {
            slice[write_idx] = slice[read_idx];
            write_idx += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> write_idx;
}

<span class="tok-comment">/// Collapse consecutive duplicate elements into one entry.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">collapseRepeats</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, slice: []T, elem: T) []T {
    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<a href="std.mem.html#std.mem.collapseRepeatsLen">collapseRepeatsLen</a>(T, slice, elem)];
}

<span class="tok-kw">fn</span> <span class="tok-fn">testCollapseRepeats</span>(str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, elem: <span class="tok-type">u8</span>, expected: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> mutable = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">dupe</a>(<span class="tok-type">u8</span>, str);
    <span class="tok-kw">defer</span> <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(mutable);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.collapseRepeats">collapseRepeats</a>(<span class="tok-type">u8</span>, mutable, elem), expected));
}
<span class="tok-kw">test</span> collapseRepeats {
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;/&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;//&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;/a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;//a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a/&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a/&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a//&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a/&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a/a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a/a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;a//a&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;a/a&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.mem.html#std.mem.testCollapseRepeats">testCollapseRepeats</a>(<span class="tok-str">&quot;//a///a////&quot;</span>, <span class="tok-str">'/'</span>, <span class="tok-str">&quot;/a/a/&quot;</span>);
}

<span class="tok-comment">/// Calculate the size needed in an output buffer to perform a replacement.</span>
<span class="tok-comment">/// The needle must not be empty.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replacementSize</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {<span class="tok-comment">
    // Empty needle will loop forever.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(needle.len &gt; <span class="tok-number">0</span>);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> size: <span class="tok-type">usize</span> = input.len;
    <span class="tok-kw">while</span> (i &lt; input.len) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(T, input[i..], needle)) {
            size = size - needle.len + replacement.len;
            i += needle.len;
        } <span class="tok-kw">else</span> {
            i += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">return</span> size;
}

<span class="tok-kw">test</span> replacementSize {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;All your base are belong to us&quot;</span>, <span class="tok-str">&quot;base&quot;</span>, <span class="tok-str">&quot;Zig&quot;</span>) == <span class="tok-number">29</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Favor reading code over writing code.&quot;</span>, <span class="tok-str">&quot;code&quot;</span>, <span class="tok-str">&quot;&quot;</span>) == <span class="tok-number">29</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;Only one obvious way to do things.&quot;</span>, <span class="tok-str">&quot;things.&quot;</span>, <span class="tok-str">&quot;things in Zig.&quot;</span>) == <span class="tok-number">41</span>);<span class="tok-comment">

    // Empty needle is not allowed but input may be empty.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;x&quot;</span>, <span class="tok-str">&quot;y&quot;</span>) == <span class="tok-number">0</span>);<span class="tok-comment">

    // Adjacent replacements.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;\\n\\n&quot;</span>, <span class="tok-str">&quot;\\n&quot;</span>, <span class="tok-str">&quot;\n&quot;</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;abbba&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;cd&quot;</span>) == <span class="tok-number">8</span>);
}

<span class="tok-comment">/// Perform a replacement on an allocated buffer of pre-determined size. Caller must free returned memory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceOwned</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, input: []<span class="tok-kw">const</span> T, needle: []<span class="tok-kw">const</span> T, replacement: []<span class="tok-kw">const</span> T) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![]T {
    <span class="tok-kw">const</span> output = <span class="tok-kw">try</span> allocator.alloc(T, <a href="std.mem.html#std.mem.replacementSize">replacementSize</a>(T, input, needle, replacement));
    _ = <a href="std.mem.html#std.mem.replace">replace</a>(T, input, needle, replacement, output);
    <span class="tok-kw">return</span> output;
}

<span class="tok-kw">test</span> replaceOwned {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;

    <span class="tok-kw">const</span> base_replace = <a href="std.mem.html#std.mem.replaceOwned">replaceOwned</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;All your base are belong to us&quot;</span>, <span class="tok-str">&quot;base&quot;</span>, <span class="tok-str">&quot;Zig&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;out of memory&quot;</span>);
    <span class="tok-kw">defer</span> gpa.free(base_replace);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, base_replace, <span class="tok-str">&quot;All your Zig are belong to us&quot;</span>));

    <span class="tok-kw">const</span> zen_replace = <a href="std.mem.html#std.mem.replaceOwned">replaceOwned</a>(<span class="tok-type">u8</span>, gpa, <span class="tok-str">&quot;Favor reading code over writing code.&quot;</span>, <span class="tok-str">&quot; code&quot;</span>, <span class="tok-str">&quot;&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;out of memory&quot;</span>);
    <span class="tok-kw">defer</span> gpa.free(zen_replace);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, zen_replace, <span class="tok-str">&quot;Favor reading over writing.&quot;</span>));
}

<span class="tok-comment">/// Converts a little-endian integer to host endianness.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">littleToNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; x,
        .big =&gt; <span class="tok-builtin">@byteSwap</span>(x),
    };
}

<span class="tok-comment">/// Converts a big-endian integer to host endianness.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigToNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; <span class="tok-builtin">@byteSwap</span>(x),
        .big =&gt; x,
    };
}

<span class="tok-comment">/// Converts an integer from specified endianness to host endianness.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toNative</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T, endianness_of_x: <a href="std.builtin.Endian.html">Endian</a>) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (endianness_of_x) {
        .little =&gt; <a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(T, x),
        .big =&gt; <a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(T, x),
    };
}

<span class="tok-comment">/// Converts an integer which has host endianness to the desired endianness.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeTo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T, desired_endianness: <a href="std.builtin.Endian.html">Endian</a>) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (desired_endianness) {
        .little =&gt; <a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(T, x),
        .big =&gt; <a href="std.mem.html#std.mem.nativeToBig">nativeToBig</a>(T, x),
    };
}

<span class="tok-comment">/// Converts an integer which has host endianness to little endian.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeToLittle</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; x,
        .big =&gt; <span class="tok-builtin">@byteSwap</span>(x),
    };
}

<span class="tok-comment">/// Converts an integer which has host endianness to big endian.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nativeToBig</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; <span class="tok-builtin">@byteSwap</span>(x),
        .big =&gt; x,
    };
}

<span class="tok-comment">/// Returns the number of elements that, if added to the given pointer, align it</span>
<span class="tok-comment">/// to a multiple of the given quantity, or `null` if one of the following</span>
<span class="tok-comment">/// conditions is met:</span>
<span class="tok-comment">/// - The aligned pointer would not fit the address space,</span>
<span class="tok-comment">/// - The delta required to align the pointer is not a multiple of the pointee's</span>
<span class="tok-comment">///   type.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignPointerOffset</span>(ptr: <span class="tok-kw">anytype</span>, align_to: <span class="tok-type">usize</span>) ?<span class="tok-type">usize</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html#std.mem.isValidAlign">isValidAlign</a>(align_to));

    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(ptr);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T);
    <span class="tok-kw">if</span> (info != .pointer <span class="tok-kw">or</span> info.pointer.size != .many)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected many item pointer, got &quot;</span> ++ <span class="tok-builtin">@typeName</span>(T));<span class="tok-comment">

    // Do nothing if the pointer is already well-aligned.
    </span><span class="tok-kw">if</span> (align_to &lt;= info.pointer.alignment)
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // Calculate the aligned base address with an eye out for overflow.
    </span><span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
    <span class="tok-kw">var</span> ov = <span class="tok-builtin">@addWithOverflow</span>(addr, align_to - <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    ov[<span class="tok-number">0</span>] &amp;= ~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, align_to - <span class="tok-number">1</span>);<span class="tok-comment">

    // The delta is expressed in terms of bytes, turn it into a number of child
    // type elements.
    </span><span class="tok-kw">const</span> delta = ov[<span class="tok-number">0</span>] - addr;
    <span class="tok-kw">const</span> pointee_size = <span class="tok-builtin">@sizeOf</span>(info.pointer.child);
    <span class="tok-kw">if</span> (delta % pointee_size != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> delta / pointee_size;
}

<span class="tok-comment">/// Aligns a given pointer value to a specified alignment factor.</span>
<span class="tok-comment">/// Returns an aligned pointer or null if one of the following conditions is</span>
<span class="tok-comment">/// met:</span>
<span class="tok-comment">/// - The aligned pointer would not fit the address space,</span>
<span class="tok-comment">/// - The delta required to align the pointer is not a multiple of the pointee's</span>
<span class="tok-comment">///   type.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignPointer</span>(ptr: <span class="tok-kw">anytype</span>, align_to: <span class="tok-type">usize</span>) ?<span class="tok-builtin">@TypeOf</span>(ptr) {
    <span class="tok-kw">const</span> adjust_off = <a href="std.mem.html#std.mem.alignPointerOffset">alignPointerOffset</a>(ptr, align_to) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // Avoid the use of ptrFromInt to avoid losing the pointer provenance info.
    </span><span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(ptr + adjust_off);
}

<span class="tok-kw">test</span> alignPointer {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">checkAlign</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, base: <span class="tok-type">usize</span>, align_to: <span class="tok-type">usize</span>, expected: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> ptr: T = <span class="tok-builtin">@ptrFromInt</span>(base);
            <span class="tok-kw">const</span> aligned = <a href="std.mem.html#std.mem.alignPointer">alignPointer</a>(ptr, align_to);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(expected, <span class="tok-builtin">@intFromPtr</span>(aligned));
        }
    };

    <span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-type">u8</span>, <span class="tok-number">0x123</span>, <span class="tok-number">0x200</span>, <span class="tok-number">0x200</span>);
    <span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-number">0x10</span>, <span class="tok-number">2</span>, <span class="tok-number">0x10</span>);
    <span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-type">u32</span>, <span class="tok-number">0x10</span>, <span class="tok-number">2</span>, <span class="tok-number">0x10</span>);
    <span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-type">u32</span>, <span class="tok-number">0x4</span>, <span class="tok-number">16</span>, <span class="tok-number">0x10</span>);<span class="tok-comment">
    // Misaligned.
    </span><span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">u32</span>, <span class="tok-number">0x3</span>, <span class="tok-number">2</span>, <span class="tok-number">0</span>);<span class="tok-comment">
    // Overflow.
    </span><span class="tok-kw">try</span> S.checkAlign([*]<span class="tok-type">u32</span>, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>) - <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">0</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">CopyPtrAttrs</span>(
    <span class="tok-kw">comptime</span> source: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> size: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.Pointer.html">Pointer</a>.<a href="std.builtin.Type.Pointer.Size.html">Size</a>,
    <span class="tok-kw">comptime</span> child: <span class="tok-type">type</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(source).pointer;
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .pointer = .{
            .size = size,
            .is_const = info.is_const,
            .is_volatile = info.is_volatile,
            .is_allowzero = info.is_allowzero,
            .alignment = info.alignment,
            .address_space = info.address_space,
            .child = child,
            .sentinel_ptr = <span class="tok-null">null</span>,
        },
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">AsBytesReturnType</span>(<span class="tok-kw">comptime</span> P: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> pointer = <span class="tok-builtin">@typeInfo</span>(P).pointer;
    <a href="std.debug.html#std.debug.assert">assert</a>(pointer.size == .one);
    <span class="tok-kw">const</span> size = <span class="tok-builtin">@sizeOf</span>(pointer.child);
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.CopyPtrAttrs">CopyPtrAttrs</a>(P, .one, [size]<span class="tok-type">u8</span>);
}

<span class="tok-comment">/// Given a pointer to a single item, returns a slice of the underlying bytes, preserving pointer attributes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asBytes</span>(ptr: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.AsBytesReturnType">AsBytesReturnType</a>(<span class="tok-builtin">@TypeOf</span>(ptr)) {
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr));
}

<span class="tok-kw">test</span> asBytes {
    <span class="tok-kw">const</span> deadbeef = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xDEADBEEF</span>);
    <span class="tok-kw">const</span> deadbeef_bytes = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xDE\xAD\xBE\xEF&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xEF\xBE\xAD\xDE&quot;</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;deadbeef), deadbeef_bytes));

    <span class="tok-kw">var</span> codeface = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xC0DEFACE</span>);
    <span class="tok-kw">for</span> (<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;codeface)) |*b|
        b.* = <span class="tok-number">0</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(codeface == <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u8</span>,
        c: <span class="tok-type">u8</span>,
        d: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> inst = S{
        .a = <span class="tok-number">0xBE</span>,
        .b = <span class="tok-number">0xEF</span>,
        .c = <span class="tok-number">0xDE</span>,
        .d = <span class="tok-number">0xA1</span>,
    };
    <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;inst), <span class="tok-str">&quot;\xBE\xEF\xDE\xA1&quot;</span>));
        },
        .big =&gt; {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;inst), <span class="tok-str">&quot;\xA1\xDE\xEF\xBE&quot;</span>));
        },
    }

    <span class="tok-kw">const</span> ZST = <span class="tok-kw">struct</span> {};
    <span class="tok-kw">const</span> zero = ZST{};
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;zero), <span class="tok-str">&quot;&quot;</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;asBytes preserves pointer attributes&quot;</span> {
    <span class="tok-kw">const</span> inArr: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">16</span>) = <span class="tok-number">0xDEADBEEF</span>;
    <span class="tok-kw">const</span> inPtr = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">16</span>) <span class="tok-kw">const</span> <span class="tok-kw">volatile</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(&amp;inArr));
    <span class="tok-kw">const</span> outSlice = <a href="std.mem.html#std.mem.asBytes">asBytes</a>(inPtr);

    <span class="tok-kw">const</span> in = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(inPtr)).pointer;
    <span class="tok-kw">const</span> out = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(outSlice)).pointer;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_const, out.is_const);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_volatile, out.is_volatile);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_allowzero, out.is_allowzero);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.alignment, out.alignment);
}

<span class="tok-comment">/// Given any value, returns a copy of its bytes in an array.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(value: <span class="tok-kw">anytype</span>) [<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value))]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value).*;
}

<span class="tok-kw">test</span> toBytes {
    <span class="tok-kw">var</span> my_bytes = <a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0x12345678</span>));
    <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;my_bytes, <span class="tok-str">&quot;\x12\x34\x56\x78&quot;</span>)),
        .little =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;my_bytes, <span class="tok-str">&quot;\x78\x56\x34\x12&quot;</span>)),
    }

    my_bytes[<span class="tok-number">0</span>] = <span class="tok-str">'\x99'</span>;
    <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;my_bytes, <span class="tok-str">&quot;\x99\x34\x56\x78&quot;</span>)),
        .little =&gt; <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;my_bytes, <span class="tok-str">&quot;\x99\x56\x34\x12&quot;</span>)),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">BytesAsValueReturnType</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> B: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.CopyPtrAttrs">CopyPtrAttrs</a>(B, .one, T);
}

<span class="tok-comment">/// Given a pointer to an array of bytes, returns a pointer to a value of the specified type</span>
<span class="tok-comment">/// backed by those bytes, preserving pointer attributes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesAsValue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.BytesAsValueReturnType">BytesAsValueReturnType</a>(T, <span class="tok-builtin">@TypeOf</span>(bytes)) {
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(bytes);
}

<span class="tok-kw">test</span> bytesAsValue {
    <span class="tok-kw">const</span> deadbeef = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xDEADBEEF</span>);
    <span class="tok-kw">const</span> deadbeef_bytes = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xDE\xAD\xBE\xEF&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xEF\xBE\xAD\xDE&quot;</span>,
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(deadbeef == <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(<span class="tok-type">u32</span>, deadbeef_bytes).*);

    <span class="tok-kw">var</span> codeface_bytes: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xC0\xDE\xFA\xCE&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xCE\xFA\xDE\xC0&quot;</span>,
    }.*;
    <span class="tok-kw">const</span> codeface = <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(<span class="tok-type">u32</span>, &amp;codeface_bytes);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(codeface.* == <span class="tok-number">0xC0DEFACE</span>);
    codeface.* = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (codeface_bytes) |b|
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(b == <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
        b: <span class="tok-type">u8</span>,
        c: <span class="tok-type">u8</span>,
        d: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> inst = S{
        .a = <span class="tok-number">0xBE</span>,
        .b = <span class="tok-number">0xEF</span>,
        .c = <span class="tok-number">0xDE</span>,
        .d = <span class="tok-number">0xA1</span>,
    };
    <span class="tok-kw">const</span> inst_bytes = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .little =&gt; <span class="tok-str">&quot;\xBE\xEF\xDE\xA1&quot;</span>,
        .big =&gt; <span class="tok-str">&quot;\xA1\xDE\xEF\xBE&quot;</span>,
    };
    <span class="tok-kw">const</span> inst2 = <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(S, inst_bytes);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(inst, inst2.*));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;bytesAsValue preserves pointer attributes&quot;</span> {
    <span class="tok-kw">const</span> inArr <span class="tok-kw">align</span>(<span class="tok-number">16</span>) = [<span class="tok-number">4</span>]<span class="tok-type">u8</span>{ <span class="tok-number">0xDE</span>, <span class="tok-number">0xAD</span>, <span class="tok-number">0xBE</span>, <span class="tok-number">0xEF</span> };
    <span class="tok-kw">const</span> inSlice = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">16</span>) <span class="tok-kw">const</span> <span class="tok-kw">volatile</span> [<span class="tok-number">4</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;inArr))[<span class="tok-number">0</span>..];
    <span class="tok-kw">const</span> outPtr = <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(<span class="tok-type">u32</span>, inSlice);

    <span class="tok-kw">const</span> in = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(inSlice)).pointer;
    <span class="tok-kw">const</span> out = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(outPtr)).pointer;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_const, out.is_const);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_volatile, out.is_volatile);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_allowzero, out.is_allowzero);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.alignment, out.alignment);
}

<span class="tok-comment">/// Given a pointer to an array of bytes, returns a value of the specified type backed by a</span>
<span class="tok-comment">/// copy of those bytes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesToValue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) T {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.bytesAsValue">bytesAsValue</a>(T, bytes).*;
}
<span class="tok-kw">test</span> bytesToValue {
    <span class="tok-kw">const</span> deadbeef_bytes = <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xDE\xAD\xBE\xEF&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xEF\xBE\xAD\xDE&quot;</span>,
    };

    <span class="tok-kw">const</span> deadbeef = <a href="std.mem.html#std.mem.bytesToValue">bytesToValue</a>(<span class="tok-type">u32</span>, deadbeef_bytes);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(deadbeef == <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xDEADBEEF</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">BytesAsSliceReturnType</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> bytesType: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.CopyPtrAttrs">CopyPtrAttrs</a>(bytesType, .slice, T);
}

<span class="tok-comment">/// Given a slice of bytes, returns a slice of the specified type</span>
<span class="tok-comment">/// backed by those bytes, preserving pointer attributes.</span>
<span class="tok-comment">/// If `T` is zero-bytes sized, the returned slice has a len of zero.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytesAsSlice</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, bytes: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.BytesAsSliceReturnType">BytesAsSliceReturnType</a>(T, <span class="tok-builtin">@TypeOf</span>(bytes)) {<span class="tok-comment">
    // let's not give an undefined pointer to @ptrCast
    // it may be equal to zero and fail a null check
    </span><span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> <span class="tok-builtin">@sizeOf</span>(T) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> &amp;[<span class="tok-number">0</span>]T{};
    }

    <span class="tok-kw">const</span> cast_target = <a href="std.mem.html#std.mem.CopyPtrAttrs">CopyPtrAttrs</a>(<span class="tok-builtin">@TypeOf</span>(bytes), .many, T);

    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(cast_target, <span class="tok-builtin">@ptrCast</span>(bytes))[<span class="tok-number">0</span>..<span class="tok-builtin">@divExact</span>(bytes.len, <span class="tok-builtin">@sizeOf</span>(T))];
}

<span class="tok-kw">test</span> bytesAsSlice {
    {
        <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0xDE</span>, <span class="tok-number">0xAD</span>, <span class="tok-number">0xBE</span>, <span class="tok-number">0xEF</span> };
        <span class="tok-kw">const</span> slice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u16</span>, bytes[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(slice.len == <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, slice[<span class="tok-number">0</span>]) == <span class="tok-number">0xDEAD</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, slice[<span class="tok-number">1</span>]) == <span class="tok-number">0xBEEF</span>);
    }
    {
        <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0xDE</span>, <span class="tok-number">0xAD</span>, <span class="tok-number">0xBE</span>, <span class="tok-number">0xEF</span> };
        <span class="tok-kw">var</span> runtime_zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        _ = &amp;runtime_zero;
        <span class="tok-kw">const</span> slice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u16</span>, bytes[runtime_zero..]);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(slice.len == <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, slice[<span class="tok-number">0</span>]) == <span class="tok-number">0xDEAD</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.bigToNative">bigToNative</a>(<span class="tok-type">u16</span>, slice[<span class="tok-number">1</span>]) == <span class="tok-number">0xBEEF</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;bytesAsSlice keeps pointer alignment&quot;</span> {
    {
        <span class="tok-kw">var</span> bytes = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x01</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x04</span> };
        <span class="tok-kw">const</span> numbers = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..]);
        <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@TypeOf</span>(numbers) == []<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@TypeOf</span>(bytes))) <span class="tok-type">u32</span>);
    }
    {
        <span class="tok-kw">var</span> bytes = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x01</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x04</span> };
        <span class="tok-kw">var</span> runtime_zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        _ = &amp;runtime_zero;
        <span class="tok-kw">const</span> numbers = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u32</span>, bytes[runtime_zero..]);
        <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@TypeOf</span>(numbers) == []<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@TypeOf</span>(bytes))) <span class="tok-type">u32</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;bytesAsSlice on a packed struct&quot;</span> {
    <span class="tok-kw">const</span> F = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">const</span> b: [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = .{<span class="tok-number">9</span>};
    <span class="tok-kw">const</span> f = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(F, &amp;b);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(f[<span class="tok-number">0</span>].a == <span class="tok-number">9</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;bytesAsSlice with specified alignment&quot;</span> {
    <span class="tok-kw">var</span> bytes <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u8</span>{
        <span class="tok-number">0x33</span>,
        <span class="tok-number">0x33</span>,
        <span class="tok-number">0x33</span>,
        <span class="tok-number">0x33</span>,
    };
    <span class="tok-kw">const</span> slice: []<span class="tok-type">u32</span> = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(slice[<span class="tok-number">0</span>] == <span class="tok-number">0x33333333</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;bytesAsSlice preserves pointer attributes&quot;</span> {
    <span class="tok-kw">const</span> inArr <span class="tok-kw">align</span>(<span class="tok-number">16</span>) = [<span class="tok-number">4</span>]<span class="tok-type">u8</span>{ <span class="tok-number">0xDE</span>, <span class="tok-number">0xAD</span>, <span class="tok-number">0xBE</span>, <span class="tok-number">0xEF</span> };
    <span class="tok-kw">const</span> inSlice = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">16</span>) <span class="tok-kw">const</span> <span class="tok-kw">volatile</span> [<span class="tok-number">4</span>]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;inArr))[<span class="tok-number">0</span>..];
    <span class="tok-kw">const</span> outSlice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u16</span>, inSlice);

    <span class="tok-kw">const</span> in = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(inSlice)).pointer;
    <span class="tok-kw">const</span> out = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(outSlice)).pointer;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_const, out.is_const);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_volatile, out.is_volatile);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_allowzero, out.is_allowzero);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.alignment, out.alignment);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;bytesAsSlice with zero-bit element type&quot;</span> {
    {
        <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u8</span>{};
        <span class="tok-kw">const</span> slice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">void</span>, &amp;bytes);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, slice.len);
    }
    {
        <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x01</span>, <span class="tok-number">0x02</span>, <span class="tok-number">0x03</span>, <span class="tok-number">0x04</span> };
        <span class="tok-kw">const</span> slice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u0</span>, &amp;bytes);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, slice.len);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">SliceAsBytesReturnType</span>(<span class="tok-kw">comptime</span> Slice: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.CopyPtrAttrs">CopyPtrAttrs</a>(Slice, .slice, <span class="tok-type">u8</span>);
}

<span class="tok-comment">/// Given a slice, returns a slice of the underlying bytes, preserving pointer attributes.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceAsBytes</span>(slice: <span class="tok-kw">anytype</span>) <a href="std.mem.html#std.mem.SliceAsBytesReturnType">SliceAsBytesReturnType</a>(<span class="tok-builtin">@TypeOf</span>(slice)) {
    <span class="tok-kw">const</span> Slice = <span class="tok-builtin">@TypeOf</span>(slice);<span class="tok-comment">

    // a slice of zero-bit values always occupies zero bytes
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(Slice)) == <span class="tok-number">0</span>) <span class="tok-kw">return</span> &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};<span class="tok-comment">

    // let's not give an undefined pointer to @ptrCast
    // it may be equal to zero and fail a null check
    </span><span class="tok-kw">if</span> (slice.len == <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.sentinel">sentinel</a>(Slice) == <span class="tok-null">null</span>) <span class="tok-kw">return</span> &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};

    <span class="tok-kw">const</span> cast_target = <a href="std.mem.html#std.mem.CopyPtrAttrs">CopyPtrAttrs</a>(Slice, .many, <span class="tok-type">u8</span>);

    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(cast_target, <span class="tok-builtin">@ptrCast</span>(slice))[<span class="tok-number">0</span> .. slice.len * <span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Elem">Elem</a>(Slice))];
}

<span class="tok-kw">test</span> sliceAsBytes {
    <span class="tok-kw">const</span> bytes = [_]<span class="tok-type">u16</span>{ <span class="tok-number">0xDEAD</span>, <span class="tok-number">0xBEEF</span> };
    <span class="tok-kw">const</span> slice = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(bytes[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(slice.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, slice, <span class="tok-kw">switch</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a>) {
        .big =&gt; <span class="tok-str">&quot;\xDE\xAD\xBE\xEF&quot;</span>,
        .little =&gt; <span class="tok-str">&quot;\xAD\xDE\xEF\xBE&quot;</span>,
    }));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sliceAsBytes with sentinel slice&quot;</span> {
    <span class="tok-kw">const</span> empty_string: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>;
    <span class="tok-kw">const</span> bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(empty_string);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(bytes.len == <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sliceAsBytes with zero-bit element type&quot;</span> {
    <span class="tok-kw">const</span> lots_of_nothing = [<span class="tok-number">1</span>]<span class="tok-type">void</span>{{}} ** <span class="tok-number">10_000</span>;
    <span class="tok-kw">const</span> bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(&amp;lots_of_nothing);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(bytes.len == <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sliceAsBytes packed struct at runtime and comptime&quot;</span> {
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u4</span>,
        b: <span class="tok-type">u4</span>,
    };
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> foo: Foo = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> slice = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(<span class="tok-builtin">@as</span>(*[<span class="tok-number">1</span>]Foo, &amp;foo)[<span class="tok-number">0</span>..<span class="tok-number">1</span>]);
            slice[<span class="tok-number">0</span>] = <span class="tok-number">0x13</span>;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(foo.a == <span class="tok-number">0x3</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(foo.b == <span class="tok-number">0x1</span>);
        }
    };
    <span class="tok-kw">try</span> S.doTheTest();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> S.doTheTest();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sliceAsBytes and bytesAsSlice back&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">i32</span>) == <span class="tok-number">4</span>);

    <span class="tok-kw">var</span> big_thing_array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> big_thing_slice: []<span class="tok-type">i32</span> = big_thing_array[<span class="tok-number">0</span>..];

    <span class="tok-kw">const</span> bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(big_thing_slice);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(bytes.len == <span class="tok-number">4</span> * <span class="tok-number">4</span>);

    bytes[<span class="tok-number">4</span>] = <span class="tok-number">0</span>;
    bytes[<span class="tok-number">5</span>] = <span class="tok-number">0</span>;
    bytes[<span class="tok-number">6</span>] = <span class="tok-number">0</span>;
    bytes[<span class="tok-number">7</span>] = <span class="tok-number">0</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(big_thing_slice[<span class="tok-number">1</span>] == <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> big_thing_again = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">i32</span>, bytes);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(big_thing_again[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);

    big_thing_again[<span class="tok-number">2</span>] = -<span class="tok-number">1</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(bytes[<span class="tok-number">8</span>] == <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(bytes[<span class="tok-number">9</span>] == <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(bytes[<span class="tok-number">10</span>] == <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(bytes[<span class="tok-number">11</span>] == <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u8</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sliceAsBytes preserves pointer attributes&quot;</span> {
    <span class="tok-kw">const</span> inArr <span class="tok-kw">align</span>(<span class="tok-number">16</span>) = [<span class="tok-number">2</span>]<span class="tok-type">u16</span>{ <span class="tok-number">0xDEAD</span>, <span class="tok-number">0xBEEF</span> };
    <span class="tok-kw">const</span> inSlice = <span class="tok-builtin">@as</span>(*<span class="tok-kw">align</span>(<span class="tok-number">16</span>) <span class="tok-kw">const</span> <span class="tok-kw">volatile</span> [<span class="tok-number">2</span>]<span class="tok-type">u16</span>, <span class="tok-builtin">@ptrCast</span>(&amp;inArr))[<span class="tok-number">0</span>..];
    <span class="tok-kw">const</span> outSlice = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(inSlice);

    <span class="tok-kw">const</span> in = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(inSlice)).pointer;
    <span class="tok-kw">const</span> out = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(outSlice)).pointer;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_const, out.is_const);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_volatile, out.is_volatile);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.is_allowzero, out.is_allowzero);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(in.alignment, out.alignment);
}

<span class="tok-comment">/// Round an address down to the next (or current) aligned address.</span>
<span class="tok-comment">/// Unlike `alignForward`, `alignment` can be any positive number, not just a power of 2.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForwardAnyAlign</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T {
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(T, alignment))
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignForward">alignForward</a>(T, addr, alignment);
    <a href="std.debug.html#std.debug.assert">assert</a>(alignment != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignBackwardAnyAlign">alignBackwardAnyAlign</a>(T, addr + (alignment - <span class="tok-number">1</span>), alignment);
}

<span class="tok-comment">/// Round an address up to the next (or current) aligned address.</span>
<span class="tok-comment">/// The alignment must be a power of 2 and greater than 0.</span>
<span class="tok-comment">/// Asserts that rounding up the address does not cause integer overflow.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForward</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(T, alignment));
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(T, addr + (alignment - <span class="tok-number">1</span>), alignment);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignForwardLog2</span>(addr: <span class="tok-type">usize</span>, log2_alignment: <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> alignment = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<span class="tok-type">usize</span>), <span class="tok-builtin">@intCast</span>(log2_alignment));
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, addr, alignment);
}

<span class="tok-comment">/// Force an evaluation of the expression; this tries to prevent</span>
<span class="tok-comment">/// the compiler from optimizing the computation away even if the</span>
<span class="tok-comment">/// result eventually gets discarded.</span><span class="tok-comment">
// TODO: use @declareSideEffect() when it is available - https://github.com/ziglang/zig/issues/6168
</span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doNotOptimizeAway</span>(val: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@inComptime</span>()) <span class="tok-kw">return</span>;

    <span class="tok-kw">const</span> max_gp_register_bits = <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">c_long</span>);
    <span class="tok-kw">const</span> t = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(val));
    <span class="tok-kw">switch</span> (t) {
        .<span class="tok-type">void</span>, .<span class="tok-null">null</span>, .<span class="tok-type">comptime_int</span>, .<span class="tok-type">comptime_float</span> =&gt; <span class="tok-kw">return</span>,
        .@&quot;enum&quot; =&gt; <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@intFromEnum</span>(val)),
        .<span class="tok-type">bool</span> =&gt; <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@intFromBool</span>(val)),
        .int =&gt; {
            <span class="tok-kw">const</span> bits = t.int.bits;
            <span class="tok-kw">if</span> (bits &lt;= max_gp_register_bits <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> != .stage2_c) {
                <span class="tok-kw">const</span> val2 = <span class="tok-builtin">@as</span>(
                    <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(t.int.signedness, <span class="tok-builtin">@max</span>(<span class="tok-number">8</span>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwoAssert">ceilPowerOfTwoAssert</a>(<span class="tok-type">u16</span>, bits))),
                    val,
                );
                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;&quot;</span>
                    :
                    : [val2] <span class="tok-str">&quot;r&quot;</span> (val2),
                );
            } <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(&amp;val);
        },
        .float =&gt; {
            <span class="tok-kw">if</span> ((t.float.bits == <span class="tok-number">32</span> <span class="tok-kw">or</span> t.float.bits == <span class="tok-number">64</span>) <span class="tok-kw">and</span> <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> != .stage2_c) {
                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;&quot;</span>
                    :
                    : [val] <span class="tok-str">&quot;rm&quot;</span> (val),
                );
            } <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(&amp;val);
        },
        .pointer =&gt; {
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) {
                <a href="std.mem.html#std.mem.doNotOptimizeAwayC">doNotOptimizeAwayC</a>(val);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;&quot;</span>
                    :
                    : [val] <span class="tok-str">&quot;m&quot;</span> (val),
                    : <span class="tok-str">&quot;memory&quot;</span>
                );
            }
        },
        .array =&gt; {
            <span class="tok-kw">if</span> (t.array.len * <span class="tok-builtin">@sizeOf</span>(t.array.child) &lt;= <span class="tok-number">64</span>) {
                <span class="tok-kw">for</span> (val) |v| <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(v);
            } <span class="tok-kw">else</span> <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(&amp;val);
        },
        <span class="tok-kw">else</span> =&gt; <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(&amp;val),
    }
}

<span class="tok-comment">/// .stage2_c doesn't support asm blocks yet, so use volatile stores instead</span>
<span class="tok-kw">var</span> deopt_target: <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) <span class="tok-type">u8</span> <span class="tok-kw">else</span> <span class="tok-type">void</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">doNotOptimizeAwayC</span>(ptr: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> dest = <span class="tok-builtin">@as</span>(*<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;<a href="std.mem.html#std.mem.deopt_target">deopt_target</a>));
    <span class="tok-kw">for</span> (<a href="std.mem.html#std.mem.asBytes">asBytes</a>(ptr)) |b| {
        dest.* = b;
    }
    dest.* = <span class="tok-number">0</span>;
}

<span class="tok-kw">test</span> doNotOptimizeAway {
    <span class="tok-kw">comptime</span> <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-str">&quot;test&quot;</span>);

    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-null">null</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-null">true</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-number">0</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-number">0.0</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u13</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u37</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u96</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u200</span>, <span class="tok-number">0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">0.0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">0.0</span>));
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">4</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">100</span>);
    <a href="std.mem.html#std.mem.doNotOptimizeAway">doNotOptimizeAway</a>(<span class="tok-builtin">@as</span>(<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>, .little));
}

<span class="tok-kw">test</span> alignForward {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span>) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>) == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">8</span>, <span class="tok-number">8</span>) == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">9</span>, <span class="tok-number">8</span>) == <span class="tok-number">16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">15</span>, <span class="tok-number">8</span>) == <span class="tok-number">16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">16</span>, <span class="tok-number">8</span>) == <span class="tok-number">16</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, <span class="tok-number">17</span>, <span class="tok-number">8</span>) == <span class="tok-number">24</span>);
}

<span class="tok-comment">/// Round an address down to the previous (or current) aligned address.</span>
<span class="tok-comment">/// Unlike `alignBackward`, `alignment` can be any positive number, not just a power of 2.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignBackwardAnyAlign</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T {
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(T, alignment))
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(T, addr, alignment);
    <a href="std.debug.html#std.debug.assert">assert</a>(alignment != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> addr - <span class="tok-builtin">@mod</span>(addr, alignment);
}

<span class="tok-comment">/// Round an address down to the previous (or current) aligned address.</span>
<span class="tok-comment">/// The alignment must be a power of 2 and greater than 0.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignBackward</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(T, alignment));<span class="tok-comment">
    // 000010000 // example alignment
    // 000001111 // subtract 1
    // 111110000 // binary not
    </span><span class="tok-kw">return</span> addr &amp; ~(alignment - <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Returns whether `alignment` is a valid alignment, meaning it is</span>
<span class="tok-comment">/// a positive power of 2.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidAlign</span>(alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.isValidAlignGeneric">isValidAlignGeneric</a>(<span class="tok-type">usize</span>, alignment);
}

<span class="tok-comment">/// Returns whether `alignment` is a valid alignment, meaning it is</span>
<span class="tok-comment">/// a positive power of 2.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isValidAlignGeneric</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, alignment: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> alignment &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(alignment);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedAnyAlign</span>(i: <span class="tok-type">usize</span>, alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.isValidAlign">isValidAlign</a>(alignment))
        <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.isAligned">isAligned</a>(i, alignment);
    <a href="std.debug.html#std.debug.assert">assert</a>(alignment != <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> <span class="tok-number">0</span> == <span class="tok-builtin">@mod</span>(i, alignment);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedLog2</span>(addr: <span class="tok-type">usize</span>, log2_alignment: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@ctz</span>(addr) &gt;= log2_alignment;
}

<span class="tok-comment">/// Given an address and an alignment, return true if the address is a multiple of the alignment</span>
<span class="tok-comment">/// The alignment must be a power of 2 and greater than 0.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAligned</span>(addr: <span class="tok-type">usize</span>, alignment: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.isAlignedGeneric">isAlignedGeneric</a>(<span class="tok-type">u64</span>, addr, alignment);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAlignedGeneric</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, addr: T, alignment: T) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html#std.mem.alignBackward">alignBackward</a>(T, addr, alignment) == addr;
}

<span class="tok-kw">test</span> isAligned {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">0</span>, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">1</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">2</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">2</span>, <span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">2</span>, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">3</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">3</span>, <span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">3</span>, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">4</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">8</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html#std.mem.isAligned">isAligned</a>(<span class="tok-number">4</span>, <span class="tok-number">16</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;freeing empty string with null-terminated sentinel&quot;</span> {
    <span class="tok-kw">const</span> empty_string = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">dupeZ</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;&quot;</span>);
    <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(empty_string);
}

<span class="tok-comment">/// Returns a slice with the given new alignment,</span>
<span class="tok-comment">/// all other pointer attributes copied from `AttributeSource`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">AlignedSlice</span>(<span class="tok-kw">comptime</span> AttributeSource: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> new_alignment: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(AttributeSource).pointer;
    <span class="tok-kw">return</span> <span class="tok-builtin">@Type</span>(.{
        .pointer = .{
            .size = .slice,
            .is_const = info.is_const,
            .is_volatile = info.is_volatile,
            .is_allowzero = info.is_allowzero,
            .alignment = new_alignment,
            .address_space = info.address_space,
            .child = info.child,
            .sentinel_ptr = <span class="tok-null">null</span>,
        },
    });
}

<span class="tok-comment">/// Returns the largest slice in the given bytes that conforms to the new alignment,</span>
<span class="tok-comment">/// or `null` if the given bytes contain no conforming address.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignInBytes</span>(bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> new_alignment: <span class="tok-type">usize</span>) ?[]<span class="tok-kw">align</span>(new_alignment) <span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> begin_address = <span class="tok-builtin">@intFromPtr</span>(bytes.ptr);
    <span class="tok-kw">const</span> end_address = begin_address + bytes.len;

    <span class="tok-kw">const</span> begin_address_aligned = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.alignForward">alignForward</a>(<span class="tok-type">usize</span>, begin_address, new_alignment);
    <span class="tok-kw">const</span> new_length = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">usize</span>, end_address, begin_address_aligned) <span class="tok-kw">catch</span> |e| <span class="tok-kw">switch</span> (e) {
        <span class="tok-kw">error</span>.Overflow =&gt; <span class="tok-kw">return</span> <span class="tok-null">null</span>,
    };
    <span class="tok-kw">const</span> alignment_offset = begin_address_aligned - begin_address;
    <span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(bytes[alignment_offset .. alignment_offset + new_length]);
}

<span class="tok-comment">/// Returns the largest sub-slice within the given slice that conforms to the new alignment,</span>
<span class="tok-comment">/// or `null` if the given slice contains no conforming address.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alignInSlice</span>(slice: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> new_alignment: <span class="tok-type">usize</span>) ?<a href="std.mem.html#std.mem.AlignedSlice">AlignedSlice</a>(<span class="tok-builtin">@TypeOf</span>(slice), new_alignment) {
    <span class="tok-kw">const</span> bytes = <a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(slice);
    <span class="tok-kw">const</span> aligned_bytes = <a href="std.mem.html#std.mem.alignInBytes">alignInBytes</a>(bytes, new_alignment) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;

    <span class="tok-kw">const</span> Element = <span class="tok-builtin">@TypeOf</span>(slice[<span class="tok-number">0</span>]);
    <span class="tok-kw">const</span> slice_length_bytes = aligned_bytes.len - (aligned_bytes.len % <span class="tok-builtin">@sizeOf</span>(Element));
    <span class="tok-kw">const</span> aligned_slice = <a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(Element, aligned_bytes[<span class="tok-number">0</span>..slice_length_bytes]);
    <span class="tok-kw">return</span> <span class="tok-builtin">@alignCast</span>(aligned_slice);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;read/write(Var)PackedInt&quot;</span> {
    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>) {<span class="tok-comment">
        // This test generates too much code to execute on WASI.
        // LLVM backend fails with &quot;too many locals: locals exceed maximum&quot;
        </span>.wasm32, .wasm64 =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; {},
    }

    <span class="tok-kw">const</span> foreign_endian: <a href="std.builtin.Endian.html">Endian</a> = <span class="tok-kw">if</span> (<a href="std.mem.html#std.mem.native_endian">native_endian</a> == .big) .little <span class="tok-kw">else</span> .big;
    <span class="tok-kw">const</span> expect = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>;
    <span class="tok-kw">var</span> prng = <a href="std.html">std</a>.<a href="std.Random.html">Random</a>.<a href="std.Random.Xoshiro256.html">DefaultPrng</a>.<a href="std.Random.Xoshiro256.html#std.Random.Xoshiro256.init">init</a>(<span class="tok-number">1234</span>);
    <span class="tok-kw">const</span> random = prng.random();

    <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">10_000</span>);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> ([_]<span class="tok-type">type</span>{ <span class="tok-type">u8</span>, <span class="tok-type">u16</span>, <span class="tok-type">u32</span>, <span class="tok-type">u128</span> }) |BackingType| {
        <span class="tok-kw">for</span> ([_]BackingType{
            <span class="tok-builtin">@as</span>(BackingType, <span class="tok-number">0</span>),<span class="tok-comment"> // all zeros
            </span>-%<span class="tok-builtin">@as</span>(BackingType, <span class="tok-number">1</span>),<span class="tok-comment"> // all ones
            </span>random.int(BackingType),<span class="tok-comment"> // random
            </span>random.int(BackingType),<span class="tok-comment"> // random
            </span>random.int(BackingType),<span class="tok-comment"> // random
        </span>}) |init_value| {
            <span class="tok-kw">const</span> uTs = [_]<span class="tok-type">type</span>{ <span class="tok-type">u1</span>, <span class="tok-type">u3</span>, <span class="tok-type">u7</span>, <span class="tok-type">u8</span>, <span class="tok-type">u9</span>, <span class="tok-type">u10</span>, <span class="tok-type">u15</span>, <span class="tok-type">u16</span>, <span class="tok-type">u86</span> };
            <span class="tok-kw">const</span> iTs = [_]<span class="tok-type">type</span>{ <span class="tok-type">i1</span>, <span class="tok-type">i3</span>, <span class="tok-type">i7</span>, <span class="tok-type">i8</span>, <span class="tok-type">i9</span>, <span class="tok-type">i10</span>, <span class="tok-type">i15</span>, <span class="tok-type">i16</span>, <span class="tok-type">i86</span> };
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (uTs ++ iTs) |PackedType| {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(PackedType) &gt; <span class="tok-builtin">@bitSizeOf</span>(BackingType))
                    <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> iPackedType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.signed, <span class="tok-builtin">@bitSizeOf</span>(PackedType));
                <span class="tok-kw">const</span> uPackedType = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(PackedType));
                <span class="tok-kw">const</span> Log2T = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(BackingType);

                <span class="tok-kw">const</span> offset_at_end = <span class="tok-builtin">@bitSizeOf</span>(BackingType) - <span class="tok-builtin">@bitSizeOf</span>(PackedType);
                <span class="tok-kw">for</span> ([_]<span class="tok-type">usize</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span>, <span class="tok-number">15</span>, <span class="tok-number">16</span>, <span class="tok-number">86</span>, offset_at_end }) |offset| {
                    <span class="tok-kw">if</span> (offset &gt; offset_at_end <span class="tok-kw">or</span> offset == <span class="tok-builtin">@bitSizeOf</span>(BackingType))
                        <span class="tok-kw">continue</span>;

                    <span class="tok-kw">for</span> ([_]PackedType{
                        ~<span class="tok-builtin">@as</span>(PackedType, <span class="tok-number">0</span>),<span class="tok-comment"> // all ones: -1 iN / maxInt uN
                        </span><span class="tok-builtin">@as</span>(PackedType, <span class="tok-number">0</span>),<span class="tok-comment"> // all zeros: 0 iN / 0 uN
                        </span><span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(iPackedType, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(iPackedType)))),<span class="tok-comment"> // maxInt iN
                        </span><span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(iPackedType, <a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(iPackedType)))),<span class="tok-comment"> // maxInt iN
                        </span>random.int(PackedType),<span class="tok-comment"> // random
                        </span>random.int(PackedType),<span class="tok-comment"> // random
                    </span>}) |write_value| {
                        {<span class="tok-comment"> // Fixed-size Read/Write (Native-endian)

                            // Initialize Value
                            </span><span class="tok-kw">var</span> value: BackingType = init_value;<span class="tok-comment">

                            // Read
                            </span><span class="tok-kw">const</span> read_value1 = <a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(PackedType, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, <a href="std.mem.html#std.mem.native_endian">native_endian</a>);
                            <span class="tok-kw">try</span> expect(read_value1 == <span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(uPackedType, <span class="tok-builtin">@truncate</span>(value &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset)))))));<span class="tok-comment">

                            // Write
                            </span><a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(PackedType, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, write_value, <a href="std.mem.html#std.mem.native_endian">native_endian</a>);
                            <span class="tok-kw">try</span> expect(write_value == <span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(uPackedType, <span class="tok-builtin">@truncate</span>(value &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset)))))));<span class="tok-comment">

                            // Read again
                            </span><span class="tok-kw">const</span> read_value2 = <a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(PackedType, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, <a href="std.mem.html#std.mem.native_endian">native_endian</a>);
                            <span class="tok-kw">try</span> expect(read_value2 == write_value);<span class="tok-comment">

                            // Verify bits outside of the target integer are unmodified
                            </span><span class="tok-kw">const</span> diff_bits = init_value ^ value;
                            <span class="tok-kw">if</span> (offset != offset_at_end)
                                <span class="tok-kw">try</span> expect(diff_bits &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset + <span class="tok-builtin">@bitSizeOf</span>(PackedType))) == <span class="tok-number">0</span>);
                            <span class="tok-kw">if</span> (offset != <span class="tok-number">0</span>)
                                <span class="tok-kw">try</span> expect(diff_bits &lt;&lt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@bitSizeOf</span>(BackingType) - offset)) == <span class="tok-number">0</span>);
                        }

                        {<span class="tok-comment"> // Fixed-size Read/Write (Foreign-endian)

                            // Initialize Value
                            </span><span class="tok-kw">var</span> value: BackingType = <span class="tok-builtin">@byteSwap</span>(init_value);<span class="tok-comment">

                            // Read
                            </span><span class="tok-kw">const</span> read_value1 = <a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(PackedType, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, foreign_endian);
                            <span class="tok-kw">try</span> expect(read_value1 == <span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(uPackedType, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@byteSwap</span>(value) &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset)))))));<span class="tok-comment">

                            // Write
                            </span><a href="std.mem.html#std.mem.writePackedInt">writePackedInt</a>(PackedType, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, write_value, foreign_endian);
                            <span class="tok-kw">try</span> expect(write_value == <span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(uPackedType, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@byteSwap</span>(value) &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset)))))));<span class="tok-comment">

                            // Read again
                            </span><span class="tok-kw">const</span> read_value2 = <a href="std.mem.html#std.mem.readPackedInt">readPackedInt</a>(PackedType, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, foreign_endian);
                            <span class="tok-kw">try</span> expect(read_value2 == write_value);<span class="tok-comment">

                            // Verify bits outside of the target integer are unmodified
                            </span><span class="tok-kw">const</span> diff_bits = init_value ^ <span class="tok-builtin">@byteSwap</span>(value);
                            <span class="tok-kw">if</span> (offset != offset_at_end)
                                <span class="tok-kw">try</span> expect(diff_bits &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset + <span class="tok-builtin">@bitSizeOf</span>(PackedType))) == <span class="tok-number">0</span>);
                            <span class="tok-kw">if</span> (offset != <span class="tok-number">0</span>)
                                <span class="tok-kw">try</span> expect(diff_bits &lt;&lt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@bitSizeOf</span>(BackingType) - offset)) == <span class="tok-number">0</span>);
                        }

                        <span class="tok-kw">const</span> signedness = <span class="tok-builtin">@typeInfo</span>(PackedType).int.signedness;
                        <span class="tok-kw">const</span> NextPowerOfTwoInt = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(signedness, <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.ceilPowerOfTwo">ceilPowerOfTwo</a>(<span class="tok-type">u16</span>, <span class="tok-builtin">@bitSizeOf</span>(PackedType)));
                        <span class="tok-kw">const</span> ui64 = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(signedness, <span class="tok-number">64</span>);
                        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> ([_]<span class="tok-type">type</span>{ PackedType, NextPowerOfTwoInt, ui64 }) |U| {
                            {<span class="tok-comment"> // Variable-size Read/Write (Native-endian)

                                </span><span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(U) &lt; <span class="tok-builtin">@bitSizeOf</span>(PackedType))
                                    <span class="tok-kw">continue</span>;<span class="tok-comment">

                                // Initialize Value
                                </span><span class="tok-kw">var</span> value: BackingType = init_value;<span class="tok-comment">

                                // Read
                                </span><span class="tok-kw">const</span> read_value1 = <a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(U, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, <span class="tok-builtin">@bitSizeOf</span>(PackedType), <a href="std.mem.html#std.mem.native_endian">native_endian</a>, signedness);
                                <span class="tok-kw">try</span> expect(read_value1 == <span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(uPackedType, <span class="tok-builtin">@truncate</span>(value &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset)))))));<span class="tok-comment">

                                // Write
                                </span><a href="std.mem.html#std.mem.writeVarPackedInt">writeVarPackedInt</a>(<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, <span class="tok-builtin">@bitSizeOf</span>(PackedType), <span class="tok-builtin">@as</span>(U, write_value), <a href="std.mem.html#std.mem.native_endian">native_endian</a>);
                                <span class="tok-kw">try</span> expect(write_value == <span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(uPackedType, <span class="tok-builtin">@truncate</span>(value &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset)))))));<span class="tok-comment">

                                // Read again
                                </span><span class="tok-kw">const</span> read_value2 = <a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(U, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, <span class="tok-builtin">@bitSizeOf</span>(PackedType), <a href="std.mem.html#std.mem.native_endian">native_endian</a>, signedness);
                                <span class="tok-kw">try</span> expect(read_value2 == write_value);<span class="tok-comment">

                                // Verify bits outside of the target integer are unmodified
                                </span><span class="tok-kw">const</span> diff_bits = init_value ^ value;
                                <span class="tok-kw">if</span> (offset != offset_at_end)
                                    <span class="tok-kw">try</span> expect(diff_bits &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset + <span class="tok-builtin">@bitSizeOf</span>(PackedType))) == <span class="tok-number">0</span>);
                                <span class="tok-kw">if</span> (offset != <span class="tok-number">0</span>)
                                    <span class="tok-kw">try</span> expect(diff_bits &lt;&lt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@bitSizeOf</span>(BackingType) - offset)) == <span class="tok-number">0</span>);
                            }

                            {<span class="tok-comment"> // Variable-size Read/Write (Foreign-endian)

                                </span><span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(U) &lt; <span class="tok-builtin">@bitSizeOf</span>(PackedType))
                                    <span class="tok-kw">continue</span>;<span class="tok-comment">

                                // Initialize Value
                                </span><span class="tok-kw">var</span> value: BackingType = <span class="tok-builtin">@byteSwap</span>(init_value);<span class="tok-comment">

                                // Read
                                </span><span class="tok-kw">const</span> read_value1 = <a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(U, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, <span class="tok-builtin">@bitSizeOf</span>(PackedType), foreign_endian, signedness);
                                <span class="tok-kw">try</span> expect(read_value1 == <span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(uPackedType, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@byteSwap</span>(value) &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset)))))));<span class="tok-comment">

                                // Write
                                </span><a href="std.mem.html#std.mem.writeVarPackedInt">writeVarPackedInt</a>(<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, <span class="tok-builtin">@bitSizeOf</span>(PackedType), <span class="tok-builtin">@as</span>(U, write_value), foreign_endian);
                                <span class="tok-kw">try</span> expect(write_value == <span class="tok-builtin">@as</span>(PackedType, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(uPackedType, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@byteSwap</span>(value) &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset)))))));<span class="tok-comment">

                                // Read again
                                </span><span class="tok-kw">const</span> read_value2 = <a href="std.mem.html#std.mem.readVarPackedInt">readVarPackedInt</a>(U, <a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;value), offset, <span class="tok-builtin">@bitSizeOf</span>(PackedType), foreign_endian, signedness);
                                <span class="tok-kw">try</span> expect(read_value2 == write_value);<span class="tok-comment">

                                // Verify bits outside of the target integer are unmodified
                                </span><span class="tok-kw">const</span> diff_bits = init_value ^ <span class="tok-builtin">@byteSwap</span>(value);
                                <span class="tok-kw">if</span> (offset != offset_at_end)
                                    <span class="tok-kw">try</span> expect(diff_bits &gt;&gt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(offset + <span class="tok-builtin">@bitSizeOf</span>(PackedType))) == <span class="tok-number">0</span>);
                                <span class="tok-kw">if</span> (offset != <span class="tok-number">0</span>)
                                    <span class="tok-kw">try</span> expect(diff_bits &lt;&lt; <span class="tok-builtin">@as</span>(Log2T, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@bitSizeOf</span>(BackingType) - offset)) == <span class="tok-number">0</span>);
                            }
                        }
                    }
                }
            }
        }
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
