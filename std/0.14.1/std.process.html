<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.process.html" class="active">process</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.process" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.process</span><a href="#src.zig-std.process">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.process.Child.html">std.process.Child</a></li><li><a href="std.process.EnvMap.html">std.process.EnvMap</a></li><li><a href="std.process.ArgIteratorPosix.html">std.process.ArgIteratorPosix</a></li><li><a href="std.process.ArgIteratorWasi.html">std.process.ArgIteratorWasi</a></li><li><a href="std.process.ArgIteratorWindows.html">std.process.ArgIteratorWindows</a></li><li><a href="std.process.ArgIteratorGeneralOptions.html">std.process.ArgIteratorGeneralOptions</a></li><li><a href="std.process.ArgIterator.html">std.process.ArgIterator</a></li><li><a href="std.process.UserInfo.html">std.process.UserInfo</a></li><li><a href="std.process.CreateEnvironOptions.html">std.process.CreateEnvironOptions</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.process.ArgIteratorGeneral" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArgIteratorGeneral</span><a href="#src.zig-std.process.ArgIteratorGeneral">[src]</a></h2><div class="tldDocs"><p>A general Iterator to parse a string into a set of arguments</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.process.ArgIteratorGeneralOptions.html">ArgIteratorGeneralOptions</a></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.process.ArgIteratorGeneral" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArgIteratorGeneral</span><a href="#src.zig-std.process.ArgIteratorGeneral">[src]</a></h3></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>cmd_line: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>free_cmd_line_on_deinit: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>Should the cmd_line field be free'd (using the allocator) on deinit()?</p>
</div></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre><div class="fieldDocs"><p>buffer MUST be long enough to hold the cmd_line plus a null terminator.
buffer will we free'd (using the allocator) on deinit()</p>
</div></div><div><pre><code>start: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div><div><pre><code>end: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectErrSets"><h3 class="sectionHeader">Error Sets</h3><div class="listErrSets"><div class="decl"><h3 id="std.process.ArgIteratorGeneral.InitError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">InitError</span><a href="#src.zig-std.process.ArgIteratorGeneral.InitError">[src]</a></h3><div class="sectFnErrors"><h4 class="sectionHeader">Errors</h4><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory</dt></div></dl></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.process.ArgIteratorGeneral.InitError">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InitError = <span class="tok-kw">error</span>{OutOfMemory}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.process.ArgIteratorGeneral.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.process.ArgIteratorGeneral.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ArgIteratorGeneral.InitError">InitError</a>!<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a></code></pre></div><div class="tldDocs"><p>cmd_line_utf8 MUST remain valid and constant while using this instance</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.process.ArgIteratorGeneral.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ArgIteratorGeneral.InitError">InitError</a>!<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a> {
    <span class="tok-kw">const</span> buffer = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, cmd_line_utf8.len + <span class="tok-number">1</span>);
    <span class="tok-kw">errdefer</span> allocator.free(buffer);

    <span class="tok-kw">return</span> <a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>{
        .allocator = allocator,
        .cmd_line = cmd_line_utf8,
        .free_cmd_line_on_deinit = <span class="tok-null">false</span>,
        .buffer = buffer,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.process.ArgIteratorGeneral.initTakeOwnership" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initTakeOwnership</span><a href="#src.zig-std.process.ArgIteratorGeneral.initTakeOwnership">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initTakeOwnership</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ArgIteratorGeneral.InitError">InitError</a>!<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a></code></pre></div><div class="tldDocs"><p>cmd_line_utf8 will be free'd (with the allocator) on deinit()</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.process.ArgIteratorGeneral.initTakeOwnership">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initTakeOwnership</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ArgIteratorGeneral.InitError">InitError</a>!<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a> {
    <span class="tok-kw">const</span> buffer = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, cmd_line_utf8.len + <span class="tok-number">1</span>);
    <span class="tok-kw">errdefer</span> allocator.free(buffer);

    <span class="tok-kw">return</span> <a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>{
        .allocator = allocator,
        .cmd_line = cmd_line_utf8,
        .free_cmd_line_on_deinit = <span class="tok-null">true</span>,
        .buffer = buffer,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.process.ArgIteratorGeneral.skip" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">skip</span><a href="#src.zig-std.process.ArgIteratorGeneral.skip">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.process.ArgIteratorGeneral.skip">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (!self.skipWhitespace()) {
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">var</span> backslash_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> in_quote = <span class="tok-null">false</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> character = <span class="tok-kw">if</span> (self.index != self.cmd_line.len) self.cmd_line[self.index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">switch</span> (character) {
            <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
            <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\''</span> =&gt; {
                <span class="tok-kw">if</span> (!options.single_quotes <span class="tok-kw">and</span> character == <span class="tok-str">'\''</span>) {
                    backslash_count = <span class="tok-number">0</span>;
                    <span class="tok-kw">continue</span>;
                }
                <span class="tok-kw">const</span> quote_is_real = backslash_count % <span class="tok-number">2</span> == <span class="tok-number">0</span>;
                <span class="tok-kw">if</span> (quote_is_real) {
                    in_quote = !in_quote;
                }
            },
            <span class="tok-str">'\\'</span> =&gt; {
                backslash_count += <span class="tok-number">1</span>;
            },
            <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span> =&gt; {
                <span class="tok-kw">if</span> (!in_quote) {
                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                }
                backslash_count = <span class="tok-number">0</span>;
            },
            <span class="tok-kw">else</span> =&gt; {
                backslash_count = <span class="tok-number">0</span>;
                <span class="tok-kw">continue</span>;
            },
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.process.ArgIteratorGeneral.next" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">next</span><a href="#src.zig-std.process.ArgIteratorGeneral.next">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Returns a slice of the internal buffer that contains the next argument.
Returns null when it reaches the end.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.process.ArgIteratorGeneral.next">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (!self.skipWhitespace()) {
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">var</span> backslash_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> in_quote = <span class="tok-null">false</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> character = <span class="tok-kw">if</span> (self.index != self.cmd_line.len) self.cmd_line[self.index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
        <span class="tok-kw">switch</span> (character) {
            <span class="tok-number">0</span> =&gt; {
                self.emitBackslashes(backslash_count);
                self.buffer[self.end] = <span class="tok-number">0</span>;
                <span class="tok-kw">const</span> token = self.buffer[self.start..self.end :<span class="tok-number">0</span>];
                self.end += <span class="tok-number">1</span>;
                self.start = self.end;
                <span class="tok-kw">return</span> token;
            },
            <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\''</span> =&gt; {
                <span class="tok-kw">if</span> (!options.single_quotes <span class="tok-kw">and</span> character == <span class="tok-str">'\''</span>) {
                    self.emitBackslashes(backslash_count);
                    backslash_count = <span class="tok-number">0</span>;
                    self.emitCharacter(character);
                    <span class="tok-kw">continue</span>;
                }
                <span class="tok-kw">const</span> quote_is_real = backslash_count % <span class="tok-number">2</span> == <span class="tok-number">0</span>;
                self.emitBackslashes(backslash_count / <span class="tok-number">2</span>);
                backslash_count = <span class="tok-number">0</span>;

                <span class="tok-kw">if</span> (quote_is_real) {
                    in_quote = !in_quote;
                } <span class="tok-kw">else</span> {
                    self.emitCharacter(<span class="tok-str">'&quot;'</span>);
                }
            },
            <span class="tok-str">'\\'</span> =&gt; {
                backslash_count += <span class="tok-number">1</span>;
            },
            <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span> =&gt; {
                self.emitBackslashes(backslash_count);
                backslash_count = <span class="tok-number">0</span>;
                <span class="tok-kw">if</span> (in_quote) {
                    self.emitCharacter(character);
                } <span class="tok-kw">else</span> {
                    self.buffer[self.end] = <span class="tok-number">0</span>;
                    <span class="tok-kw">const</span> token = self.buffer[self.start..self.end :<span class="tok-number">0</span>];
                    self.end += <span class="tok-number">1</span>;
                    self.start = self.end;
                    <span class="tok-kw">return</span> token;
                }
            },
            <span class="tok-kw">else</span> =&gt; {
                self.emitBackslashes(backslash_count);
                backslash_count = <span class="tok-number">0</span>;
                self.emitCharacter(character);
            },
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.process.ArgIteratorGeneral.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.process.ArgIteratorGeneral.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Call to free the internal buffer of the iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.process.ArgIteratorGeneral.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">void</span> {
    self.allocator.free(self.buffer);

    <span class="tok-kw">if</span> (self.free_cmd_line_on_deinit) {
        self.allocator.free(self.cmd_line);
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.ArgIteratorGeneral">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArgIteratorGeneral</span>(<span class="tok-kw">comptime</span> options: <a href="std.process.ArgIteratorGeneralOptions.html">ArgIteratorGeneralOptions</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        cmd_line: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

        <span class="tok-comment">/// Should the cmd_line field be free'd (using the allocator) on deinit()?</span>
        free_cmd_line_on_deinit: <span class="tok-type">bool</span>,

        <span class="tok-comment">/// buffer MUST be long enough to hold the cmd_line plus a null terminator.</span>
        <span class="tok-comment">/// buffer will we free'd (using the allocator) on deinit()</span>
        buffer: []<span class="tok-type">u8</span>,
        start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        end: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InitError = <span class="tok-kw">error</span>{OutOfMemory};

        <span class="tok-comment">/// cmd_line_utf8 MUST remain valid and constant while using this instance</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ArgIteratorGeneral.InitError">InitError</a>!<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a> {
            <span class="tok-kw">const</span> buffer = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, cmd_line_utf8.len + <span class="tok-number">1</span>);
            <span class="tok-kw">errdefer</span> allocator.free(buffer);

            <span class="tok-kw">return</span> <a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>{
                .allocator = allocator,
                .cmd_line = cmd_line_utf8,
                .free_cmd_line_on_deinit = <span class="tok-null">false</span>,
                .buffer = buffer,
            };
        }

        <span class="tok-comment">/// cmd_line_utf8 will be free'd (with the allocator) on deinit()</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initTakeOwnership</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ArgIteratorGeneral.InitError">InitError</a>!<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a> {
            <span class="tok-kw">const</span> buffer = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, cmd_line_utf8.len + <span class="tok-number">1</span>);
            <span class="tok-kw">errdefer</span> allocator.free(buffer);

            <span class="tok-kw">return</span> <a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>{
                .allocator = allocator,
                .cmd_line = cmd_line_utf8,
                .free_cmd_line_on_deinit = <span class="tok-null">true</span>,
                .buffer = buffer,
            };
        }<span class="tok-comment">

        // Skips over whitespace in the cmd_line.
        // Returns false if the terminating sentinel is reached, true otherwise.
        // Also skips over comments (if supported).
        </span><span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespace</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> character = <span class="tok-kw">if</span> (self.index != self.cmd_line.len) self.cmd_line[self.index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                <span class="tok-kw">switch</span> (character) {
                    <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">continue</span>,
                    <span class="tok-str">'#'</span> =&gt; {
                        <span class="tok-kw">if</span> (options.comments) {
                            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                                <span class="tok-kw">switch</span> (self.cmd_line[self.index]) {
                                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">break</span>,
                                    <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                                }
                            }
                            <span class="tok-kw">continue</span>;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">break</span>;
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (!self.skipWhitespace()) {
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }

            <span class="tok-kw">var</span> backslash_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> in_quote = <span class="tok-null">false</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> character = <span class="tok-kw">if</span> (self.index != self.cmd_line.len) self.cmd_line[self.index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                <span class="tok-kw">switch</span> (character) {
                    <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
                    <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\''</span> =&gt; {
                        <span class="tok-kw">if</span> (!options.single_quotes <span class="tok-kw">and</span> character == <span class="tok-str">'\''</span>) {
                            backslash_count = <span class="tok-number">0</span>;
                            <span class="tok-kw">continue</span>;
                        }
                        <span class="tok-kw">const</span> quote_is_real = backslash_count % <span class="tok-number">2</span> == <span class="tok-number">0</span>;
                        <span class="tok-kw">if</span> (quote_is_real) {
                            in_quote = !in_quote;
                        }
                    },
                    <span class="tok-str">'\\'</span> =&gt; {
                        backslash_count += <span class="tok-number">1</span>;
                    },
                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span> =&gt; {
                        <span class="tok-kw">if</span> (!in_quote) {
                            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                        }
                        backslash_count = <span class="tok-number">0</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        backslash_count = <span class="tok-number">0</span>;
                        <span class="tok-kw">continue</span>;
                    },
                }
            }
        }

        <span class="tok-comment">/// Returns a slice of the internal buffer that contains the next argument.</span>
        <span class="tok-comment">/// Returns null when it reaches the end.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">if</span> (!self.skipWhitespace()) {
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }

            <span class="tok-kw">var</span> backslash_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> in_quote = <span class="tok-null">false</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> character = <span class="tok-kw">if</span> (self.index != self.cmd_line.len) self.cmd_line[self.index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                <span class="tok-kw">switch</span> (character) {
                    <span class="tok-number">0</span> =&gt; {
                        self.emitBackslashes(backslash_count);
                        self.buffer[self.end] = <span class="tok-number">0</span>;
                        <span class="tok-kw">const</span> token = self.buffer[self.start..self.end :<span class="tok-number">0</span>];
                        self.end += <span class="tok-number">1</span>;
                        self.start = self.end;
                        <span class="tok-kw">return</span> token;
                    },
                    <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\''</span> =&gt; {
                        <span class="tok-kw">if</span> (!options.single_quotes <span class="tok-kw">and</span> character == <span class="tok-str">'\''</span>) {
                            self.emitBackslashes(backslash_count);
                            backslash_count = <span class="tok-number">0</span>;
                            self.emitCharacter(character);
                            <span class="tok-kw">continue</span>;
                        }
                        <span class="tok-kw">const</span> quote_is_real = backslash_count % <span class="tok-number">2</span> == <span class="tok-number">0</span>;
                        self.emitBackslashes(backslash_count / <span class="tok-number">2</span>);
                        backslash_count = <span class="tok-number">0</span>;

                        <span class="tok-kw">if</span> (quote_is_real) {
                            in_quote = !in_quote;
                        } <span class="tok-kw">else</span> {
                            self.emitCharacter(<span class="tok-str">'&quot;'</span>);
                        }
                    },
                    <span class="tok-str">'\\'</span> =&gt; {
                        backslash_count += <span class="tok-number">1</span>;
                    },
                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span> =&gt; {
                        self.emitBackslashes(backslash_count);
                        backslash_count = <span class="tok-number">0</span>;
                        <span class="tok-kw">if</span> (in_quote) {
                            self.emitCharacter(character);
                        } <span class="tok-kw">else</span> {
                            self.buffer[self.end] = <span class="tok-number">0</span>;
                            <span class="tok-kw">const</span> token = self.buffer[self.start..self.end :<span class="tok-number">0</span>];
                            self.end += <span class="tok-number">1</span>;
                            self.start = self.end;
                            <span class="tok-kw">return</span> token;
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        self.emitBackslashes(backslash_count);
                        backslash_count = <span class="tok-number">0</span>;
                        self.emitCharacter(character);
                    },
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">emitBackslashes</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>, emit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (i &lt; emit_count) : (i += <span class="tok-number">1</span>) {
                self.emitCharacter(<span class="tok-str">'\\'</span>);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">emitCharacter</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>, char: <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.buffer[self.end] = char;
            self.end += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Call to free the internal buffer of the iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">void</span> {
            self.allocator.free(self.buffer);

            <span class="tok-kw">if</span> (self.free_cmd_line_on_deinit) {
                self.allocator.free(self.cmd_line);
            }
        }
    };
}</code></pre></details></div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.process.can_execv" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">can_execv</span><a href="#src.zig-std.process.can_execv">[src]</a></h2><div class="tldDocs"><p>Tells whether calling the <code><a href="std.process.html#std.process.execv">execv</a></code> or <code><a href="std.process.html#std.process.execve">execve</a></code> functions will be a compile error.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.can_execv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> can_execv = <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
    .windows, .haiku, .wasi =&gt; <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.can_spawn" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">can_spawn</span><a href="#src.zig-std.process.can_spawn">[src]</a></h2><div class="tldDocs"><p>Tells whether spawning child processes is supported (e.g. via Child)</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.can_spawn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> can_spawn = <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
    .wasi, .watchos, .tvos, .visionos =&gt; <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
}</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.posix.GetCwdError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetCwdError</span><a href="#src.zig-std.posix.GetCwdError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CurrentWorkingDirectoryUnlinked</dt></div><div><dt>NameTooLong</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.GetCwdError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetCwdError = <span class="tok-kw">error</span>{
    NameTooLong,
    CurrentWorkingDirectoryUnlinked,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.process.GetCwdAllocError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetCwdAllocError</span><a href="#src.zig-std.process.GetCwdAllocError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>CurrentWorkingDirectoryUnlinked <a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a></dt></div><div><dt>OutOfMemory <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.GetCwdAllocError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetCwdAllocError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a></code></pre></details></div></div><div class="decl"><h2 id="std.process.GetEnvMapError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetEnvMapError</span><a href="#src.zig-std.process.GetEnvMapError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>OutOfMemory</dt></div><div><dt>Unexpected</dt><dd><p>WASI-only. <code>environ_sizes_get</code> or <code>environ_get</code>
failed for an unexpected reason.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.GetEnvMapError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetEnvMapError = <span class="tok-kw">error</span>{
    OutOfMemory,
    <span class="tok-comment">/// WASI-only. `environ_sizes_get` or `environ_get`</span>
    <span class="tok-comment">/// failed for an unexpected reason.</span>
    Unexpected,
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.GetEnvVarOwnedError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetEnvVarOwnedError</span><a href="#src.zig-std.process.GetEnvVarOwnedError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>EnvironmentVariableNotFound</dt></div><div><dt>InvalidWtf8</dt><dd><p>On Windows, environment variable keys provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>OutOfMemory</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.GetEnvVarOwnedError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetEnvVarOwnedError = <span class="tok-kw">error</span>{
    OutOfMemory,
    EnvironmentVariableNotFound,

    <span class="tok-comment">/// On Windows, environment variable keys provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.ParseEnvVarIntError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ParseEnvVarIntError</span><a href="#src.zig-std.process.ParseEnvVarIntError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>EnvironmentVariableNotFound</dt></div><div><dt>InvalidCharacter <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The input was empty or contained an invalid character</p>
</dd></div><div><dt>Overflow <a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a></dt><dd><p>The result cannot fit in the type specified</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.ParseEnvVarIntError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseEnvVarIntError = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a> || <span class="tok-kw">error</span>{EnvironmentVariableNotFound}</code></pre></details></div></div><div class="decl"><h2 id="std.process.HasEnvVarError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">HasEnvVarError</span><a href="#src.zig-std.process.HasEnvVarError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>InvalidWtf8</dt><dd><p>On Windows, environment variable keys provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>OutOfMemory</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.HasEnvVarError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HasEnvVarError = <span class="tok-kw">error</span>{
    OutOfMemory,

    <span class="tok-comment">/// On Windows, environment variable keys provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.ExecvError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ExecvError</span><a href="#src.zig-std.process.ExecvError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>FileSystem <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>InvalidExe <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>IsDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>NotDir <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>OutOfMemory</dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ExecveError">ExecveError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.ExecvError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExecvError = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ExecveError">ExecveError</a> || <span class="tok-kw">error</span>{OutOfMemory}</code></pre></details></div></div><div class="decl"><h2 id="std.process.TotalSystemMemoryError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TotalSystemMemoryError</span><a href="#src.zig-std.process.TotalSystemMemoryError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>UnknownTotalSystemMemory</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.TotalSystemMemoryError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TotalSystemMemoryError = <span class="tok-kw">error</span>{
    UnknownTotalSystemMemory,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.posix.abort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">abort</span><a href="#src.zig-std.posix.abort">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span></code></pre></div><div class="tldDocs"><p>Causes abnormal process termination.
If linking against libc, this calls the abort() libc function. Otherwise
it raises SIGABRT followed by SIGKILL and finally lo
Invokes the current signal handler for SIGABRT, if any.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.abort">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);<span class="tok-comment">
    // MSVCRT abort() sometimes opens a popup window which is undesirable, so
    // even when linking libc on Windows we use our own abort implementation.
    // See https://github.com/ziglang/zig/issues/2071 for more details.
    </span><span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) {
            <span class="tok-builtin">@breakpoint</span>();
        }
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.ExitProcess">ExitProcess</a>(<span class="tok-number">3</span>);
    }
    <span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a> <span class="tok-kw">and</span> <a href="std.posix.html#std.posix.native_os">native_os</a> == .linux) {<span class="tok-comment">
        // The Linux man page says that the libc abort() function
        // &quot;first unblocks the SIGABRT signal&quot;, but this is a footgun
        // for user-defined signal handlers that want to restore some state in
        // some program sections and crash in others.
        // So, the user-installed SIGABRT handler is run, if present.
        </span><a href="std.posix.html#std.posix.raise">raise</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>) <span class="tok-kw">catch</span> {};<span class="tok-comment">

        // Disable all signal handlers.
        </span><a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">BLOCK</a>, &amp;<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.all_mask">all_mask</a>, <span class="tok-null">null</span>);<span class="tok-comment">

        // Only one thread may proceed to the rest of abort().
        </span><span class="tok-kw">if</span> (!<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
            <span class="tok-kw">const</span> global = <span class="tok-kw">struct</span> {
                <span class="tok-kw">var</span> abort_entered: <span class="tok-type">bool</span> = <span class="tok-null">false</span>;
            };
            <span class="tok-kw">while</span> (<span class="tok-builtin">@cmpxchgWeak</span>(<span class="tok-type">bool</span>, &amp;global.abort_entered, <span class="tok-null">false</span>, <span class="tok-null">true</span>, .seq_cst, .seq_cst)) |_| {}
        }<span class="tok-comment">

        // Install default handler so that the tkill below will terminate.
        </span><span class="tok-kw">const</span> sigact = <a href="std.posix.html#std.posix.Sigaction">Sigaction</a>{
            .handler = .{ .handler = <a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">DFL</a> },
            .mask = <a href="std.posix.html#std.posix.empty_sigset">empty_sigset</a>,
            .flags = <span class="tok-number">0</span>,
        };
        <a href="std.posix.html#std.posix.sigaction">sigaction</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>, &amp;sigact, <span class="tok-null">null</span>);

        _ = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.tkill">tkill</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.gettid">gettid</a>(), <a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a>);

        <span class="tok-kw">const</span> sigabrtmask: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.sigset_t">sigset_t</a> = [_]<span class="tok-type">u32</span>{<span class="tok-number">0</span>} ** <span class="tok-number">31</span> ++ [_]<span class="tok-type">u32</span>{<span class="tok-number">1</span> &lt;&lt; (<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">ABRT</a> - <span class="tok-number">1</span>)};
        <a href="std.posix.html#std.posix.sigprocmask">sigprocmask</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">UNBLOCK</a>, &amp;sigabrtmask, <span class="tok-null">null</span>);<span class="tok-comment">

        // Beyond this point should be unreachable.
        </span><span class="tok-builtin">@as</span>(*<span class="tok-kw">allowzero</span> <span class="tok-kw">volatile</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0</span>)).* = <span class="tok-number">0</span>;
        <a href="std.posix.html#std.posix.raise">raise</a>(<a href="std.posix.html#std.posix.SIG">SIG</a>.<a href="#">KILL</a>) <span class="tok-kw">catch</span> {};
        <a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">127</span>);<span class="tok-comment"> // Pid 1 might not be signalled in some containers.
    </span>}
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.native_os">native_os</a>) {
        .uefi, .wasi, .emscripten, .cuda, .amdhsa =&gt; <span class="tok-builtin">@trap</span>(),
        <span class="tok-kw">else</span> =&gt; <a href="std.posix.html#std.posix.system">system</a>.<a href="#">abort</a>(),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.exit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">exit</span><a href="#src.zig-std.posix.exit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>(status: <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span></code></pre></div><div class="tldDocs"><p>Exits all threads of the program with the specified status code.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>status: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.exit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>(status: <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.exit">exit</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.ExitProcess">ExitProcess</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi) {
        <a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.proc_exit">proc_exit</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .linux <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
        <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.exit_group">exit_group</a>(status);
    }
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .uefi) {
        <span class="tok-kw">const</span> uefi = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.uefi.html">uefi</a>;<span class="tok-comment">
        // exit() is only available if exitBootServices() has not been called yet.
        // This call to exit should not fail, so we don't care about its return value.
        </span><span class="tok-kw">if</span> (uefi.system_table.boot_services) |bs| {
            _ = bs.exit(uefi.handle, <span class="tok-builtin">@enumFromInt</span>(status), <span class="tok-number">0</span>, <span class="tok-null">null</span>);
        }<span class="tok-comment">
        // If we can't exit, reboot the system instead.
        </span>uefi.system_table.runtime_services.resetSystem(.reset_cold, <span class="tok-builtin">@enumFromInt</span>(status), <span class="tok-number">0</span>, <span class="tok-null">null</span>);
    }
    <a href="std.posix.html#std.posix.system">system</a>.<a href="#">exit</a>(status);
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.chdir" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chdir</span><a href="#src.zig-std.posix.chdir">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the current working directory of the calling process.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.chdir">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdir</span>(dir_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;WASI does not support os.chdir&quot;</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> wtf16_dir_path: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.checkWtf8ToWtf16LeOverflow">checkWtf8ToWtf16LeOverflow</a>(dir_path, &amp;wtf16_dir_path)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        }
        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;wtf16_dir_path, dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirW">chdirW</a>(wtf16_dir_path[<span class="tok-number">0</span>..len]);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> dir_path_c = <span class="tok-kw">try</span> <a href="std.posix.html#std.posix.toPosixPath">toPosixPath</a>(dir_path);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirZ">chdirZ</a>(&amp;dir_path_c);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.chdirZ" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chdirZ</span><a href="#src.zig-std.posix.chdirZ">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Same as <code><a href="std.posix.html#std.posix.chdir">chdir</a></code> except the parameter is null-terminated.
On Windows, <code>dir_path</code> should be encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On WASI, <code>dir_path</code> should be encoded as valid UTF-8.
On other platforms, <code>dir_path</code> is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.chdirZ">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chdirZ</span>(dir_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ChangeCurDirError">ChangeCurDirError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> dir_path_span = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dir_path);
        <span class="tok-kw">var</span> wtf16_dir_path: [<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.PATH_MAX_WIDE">PATH_MAX_WIDE</a>]<span class="tok-type">u16</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.checkWtf8ToWtf16LeOverflow">checkWtf8ToWtf16LeOverflow</a>(dir_path_span, &amp;wtf16_dir_path)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong;
        }
        <span class="tok-kw">const</span> len = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(&amp;wtf16_dir_path, dir_path_span);
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdirW">chdirW</a>(wtf16_dir_path[<span class="tok-number">0</span>..len]);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.chdir">chdir</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(dir_path));
    }
    <span class="tok-kw">switch</span> (<a href="std.posix.html#std.posix.errno">errno</a>(<a href="std.posix.html#std.posix.system">system</a>.<a href="#">chdir</a>(dir_path))) {
        .SUCCESS =&gt; <span class="tok-kw">return</span>,
        .ACCES =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
        .FAULT =&gt; <span class="tok-kw">unreachable</span>,
        .IO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileSystem,
        .LOOP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SymLinkLoop,
        .NAMETOOLONG =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NameTooLong,
        .NOENT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
        .NOTDIR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir,
        .ILSEQ =&gt; |err| <span class="tok-kw">if</span> (<a href="std.posix.html#std.posix.native_os">native_os</a> == .wasi)
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidUtf8
        <span class="tok-kw">else</span>
            <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.getCwd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getCwd</span><a href="#src.zig-std.process.getCwd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCwd</span>(out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>The result is a slice of <code>out_buffer</code>, from index <code>0</code>.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>out_buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.getCwd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCwd</span>(out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getcwd">getcwd</a>(out_buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.getCwdAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getCwdAlloc</span><a href="#src.zig-std.process.getCwdAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCwdAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Caller must free the returned memory.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> getCwdAlloc {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> cwd = <span class="tok-kw">try</span> <a href="std.process.html#std.process.getCwdAlloc">getCwdAlloc</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(cwd);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.getCwdAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCwdAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // The use of max_path_bytes here is just a heuristic: most paths will fit
    // in stack_buf, avoiding an extra allocation in the common case.
    </span><span class="tok-kw">var</span> stack_buf: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> heap_buf: ?[]<span class="tok-type">u8</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (heap_buf) |buf| allocator.free(buf);

    <span class="tok-kw">var</span> current_buf: []<span class="tok-type">u8</span> = &amp;stack_buf;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getcwd">getcwd</a>(current_buf)) |slice| {
            <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, slice);
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.NameTooLong =&gt; {<span class="tok-comment">
                // The path is too long to fit in stack_buf. Allocate geometrically
                // increasing buffers until we find one that works
                </span><span class="tok-kw">const</span> new_capacity = current_buf.len * <span class="tok-number">2</span>;
                <span class="tok-kw">if</span> (heap_buf) |buf| allocator.free(buf);
                current_buf = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, new_capacity);
                heap_buf = current_buf;
            },
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.getEnvMap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEnvMap</span><a href="#src.zig-std.process.getEnvMap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEnvMap</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.html#std.process.GetEnvMapError">GetEnvMapError</a>!<a href="std.process.EnvMap.html">EnvMap</a></code></pre></div><div class="tldDocs"><p>Returns a snapshot of the environment variables of the current process.
Any modifications to the resulting EnvMap will not be reflected in the environment, and
likewise, any future modifications to the environment will not be reflected in the EnvMap.
Caller owns resulting <code><a href="std.process.EnvMap.html">EnvMap</a></code> and should call its <code>deinit</code> fn when done.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> getEnvMap {
    <span class="tok-kw">var</span> env = <span class="tok-kw">try</span> <a href="std.process.html#std.process.getEnvMap">getEnvMap</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> env.deinit();
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.getEnvMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEnvMap</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.html#std.process.GetEnvMapError">GetEnvMapError</a>!<a href="std.process.EnvMap.html">EnvMap</a> {
    <span class="tok-kw">var</span> result = <a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.init">init</a>(allocator);
    <span class="tok-kw">errdefer</span> result.deinit();

    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> ptr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.Environment;

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> key_start = i;<span class="tok-comment">

            // There are some special environment variables that start with =,
            // so we need a special case to not treat = as a key/value separator
            // if it's the first character.
            // https://devblogs.microsoft.com/oldnewthing/20100506-00/?p=14133
            </span><span class="tok-kw">if</span> (ptr[key_start] == <span class="tok-str">'='</span>) i += <span class="tok-number">1</span>;

            <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> ptr[i] != <span class="tok-str">'='</span>) : (i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> key_w = ptr[key_start..i];
            <span class="tok-kw">const</span> key = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8Alloc">wtf16LeToWtf8Alloc</a>(allocator, key_w);
            <span class="tok-kw">errdefer</span> allocator.free(key);

            <span class="tok-kw">if</span> (ptr[i] == <span class="tok-str">'='</span>) i += <span class="tok-number">1</span>;

            <span class="tok-kw">const</span> value_start = i;
            <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> value_w = ptr[value_start..i];
            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8Alloc">wtf16LeToWtf8Alloc</a>(allocator, value_w);
            <span class="tok-kw">errdefer</span> allocator.free(value);

            i += <span class="tok-number">1</span>;<span class="tok-comment"> // skip over null byte

            </span><span class="tok-kw">try</span> result.putMove(key, value);
        }
        <span class="tok-kw">return</span> result;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> environ_count: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> environ_buf_size: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">const</span> environ_sizes_get_ret = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.environ_sizes_get">environ_sizes_get</a>(&amp;environ_count, &amp;environ_buf_size);
        <span class="tok-kw">if</span> (environ_sizes_get_ret != .SUCCESS) {
            <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(environ_sizes_get_ret);
        }

        <span class="tok-kw">if</span> (environ_count == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">const</span> environ = <span class="tok-kw">try</span> allocator.alloc([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, environ_count);
        <span class="tok-kw">defer</span> allocator.free(environ);
        <span class="tok-kw">const</span> environ_buf = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, environ_buf_size);
        <span class="tok-kw">defer</span> allocator.free(environ_buf);

        <span class="tok-kw">const</span> environ_get_ret = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.environ_get">environ_get</a>(environ.ptr, environ_buf.ptr);
        <span class="tok-kw">if</span> (environ_get_ret != .SUCCESS) {
            <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(environ_get_ret);
        }

        <span class="tok-kw">for</span> (environ) |env| {
            <span class="tok-kw">const</span> pair = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(env, <span class="tok-number">0</span>);
            <span class="tok-kw">var</span> parts = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, pair, <span class="tok-str">'='</span>);
            <span class="tok-kw">const</span> key = parts.first();
            <span class="tok-kw">const</span> value = parts.rest();
            <span class="tok-kw">try</span> result.put(key, value);
        }
        <span class="tok-kw">return</span> result;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> ptr = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.environ">environ</a>;
        <span class="tok-kw">while</span> (ptr[<span class="tok-number">0</span>]) |line| : (ptr += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> line_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (line[line_i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> line[line_i] != <span class="tok-str">'='</span>) : (line_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> key = line[<span class="tok-number">0</span>..line_i];

            <span class="tok-kw">var</span> end_i: <span class="tok-type">usize</span> = line_i;
            <span class="tok-kw">while</span> (line[end_i] != <span class="tok-number">0</span>) : (end_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> value = line[line_i + <span class="tok-number">1</span> .. end_i];

            <span class="tok-kw">try</span> result.put(key, value);
        }
        <span class="tok-kw">return</span> result;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.environ">environ</a>) |line| {
            <span class="tok-kw">var</span> line_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (line[line_i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> line[line_i] != <span class="tok-str">'='</span>) : (line_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> key = line[<span class="tok-number">0</span>..line_i];

            <span class="tok-kw">var</span> end_i: <span class="tok-type">usize</span> = line_i;
            <span class="tok-kw">while</span> (line[end_i] != <span class="tok-number">0</span>) : (end_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> value = line[line_i + <span class="tok-number">1</span> .. end_i];

            <span class="tok-kw">try</span> result.put(key, value);
        }
        <span class="tok-kw">return</span> result;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.getEnvVarOwned" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEnvVarOwned</span><a href="#src.zig-std.process.getEnvVarOwned">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEnvVarOwned</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.GetEnvVarOwnedError">GetEnvVarOwnedError</a>![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Caller must free returned memory.
On Windows, if <code>key</code> is not valid <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>,
then <code>error.InvalidWtf8</code> is returned.
On Windows, the value is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, the value is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> getEnvVarOwned {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
        <span class="tok-kw">error</span>.EnvironmentVariableNotFound,
        <a href="std.process.html#std.process.getEnvVarOwned">getEnvVarOwned</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;BADENV&quot;</span>),
    );
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.getEnvVarOwned">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEnvVarOwned</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.GetEnvVarOwnedError">GetEnvVarOwnedError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> result_w = blk: {
            <span class="tok-kw">var</span> stack_alloc = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-number">256</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u16</span>), allocator);
            <span class="tok-kw">const</span> stack_allocator = stack_alloc.get();
            <span class="tok-kw">const</span> key_w = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(stack_allocator, key);
            <span class="tok-kw">defer</span> stack_allocator.free(key_w);

            <span class="tok-kw">break</span> :blk <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        };<span class="tok-comment">
        // wtf16LeToWtf8Alloc can only fail with OutOfMemory
        </span><span class="tok-kw">return</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8Alloc">wtf16LeToWtf8Alloc</a>(allocator, result_w);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> envmap = <a href="std.process.html#std.process.getEnvMap">getEnvMap</a>(allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        <span class="tok-kw">defer</span> envmap.deinit();
        <span class="tok-kw">const</span> val = envmap.get(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, val);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> result = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, result);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.hasEnvVarConstant" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hasEnvVarConstant</span><a href="#src.zig-std.process.hasEnvVarConstant">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasEnvVarConstant</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>On Windows, <code>key</code> must be valid UTF-8.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> hasEnvVarConstant {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.process.html#std.process.hasEnvVarConstant">hasEnvVarConstant</a>(<span class="tok-str">&quot;BADENV&quot;</span>));
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.hasEnvVarConstant">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasEnvVarConstant</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">comptime</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(key);
        <span class="tok-kw">return</span> <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) != <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;hasEnvVarConstant is not supported for WASI without libc&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) != <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.hasNonEmptyEnvVarConstant" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hasNonEmptyEnvVarConstant</span><a href="#src.zig-std.process.hasNonEmptyEnvVarConstant">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasNonEmptyEnvVarConstant</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>On Windows, <code>key</code> must be valid UTF-8.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.hasNonEmptyEnvVarConstant">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasNonEmptyEnvVarConstant</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">comptime</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(key);
        <span class="tok-kw">const</span> value = <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;hasNonEmptyEnvVarConstant is not supported for WASI without libc&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> value = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.parseEnvVarInt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">parseEnvVarInt</span><a href="#src.zig-std.process.parseEnvVarInt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseEnvVarInt</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, base: <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ParseEnvVarIntError">ParseEnvVarIntError</a>!I</code></pre></div><div class="tldDocs"><p>Parses an environment variable as an integer.</p>
<p>Since the key is comptime-known, no allocation is needed.</p>
<p>On Windows, <code>key</code> must be valid UTF-8.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>I: <span class="tok-type">type</span></code></pre></div><div><pre><code>base: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.parseEnvVarInt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseEnvVarInt</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, base: <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ParseEnvVarIntError">ParseEnvVarIntError</a>!I {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(key);
        <span class="tok-kw">const</span> text = <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseIntWithGenericCharacter">parseIntWithGenericCharacter</a>(I, <span class="tok-type">u16</span>, text, base);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;parseEnvVarInt is not supported for WASI without libc&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> text = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(I, text, base);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.hasEnvVar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hasEnvVar</span><a href="#src.zig-std.process.hasEnvVar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasEnvVar</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.HasEnvVarError">HasEnvVarError</a>!<span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>On Windows, if <code>key</code> is not valid <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>,
then <code>error.InvalidWtf8</code> is returned.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> hasEnvVar {
    <span class="tok-kw">const</span> has_env = <span class="tok-kw">try</span> <a href="std.process.html#std.process.hasEnvVar">hasEnvVar</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;BADENV&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!has_env);
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.hasEnvVar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasEnvVar</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.HasEnvVarError">HasEnvVarError</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> stack_alloc = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-number">256</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u16</span>), allocator);
        <span class="tok-kw">const</span> stack_allocator = stack_alloc.get();
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(stack_allocator, key);
        <span class="tok-kw">defer</span> stack_allocator.free(key_w);
        <span class="tok-kw">return</span> <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) != <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> envmap = <a href="std.process.html#std.process.getEnvMap">getEnvMap</a>(allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        <span class="tok-kw">defer</span> envmap.deinit();
        <span class="tok-kw">return</span> envmap.getPtr(key) != <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) != <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.hasNonEmptyEnvVar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hasNonEmptyEnvVar</span><a href="#src.zig-std.process.hasNonEmptyEnvVar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasNonEmptyEnvVar</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.HasEnvVarError">HasEnvVarError</a>!<span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>On Windows, if <code>key</code> is not valid <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>,
then <code>error.InvalidWtf8</code> is returned.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.hasNonEmptyEnvVar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasNonEmptyEnvVar</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.HasEnvVarError">HasEnvVarError</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> stack_alloc = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-number">256</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u16</span>), allocator);
        <span class="tok-kw">const</span> stack_allocator = stack_alloc.get();
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(stack_allocator, key);
        <span class="tok-kw">defer</span> stack_allocator.free(key_w);
        <span class="tok-kw">const</span> value = <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> envmap = <a href="std.process.html#std.process.getEnvMap">getEnvMap</a>(allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        <span class="tok-kw">defer</span> envmap.deinit();
        <span class="tok-kw">const</span> value = envmap.getPtr(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> value = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.getenvW" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getenvW</span><a href="#src.zig-std.process.getenvW">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenvW</span>(key: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div><div class="tldDocs"><p>Windows-only. Get an environment variable with a null-terminated, WTF-16 encoded name.</p>
<p>This function performs a Unicode-aware case-insensitive lookup using RtlEqualUnicodeString.</p>
<p>See also:</p>
<ul>
<li><code><a href="std.posix.html#std.posix.getenv">std.posix.getenv</a></code></li>
<li><code><a href="std.process.html#std.process.getEnvMap">getEnvMap</a></code></li>
<li><code><a href="std.process.html#std.process.getEnvVarOwned">getEnvVarOwned</a></code></li>
<li><code><a href="std.process.html#std.process.hasEnvVarConstant">hasEnvVarConstant</a></code></li>
<li><code><a href="std.process.html#std.process.hasEnvVar">hasEnvVar</a></code></li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>key: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.getenvW">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenvW</span>(key: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> != .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows-only&quot;</span>);
    }
    <span class="tok-kw">const</span> key_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(key, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> ptr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.Environment;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> key_start = i;<span class="tok-comment">

        // There are some special environment variables that start with =,
        // so we need a special case to not treat = as a key/value separator
        // if it's the first character.
        // https://devblogs.microsoft.com/oldnewthing/20100506-00/?p=14133
        </span><span class="tok-kw">if</span> (ptr[key_start] == <span class="tok-str">'='</span>) i += <span class="tok-number">1</span>;

        <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> ptr[i] != <span class="tok-str">'='</span>) : (i += <span class="tok-number">1</span>) {}
        <span class="tok-kw">const</span> this_key = ptr[key_start..i];

        <span class="tok-kw">if</span> (ptr[i] == <span class="tok-str">'='</span>) i += <span class="tok-number">1</span>;

        <span class="tok-kw">const</span> value_start = i;
        <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {}
        <span class="tok-kw">const</span> this_value = ptr[value_start..i :<span class="tok-number">0</span>];

        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.eqlIgnoreCaseWTF16">eqlIgnoreCaseWTF16</a>(key_slice, this_key)) {
            <span class="tok-kw">return</span> this_value;
        }

        i += <span class="tok-number">1</span>;<span class="tok-comment"> // skip over null byte
    </span>}
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.args" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">args</span><a href="#src.zig-std.process.args">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">args</span>() <a href="std.process.ArgIterator.html">ArgIterator</a></code></pre></div><div class="tldDocs"><p>Holds the command-line arguments, with the program name as the first entry.
Use argsWithAllocator() for cross-platform code.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.args">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">args</span>() <a href="std.process.ArgIterator.html">ArgIterator</a> {
    <span class="tok-kw">return</span> <a href="std.process.ArgIterator.html">ArgIterator</a>.<a href="std.process.ArgIterator.html#std.process.ArgIterator.init">init</a>();
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.argsWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">argsWithAllocator</span><a href="#src.zig-std.process.argsWithAllocator">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsWithAllocator</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.ArgIterator.html">ArgIterator</a>.<a href="std.process.ArgIterator.html#std.process.ArgIterator.InitError">InitError</a>!<a href="std.process.ArgIterator.html">ArgIterator</a></code></pre></div><div class="tldDocs"><p>You must deinitialize iterator's internal buffers by calling <code>deinit</code> when done.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.argsWithAllocator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsWithAllocator</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.ArgIterator.html">ArgIterator</a>.<a href="std.process.ArgIterator.html#std.process.ArgIterator.InitError">InitError</a>!<a href="std.process.ArgIterator.html">ArgIterator</a> {
    <span class="tok-kw">return</span> <a href="std.process.ArgIterator.html">ArgIterator</a>.<a href="std.process.ArgIterator.html#std.process.ArgIterator.initWithAllocator">initWithAllocator</a>(allocator);
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.argsAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">argsAlloc</span><a href="#src.zig-std.process.argsAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![][:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Caller must call argsFree on result.
On Windows, the result is encoded as <a href="https://simonsapin.github.io/wtf-8/">WTF-8</a>.
On other platforms, the result is an opaque sequence of bytes with no particular encoding.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.argsAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![][:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {<span class="tok-comment">
    // TODO refactor to only make 1 allocation.
    </span><span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.process.html#std.process.argsWithAllocator">argsWithAllocator</a>(allocator);
    <span class="tok-kw">defer</span> it.deinit();

    <span class="tok-kw">var</span> contents = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
    <span class="tok-kw">defer</span> contents.deinit();

    <span class="tok-kw">var</span> slice_list = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">usize</span>).init(allocator);
    <span class="tok-kw">defer</span> slice_list.deinit();

    <span class="tok-kw">while</span> (it.next()) |arg| {
        <span class="tok-kw">try</span> contents.appendSlice(arg[<span class="tok-number">0</span> .. arg.len + <span class="tok-number">1</span>]);
        <span class="tok-kw">try</span> slice_list.append(arg.len);
    }

    <span class="tok-kw">const</span> contents_slice = contents.items;
    <span class="tok-kw">const</span> slice_sizes = slice_list.items;
    <span class="tok-kw">const</span> slice_list_bytes = <span class="tok-kw">try</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@sizeOf</span>([]<span class="tok-type">u8</span>), slice_sizes.len);
    <span class="tok-kw">const</span> total_bytes = <span class="tok-kw">try</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">usize</span>, slice_list_bytes, contents_slice.len);
    <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> allocator.alignedAlloc(<span class="tok-type">u8</span>, <span class="tok-builtin">@alignOf</span>([]<span class="tok-type">u8</span>), total_bytes);
    <span class="tok-kw">errdefer</span> allocator.free(buf);

    <span class="tok-kw">const</span> result_slice_list = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>([:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, buf[<span class="tok-number">0</span>..slice_list_bytes]);
    <span class="tok-kw">const</span> result_contents = buf[slice_list_bytes..];
    <span class="tok-builtin">@memcpy</span>(result_contents[<span class="tok-number">0</span>..contents_slice.len], contents_slice);

    <span class="tok-kw">var</span> contents_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slice_sizes, <span class="tok-number">0</span>..) |len, i| {
        <span class="tok-kw">const</span> new_index = contents_index + len;
        result_slice_list[i] = result_contents[contents_index..new_index :<span class="tok-number">0</span>];
        contents_index = new_index + <span class="tok-number">1</span>;
    }

    <span class="tok-kw">return</span> result_slice_list;
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.argsFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">argsFree</span><a href="#src.zig-std.process.argsFree">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsFree</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, args_alloc: []<span class="tok-kw">const</span> [:<span class="tok-number">0</span>]<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>args_alloc: []<span class="tok-kw">const</span> [:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.argsFree">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsFree</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, args_alloc: []<span class="tok-kw">const</span> [:<span class="tok-number">0</span>]<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> total_bytes: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (args_alloc) |arg| {
        total_bytes += <span class="tok-builtin">@sizeOf</span>([]<span class="tok-type">u8</span>) + arg.len + <span class="tok-number">1</span>;
    }
    <span class="tok-kw">const</span> unaligned_allocated_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(args_alloc.ptr))[<span class="tok-number">0</span>..total_bytes];
    <span class="tok-kw">const</span> aligned_allocated_buf: []<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>([]<span class="tok-type">u8</span>)) <span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(unaligned_allocated_buf);
    <span class="tok-kw">return</span> allocator.free(aligned_allocated_buf);
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.getUserInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getUserInfo</span><a href="#src.zig-std.process.getUserInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getUserInfo</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.process.UserInfo.html">UserInfo</a></code></pre></div><div class="tldDocs"><p>POSIX function which gets a uid from username.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.getUserInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getUserInfo</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.process.UserInfo.html">UserInfo</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
        .linux,
        .macos,
        .watchos,
        .visionos,
        .tvos,
        .ios,
        .freebsd,
        .netbsd,
        .openbsd,
        .haiku,
        .solaris,
        .illumos,
        =&gt; <a href="std.process.html#std.process.posixGetUserInfo">posixGetUserInfo</a>(name),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.posixGetUserInfo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">posixGetUserInfo</span><a href="#src.zig-std.process.posixGetUserInfo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">posixGetUserInfo</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.process.UserInfo.html">UserInfo</a></code></pre></div><div class="tldDocs"><p>TODO this reads /etc/passwd. But sometimes the user/id mapping is in something else
like NIS, AD, etc. See <code>man nss</code> or look at an strace for <code>id myuser</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.posixGetUserInfo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">posixGetUserInfo</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.process.UserInfo.html">UserInfo</a> {
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsolute">openFileAbsolute</a>(<span class="tok-str">&quot;/etc/passwd&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">const</span> reader = file.reader();

    <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
        Start,
        WaitForNextLine,
        SkipPassword,
        ReadUserId,
        ReadGroupId,
    };

    <span class="tok-kw">var</span> buf: [<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> name_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> state = State.Start;
    <span class="tok-kw">var</span> uid: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uid_t">uid_t</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> gid: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.gid_t">gid_t</a> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> reader.read(buf[<span class="tok-number">0</span>..]);
        <span class="tok-kw">for</span> (buf[<span class="tok-number">0</span>..amt_read]) |byte| {
            <span class="tok-kw">switch</span> (state) {
                .Start =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">':'</span> =&gt; {
                        state = <span class="tok-kw">if</span> (name_index == name.len) State.SkipPassword <span class="tok-kw">else</span> State.WaitForNextLine;
                    },
                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">if</span> (name_index == name.len <span class="tok-kw">or</span> name[name_index] != byte) {
                            state = .WaitForNextLine;
                        }
                        name_index += <span class="tok-number">1</span>;
                    },
                },
                .WaitForNextLine =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'\n'</span> =&gt; {
                        name_index = <span class="tok-number">0</span>;
                        state = .Start;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                },
                .SkipPassword =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                    <span class="tok-str">':'</span> =&gt; {
                        state = .ReadUserId;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                },
                .ReadUserId =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">':'</span> =&gt; {
                        state = .ReadGroupId;
                    },
                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">const</span> digit = <span class="tok-kw">switch</span> (byte) {
                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; byte - <span class="tok-str">'0'</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                        };
                        {
                            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(uid, <span class="tok-number">10</span>);
                            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile;
                            uid = ov[<span class="tok-number">0</span>];
                        }
                        {
                            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(uid, digit);
                            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile;
                            uid = ov[<span class="tok-number">0</span>];
                        }
                    },
                },
                .ReadGroupId =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'\n'</span>, <span class="tok-str">':'</span> =&gt; {
                        <span class="tok-kw">return</span> <a href="std.process.UserInfo.html">UserInfo</a>{
                            .uid = uid,
                            .gid = gid,
                        };
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">const</span> digit = <span class="tok-kw">switch</span> (byte) {
                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; byte - <span class="tok-str">'0'</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                        };
                        {
                            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(gid, <span class="tok-number">10</span>);
                            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile;
                            gid = ov[<span class="tok-number">0</span>];
                        }
                        {
                            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(gid, digit);
                            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile;
                            gid = ov[<span class="tok-number">0</span>];
                        }
                    },
                },
            }
        }
        <span class="tok-kw">if</span> (amt_read &lt; buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserNotFound;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.getBaseAddress" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getBaseAddress</span><a href="#src.zig-std.process.getBaseAddress">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getBaseAddress</span>() <span class="tok-type">usize</span></code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.getBaseAddress">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getBaseAddress</span>() <span class="tok-type">usize</span> {
    <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
        .linux =&gt; {
            <span class="tok-kw">const</span> getauxval = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.getauxval">getauxval</a> <span class="tok-kw">else</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.getauxval">getauxval</a>;
            <span class="tok-kw">const</span> base = getauxval(<a href="std.html">std</a>.<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.AT_BASE">AT_BASE</a>);
            <span class="tok-kw">if</span> (base != <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> base;
            }
            <span class="tok-kw">const</span> phdr = getauxval(<a href="std.html">std</a>.<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.AT_PHDR">AT_PHDR</a>);
            <span class="tok-kw">return</span> phdr - <span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Ehdr">Ehdr</a>);
        },
        .driverkit, .ios, .macos, .tvos, .visionos, .watchos =&gt; {
            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromPtr</span>(&amp;<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._mh_execute_header">_mh_execute_header</a>);
        },
        .windows =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intFromPtr</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetModuleHandleW">GetModuleHandleW</a>(<span class="tok-null">null</span>)),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.execv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">execv</span><a href="#src.zig-std.process.execv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execv</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ExecvError">ExecvError</a></code></pre></div><div class="tldDocs"><p>Replaces the current process image with the executed process.
This function must allocate memory to add a null terminating bytes on path and each arg.
It must also convert to KEY=VALUE\0 format for environment variables, and include null
pointers after the args and after the environment variables.
<code>argv[0]</code> is the executable path.
This function also uses the PATH environment variable to get the full path to the executable.
Due to the heap-allocation, it is illegal to call this function in a fork() child.
For that use case, use the <code><a href="std.posix.html">std.posix</a></code> functions directly.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.execv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execv</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ExecvError">ExecvError</a> {
    <span class="tok-kw">return</span> <a href="std.process.html#std.process.execve">execve</a>(allocator, argv, <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.execve" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">execve</span><a href="#src.zig-std.process.execve">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execve</span>( allocator: <a href="std.mem.Allocator.html">Allocator</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>, ) <a href="std.process.html#std.process.ExecvError">ExecvError</a></code></pre></div><div class="tldDocs"><p>Replaces the current process image with the executed process.
This function must allocate memory to add a null terminating bytes on path and each arg.
It must also convert to KEY=VALUE\0 format for environment variables, and include null
pointers after the args and after the environment variables.
<code>argv[0]</code> is the executable path.
This function also uses the PATH environment variable to get the full path to the executable.
Due to the heap-allocation, it is illegal to call this function in a fork() child.
For that use case, use the <code><a href="std.posix.html">std.posix</a></code> functions directly.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.execve">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execve</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>,
) <a href="std.process.html#std.process.ExecvError">ExecvError</a> {
    <span class="tok-kw">if</span> (!<a href="std.process.html#std.process.can_execv">can_execv</a>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The target OS does not support execv&quot;</span>);

    <span class="tok-kw">var</span> arena_allocator = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(allocator);
    <span class="tok-kw">defer</span> arena_allocator.deinit();
    <span class="tok-kw">const</span> arena = arena_allocator.allocator();

    <span class="tok-kw">const</span> argv_buf = <span class="tok-kw">try</span> arena.allocSentinel(?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv.len, <span class="tok-null">null</span>);
    <span class="tok-kw">for</span> (argv, <span class="tok-number">0</span>..) |arg, i| argv_buf[i] = (<span class="tok-kw">try</span> arena.dupeZ(<span class="tok-type">u8</span>, arg)).ptr;

    <span class="tok-kw">const</span> envp = m: {
        <span class="tok-kw">if</span> (env_map) |m| {
            <span class="tok-kw">const</span> envp_buf = <span class="tok-kw">try</span> <a href="std.process.html#std.process.createNullDelimitedEnvMap">createNullDelimitedEnvMap</a>(arena, m);
            <span class="tok-kw">break</span> :m envp_buf.ptr;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">break</span> :m <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.environ">environ</a>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.output_mode">output_mode</a> == .Exe) {<span class="tok-comment">
            // Then we have Zig start code and this works.
            // TODO type-safety for null-termination of `os.environ`.
            </span><span class="tok-kw">break</span> :m <span class="tok-builtin">@as</span>([*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.environ">environ</a>.<a href="#">ptr</a>));
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // TODO come up with a solution for this.
            </span><span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;missing std lib enhancement: std.process.execv implementation has no way to collect the environment variables to forward to the child process&quot;</span>);
        }
    };

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.execvpeZ_expandArg0">execvpeZ_expandArg0</a>(.no_expand, argv_buf.ptr[<span class="tok-number">0</span>].?, argv_buf.ptr, envp);
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.totalSystemMemory" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">totalSystemMemory</span><a href="#src.zig-std.process.totalSystemMemory">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">totalSystemMemory</span>() <a href="std.process.html#std.process.TotalSystemMemoryError">TotalSystemMemoryError</a>!<span class="tok-type">u64</span></code></pre></div><div class="tldDocs"><p>Returns the total system memory, in bytes as a u64.
We return a u64 instead of usize due to PAE on ARM
and Linux's /proc/meminfo reporting more memory when
using QEMU user mode emulation.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.totalSystemMemory">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">totalSystemMemory</span>() <a href="std.process.html#std.process.TotalSystemMemoryError">TotalSystemMemoryError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
        .linux =&gt; {
            <span class="tok-kw">return</span> <a href="std.process.html#std.process.totalSystemMemoryLinux">totalSystemMemoryLinux</a>() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory;
        },
        .freebsd =&gt; {
            <span class="tok-kw">var</span> physmem: <span class="tok-type">c_ulong</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">c_ulong</span>);
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctlbynameZ">sysctlbynameZ</a>(<span class="tok-str">&quot;hw.physmem&quot;</span>, &amp;physmem, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.NameTooLong, <span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory,
            };
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(physmem));
        },
        .openbsd =&gt; {
            <span class="tok-kw">const</span> mib: [<span class="tok-number">2</span>]<span class="tok-type">c_int</span> = [_]<span class="tok-type">c_int</span>{
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CTL">CTL</a>.<a href="#">HW</a>,
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.HW">HW</a>.<a href="#">PHYSMEM64</a>,
            };
            <span class="tok-kw">var</span> physmem: <span class="tok-type">i64</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(physmem));
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctl">sysctl</a>(&amp;mib, &amp;physmem, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                </span><span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only when setting values,
                </span><span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // memory already on the stack
                </span><span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory,
            };
            <a href="std.debug.html#std.debug.assert">assert</a>(physmem &gt;= <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(physmem));
        },
        .windows =&gt; {
            <span class="tok-kw">var</span> sbi: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.SYSTEM_BASIC_INFORMATION.html">SYSTEM_BASIC_INFORMATION</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQuerySystemInformation">NtQuerySystemInformation</a>(
                .SystemBasicInformation,
                &amp;sbi,
                <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.SYSTEM_BASIC_INFORMATION.html">SYSTEM_BASIC_INFORMATION</a>),
                <span class="tok-null">null</span>,
            );
            <span class="tok-kw">if</span> (rc != .SUCCESS) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory;
            }
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, sbi.NumberOfPhysicalPages) * sbi.PageSize;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory,
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.cleanExit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cleanExit</span><a href="#src.zig-std.process.cleanExit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cleanExit</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Indicate that we are now terminating with a successful exit code.
In debug builds, this is a no-op, so that the calling code's
cleanup mechanisms are tested and so that external tools that
check for resource leaks can be accurate. In release builds, this
calls exit(0), and does not return.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.cleanExit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cleanExit</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) {
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
        <a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">0</span>);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.raiseFileDescriptorLimit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">raiseFileDescriptorLimit</span><a href="#src.zig-std.process.raiseFileDescriptorLimit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">raiseFileDescriptorLimit</span>() <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Raise the open file descriptor limit.</p>
<p>On some systems, this raises the limit before seeing ProcessFdQuotaExceeded
errors. On other systems, this does nothing.</p>
</div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> raiseFileDescriptorLimit {
    <a href="std.process.html#std.process.raiseFileDescriptorLimit">raiseFileDescriptorLimit</a>();
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.raiseFileDescriptorLimit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">raiseFileDescriptorLimit</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> have_rlimit = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a> != <span class="tok-type">void</span>;
    <span class="tok-kw">if</span> (!have_rlimit) <span class="tok-kw">return</span>;

    <span class="tok-kw">var</span> lim = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getrlimit">getrlimit</a>(.NOFILE) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;<span class="tok-comment"> // Oh well; we tried.
    </span><span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a>.<a href="#">isDarwin</a>()) {<span class="tok-comment">
        // On Darwin, `NOFILE` is bounded by a hardcoded value `OPEN_MAX`.
        // According to the man pages for setrlimit():
        //   setrlimit() now returns with errno set to EINVAL in places that historically succeeded.
        //   It no longer accepts &quot;rlim_cur = RLIM.INFINITY&quot; for RLIM.NOFILE.
        //   Use &quot;rlim_cur = min(OPEN_MAX, rlim_max)&quot;.
        </span>lim.max = <span class="tok-builtin">@min</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin.OPEN_MAX">OPEN_MAX</a>, lim.max);
    }
    <span class="tok-kw">if</span> (lim.cur == lim.max) <span class="tok-kw">return</span>;<span class="tok-comment">

    // Do a binary search for the limit.
    </span><span class="tok-kw">var</span> min: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rlim_t">rlim_t</a> = lim.cur;
    <span class="tok-kw">var</span> max: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rlim_t">rlim_t</a> = <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">20</span>;<span class="tok-comment">
    // But if there's a defined upper bound, don't search, just set it.
    </span><span class="tok-kw">if</span> (lim.max != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RLIM">RLIM</a>.<a href="#">INFINITY</a>) {
        min = lim.max;
        max = lim.max;
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        lim.cur = min + <span class="tok-builtin">@divTrunc</span>(max - min, <span class="tok-number">2</span>);<span class="tok-comment"> // on freebsd rlim_t is signed
        </span><span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setrlimit">setrlimit</a>(.NOFILE, lim)) |_| {
            min = lim.cur;
        } <span class="tok-kw">else</span> |_| {
            max = lim.cur;
        }
        <span class="tok-kw">if</span> (min + <span class="tok-number">1</span> &gt;= max) <span class="tok-kw">break</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.createEnvironFromMap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createEnvironFromMap</span><a href="#src.zig-std.process.createEnvironFromMap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createEnvironFromMap</span>( arena: <a href="std.mem.Allocator.html">Allocator</a>, map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>, options: <a href="std.process.CreateEnvironOptions.html">CreateEnvironOptions</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Creates a null-delimited environment variable block in the format
expected by POSIX, from a hash map plus options.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>arena: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a></code></pre></div><div><pre><code>options: <a href="std.process.CreateEnvironOptions.html">CreateEnvironOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.createEnvironFromMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createEnvironFromMap</span>(
    arena: <a href="std.mem.Allocator.html">Allocator</a>,
    map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>,
    options: <a href="std.process.CreateEnvironOptions.html">CreateEnvironOptions</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> ZigProgressAction = <span class="tok-kw">enum</span> { nothing, edit, delete, add };
    <span class="tok-kw">const</span> zig_progress_action: ZigProgressAction = a: {
        <span class="tok-kw">const</span> fd = options.zig_progress_fd <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :a .nothing;
        <span class="tok-kw">const</span> contains = map.get(<span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>) != <span class="tok-null">null</span>;
        <span class="tok-kw">if</span> (fd &gt;= <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span> :a <span class="tok-kw">if</span> (contains) .edit <span class="tok-kw">else</span> .add;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">if</span> (contains) <span class="tok-kw">break</span> :a .delete;
        }
        <span class="tok-kw">break</span> :a .nothing;
    };

    <span class="tok-kw">const</span> envp_count: <span class="tok-type">usize</span> = c: {
        <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = map.count();
        <span class="tok-kw">switch</span> (zig_progress_action) {
            .add =&gt; count += <span class="tok-number">1</span>,
            .delete =&gt; count -= <span class="tok-number">1</span>,
            .nothing, .edit =&gt; {},
        }
        <span class="tok-kw">break</span> :c count;
    };

    <span class="tok-kw">const</span> envp_buf = <span class="tok-kw">try</span> arena.allocSentinel(?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, envp_count, <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">if</span> (zig_progress_action == .add) {
        envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;ZIG_PROGRESS={d}&quot;</span>, .{options.zig_progress_fd.?});
        i += <span class="tok-number">1</span>;
    }

    {
        <span class="tok-kw">var</span> it = map.iterator();
        <span class="tok-kw">while</span> (it.next()) |pair| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, pair.key_ptr.*, <span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>)) <span class="tok-kw">switch</span> (zig_progress_action) {
                .add =&gt; <span class="tok-kw">unreachable</span>,
                .delete =&gt; <span class="tok-kw">continue</span>,
                .edit =&gt; {
                    envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;{s}={d}&quot;</span>, .{
                        pair.key_ptr.*, options.zig_progress_fd.?,
                    });
                    i += <span class="tok-number">1</span>;
                    <span class="tok-kw">continue</span>;
                },
                .nothing =&gt; {},
            };

            envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;{s}={s}&quot;</span>, .{ pair.key_ptr.*, pair.value_ptr.* });
            i += <span class="tok-number">1</span>;
        }
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(i == envp_count);
    <span class="tok-kw">return</span> envp_buf;
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.createEnvironFromExisting" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createEnvironFromExisting</span><a href="#src.zig-std.process.createEnvironFromExisting">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createEnvironFromExisting</span>( arena: <a href="std.mem.Allocator.html">Allocator</a>, existing: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.process.CreateEnvironOptions.html">CreateEnvironOptions</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Creates a null-delimited environment variable block in the format
expected by POSIX, from a hash map plus options.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>arena: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>existing: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.process.CreateEnvironOptions.html">CreateEnvironOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.createEnvironFromExisting">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createEnvironFromExisting</span>(
    arena: <a href="std.mem.Allocator.html">Allocator</a>,
    existing: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.process.CreateEnvironOptions.html">CreateEnvironOptions</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> existing_count, <span class="tok-kw">const</span> contains_zig_progress = c: {
        <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> contains = <span class="tok-null">false</span>;
        <span class="tok-kw">while</span> (existing[count]) |line| : (count += <span class="tok-number">1</span>) {
            contains = contains <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, mem.sliceTo(line, <span class="tok-str">'='</span>), <span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>);
        }
        <span class="tok-kw">break</span> :c .{ count, contains };
    };
    <span class="tok-kw">const</span> ZigProgressAction = <span class="tok-kw">enum</span> { nothing, edit, delete, add };
    <span class="tok-kw">const</span> zig_progress_action: ZigProgressAction = a: {
        <span class="tok-kw">const</span> fd = options.zig_progress_fd <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :a .nothing;
        <span class="tok-kw">if</span> (fd &gt;= <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span> :a <span class="tok-kw">if</span> (contains_zig_progress) .edit <span class="tok-kw">else</span> .add;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">if</span> (contains_zig_progress) <span class="tok-kw">break</span> :a .delete;
        }
        <span class="tok-kw">break</span> :a .nothing;
    };

    <span class="tok-kw">const</span> envp_count: <span class="tok-type">usize</span> = c: {
        <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = existing_count;
        <span class="tok-kw">switch</span> (zig_progress_action) {
            .add =&gt; count += <span class="tok-number">1</span>,
            .delete =&gt; count -= <span class="tok-number">1</span>,
            .nothing, .edit =&gt; {},
        }
        <span class="tok-kw">break</span> :c count;
    };

    <span class="tok-kw">const</span> envp_buf = <span class="tok-kw">try</span> arena.allocSentinel(?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, envp_count, <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> existing_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">if</span> (zig_progress_action == .add) {
        envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;ZIG_PROGRESS={d}&quot;</span>, .{options.zig_progress_fd.?});
        i += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">while</span> (existing[existing_index]) |line| : (existing_index += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(line, <span class="tok-str">'='</span>), <span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>)) <span class="tok-kw">switch</span> (zig_progress_action) {
            .add =&gt; <span class="tok-kw">unreachable</span>,
            .delete =&gt; <span class="tok-kw">continue</span>,
            .edit =&gt; {
                envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;ZIG_PROGRESS={d}&quot;</span>, .{options.zig_progress_fd.?});
                i += <span class="tok-number">1</span>;
                <span class="tok-kw">continue</span>;
            },
            .nothing =&gt; {},
        };
        envp_buf[i] = <span class="tok-kw">try</span> arena.dupeZ(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(line));
        i += <span class="tok-number">1</span>;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(i == envp_count);
    <span class="tok-kw">return</span> envp_buf;
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.createNullDelimitedEnvMap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createNullDelimitedEnvMap</span><a href="#src.zig-std.process.createNullDelimitedEnvMap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createNullDelimitedEnvMap</span>(arena: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, env_map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>arena: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>env_map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> createNullDelimitedEnvMap {
    <span class="tok-kw">const</span> allocator = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;
    <span class="tok-kw">var</span> envmap = <a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.init">init</a>(allocator);
    <span class="tok-kw">defer</span> envmap.deinit();

    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;HOME&quot;</span>, <span class="tok-str">&quot;/home/ifreund&quot;</span>);
    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;WAYLAND_DISPLAY&quot;</span>, <span class="tok-str">&quot;wayland-1&quot;</span>);
    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;DISPLAY&quot;</span>, <span class="tok-str">&quot;:1&quot;</span>);
    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;DEBUGINFOD_URLS&quot;</span>, <span class="tok-str">&quot; &quot;</span>);
    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;XCURSOR_SIZE&quot;</span>, <span class="tok-str">&quot;24&quot;</span>);

    <span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(allocator);
    <span class="tok-kw">defer</span> arena.deinit();
    <span class="tok-kw">const</span> environ = <span class="tok-kw">try</span> <a href="std.process.html#std.process.createNullDelimitedEnvMap">createNullDelimitedEnvMap</a>(arena.allocator(), &amp;envmap);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), environ.len);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{
        <span class="tok-str">&quot;HOME=/home/ifreund&quot;</span>,
        <span class="tok-str">&quot;WAYLAND_DISPLAY=wayland-1&quot;</span>,
        <span class="tok-str">&quot;DISPLAY=:1&quot;</span>,
        <span class="tok-str">&quot;DEBUGINFOD_URLS= &quot;</span>,
        <span class="tok-str">&quot;XCURSOR_SIZE=24&quot;</span>,
    }) |target| {
        <span class="tok-kw">for</span> (environ) |variable| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(variable <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>), target)) <span class="tok-kw">break</span>;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-null">false</span>);<span class="tok-comment"> // Environment variable not found
        </span>}
    }
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.createNullDelimitedEnvMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createNullDelimitedEnvMap</span>(arena: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, env_map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.process.html#std.process.createEnvironFromMap">createEnvironFromMap</a>(arena, env_map, .{});
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.createWindowsEnvBlock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">createWindowsEnvBlock</span><a href="#src.zig-std.process.createWindowsEnvBlock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createWindowsEnvBlock</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, env_map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>) ![]<span class="tok-type">u16</span></code></pre></div><div class="tldDocs"><p>Caller must free result.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>env_map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.createWindowsEnvBlock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createWindowsEnvBlock</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, env_map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>) ![]<span class="tok-type">u16</span> {<span class="tok-comment">
    // count bytes needed
    </span><span class="tok-kw">const</span> max_chars_needed = x: {
        <span class="tok-kw">var</span> max_chars_needed: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;<span class="tok-comment"> // 4 for the final 4 null bytes
        </span><span class="tok-kw">var</span> it = env_map.iterator();
        <span class="tok-kw">while</span> (it.next()) |pair| {<span class="tok-comment">
            // +1 for '='
            // +1 for null byte
            </span>max_chars_needed += pair.key_ptr.len + pair.value_ptr.len + <span class="tok-number">2</span>;
        }
        <span class="tok-kw">break</span> :x max_chars_needed;
    };
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u16</span>, max_chars_needed);
    <span class="tok-kw">errdefer</span> allocator.free(result);

    <span class="tok-kw">var</span> it = env_map.iterator();
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (it.next()) |pair| {
        i += <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(result[i..], pair.key_ptr.*);
        result[i] = <span class="tok-str">'='</span>;
        i += <span class="tok-number">1</span>;
        i += <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(result[i..], pair.value_ptr.*);
        result[i] = <span class="tok-number">0</span>;
        i += <span class="tok-number">1</span>;
    }
    result[i] = <span class="tok-number">0</span>;
    i += <span class="tok-number">1</span>;
    result[i] = <span class="tok-number">0</span>;
    i += <span class="tok-number">1</span>;
    result[i] = <span class="tok-number">0</span>;
    i += <span class="tok-number">1</span>;
    result[i] = <span class="tok-number">0</span>;
    i += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> allocator.realloc(result, i);
}</code></pre></details></div></div><div class="decl"><h2 id="std.process.fatal" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fatal</span><a href="#src.zig-std.process.fatal">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fatal</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, format_arguments: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span></code></pre></div><div class="tldDocs"><p>Logs an error and then terminates the process with exit code 1.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.process.fatal">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fatal</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, format_arguments: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span> {
    <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(format, format_arguments);
    <a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.process">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> native_os = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
<span class="tok-kw">const</span> unicode = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Child = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;process/Child.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> abort = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.abort">abort</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> exit = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.exit">exit</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> changeCurDir = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.chdir">chdir</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> changeCurDirZ = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.chdirZ">chdirZ</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetCwdError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a>;

<span class="tok-comment">/// The result is a slice of `out_buffer`, from index `0`.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCwd</span>(out_buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getcwd">getcwd</a>(out_buffer);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetCwdAllocError = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.GetCwdError">GetCwdError</a>;

<span class="tok-comment">/// Caller must free the returned memory.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getCwdAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![]<span class="tok-type">u8</span> {<span class="tok-comment">
    // The use of max_path_bytes here is just a heuristic: most paths will fit
    // in stack_buf, avoiding an extra allocation in the common case.
    </span><span class="tok-kw">var</span> stack_buf: [<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> heap_buf: ?[]<span class="tok-type">u8</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (heap_buf) |buf| allocator.free(buf);

    <span class="tok-kw">var</span> current_buf: []<span class="tok-type">u8</span> = &amp;stack_buf;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getcwd">getcwd</a>(current_buf)) |slice| {
            <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, slice);
        } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.NameTooLong =&gt; {<span class="tok-comment">
                // The path is too long to fit in stack_buf. Allocate geometrically
                // increasing buffers until we find one that works
                </span><span class="tok-kw">const</span> new_capacity = current_buf.len * <span class="tok-number">2</span>;
                <span class="tok-kw">if</span> (heap_buf) |buf| allocator.free(buf);
                current_buf = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, new_capacity);
                heap_buf = current_buf;
            },
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        }
    }
}

<span class="tok-kw">test</span> getCwdAlloc {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> cwd = <span class="tok-kw">try</span> <a href="std.process.html#std.process.getCwdAlloc">getCwdAlloc</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(cwd);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnvMap = <span class="tok-kw">struct</span> {
    hash_map: <a href="std.process.EnvMap.html#std.process.EnvMap.HashMap">HashMap</a>,

    <span class="tok-kw">const</span> HashMap = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.HashMap">HashMap</a>(
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        <a href="std.process.EnvMap.EnvNameHashContext.html">EnvNameHashContext</a>,
        <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.default_max_load_percentage">default_max_load_percentage</a>,
    );

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <a href="std.process.EnvMap.html#std.process.EnvMap.HashMap">HashMap</a>.<a href="#">Size</a>;

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnvNameHashContext = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">upcase</span>(c: <span class="tok-type">u21</span>) <span class="tok-type">u21</span> {
            <span class="tok-kw">if</span> (c &lt;= <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u16</span>))
                <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.RtlUpcaseUnicodeChar">RtlUpcaseUnicodeChar</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(c)));
            <span class="tok-kw">return</span> c;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: <span class="tok-builtin">@This</span>(), s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
            _ = self;
            <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
                <span class="tok-kw">var</span> h = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
                <span class="tok-kw">var</span> it = <a href="std.unicode.html">unicode</a>.<a href="std.unicode.Wtf8View.html">Wtf8View</a>.<a href="std.unicode.Wtf8View.html#std.unicode.Wtf8View.initUnchecked">initUnchecked</a>(s).iterator();
                <span class="tok-kw">while</span> (it.nextCodepoint()) |cp| {
                    <span class="tok-kw">const</span> cp_upper = <a href="std.process.EnvMap.EnvNameHashContext.html#std.process.EnvMap.EnvNameHashContext.upcase">upcase</a>(cp);
                    h.update(&amp;[_]<span class="tok-type">u8</span>{
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>((cp_upper &gt;&gt; <span class="tok-number">16</span>) &amp; <span class="tok-number">0xff</span>)),
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>((cp_upper &gt;&gt; <span class="tok-number">8</span>) &amp; <span class="tok-number">0xff</span>)),
                        <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>((cp_upper &gt;&gt; <span class="tok-number">0</span>) &amp; <span class="tok-number">0xff</span>)),
                    });
                }
                <span class="tok-kw">return</span> h.final();
            }
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.hashString">hashString</a>(s);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <span class="tok-builtin">@This</span>(), a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
            _ = self;
            <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
                <span class="tok-kw">var</span> it_a = <a href="std.unicode.html">unicode</a>.<a href="std.unicode.Wtf8View.html">Wtf8View</a>.<a href="std.unicode.Wtf8View.html#std.unicode.Wtf8View.initUnchecked">initUnchecked</a>(a).iterator();
                <span class="tok-kw">var</span> it_b = <a href="std.unicode.html">unicode</a>.<a href="std.unicode.Wtf8View.html">Wtf8View</a>.<a href="std.unicode.Wtf8View.html#std.unicode.Wtf8View.initUnchecked">initUnchecked</a>(b).iterator();
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> c_a = it_a.nextCodepoint() <span class="tok-kw">orelse</span> <span class="tok-kw">break</span>;
                    <span class="tok-kw">const</span> c_b = it_b.nextCodepoint() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                    <span class="tok-kw">if</span> (<a href="std.process.EnvMap.EnvNameHashContext.html#std.process.EnvMap.EnvNameHashContext.upcase">upcase</a>(c_a) != <a href="std.process.EnvMap.EnvNameHashContext.html#std.process.EnvMap.EnvNameHashContext.upcase">upcase</a>(c_b))
                        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
                <span class="tok-kw">return</span> <span class="tok-kw">if</span> (it_b.nextCodepoint()) |_| <span class="tok-null">false</span> <span class="tok-kw">else</span> <span class="tok-null">true</span>;
            }
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.hash_map.html">hash_map</a>.<a href="std.hash_map.html#std.hash_map.eqlString">eqlString</a>(a, b);
        }
    };

    <span class="tok-comment">/// Create a EnvMap backed by a specific allocator.</span>
    <span class="tok-comment">/// That allocator will be used for both backing allocations</span>
    <span class="tok-comment">/// and string deduplication.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.EnvMap.html">EnvMap</a> {
        <span class="tok-kw">return</span> <a href="std.process.EnvMap.html">EnvMap</a>{ .hash_map = <a href="std.process.EnvMap.html#std.process.EnvMap.HashMap">HashMap</a>.<a href="#">init</a>(allocator) };
    }

    <span class="tok-comment">/// Free the backing storage of the map, as well as all</span>
    <span class="tok-comment">/// of the stored keys and values.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.EnvMap.html">EnvMap</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">var</span> it = self.hash_map.iterator();
        <span class="tok-kw">while</span> (it.next()) |entry| {
            self.free(entry.key_ptr.*);
            self.free(entry.value_ptr.*);
        }

        self.hash_map.deinit();
    }

    <span class="tok-comment">/// Same as `put` but the key and value become owned by the EnvMap rather</span>
    <span class="tok-comment">/// than being copied.</span>
    <span class="tok-comment">/// If `putMove` fails, the ownership of key and value does not transfer.</span>
    <span class="tok-comment">/// On Windows `key` must be a valid [WTF-8](https://simonsapin.github.io/wtf-8/) string.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putMove</span>(self: *<a href="std.process.EnvMap.html">EnvMap</a>, key: []<span class="tok-type">u8</span>, value: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ValidateSlice">wtf8ValidateSlice</a>(key));
        <span class="tok-kw">const</span> get_or_put = <span class="tok-kw">try</span> self.hash_map.getOrPut(key);
        <span class="tok-kw">if</span> (get_or_put.found_existing) {
            self.free(get_or_put.key_ptr.*);
            self.free(get_or_put.value_ptr.*);
            get_or_put.key_ptr.* = key;
        }
        get_or_put.value_ptr.* = value;
    }

    <span class="tok-comment">/// `key` and `value` are copied into the EnvMap.</span>
    <span class="tok-comment">/// On Windows `key` must be a valid [WTF-8](https://simonsapin.github.io/wtf-8/) string.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.process.EnvMap.html">EnvMap</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ValidateSlice">wtf8ValidateSlice</a>(key));
        <span class="tok-kw">const</span> value_copy = <span class="tok-kw">try</span> self.copy(value);
        <span class="tok-kw">errdefer</span> self.free(value_copy);
        <span class="tok-kw">const</span> get_or_put = <span class="tok-kw">try</span> self.hash_map.getOrPut(key);
        <span class="tok-kw">if</span> (get_or_put.found_existing) {
            self.free(get_or_put.value_ptr.*);
        } <span class="tok-kw">else</span> {
            get_or_put.key_ptr.* = self.copy(key) <span class="tok-kw">catch</span> |err| {
                _ = self.hash_map.remove(key);
                <span class="tok-kw">return</span> err;
            };
        }
        get_or_put.value_ptr.* = value_copy;
    }

    <span class="tok-comment">/// Find the address of the value associated with a key.</span>
    <span class="tok-comment">/// The returned pointer is invalidated if the map resizes.</span>
    <span class="tok-comment">/// On Windows `key` must be a valid [WTF-8](https://simonsapin.github.io/wtf-8/) string.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.process.EnvMap.html">EnvMap</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?*[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ValidateSlice">wtf8ValidateSlice</a>(key));
        <span class="tok-kw">return</span> self.hash_map.getPtr(key);
    }

    <span class="tok-comment">/// Return the map's copy of the value associated with</span>
    <span class="tok-comment">/// a key.  The returned string is invalidated if this</span>
    <span class="tok-comment">/// key is removed from the map.</span>
    <span class="tok-comment">/// On Windows `key` must be a valid [WTF-8](https://simonsapin.github.io/wtf-8/) string.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.process.EnvMap.html">EnvMap</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ValidateSlice">wtf8ValidateSlice</a>(key));
        <span class="tok-kw">return</span> self.hash_map.get(key);
    }

    <span class="tok-comment">/// Removes the item from the map and frees its value.</span>
    <span class="tok-comment">/// This invalidates the value returned by get() for this key.</span>
    <span class="tok-comment">/// On Windows `key` must be a valid [WTF-8](https://simonsapin.github.io/wtf-8/) string.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove</span>(self: *<a href="std.process.EnvMap.html">EnvMap</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ValidateSlice">wtf8ValidateSlice</a>(key));
        <span class="tok-kw">const</span> kv = self.hash_map.fetchRemove(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        self.free(kv.key);
        self.free(kv.value);
    }

    <span class="tok-comment">/// Returns the number of KV pairs stored in the map.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.process.EnvMap.html">EnvMap</a>) <a href="std.process.EnvMap.html#std.process.EnvMap.HashMap">HashMap</a>.<a href="#">Size</a> {
        <span class="tok-kw">return</span> self.hash_map.count();
    }

    <span class="tok-comment">/// Returns an iterator over entries in the map.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>) <a href="std.process.EnvMap.html#std.process.EnvMap.HashMap">HashMap</a>.<a href="#">Iterator</a> {
        <span class="tok-kw">return</span> self.hash_map.iterator();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(self: <a href="std.process.EnvMap.html">EnvMap</a>, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
        self.hash_map.allocator.free(value);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">copy</span>(self: <a href="std.process.EnvMap.html">EnvMap</a>, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> self.hash_map.allocator.dupe(<span class="tok-type">u8</span>, value);
    }
};

<span class="tok-kw">test</span> EnvMap {
    <span class="tok-kw">var</span> env = <a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.init">init</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> env.deinit();

    <span class="tok-kw">try</span> env.put(<span class="tok-str">&quot;SOMETHING_NEW&quot;</span>, <span class="tok-str">&quot;hello&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;hello&quot;</span>, env.get(<span class="tok-str">&quot;SOMETHING_NEW&quot;</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.Size">Size</a>, <span class="tok-number">1</span>), env.count());<span class="tok-comment">

    // overwrite
    </span><span class="tok-kw">try</span> env.put(<span class="tok-str">&quot;SOMETHING_NEW&quot;</span>, <span class="tok-str">&quot;something&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;something&quot;</span>, env.get(<span class="tok-str">&quot;SOMETHING_NEW&quot;</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.Size">Size</a>, <span class="tok-number">1</span>), env.count());<span class="tok-comment">

    // a new longer name to test the Windows-specific conversion buffer
    </span><span class="tok-kw">try</span> env.put(<span class="tok-str">&quot;SOMETHING_NEW_AND_LONGER&quot;</span>, <span class="tok-str">&quot;1&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;1&quot;</span>, env.get(<span class="tok-str">&quot;SOMETHING_NEW_AND_LONGER&quot;</span>).?);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.Size">Size</a>, <span class="tok-number">2</span>), env.count());<span class="tok-comment">

    // case insensitivity on Windows only
    </span><span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;1&quot;</span>, env.get(<span class="tok-str">&quot;something_New_aNd_LONGER&quot;</span>).?);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-null">null</span> == env.get(<span class="tok-str">&quot;something_New_aNd_LONGER&quot;</span>));
    }

    <span class="tok-kw">var</span> it = env.iterator();
    <span class="tok-kw">var</span> count: <a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.Size">Size</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (it.next()) |entry| {
        <span class="tok-kw">const</span> is_an_expected_name = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;SOMETHING_NEW&quot;</span>, entry.key_ptr.*) <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;SOMETHING_NEW_AND_LONGER&quot;</span>, entry.key_ptr.*);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(is_an_expected_name);
        count += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.Size">Size</a>, <span class="tok-number">2</span>), count);

    env.remove(<span class="tok-str">&quot;SOMETHING_NEW&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(env.get(<span class="tok-str">&quot;SOMETHING_NEW&quot;</span>) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.Size">Size</a>, <span class="tok-number">1</span>), env.count());

    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {<span class="tok-comment">
        // test Unicode case-insensitivity on Windows
        </span><span class="tok-kw">try</span> env.put(<span class="tok-str">&quot;КИРиллИЦА&quot;</span>, <span class="tok-str">&quot;something else&quot;</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;something else&quot;</span>, env.get(<span class="tok-str">&quot;кириллица&quot;</span>).?);<span class="tok-comment">

        // and WTF-8 that's not valid UTF-8
        </span><span class="tok-kw">const</span> wtf8_with_surrogate_pair = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8Alloc">wtf16LeToWtf8Alloc</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, &amp;[_]<span class="tok-type">u16</span>{
            <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.nativeToLittle">nativeToLittle</a>(<span class="tok-type">u16</span>, <span class="tok-number">0xD83D</span>),<span class="tok-comment"> // unpaired high surrogate
        </span>});
        <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(wtf8_with_surrogate_pair);

        <span class="tok-kw">try</span> env.put(wtf8_with_surrogate_pair, wtf8_with_surrogate_pair);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, wtf8_with_surrogate_pair, env.get(wtf8_with_surrogate_pair).?);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetEnvMapError = <span class="tok-kw">error</span>{
    OutOfMemory,
    <span class="tok-comment">/// WASI-only. `environ_sizes_get` or `environ_get`</span>
    <span class="tok-comment">/// failed for an unexpected reason.</span>
    Unexpected,
};

<span class="tok-comment">/// Returns a snapshot of the environment variables of the current process.</span>
<span class="tok-comment">/// Any modifications to the resulting EnvMap will not be reflected in the environment, and</span>
<span class="tok-comment">/// likewise, any future modifications to the environment will not be reflected in the EnvMap.</span>
<span class="tok-comment">/// Caller owns resulting `EnvMap` and should call its `deinit` fn when done.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEnvMap</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.html#std.process.GetEnvMapError">GetEnvMapError</a>!<a href="std.process.EnvMap.html">EnvMap</a> {
    <span class="tok-kw">var</span> result = <a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.init">init</a>(allocator);
    <span class="tok-kw">errdefer</span> result.deinit();

    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> ptr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.Environment;

        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span>) {
            <span class="tok-kw">const</span> key_start = i;<span class="tok-comment">

            // There are some special environment variables that start with =,
            // so we need a special case to not treat = as a key/value separator
            // if it's the first character.
            // https://devblogs.microsoft.com/oldnewthing/20100506-00/?p=14133
            </span><span class="tok-kw">if</span> (ptr[key_start] == <span class="tok-str">'='</span>) i += <span class="tok-number">1</span>;

            <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> ptr[i] != <span class="tok-str">'='</span>) : (i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> key_w = ptr[key_start..i];
            <span class="tok-kw">const</span> key = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8Alloc">wtf16LeToWtf8Alloc</a>(allocator, key_w);
            <span class="tok-kw">errdefer</span> allocator.free(key);

            <span class="tok-kw">if</span> (ptr[i] == <span class="tok-str">'='</span>) i += <span class="tok-number">1</span>;

            <span class="tok-kw">const</span> value_start = i;
            <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> value_w = ptr[value_start..i];
            <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8Alloc">wtf16LeToWtf8Alloc</a>(allocator, value_w);
            <span class="tok-kw">errdefer</span> allocator.free(value);

            i += <span class="tok-number">1</span>;<span class="tok-comment"> // skip over null byte

            </span><span class="tok-kw">try</span> result.putMove(key, value);
        }
        <span class="tok-kw">return</span> result;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> environ_count: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> environ_buf_size: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">const</span> environ_sizes_get_ret = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.environ_sizes_get">environ_sizes_get</a>(&amp;environ_count, &amp;environ_buf_size);
        <span class="tok-kw">if</span> (environ_sizes_get_ret != .SUCCESS) {
            <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(environ_sizes_get_ret);
        }

        <span class="tok-kw">if</span> (environ_count == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">const</span> environ = <span class="tok-kw">try</span> allocator.alloc([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, environ_count);
        <span class="tok-kw">defer</span> allocator.free(environ);
        <span class="tok-kw">const</span> environ_buf = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, environ_buf_size);
        <span class="tok-kw">defer</span> allocator.free(environ_buf);

        <span class="tok-kw">const</span> environ_get_ret = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.environ_get">environ_get</a>(environ.ptr, environ_buf.ptr);
        <span class="tok-kw">if</span> (environ_get_ret != .SUCCESS) {
            <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(environ_get_ret);
        }

        <span class="tok-kw">for</span> (environ) |env| {
            <span class="tok-kw">const</span> pair = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(env, <span class="tok-number">0</span>);
            <span class="tok-kw">var</span> parts = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, pair, <span class="tok-str">'='</span>);
            <span class="tok-kw">const</span> key = parts.first();
            <span class="tok-kw">const</span> value = parts.rest();
            <span class="tok-kw">try</span> result.put(key, value);
        }
        <span class="tok-kw">return</span> result;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> ptr = <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.environ">environ</a>;
        <span class="tok-kw">while</span> (ptr[<span class="tok-number">0</span>]) |line| : (ptr += <span class="tok-number">1</span>) {
            <span class="tok-kw">var</span> line_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (line[line_i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> line[line_i] != <span class="tok-str">'='</span>) : (line_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> key = line[<span class="tok-number">0</span>..line_i];

            <span class="tok-kw">var</span> end_i: <span class="tok-type">usize</span> = line_i;
            <span class="tok-kw">while</span> (line[end_i] != <span class="tok-number">0</span>) : (end_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> value = line[line_i + <span class="tok-number">1</span> .. end_i];

            <span class="tok-kw">try</span> result.put(key, value);
        }
        <span class="tok-kw">return</span> result;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.environ">environ</a>) |line| {
            <span class="tok-kw">var</span> line_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (line[line_i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> line[line_i] != <span class="tok-str">'='</span>) : (line_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> key = line[<span class="tok-number">0</span>..line_i];

            <span class="tok-kw">var</span> end_i: <span class="tok-type">usize</span> = line_i;
            <span class="tok-kw">while</span> (line[end_i] != <span class="tok-number">0</span>) : (end_i += <span class="tok-number">1</span>) {}
            <span class="tok-kw">const</span> value = line[line_i + <span class="tok-number">1</span> .. end_i];

            <span class="tok-kw">try</span> result.put(key, value);
        }
        <span class="tok-kw">return</span> result;
    }
}

<span class="tok-kw">test</span> getEnvMap {
    <span class="tok-kw">var</span> env = <span class="tok-kw">try</span> <a href="std.process.html#std.process.getEnvMap">getEnvMap</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> env.deinit();
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetEnvVarOwnedError = <span class="tok-kw">error</span>{
    OutOfMemory,
    EnvironmentVariableNotFound,

    <span class="tok-comment">/// On Windows, environment variable keys provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
};

<span class="tok-comment">/// Caller must free returned memory.</span>
<span class="tok-comment">/// On Windows, if `key` is not valid [WTF-8](https://simonsapin.github.io/wtf-8/),</span>
<span class="tok-comment">/// then `error.InvalidWtf8` is returned.</span>
<span class="tok-comment">/// On Windows, the value is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, the value is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEnvVarOwned</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.GetEnvVarOwnedError">GetEnvVarOwnedError</a>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> result_w = blk: {
            <span class="tok-kw">var</span> stack_alloc = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-number">256</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u16</span>), allocator);
            <span class="tok-kw">const</span> stack_allocator = stack_alloc.get();
            <span class="tok-kw">const</span> key_w = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(stack_allocator, key);
            <span class="tok-kw">defer</span> stack_allocator.free(key_w);

            <span class="tok-kw">break</span> :blk <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        };<span class="tok-comment">
        // wtf16LeToWtf8Alloc can only fail with OutOfMemory
        </span><span class="tok-kw">return</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf16LeToWtf8Alloc">wtf16LeToWtf8Alloc</a>(allocator, result_w);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> envmap = <a href="std.process.html#std.process.getEnvMap">getEnvMap</a>(allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        <span class="tok-kw">defer</span> envmap.deinit();
        <span class="tok-kw">const</span> val = envmap.get(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, val);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> result = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        <span class="tok-kw">return</span> allocator.dupe(<span class="tok-type">u8</span>, result);
    }
}

<span class="tok-comment">/// On Windows, `key` must be valid UTF-8.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasEnvVarConstant</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">comptime</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(key);
        <span class="tok-kw">return</span> <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) != <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;hasEnvVarConstant is not supported for WASI without libc&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) != <span class="tok-null">null</span>;
    }
}

<span class="tok-comment">/// On Windows, `key` must be valid UTF-8.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasNonEmptyEnvVarConstant</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">comptime</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(key);
        <span class="tok-kw">const</span> value = <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;hasNonEmptyEnvVarConstant is not supported for WASI without libc&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> value = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseEnvVarIntError = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.ParseIntError">ParseIntError</a> || <span class="tok-kw">error</span>{EnvironmentVariableNotFound};

<span class="tok-comment">/// Parses an environment variable as an integer.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Since the key is comptime-known, no allocation is needed.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On Windows, `key` must be valid UTF-8.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseEnvVarInt</span>(<span class="tok-kw">comptime</span> key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, base: <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ParseEnvVarIntError">ParseEnvVarIntError</a>!I {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8ToUtf16LeStringLiteral">utf8ToUtf16LeStringLiteral</a>(key);
        <span class="tok-kw">const</span> text = <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseIntWithGenericCharacter">parseIntWithGenericCharacter</a>(I, <span class="tok-type">u16</span>, text, base);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;parseEnvVarInt is not supported for WASI without libc&quot;</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> text = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EnvironmentVariableNotFound;
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(I, text, base);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HasEnvVarError = <span class="tok-kw">error</span>{
    OutOfMemory,

    <span class="tok-comment">/// On Windows, environment variable keys provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
};

<span class="tok-comment">/// On Windows, if `key` is not valid [WTF-8](https://simonsapin.github.io/wtf-8/),</span>
<span class="tok-comment">/// then `error.InvalidWtf8` is returned.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasEnvVar</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.HasEnvVarError">HasEnvVarError</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> stack_alloc = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-number">256</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u16</span>), allocator);
        <span class="tok-kw">const</span> stack_allocator = stack_alloc.get();
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(stack_allocator, key);
        <span class="tok-kw">defer</span> stack_allocator.free(key_w);
        <span class="tok-kw">return</span> <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) != <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> envmap = <a href="std.process.html#std.process.getEnvMap">getEnvMap</a>(allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        <span class="tok-kw">defer</span> envmap.deinit();
        <span class="tok-kw">return</span> envmap.getPtr(key) != <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) != <span class="tok-null">null</span>;
    }
}

<span class="tok-comment">/// On Windows, if `key` is not valid [WTF-8](https://simonsapin.github.io/wtf-8/),</span>
<span class="tok-comment">/// then `error.InvalidWtf8` is returned.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasNonEmptyEnvVar</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.HasEnvVarError">HasEnvVarError</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
        <span class="tok-kw">var</span> stack_alloc = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-number">256</span> * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u16</span>), allocator);
        <span class="tok-kw">const</span> stack_allocator = stack_alloc.get();
        <span class="tok-kw">const</span> key_w = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(stack_allocator, key);
        <span class="tok-kw">defer</span> stack_allocator.free(key_w);
        <span class="tok-kw">const</span> value = <a href="std.process.html#std.process.getenvW">getenvW</a>(key_w) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">var</span> envmap = <a href="std.process.html#std.process.getEnvMap">getEnvMap</a>(allocator) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        <span class="tok-kw">defer</span> envmap.deinit();
        <span class="tok-kw">const</span> value = envmap.getPtr(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> value = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenv">getenv</a>(key) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <span class="tok-kw">return</span> value.len != <span class="tok-number">0</span>;
    }
}

<span class="tok-comment">/// Windows-only. Get an environment variable with a null-terminated, WTF-16 encoded name.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This function performs a Unicode-aware case-insensitive lookup using RtlEqualUnicodeString.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also:</span>
<span class="tok-comment">/// * `std.posix.getenv`</span>
<span class="tok-comment">/// * `getEnvMap`</span>
<span class="tok-comment">/// * `getEnvVarOwned`</span>
<span class="tok-comment">/// * `hasEnvVarConstant`</span>
<span class="tok-comment">/// * `hasEnvVar`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getenvW</span>(key: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u16</span> {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> != .windows) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Windows-only&quot;</span>);
    }
    <span class="tok-kw">const</span> key_slice = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(key, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> ptr = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.Environment;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span>) {
        <span class="tok-kw">const</span> key_start = i;<span class="tok-comment">

        // There are some special environment variables that start with =,
        // so we need a special case to not treat = as a key/value separator
        // if it's the first character.
        // https://devblogs.microsoft.com/oldnewthing/20100506-00/?p=14133
        </span><span class="tok-kw">if</span> (ptr[key_start] == <span class="tok-str">'='</span>) i += <span class="tok-number">1</span>;

        <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span> <span class="tok-kw">and</span> ptr[i] != <span class="tok-str">'='</span>) : (i += <span class="tok-number">1</span>) {}
        <span class="tok-kw">const</span> this_key = ptr[key_start..i];

        <span class="tok-kw">if</span> (ptr[i] == <span class="tok-str">'='</span>) i += <span class="tok-number">1</span>;

        <span class="tok-kw">const</span> value_start = i;
        <span class="tok-kw">while</span> (ptr[i] != <span class="tok-number">0</span>) : (i += <span class="tok-number">1</span>) {}
        <span class="tok-kw">const</span> this_value = ptr[value_start..i :<span class="tok-number">0</span>];

        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.eqlIgnoreCaseWTF16">eqlIgnoreCaseWTF16</a>(key_slice, this_key)) {
            <span class="tok-kw">return</span> this_value;
        }

        i += <span class="tok-number">1</span>;<span class="tok-comment"> // skip over null byte
    </span>}
    <span class="tok-kw">return</span> <span class="tok-null">null</span>;
}

<span class="tok-kw">test</span> getEnvVarOwned {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(
        <span class="tok-kw">error</span>.EnvironmentVariableNotFound,
        <a href="std.process.html#std.process.getEnvVarOwned">getEnvVarOwned</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;BADENV&quot;</span>),
    );
}

<span class="tok-kw">test</span> hasEnvVarConstant {
    <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.process.html#std.process.hasEnvVarConstant">hasEnvVarConstant</a>(<span class="tok-str">&quot;BADENV&quot;</span>));
}

<span class="tok-kw">test</span> hasEnvVar {
    <span class="tok-kw">const</span> has_env = <span class="tok-kw">try</span> <a href="std.process.html#std.process.hasEnvVar">hasEnvVar</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-str">&quot;BADENV&quot;</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!has_env);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArgIteratorPosix = <span class="tok-kw">struct</span> {
    index: <span class="tok-type">usize</span>,
    count: <span class="tok-type">usize</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InitError = <span class="tok-kw">error</span>{};

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>() <a href="std.process.ArgIteratorPosix.html">ArgIteratorPosix</a> {
        <span class="tok-kw">return</span> <a href="std.process.ArgIteratorPosix.html">ArgIteratorPosix</a>{
            .index = <span class="tok-number">0</span>,
            .count = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>.<a href="#">len</a>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.process.ArgIteratorPosix.html">ArgIteratorPosix</a>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">if</span> (self.index == self.count) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

        <span class="tok-kw">const</span> s = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.argv">argv</a>[self.index];
        self.index += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(s, <span class="tok-number">0</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: *<a href="std.process.ArgIteratorPosix.html">ArgIteratorPosix</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.index == self.count) <span class="tok-kw">return</span> <span class="tok-null">false</span>;

        self.index += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArgIteratorWasi = <span class="tok-kw">struct</span> {
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    index: <span class="tok-type">usize</span>,
    args: [][:<span class="tok-number">0</span>]<span class="tok-type">u8</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InitError = <span class="tok-kw">error</span>{OutOfMemory} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

    <span class="tok-comment">/// You must call deinit to free the internal buffer of the</span>
    <span class="tok-comment">/// iterator after you are done.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.ArgIteratorWasi.html#std.process.ArgIteratorWasi.InitError">InitError</a>!<a href="std.process.ArgIteratorWasi.html">ArgIteratorWasi</a> {
        <span class="tok-kw">const</span> fetched_args = <span class="tok-kw">try</span> <a href="std.process.ArgIteratorWasi.html">ArgIteratorWasi</a>.<a href="std.process.ArgIteratorWasi.html#std.process.ArgIteratorWasi.internalInit">internalInit</a>(allocator);
        <span class="tok-kw">return</span> <a href="std.process.ArgIteratorWasi.html">ArgIteratorWasi</a>{
            .allocator = allocator,
            .index = <span class="tok-number">0</span>,
            .args = fetched_args,
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">internalInit</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.ArgIteratorWasi.html#std.process.ArgIteratorWasi.InitError">InitError</a>![][:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
        <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> buf_size: <span class="tok-type">usize</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.args_sizes_get">args_sizes_get</a>(&amp;count, &amp;buf_size)) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }

        <span class="tok-kw">if</span> (count == <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> &amp;[_][:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};
        }

        <span class="tok-kw">const</span> argv = <span class="tok-kw">try</span> allocator.alloc([*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, count);
        <span class="tok-kw">defer</span> allocator.free(argv);

        <span class="tok-kw">const</span> argv_buf = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, buf_size);

        <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.html#std.os.wasi.args_get">args_get</a>(argv.ptr, argv_buf.ptr)) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        }

        <span class="tok-kw">var</span> result_args = <span class="tok-kw">try</span> allocator.alloc([:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, count);
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; count) : (i += <span class="tok-number">1</span>) {
            result_args[i] = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(argv[i], <span class="tok-number">0</span>);
        }

        <span class="tok-kw">return</span> result_args;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.process.ArgIteratorWasi.html">ArgIteratorWasi</a>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">if</span> (self.index == self.args.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;

        <span class="tok-kw">const</span> arg = self.args[self.index];
        self.index += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> arg;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: *<a href="std.process.ArgIteratorWasi.html">ArgIteratorWasi</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.index == self.args.len) <span class="tok-kw">return</span> <span class="tok-null">false</span>;

        self.index += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Call to free the internal buffer of the iterator.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.ArgIteratorWasi.html">ArgIteratorWasi</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> last_item = self.args[self.args.len - <span class="tok-number">1</span>];
        <span class="tok-kw">const</span> last_byte_addr = <span class="tok-builtin">@intFromPtr</span>(last_item.ptr) + last_item.len + <span class="tok-number">1</span>;<span class="tok-comment"> // null terminated
        </span><span class="tok-kw">const</span> first_item_ptr = self.args[<span class="tok-number">0</span>].ptr;
        <span class="tok-kw">const</span> len = last_byte_addr - <span class="tok-builtin">@intFromPtr</span>(first_item_ptr);
        self.allocator.free(first_item_ptr[<span class="tok-number">0</span>..len]);
        self.allocator.free(self.args);
    }
};

<span class="tok-comment">/// Iterator that implements the Windows command-line parsing algorithm.</span>
<span class="tok-comment">/// The implementation is intended to be compatible with the post-2008 C runtime,</span>
<span class="tok-comment">/// but is *not* intended to be compatible with `CommandLineToArgvW` since</span>
<span class="tok-comment">/// `CommandLineToArgvW` uses the pre-2008 parsing rules.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This iterator faithfully implements the parsing behavior observed from the C runtime with</span>
<span class="tok-comment">/// one exception: if the command-line string is empty, the iterator will immediately complete</span>
<span class="tok-comment">/// without returning any arguments (whereas the C runtime will return a single argument</span>
<span class="tok-comment">/// representing the name of the current executable).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The essential parts of the algorithm are described in Microsoft's documentation:</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// - https://learn.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-170#parsing-c-command-line-arguments</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// David Deley explains some additional undocumented quirks in great detail:</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// - https://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULES</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArgIteratorWindows = <span class="tok-kw">struct</span> {
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    <span class="tok-comment">/// Encoded as WTF-16 LE.</span>
    cmd_line: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>,
    index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    <span class="tok-comment">/// Owned by the iterator. Long enough to hold contiguous NUL-terminated slices</span>
    <span class="tok-comment">/// of each argument encoded as WTF-8.</span>
    buffer: []<span class="tok-type">u8</span>,
    start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
    end: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InitError = <span class="tok-kw">error</span>{OutOfMemory};

    <span class="tok-comment">/// `cmd_line_w` *must* be a WTF16-LE-encoded string.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The iterator stores and uses `cmd_line_w`, so its memory must be valid for</span>
    <span class="tok-comment">/// at least as long as the returned ArgIteratorWindows.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_w: []<span class="tok-kw">const</span> <span class="tok-type">u16</span>) <a href="std.process.ArgIteratorWindows.html#std.process.ArgIteratorWindows.InitError">InitError</a>!<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a> {
        <span class="tok-kw">const</span> wtf8_len = <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.calcWtf8Len">calcWtf8Len</a>(cmd_line_w);<span class="tok-comment">

        // This buffer must be large enough to contain contiguous NUL-terminated slices
        // of each argument.
        // - During parsing, the length of a parsed argument will always be equal to
        //   to less than its unparsed length
        // - The first argument needs one extra byte of space allocated for its NUL
        //   terminator, but for each subsequent argument the necessary whitespace
        //   between arguments guarantees room for their NUL terminator(s).
        </span><span class="tok-kw">const</span> buffer = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, wtf8_len + <span class="tok-number">1</span>);
        <span class="tok-kw">errdefer</span> allocator.free(buffer);

        <span class="tok-kw">return</span> .{
            .allocator = allocator,
            .cmd_line = cmd_line_w,
            .buffer = buffer,
        };
    }

    <span class="tok-comment">/// Returns the next argument and advances the iterator. Returns `null` if at the end of the</span>
    <span class="tok-comment">/// command-line string. The iterator owns the returned slice.</span>
    <span class="tok-comment">/// The result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">return</span> self.nextWithStrategy(<a href="std.process.ArgIteratorWindows.next_strategy.html">next_strategy</a>);
    }

    <span class="tok-comment">/// Skips the next argument and advances the iterator. Returns `true` if an argument was</span>
    <span class="tok-comment">/// skipped, `false` if at the end of the command-line string.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.nextWithStrategy(<a href="std.process.ArgIteratorWindows.skip_strategy.html">skip_strategy</a>);
    }

    <span class="tok-kw">const</span> next_strategy = <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> T = ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>;

        <span class="tok-kw">const</span> eof = <span class="tok-null">null</span>;

        <span class="tok-comment">/// Returns '\' if any backslashes are emitted, otherwise returns `last_emitted_code_unit`.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">emitBackslashes</span>(self: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>, count: <span class="tok-type">usize</span>, last_emitted_code_unit: ?<span class="tok-type">u16</span>) ?<span class="tok-type">u16</span> {
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..count) |_| {
                self.buffer[self.end] = <span class="tok-str">'\\'</span>;
                self.end += <span class="tok-number">1</span>;
            }
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (count != <span class="tok-number">0</span>) <span class="tok-str">'\\'</span> <span class="tok-kw">else</span> last_emitted_code_unit;
        }

        <span class="tok-comment">/// If `last_emitted_code_unit` and `code_unit` form a surrogate pair, then</span>
        <span class="tok-comment">/// the previously emitted high surrogate is overwritten by the codepoint encoded</span>
        <span class="tok-comment">/// by the surrogate pair, and `null` is returned.</span>
        <span class="tok-comment">/// Otherwise, `code_unit` is emitted and returned.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">emitCharacter</span>(self: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>, code_unit: <span class="tok-type">u16</span>, last_emitted_code_unit: ?<span class="tok-type">u16</span>) ?<span class="tok-type">u16</span> {<span class="tok-comment">
            // Because we are emitting WTF-8, we need to
            // check to see if we've emitted two consecutive surrogate
            // codepoints that form a valid surrogate pair in order
            // to ensure that we're always emitting well-formed WTF-8
            // (https://simonsapin.github.io/wtf-8/#concatenating).
            //
            // If we do have a valid surrogate pair, we need to emit
            // the UTF-8 sequence for the codepoint that they encode
            // instead of the WTF-8 encoding for the two surrogate pairs
            // separately.
            //
            // This is relevant when dealing with a WTF-16 encoded
            // command line like this:
            // &quot;&lt;0xD801&gt;&quot;&lt;0xDC37&gt;
            // which would get parsed and converted to WTF-8 as:
            // &lt;0xED&gt;&lt;0xA0&gt;&lt;0x81&gt;&lt;0xED&gt;&lt;0xB0&gt;&lt;0xB7&gt;
            // but instead, we need to recognize the surrogate pair
            // and emit the codepoint it encodes, which in this
            // example is U+10437 (𐐷), which is encoded in UTF-8 as:
            // &lt;0xF0&gt;&lt;0x90&gt;&lt;0x90&gt;&lt;0xB7&gt;
            </span><span class="tok-kw">if</span> (last_emitted_code_unit != <span class="tok-null">null</span> <span class="tok-kw">and</span>
                <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16IsLowSurrogate">utf16IsLowSurrogate</a>(code_unit) <span class="tok-kw">and</span>
                <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16IsHighSurrogate">utf16IsHighSurrogate</a>(last_emitted_code_unit.?))
            {
                <span class="tok-kw">const</span> codepoint = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf16DecodeSurrogatePair">utf16DecodeSurrogatePair</a>(&amp;.{ last_emitted_code_unit.?, code_unit }) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment">

                // Unpaired surrogate is 3 bytes long
                </span><span class="tok-kw">const</span> dest = self.buffer[self.end - <span class="tok-number">3</span> ..];
                <span class="tok-kw">const</span> len = <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.utf8Encode">utf8Encode</a>(codepoint, dest) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;<span class="tok-comment">
                // All codepoints that require a surrogate pair (&gt; U+FFFF) are encoded as 4 bytes
                </span><a href="std.debug.html#std.debug.assert">assert</a>(len == <span class="tok-number">4</span>);
                self.end += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }

            <span class="tok-kw">const</span> wtf8_len = <a href="std.html">std</a>.<a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8Encode">wtf8Encode</a>(code_unit, self.buffer[self.end..]) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            self.end += wtf8_len;
            <span class="tok-kw">return</span> code_unit;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">yieldArg</span>(self: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            self.buffer[self.end] = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> arg = self.buffer[self.start..self.end :<span class="tok-number">0</span>];
            self.end += <span class="tok-number">1</span>;
            self.start = self.end;
            <span class="tok-kw">return</span> arg;
        }
    };

    <span class="tok-kw">const</span> skip_strategy = <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> T = <span class="tok-type">bool</span>;

        <span class="tok-kw">const</span> eof = <span class="tok-null">false</span>;

        <span class="tok-kw">fn</span> <span class="tok-fn">emitBackslashes</span>(_: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>, _: <span class="tok-type">usize</span>, last_emitted_code_unit: ?<span class="tok-type">u16</span>) ?<span class="tok-type">u16</span> {
            <span class="tok-kw">return</span> last_emitted_code_unit;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">emitCharacter</span>(_: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>, _: <span class="tok-type">u16</span>, last_emitted_code_unit: ?<span class="tok-type">u16</span>) ?<span class="tok-type">u16</span> {
            <span class="tok-kw">return</span> last_emitted_code_unit;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">yieldArg</span>(_: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">nextWithStrategy</span>(self: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>, <span class="tok-kw">comptime</span> strategy: <span class="tok-type">type</span>) strategy.T {
        <span class="tok-kw">var</span> last_emitted_code_unit: ?<span class="tok-type">u16</span> = <span class="tok-null">null</span>;<span class="tok-comment">
        // The first argument (the executable name) uses different parsing rules.
        </span><span class="tok-kw">if</span> (self.index == <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (self.cmd_line.len == <span class="tok-number">0</span> <span class="tok-kw">or</span> self.cmd_line[<span class="tok-number">0</span>] == <span class="tok-number">0</span>) {<span class="tok-comment">
                // Immediately complete the iterator.
                // The C runtime would return the name of the current executable here.
                </span><span class="tok-kw">return</span> strategy.eof;
            }

            <span class="tok-kw">var</span> inside_quotes = <span class="tok-null">false</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> char = <span class="tok-kw">if</span> (self.index != self.cmd_line.len)
                    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(<span class="tok-type">u16</span>, self.cmd_line[self.index])
                <span class="tok-kw">else</span>
                    <span class="tok-number">0</span>;
                <span class="tok-kw">switch</span> (char) {
                    <span class="tok-number">0</span> =&gt; {
                        <span class="tok-kw">return</span> strategy.yieldArg(self);
                    },
                    <span class="tok-str">'&quot;'</span> =&gt; {
                        inside_quotes = !inside_quotes;
                    },
                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span> =&gt; {
                        <span class="tok-kw">if</span> (inside_quotes) {
                            last_emitted_code_unit = strategy.emitCharacter(self, char, last_emitted_code_unit);
                        } <span class="tok-kw">else</span> {
                            self.index += <span class="tok-number">1</span>;
                            <span class="tok-kw">return</span> strategy.yieldArg(self);
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        last_emitted_code_unit = strategy.emitCharacter(self, char, last_emitted_code_unit);
                    },
                }
            }
        }<span class="tok-comment">

        // Skip spaces and tabs. The iterator completes if we reach the end of the string here.
        </span><span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> char = <span class="tok-kw">if</span> (self.index != self.cmd_line.len)
                <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(<span class="tok-type">u16</span>, self.cmd_line[self.index])
            <span class="tok-kw">else</span>
                <span class="tok-number">0</span>;
            <span class="tok-kw">switch</span> (char) {
                <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> strategy.eof,
                <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span> =&gt; <span class="tok-kw">continue</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
            }
        }<span class="tok-comment">

        // Parsing rules for subsequent arguments:
        //
        // - The end of the string always terminates the current argument.
        // - When not in 'inside_quotes' mode, a space or tab terminates the current argument.
        // - 2n backslashes followed by a quote emit n backslashes (note: n can be zero).
        //   If in 'inside_quotes' and the quote is immediately followed by a second quote,
        //   one quote is emitted and the other is skipped, otherwise, the quote is skipped
        //   and 'inside_quotes' is toggled.
        // - 2n + 1 backslashes followed by a quote emit n backslashes followed by a quote.
        // - n backslashes not followed by a quote emit n backslashes.
        </span><span class="tok-kw">var</span> backslash_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> inside_quotes = <span class="tok-null">false</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> char = <span class="tok-kw">if</span> (self.index != self.cmd_line.len)
                <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(<span class="tok-type">u16</span>, self.cmd_line[self.index])
            <span class="tok-kw">else</span>
                <span class="tok-number">0</span>;
            <span class="tok-kw">switch</span> (char) {
                <span class="tok-number">0</span> =&gt; {
                    last_emitted_code_unit = strategy.emitBackslashes(self, backslash_count, last_emitted_code_unit);
                    <span class="tok-kw">return</span> strategy.yieldArg(self);
                },
                <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span> =&gt; {
                    last_emitted_code_unit = strategy.emitBackslashes(self, backslash_count, last_emitted_code_unit);
                    backslash_count = <span class="tok-number">0</span>;
                    <span class="tok-kw">if</span> (inside_quotes) {
                        last_emitted_code_unit = strategy.emitCharacter(self, char, last_emitted_code_unit);
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> strategy.yieldArg(self);
                },
                <span class="tok-str">'&quot;'</span> =&gt; {
                    <span class="tok-kw">const</span> char_is_escaped_quote = backslash_count % <span class="tok-number">2</span> != <span class="tok-number">0</span>;
                    last_emitted_code_unit = strategy.emitBackslashes(self, backslash_count / <span class="tok-number">2</span>, last_emitted_code_unit);
                    backslash_count = <span class="tok-number">0</span>;
                    <span class="tok-kw">if</span> (char_is_escaped_quote) {
                        last_emitted_code_unit = strategy.emitCharacter(self, <span class="tok-str">'&quot;'</span>, last_emitted_code_unit);
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">if</span> (inside_quotes <span class="tok-kw">and</span>
                            self.index + <span class="tok-number">1</span> != self.cmd_line.len <span class="tok-kw">and</span>
                            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(<span class="tok-type">u16</span>, self.cmd_line[self.index + <span class="tok-number">1</span>]) == <span class="tok-str">'&quot;'</span>)
                        {
                            last_emitted_code_unit = strategy.emitCharacter(self, <span class="tok-str">'&quot;'</span>, last_emitted_code_unit);
                            self.index += <span class="tok-number">1</span>;
                        } <span class="tok-kw">else</span> {
                            inside_quotes = !inside_quotes;
                        }
                    }
                },
                <span class="tok-str">'\\'</span> =&gt; {
                    backslash_count += <span class="tok-number">1</span>;
                },
                <span class="tok-kw">else</span> =&gt; {
                    last_emitted_code_unit = strategy.emitBackslashes(self, backslash_count, last_emitted_code_unit);
                    backslash_count = <span class="tok-number">0</span>;
                    last_emitted_code_unit = strategy.emitCharacter(self, char, last_emitted_code_unit);
                },
            }
        }
    }

    <span class="tok-comment">/// Frees the iterator's copy of the command-line string and all previously returned</span>
    <span class="tok-comment">/// argument slices.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>) <span class="tok-type">void</span> {
        self.allocator.free(self.buffer);
    }
};

<span class="tok-comment">/// Optional parameters for `ArgIteratorGeneral`</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArgIteratorGeneralOptions = <span class="tok-kw">struct</span> {
    comments: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    single_quotes: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
};

<span class="tok-comment">/// A general Iterator to parse a string into a set of arguments</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArgIteratorGeneral</span>(<span class="tok-kw">comptime</span> options: <a href="std.process.ArgIteratorGeneralOptions.html">ArgIteratorGeneralOptions</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        cmd_line: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

        <span class="tok-comment">/// Should the cmd_line field be free'd (using the allocator) on deinit()?</span>
        free_cmd_line_on_deinit: <span class="tok-type">bool</span>,

        <span class="tok-comment">/// buffer MUST be long enough to hold the cmd_line plus a null terminator.</span>
        <span class="tok-comment">/// buffer will we free'd (using the allocator) on deinit()</span>
        buffer: []<span class="tok-type">u8</span>,
        start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
        end: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InitError = <span class="tok-kw">error</span>{OutOfMemory};

        <span class="tok-comment">/// cmd_line_utf8 MUST remain valid and constant while using this instance</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ArgIteratorGeneral.InitError">InitError</a>!<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a> {
            <span class="tok-kw">const</span> buffer = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, cmd_line_utf8.len + <span class="tok-number">1</span>);
            <span class="tok-kw">errdefer</span> allocator.free(buffer);

            <span class="tok-kw">return</span> <a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>{
                .allocator = allocator,
                .cmd_line = cmd_line_utf8,
                .free_cmd_line_on_deinit = <span class="tok-null">false</span>,
                .buffer = buffer,
            };
        }

        <span class="tok-comment">/// cmd_line_utf8 will be free'd (with the allocator) on deinit()</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initTakeOwnership</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, cmd_line_utf8: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ArgIteratorGeneral.InitError">InitError</a>!<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a> {
            <span class="tok-kw">const</span> buffer = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, cmd_line_utf8.len + <span class="tok-number">1</span>);
            <span class="tok-kw">errdefer</span> allocator.free(buffer);

            <span class="tok-kw">return</span> <a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>{
                .allocator = allocator,
                .cmd_line = cmd_line_utf8,
                .free_cmd_line_on_deinit = <span class="tok-null">true</span>,
                .buffer = buffer,
            };
        }<span class="tok-comment">

        // Skips over whitespace in the cmd_line.
        // Returns false if the terminating sentinel is reached, true otherwise.
        // Also skips over comments (if supported).
        </span><span class="tok-kw">fn</span> <span class="tok-fn">skipWhitespace</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> character = <span class="tok-kw">if</span> (self.index != self.cmd_line.len) self.cmd_line[self.index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                <span class="tok-kw">switch</span> (character) {
                    <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">continue</span>,
                    <span class="tok-str">'#'</span> =&gt; {
                        <span class="tok-kw">if</span> (options.comments) {
                            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                                <span class="tok-kw">switch</span> (self.cmd_line[self.index]) {
                                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">break</span>,
                                    <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                                }
                            }
                            <span class="tok-kw">continue</span>;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">break</span>;
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span>,
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (!self.skipWhitespace()) {
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }

            <span class="tok-kw">var</span> backslash_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> in_quote = <span class="tok-null">false</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> character = <span class="tok-kw">if</span> (self.index != self.cmd_line.len) self.cmd_line[self.index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                <span class="tok-kw">switch</span> (character) {
                    <span class="tok-number">0</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
                    <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\''</span> =&gt; {
                        <span class="tok-kw">if</span> (!options.single_quotes <span class="tok-kw">and</span> character == <span class="tok-str">'\''</span>) {
                            backslash_count = <span class="tok-number">0</span>;
                            <span class="tok-kw">continue</span>;
                        }
                        <span class="tok-kw">const</span> quote_is_real = backslash_count % <span class="tok-number">2</span> == <span class="tok-number">0</span>;
                        <span class="tok-kw">if</span> (quote_is_real) {
                            in_quote = !in_quote;
                        }
                    },
                    <span class="tok-str">'\\'</span> =&gt; {
                        backslash_count += <span class="tok-number">1</span>;
                    },
                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span> =&gt; {
                        <span class="tok-kw">if</span> (!in_quote) {
                            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                        }
                        backslash_count = <span class="tok-number">0</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        backslash_count = <span class="tok-number">0</span>;
                        <span class="tok-kw">continue</span>;
                    },
                }
            }
        }

        <span class="tok-comment">/// Returns a slice of the internal buffer that contains the next argument.</span>
        <span class="tok-comment">/// Returns null when it reaches the end.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) ?[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
            <span class="tok-kw">if</span> (!self.skipWhitespace()) {
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            }

            <span class="tok-kw">var</span> backslash_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> in_quote = <span class="tok-null">false</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (self.index += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> character = <span class="tok-kw">if</span> (self.index != self.cmd_line.len) self.cmd_line[self.index] <span class="tok-kw">else</span> <span class="tok-number">0</span>;
                <span class="tok-kw">switch</span> (character) {
                    <span class="tok-number">0</span> =&gt; {
                        self.emitBackslashes(backslash_count);
                        self.buffer[self.end] = <span class="tok-number">0</span>;
                        <span class="tok-kw">const</span> token = self.buffer[self.start..self.end :<span class="tok-number">0</span>];
                        self.end += <span class="tok-number">1</span>;
                        self.start = self.end;
                        <span class="tok-kw">return</span> token;
                    },
                    <span class="tok-str">'&quot;'</span>, <span class="tok-str">'\''</span> =&gt; {
                        <span class="tok-kw">if</span> (!options.single_quotes <span class="tok-kw">and</span> character == <span class="tok-str">'\''</span>) {
                            self.emitBackslashes(backslash_count);
                            backslash_count = <span class="tok-number">0</span>;
                            self.emitCharacter(character);
                            <span class="tok-kw">continue</span>;
                        }
                        <span class="tok-kw">const</span> quote_is_real = backslash_count % <span class="tok-number">2</span> == <span class="tok-number">0</span>;
                        self.emitBackslashes(backslash_count / <span class="tok-number">2</span>);
                        backslash_count = <span class="tok-number">0</span>;

                        <span class="tok-kw">if</span> (quote_is_real) {
                            in_quote = !in_quote;
                        } <span class="tok-kw">else</span> {
                            self.emitCharacter(<span class="tok-str">'&quot;'</span>);
                        }
                    },
                    <span class="tok-str">'\\'</span> =&gt; {
                        backslash_count += <span class="tok-number">1</span>;
                    },
                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\r'</span>, <span class="tok-str">'\n'</span> =&gt; {
                        self.emitBackslashes(backslash_count);
                        backslash_count = <span class="tok-number">0</span>;
                        <span class="tok-kw">if</span> (in_quote) {
                            self.emitCharacter(character);
                        } <span class="tok-kw">else</span> {
                            self.buffer[self.end] = <span class="tok-number">0</span>;
                            <span class="tok-kw">const</span> token = self.buffer[self.start..self.end :<span class="tok-number">0</span>];
                            self.end += <span class="tok-number">1</span>;
                            self.start = self.end;
                            <span class="tok-kw">return</span> token;
                        }
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        self.emitBackslashes(backslash_count);
                        backslash_count = <span class="tok-number">0</span>;
                        self.emitCharacter(character);
                    },
                }
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">emitBackslashes</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>, emit_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (i &lt; emit_count) : (i += <span class="tok-number">1</span>) {
                self.emitCharacter(<span class="tok-str">'\\'</span>);
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">emitCharacter</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>, char: <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            self.buffer[self.end] = char;
            self.end += <span class="tok-number">1</span>;
        }

        <span class="tok-comment">/// Call to free the internal buffer of the iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.html#std.process.ArgIteratorGeneral">Self</a>) <span class="tok-type">void</span> {
            self.allocator.free(self.buffer);

            <span class="tok-kw">if</span> (self.free_cmd_line_on_deinit) {
                self.allocator.free(self.cmd_line);
            }
        }
    };
}

<span class="tok-comment">/// Cross-platform command line argument iterator.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArgIterator = <span class="tok-kw">struct</span> {
    <span class="tok-kw">const</span> InnerType = <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
        .windows =&gt; <a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>,
        .wasi =&gt; <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <a href="std.process.ArgIteratorPosix.html">ArgIteratorPosix</a> <span class="tok-kw">else</span> <a href="std.process.ArgIteratorWasi.html">ArgIteratorWasi</a>,
        <span class="tok-kw">else</span> =&gt; <a href="std.process.ArgIteratorPosix.html">ArgIteratorPosix</a>,
    };

    inner: <a href="std.process.ArgIterator.html#std.process.ArgIterator.InnerType">InnerType</a>,

    <span class="tok-comment">/// Initialize the args iterator. Consider using initWithAllocator() instead</span>
    <span class="tok-comment">/// for cross-platform compatibility.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>() <a href="std.process.ArgIterator.html">ArgIterator</a> {
        <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;In WASI, use initWithAllocator instead.&quot;</span>);
        }
        <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;In Windows, use initWithAllocator instead.&quot;</span>);
        }

        <span class="tok-kw">return</span> <a href="std.process.ArgIterator.html">ArgIterator</a>{ .inner = <a href="std.process.ArgIterator.html#std.process.ArgIterator.InnerType">InnerType</a>.<a href="#">init</a>() };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InitError = <a href="std.process.ArgIterator.html#std.process.ArgIterator.InnerType">InnerType</a>.<a href="#">InitError</a>;

    <span class="tok-comment">/// You must deinitialize iterator's internal buffers by calling `deinit` when done.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithAllocator</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.ArgIterator.html#std.process.ArgIterator.InitError">InitError</a>!<a href="std.process.ArgIterator.html">ArgIterator</a> {
        <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">return</span> <a href="std.process.ArgIterator.html">ArgIterator</a>{ .inner = <span class="tok-kw">try</span> <a href="std.process.ArgIterator.html#std.process.ArgIterator.InnerType">InnerType</a>.<a href="#">init</a>(allocator) };
        }
        <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
            <span class="tok-kw">const</span> cmd_line = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.peb">peb</a>().ProcessParameters.CommandLine;
            <span class="tok-kw">const</span> cmd_line_w = cmd_line.Buffer.?[<span class="tok-number">0</span> .. cmd_line.Length / <span class="tok-number">2</span>];
            <span class="tok-kw">return</span> <a href="std.process.ArgIterator.html">ArgIterator</a>{ .inner = <span class="tok-kw">try</span> <a href="std.process.ArgIterator.html#std.process.ArgIterator.InnerType">InnerType</a>.<a href="#">init</a>(allocator, cmd_line_w) };
        }

        <span class="tok-kw">return</span> <a href="std.process.ArgIterator.html">ArgIterator</a>{ .inner = <a href="std.process.ArgIterator.html#std.process.ArgIterator.InnerType">InnerType</a>.<a href="#">init</a>() };
    }

    <span class="tok-comment">/// Get the next argument. Returns 'null' if we are at the end.</span>
    <span class="tok-comment">/// Returned slice is pointing to the iterator's internal buffer.</span>
    <span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
    <span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(self: *<a href="std.process.ArgIterator.html">ArgIterator</a>) ?([:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {
        <span class="tok-kw">return</span> self.inner.next();
    }

    <span class="tok-comment">/// Parse past 1 argument without capturing it.</span>
    <span class="tok-comment">/// Returns `true` if skipped an arg, `false` if we are at the end.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">skip</span>(self: *<a href="std.process.ArgIterator.html">ArgIterator</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.inner.skip();
    }

    <span class="tok-comment">/// Call this to free the iterator's internal buffer if the iterator</span>
    <span class="tok-comment">/// was created with `initWithAllocator` function.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.process.ArgIterator.html">ArgIterator</a>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Unless we're targeting WASI or Windows, this is a no-op.
        </span><span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            self.inner.deinit();
        }

        <span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a> == .windows) {
            self.inner.deinit();
        }
    }
};

<span class="tok-comment">/// Holds the command-line arguments, with the program name as the first entry.</span>
<span class="tok-comment">/// Use argsWithAllocator() for cross-platform code.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">args</span>() <a href="std.process.ArgIterator.html">ArgIterator</a> {
    <span class="tok-kw">return</span> <a href="std.process.ArgIterator.html">ArgIterator</a>.<a href="std.process.ArgIterator.html#std.process.ArgIterator.init">init</a>();
}

<span class="tok-comment">/// You must deinitialize iterator's internal buffers by calling `deinit` when done.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsWithAllocator</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.process.ArgIterator.html">ArgIterator</a>.<a href="std.process.ArgIterator.html#std.process.ArgIterator.InitError">InitError</a>!<a href="std.process.ArgIterator.html">ArgIterator</a> {
    <span class="tok-kw">return</span> <a href="std.process.ArgIterator.html">ArgIterator</a>.<a href="std.process.ArgIterator.html#std.process.ArgIterator.initWithAllocator">initWithAllocator</a>(allocator);
}

<span class="tok-comment">/// Caller must call argsFree on result.</span>
<span class="tok-comment">/// On Windows, the result is encoded as [WTF-8](https://simonsapin.github.io/wtf-8/).</span>
<span class="tok-comment">/// On other platforms, the result is an opaque sequence of bytes with no particular encoding.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsAlloc</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) ![][:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {<span class="tok-comment">
    // TODO refactor to only make 1 allocation.
    </span><span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.process.html#std.process.argsWithAllocator">argsWithAllocator</a>(allocator);
    <span class="tok-kw">defer</span> it.deinit();

    <span class="tok-kw">var</span> contents = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
    <span class="tok-kw">defer</span> contents.deinit();

    <span class="tok-kw">var</span> slice_list = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">usize</span>).init(allocator);
    <span class="tok-kw">defer</span> slice_list.deinit();

    <span class="tok-kw">while</span> (it.next()) |arg| {
        <span class="tok-kw">try</span> contents.appendSlice(arg[<span class="tok-number">0</span> .. arg.len + <span class="tok-number">1</span>]);
        <span class="tok-kw">try</span> slice_list.append(arg.len);
    }

    <span class="tok-kw">const</span> contents_slice = contents.items;
    <span class="tok-kw">const</span> slice_sizes = slice_list.items;
    <span class="tok-kw">const</span> slice_list_bytes = <span class="tok-kw">try</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mul">mul</a>(<span class="tok-type">usize</span>, <span class="tok-builtin">@sizeOf</span>([]<span class="tok-type">u8</span>), slice_sizes.len);
    <span class="tok-kw">const</span> total_bytes = <span class="tok-kw">try</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">usize</span>, slice_list_bytes, contents_slice.len);
    <span class="tok-kw">const</span> buf = <span class="tok-kw">try</span> allocator.alignedAlloc(<span class="tok-type">u8</span>, <span class="tok-builtin">@alignOf</span>([]<span class="tok-type">u8</span>), total_bytes);
    <span class="tok-kw">errdefer</span> allocator.free(buf);

    <span class="tok-kw">const</span> result_slice_list = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>([:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, buf[<span class="tok-number">0</span>..slice_list_bytes]);
    <span class="tok-kw">const</span> result_contents = buf[slice_list_bytes..];
    <span class="tok-builtin">@memcpy</span>(result_contents[<span class="tok-number">0</span>..contents_slice.len], contents_slice);

    <span class="tok-kw">var</span> contents_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (slice_sizes, <span class="tok-number">0</span>..) |len, i| {
        <span class="tok-kw">const</span> new_index = contents_index + len;
        result_slice_list[i] = result_contents[contents_index..new_index :<span class="tok-number">0</span>];
        contents_index = new_index + <span class="tok-number">1</span>;
    }

    <span class="tok-kw">return</span> result_slice_list;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">argsFree</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, args_alloc: []<span class="tok-kw">const</span> [:<span class="tok-number">0</span>]<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> total_bytes: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (args_alloc) |arg| {
        total_bytes += <span class="tok-builtin">@sizeOf</span>([]<span class="tok-type">u8</span>) + arg.len + <span class="tok-number">1</span>;
    }
    <span class="tok-kw">const</span> unaligned_allocated_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(args_alloc.ptr))[<span class="tok-number">0</span>..total_bytes];
    <span class="tok-kw">const</span> aligned_allocated_buf: []<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>([]<span class="tok-type">u8</span>)) <span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-builtin">@alignCast</span>(unaligned_allocated_buf);
    <span class="tok-kw">return</span> allocator.free(aligned_allocated_buf);
}

<span class="tok-kw">test</span> ArgIteratorWindows {
    <span class="tok-kw">const</span> t = <a href="std.process.html#std.process.testArgIteratorWindows">testArgIteratorWindows</a>;

    <span class="tok-kw">try</span> t(
        <span class="tok-str">\\&quot;C:\Program Files\zig\zig.exe&quot; run .\src\main.zig -target x86_64-windows-gnu -O ReleaseSafe -- --emoji=🗿 --eval=&quot;new Regex(\&quot;Dwayne \\\&quot;The Rock\\\&quot; Johnson\&quot;)&quot;</span>
    , &amp;.{
        <span class="tok-str">\\C:\Program Files\zig\zig.exe</span>
        ,
        <span class="tok-str">\\run</span>
        ,
        <span class="tok-str">\\.\src\main.zig</span>
        ,
        <span class="tok-str">\\-target</span>
        ,
        <span class="tok-str">\\x86_64-windows-gnu</span>
        ,
        <span class="tok-str">\\-O</span>
        ,
        <span class="tok-str">\\ReleaseSafe</span>
        ,
        <span class="tok-str">\\--</span>
        ,
        <span class="tok-str">\\--emoji=🗿</span>
        ,
        <span class="tok-str">\\--eval=new Regex(&quot;Dwayne \&quot;The Rock\&quot; Johnson&quot;)</span>
        ,
    });<span class="tok-comment">

    // Empty
    </span><span class="tok-kw">try</span> t(<span class="tok-str">&quot;&quot;</span>, &amp;.{});<span class="tok-comment">

    // Separators
    </span><span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa bb cc&quot;</span>, &amp;.{ <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-str">&quot;bb&quot;</span>, <span class="tok-str">&quot;cc&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\tbb\tcc&quot;</span>, &amp;.{ <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-str">&quot;bb&quot;</span>, <span class="tok-str">&quot;cc&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\nbb\ncc&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\nbb\ncc&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\r\nbb\r\ncc&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\r\nbb\r\ncc&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\rbb\rcc&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\rbb\rcc&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\x07bb\x07cc&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\x07bb\x07cc&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\x7Fbb\x7Fcc&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\x7Fbb\x7Fcc&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa🦎bb🦎cc&quot;</span>, &amp;.{<span class="tok-str">&quot;aa🦎bb🦎cc&quot;</span>});<span class="tok-comment">

    // Leading/trailing whitespace
    </span><span class="tok-kw">try</span> t(<span class="tok-str">&quot;  &quot;</span>, &amp;.{<span class="tok-str">&quot;&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;  aa  bb  &quot;</span>, &amp;.{ <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-str">&quot;bb&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\t\t&quot;</span>, &amp;.{<span class="tok-str">&quot;&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\t\taa\t\tbb\t\t&quot;</span>, &amp;.{ <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;aa&quot;</span>, <span class="tok-str">&quot;bb&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\n\n&quot;</span>, &amp;.{<span class="tok-str">&quot;\n\n&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\n\naa\n\nbb\n\n&quot;</span>, &amp;.{<span class="tok-str">&quot;\n\naa\n\nbb\n\n&quot;</span>});<span class="tok-comment">

    // Executable name with quotes/backslashes
    </span><span class="tok-kw">try</span> t(<span class="tok-str">&quot;\&quot;aa bb\tcc\ndd\&quot;&quot;</span>, &amp;.{<span class="tok-str">&quot;aa bb\tcc\ndd&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\&quot;&quot;</span>, &amp;.{<span class="tok-str">&quot;&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\&quot;\&quot;&quot;</span>, &amp;.{<span class="tok-str">&quot;&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{<span class="tok-str">&quot;&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{<span class="tok-str">&quot;&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{<span class="tok-str">&quot;&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\&quot;bb\&quot;cc\&quot;dd&quot;</span>, &amp;.{<span class="tok-str">&quot;aabbccdd&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\&quot;bb cc\&quot;dd&quot;</span>, &amp;.{<span class="tok-str">&quot;aabb ccdd&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\&quot;aa\\\&quot;bb\&quot;&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\\bb&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;\&quot;aa\\\\\&quot;&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\\\\&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\\\&quot;bb&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\\bb&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;aa\\\\\&quot;bb&quot;</span>, &amp;.{<span class="tok-str">&quot;aa\\\\bb&quot;</span>});<span class="tok-comment">

    // Arguments with quotes/backslashes
    </span><span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot;aa bb\tcc\ndd\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;aa bb\tcc\ndd&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. aa\&quot; \&quot;bb\&quot;\t\&quot;cc\&quot;\n\&quot;dd\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;aa bb\tcc\ndd&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. &quot;</span>, &amp;.{<span class="tok-str">&quot;.&quot;</span>});
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot;\&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; &quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \&quot;\&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;\&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \\\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \\\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \\\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \\\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \\\&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \\\&quot;\&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\&quot;\&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \\\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \\\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \\\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \\\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \\\&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;\&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \&quot; \\\&quot;\&quot;\&quot;\&quot;\&quot;\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot; \&quot;\&quot;\&quot;&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. aa\\bb\\\\cc\\\\\\dd&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;aa\\bb\\\\cc\\\\\\dd&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \\\\\\\&quot;aa bb\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\\\&quot;aa&quot;</span>, <span class="tok-str">&quot;bb&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;. \\\\\\\\\&quot;aa bb\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;.&quot;</span>, <span class="tok-str">&quot;\\\\aa bb&quot;</span> });<span class="tok-comment">

    // From https://learn.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#results-of-parsing-command-lines
    </span><span class="tok-kw">try</span> t(
        <span class="tok-str">\\foo.exe &quot;abc&quot; d e</span>
    , &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;d&quot;</span>, <span class="tok-str">&quot;e&quot;</span> });
    <span class="tok-kw">try</span> t(
        <span class="tok-str">\\foo.exe a\\b d&quot;e f&quot;g h</span>
    , &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;a\\\\b&quot;</span>, <span class="tok-str">&quot;de fg&quot;</span>, <span class="tok-str">&quot;h&quot;</span> });
    <span class="tok-kw">try</span> t(
        <span class="tok-str">\\foo.exe a\\\&quot;b c d</span>
    , &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;a\\\&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;d&quot;</span> });
    <span class="tok-kw">try</span> t(
        <span class="tok-str">\\foo.exe a\\\\&quot;b c&quot; d e</span>
    , &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;a\\\\b c&quot;</span>, <span class="tok-str">&quot;d&quot;</span>, <span class="tok-str">&quot;e&quot;</span> });
    <span class="tok-kw">try</span> t(
        <span class="tok-str">\\foo.exe a&quot;b&quot;&quot; c d</span>
    , &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;ab\&quot; c d&quot;</span> });<span class="tok-comment">

    // From https://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULESEX
    </span><span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe CallMeIshmael&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;CallMeIshmael&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe \&quot;Call Me Ishmael\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;Call Me Ishmael&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe Cal\&quot;l Me I\&quot;shmael&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;Call Me Ishmael&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe CallMe\\\&quot;Ishmael&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;CallMe\&quot;Ishmael&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe \&quot;CallMe\\\&quot;Ishmael\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;CallMe\&quot;Ishmael&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe \&quot;Call Me Ishmael\\\\\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;Call Me Ishmael\\&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe \&quot;CallMe\\\\\\\&quot;Ishmael\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;CallMe\\\&quot;Ishmael&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe a\\\\\\b&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;a\\\\\\b&quot;</span> });
    <span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe \&quot;a\\\\\\b\&quot;&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;a\\\\\\b&quot;</span> });<span class="tok-comment">

    // Surrogate pair encoding of 𐐷 separated by quotes.
    // Encoded as WTF-16:
    // &quot;&lt;0xD801&gt;&quot;&lt;0xDC37&gt;
    // Encoded as WTF-8:
    // &quot;&lt;0xED&gt;&lt;0xA0&gt;&lt;0x81&gt;&quot;&lt;0xED&gt;&lt;0xB0&gt;&lt;0xB7&gt;
    // During parsing, the quotes drop out and the surrogate pair
    // should end up encoded as its normal UTF-8 representation.
    </span><span class="tok-kw">try</span> t(<span class="tok-str">&quot;foo.exe \&quot;\xed\xa0\x81\&quot;\xed\xb0\xb7&quot;</span>, &amp;.{ <span class="tok-str">&quot;foo.exe&quot;</span>, <span class="tok-str">&quot;𐐷&quot;</span> });
}

<span class="tok-kw">fn</span> <span class="tok-fn">testArgIteratorWindows</span>(cmd_line: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected_args: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> cmd_line_w = <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16LeAllocZ">wtf8ToWtf16LeAllocZ</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, cmd_line);
    <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(cmd_line_w);<span class="tok-comment">

    // next
    </span>{
        <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>.<a href="std.process.ArgIteratorWindows.html#std.process.ArgIteratorWindows.init">init</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, cmd_line_w);
        <span class="tok-kw">defer</span> it.deinit();

        <span class="tok-kw">for</span> (expected_args) |expected| {
            <span class="tok-kw">if</span> (it.next()) |actual| {
                <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected, actual);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.TestUnexpectedResult;
            }
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
    }<span class="tok-comment">

    // skip
    </span>{
        <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.process.ArgIteratorWindows.html">ArgIteratorWindows</a>.<a href="std.process.ArgIteratorWindows.html#std.process.ArgIteratorWindows.init">init</a>(<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, cmd_line_w);
        <span class="tok-kw">defer</span> it.deinit();

        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..expected_args.len) |_| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.skip());
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.skip());
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;general arg parsing&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;a   b\tc d&quot;</span>, &amp;.{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;d&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;\&quot;abc\&quot; d e&quot;</span>, &amp;.{ <span class="tok-str">&quot;abc&quot;</span>, <span class="tok-str">&quot;d&quot;</span>, <span class="tok-str">&quot;e&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;a\\\\\\b d\&quot;e f\&quot;g h&quot;</span>, &amp;.{ <span class="tok-str">&quot;a\\\\\\b&quot;</span>, <span class="tok-str">&quot;de fg&quot;</span>, <span class="tok-str">&quot;h&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;a\\\\\\\&quot;b c d&quot;</span>, &amp;.{ <span class="tok-str">&quot;a\\\&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;d&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;a\\\\\\\\\&quot;b c\&quot; d e&quot;</span>, &amp;.{ <span class="tok-str">&quot;a\\\\b c&quot;</span>, <span class="tok-str">&quot;d&quot;</span>, <span class="tok-str">&quot;e&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;a   b\tc \&quot;d f&quot;</span>, &amp;.{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;d f&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;j k l\\&quot;</span>, &amp;.{ <span class="tok-str">&quot;j&quot;</span>, <span class="tok-str">&quot;k&quot;</span>, <span class="tok-str">&quot;l\\&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;\&quot;\&quot; x y z\\\\&quot;</span>, &amp;.{ <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;x&quot;</span>, <span class="tok-str">&quot;y&quot;</span>, <span class="tok-str">&quot;z\\\\&quot;</span> });

    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(<span class="tok-str">&quot;\&quot;.\\..\\zig-cache\\build\&quot; \&quot;bin\\zig.exe\&quot; \&quot;.\\..\&quot; \&quot;.\\..\\zig-cache\&quot; \&quot;--help\&quot;&quot;</span>, &amp;.{
        <span class="tok-str">&quot;.\\..\\zig-cache\\build&quot;</span>,
        <span class="tok-str">&quot;bin\\zig.exe&quot;</span>,
        <span class="tok-str">&quot;.\\..&quot;</span>,
        <span class="tok-str">&quot;.\\..\\zig-cache&quot;</span>,
        <span class="tok-str">&quot;--help&quot;</span>,
    });

    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testGeneralCmdLine">testGeneralCmdLine</a>(
        <span class="tok-str">\\ 'foo' &quot;bar&quot;</span>
    , &amp;.{ <span class="tok-str">&quot;'foo'&quot;</span>, <span class="tok-str">&quot;bar&quot;</span> });
}

<span class="tok-kw">fn</span> <span class="tok-fn">testGeneralCmdLine</span>(input_cmd_line: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected_args: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.process.html#std.process.ArgIteratorGeneral">ArgIteratorGeneral</a>(.{}).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, input_cmd_line);
    <span class="tok-kw">defer</span> it.deinit();
    <span class="tok-kw">for</span> (expected_args) |expected_arg| {
        <span class="tok-kw">const</span> arg = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected_arg, arg);
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;response file arg parsing&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testResponseFileCmdLine">testResponseFileCmdLine</a>(
        <span class="tok-str">\\a b</span>
        <span class="tok-str">\\c d\</span>
    , &amp;.{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;d\\&quot;</span> });
    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testResponseFileCmdLine">testResponseFileCmdLine</a>(<span class="tok-str">&quot;a b c d\\&quot;</span>, &amp;.{ <span class="tok-str">&quot;a&quot;</span>, <span class="tok-str">&quot;b&quot;</span>, <span class="tok-str">&quot;c&quot;</span>, <span class="tok-str">&quot;d\\&quot;</span> });

    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testResponseFileCmdLine">testResponseFileCmdLine</a>(
        <span class="tok-str">\\j</span>
        <span class="tok-str">\\ k l # this is a comment \\ \\\ \\\\ &quot;none&quot; &quot;\\&quot; &quot;\\\&quot;</span>
        <span class="tok-str">\\ &quot;m&quot; #another comment</span>
        <span class="tok-str">\\</span>
    , &amp;.{ <span class="tok-str">&quot;j&quot;</span>, <span class="tok-str">&quot;k&quot;</span>, <span class="tok-str">&quot;l&quot;</span>, <span class="tok-str">&quot;m&quot;</span> });

    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testResponseFileCmdLine">testResponseFileCmdLine</a>(
        <span class="tok-str">\\ &quot;&quot; q &quot;&quot;</span>
        <span class="tok-str">\\ &quot;r s # t&quot; &quot;u\&quot; v&quot; #another comment</span>
        <span class="tok-str">\\</span>
    , &amp;.{ <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;q&quot;</span>, <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;r s # t&quot;</span>, <span class="tok-str">&quot;u\&quot; v&quot;</span> });

    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testResponseFileCmdLine">testResponseFileCmdLine</a>(
        <span class="tok-str">\\ -l&quot;advapi32&quot; a# b#c d#</span>
        <span class="tok-str">\\e\\\</span>
    , &amp;.{ <span class="tok-str">&quot;-ladvapi32&quot;</span>, <span class="tok-str">&quot;a#&quot;</span>, <span class="tok-str">&quot;b#c&quot;</span>, <span class="tok-str">&quot;d#&quot;</span>, <span class="tok-str">&quot;e\\\\\\&quot;</span> });

    <span class="tok-kw">try</span> <a href="std.process.html#std.process.testResponseFileCmdLine">testResponseFileCmdLine</a>(
        <span class="tok-str">\\ 'foo' &quot;bar&quot;</span>
    , &amp;.{ <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;bar&quot;</span> });
}

<span class="tok-kw">fn</span> <span class="tok-fn">testResponseFileCmdLine</span>(input_cmd_line: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected_args: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> <a href="std.process.html#std.process.ArgIteratorGeneral">ArgIteratorGeneral</a>(.{ .comments = <span class="tok-null">true</span>, .single_quotes = <span class="tok-null">true</span> })
        .init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, input_cmd_line);
    <span class="tok-kw">defer</span> it.deinit();
    <span class="tok-kw">for</span> (expected_args) |expected_arg| {
        <span class="tok-kw">const</span> arg = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(expected_arg, arg);
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> UserInfo = <span class="tok-kw">struct</span> {
    uid: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uid_t">uid_t</a>,
    gid: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.gid_t">gid_t</a>,
};

<span class="tok-comment">/// POSIX function which gets a uid from username.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getUserInfo</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.process.UserInfo.html">UserInfo</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
        .linux,
        .macos,
        .watchos,
        .visionos,
        .tvos,
        .ios,
        .freebsd,
        .netbsd,
        .openbsd,
        .haiku,
        .solaris,
        .illumos,
        =&gt; <a href="std.process.html#std.process.posixGetUserInfo">posixGetUserInfo</a>(name),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
    };
}

<span class="tok-comment">/// TODO this reads /etc/passwd. But sometimes the user/id mapping is in something else</span>
<span class="tok-comment">/// like NIS, AD, etc. See `man nss` or look at an strace for `id myuser`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">posixGetUserInfo</span>(name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.process.UserInfo.html">UserInfo</a> {
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsolute">openFileAbsolute</a>(<span class="tok-str">&quot;/etc/passwd&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">const</span> reader = file.reader();

    <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
        Start,
        WaitForNextLine,
        SkipPassword,
        ReadUserId,
        ReadGroupId,
    };

    <span class="tok-kw">var</span> buf: [<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> name_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> state = State.Start;
    <span class="tok-kw">var</span> uid: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uid_t">uid_t</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> gid: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.gid_t">gid_t</a> = <span class="tok-number">0</span>;

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> amt_read = <span class="tok-kw">try</span> reader.read(buf[<span class="tok-number">0</span>..]);
        <span class="tok-kw">for</span> (buf[<span class="tok-number">0</span>..amt_read]) |byte| {
            <span class="tok-kw">switch</span> (state) {
                .Start =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">':'</span> =&gt; {
                        state = <span class="tok-kw">if</span> (name_index == name.len) State.SkipPassword <span class="tok-kw">else</span> State.WaitForNextLine;
                    },
                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">if</span> (name_index == name.len <span class="tok-kw">or</span> name[name_index] != byte) {
                            state = .WaitForNextLine;
                        }
                        name_index += <span class="tok-number">1</span>;
                    },
                },
                .WaitForNextLine =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'\n'</span> =&gt; {
                        name_index = <span class="tok-number">0</span>;
                        state = .Start;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                },
                .SkipPassword =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                    <span class="tok-str">':'</span> =&gt; {
                        state = .ReadUserId;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                },
                .ReadUserId =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">':'</span> =&gt; {
                        state = .ReadGroupId;
                    },
                    <span class="tok-str">'\n'</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">const</span> digit = <span class="tok-kw">switch</span> (byte) {
                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; byte - <span class="tok-str">'0'</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                        };
                        {
                            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(uid, <span class="tok-number">10</span>);
                            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile;
                            uid = ov[<span class="tok-number">0</span>];
                        }
                        {
                            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(uid, digit);
                            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile;
                            uid = ov[<span class="tok-number">0</span>];
                        }
                    },
                },
                .ReadGroupId =&gt; <span class="tok-kw">switch</span> (byte) {
                    <span class="tok-str">'\n'</span>, <span class="tok-str">':'</span> =&gt; {
                        <span class="tok-kw">return</span> <a href="std.process.UserInfo.html">UserInfo</a>{
                            .uid = uid,
                            .gid = gid,
                        };
                    },
                    <span class="tok-kw">else</span> =&gt; {
                        <span class="tok-kw">const</span> digit = <span class="tok-kw">switch</span> (byte) {
                            <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; byte - <span class="tok-str">'0'</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile,
                        };
                        {
                            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(gid, <span class="tok-number">10</span>);
                            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile;
                            gid = ov[<span class="tok-number">0</span>];
                        }
                        {
                            <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(gid, digit);
                            <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CorruptPasswordFile;
                            gid = ov[<span class="tok-number">0</span>];
                        }
                    },
                },
            }
        }
        <span class="tok-kw">if</span> (amt_read &lt; buf.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserNotFound;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getBaseAddress</span>() <span class="tok-type">usize</span> {
    <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
        .linux =&gt; {
            <span class="tok-kw">const</span> getauxval = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.getauxval">getauxval</a> <span class="tok-kw">else</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.getauxval">getauxval</a>;
            <span class="tok-kw">const</span> base = getauxval(<a href="std.html">std</a>.<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.AT_BASE">AT_BASE</a>);
            <span class="tok-kw">if</span> (base != <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> base;
            }
            <span class="tok-kw">const</span> phdr = getauxval(<a href="std.html">std</a>.<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.AT_PHDR">AT_PHDR</a>);
            <span class="tok-kw">return</span> phdr - <span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.elf.html">elf</a>.<a href="std.elf.html#std.elf.Ehdr">Ehdr</a>);
        },
        .driverkit, .ios, .macos, .tvos, .visionos, .watchos =&gt; {
            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromPtr</span>(&amp;<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c._mh_execute_header">_mh_execute_header</a>);
        },
        .windows =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@intFromPtr</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetModuleHandleW">GetModuleHandleW</a>(<span class="tok-null">null</span>)),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),
    }
}

<span class="tok-comment">/// Tells whether calling the `execv` or `execve` functions will be a compile error.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> can_execv = <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
    .windows, .haiku, .wasi =&gt; <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
};

<span class="tok-comment">/// Tells whether spawning child processes is supported (e.g. via Child)</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> can_spawn = <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
    .wasi, .watchos, .tvos, .visionos =&gt; <span class="tok-null">false</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExecvError = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ExecveError">ExecveError</a> || <span class="tok-kw">error</span>{OutOfMemory};

<span class="tok-comment">/// Replaces the current process image with the executed process.</span>
<span class="tok-comment">/// This function must allocate memory to add a null terminating bytes on path and each arg.</span>
<span class="tok-comment">/// It must also convert to KEY=VALUE\0 format for environment variables, and include null</span>
<span class="tok-comment">/// pointers after the args and after the environment variables.</span>
<span class="tok-comment">/// `argv[0]` is the executable path.</span>
<span class="tok-comment">/// This function also uses the PATH environment variable to get the full path to the executable.</span>
<span class="tok-comment">/// Due to the heap-allocation, it is illegal to call this function in a fork() child.</span>
<span class="tok-comment">/// For that use case, use the `std.posix` functions directly.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execv</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.process.html#std.process.ExecvError">ExecvError</a> {
    <span class="tok-kw">return</span> <a href="std.process.html#std.process.execve">execve</a>(allocator, argv, <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Replaces the current process image with the executed process.</span>
<span class="tok-comment">/// This function must allocate memory to add a null terminating bytes on path and each arg.</span>
<span class="tok-comment">/// It must also convert to KEY=VALUE\0 format for environment variables, and include null</span>
<span class="tok-comment">/// pointers after the args and after the environment variables.</span>
<span class="tok-comment">/// `argv[0]` is the executable path.</span>
<span class="tok-comment">/// This function also uses the PATH environment variable to get the full path to the executable.</span>
<span class="tok-comment">/// Due to the heap-allocation, it is illegal to call this function in a fork() child.</span>
<span class="tok-comment">/// For that use case, use the `std.posix` functions directly.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">execve</span>(
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    argv: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    env_map: ?*<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>,
) <a href="std.process.html#std.process.ExecvError">ExecvError</a> {
    <span class="tok-kw">if</span> (!<a href="std.process.html#std.process.can_execv">can_execv</a>) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;The target OS does not support execv&quot;</span>);

    <span class="tok-kw">var</span> arena_allocator = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(allocator);
    <span class="tok-kw">defer</span> arena_allocator.deinit();
    <span class="tok-kw">const</span> arena = arena_allocator.allocator();

    <span class="tok-kw">const</span> argv_buf = <span class="tok-kw">try</span> arena.allocSentinel(?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, argv.len, <span class="tok-null">null</span>);
    <span class="tok-kw">for</span> (argv, <span class="tok-number">0</span>..) |arg, i| argv_buf[i] = (<span class="tok-kw">try</span> arena.dupeZ(<span class="tok-type">u8</span>, arg)).ptr;

    <span class="tok-kw">const</span> envp = m: {
        <span class="tok-kw">if</span> (env_map) |m| {
            <span class="tok-kw">const</span> envp_buf = <span class="tok-kw">try</span> <a href="std.process.html#std.process.createNullDelimitedEnvMap">createNullDelimitedEnvMap</a>(arena, m);
            <span class="tok-kw">break</span> :m envp_buf.ptr;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
            <span class="tok-kw">break</span> :m <a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.html#std.c.environ">environ</a>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.output_mode">output_mode</a> == .Exe) {<span class="tok-comment">
            // Then we have Zig start code and this works.
            // TODO type-safety for null-termination of `os.environ`.
            </span><span class="tok-kw">break</span> :m <span class="tok-builtin">@as</span>([*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(<a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.environ">environ</a>.<a href="#">ptr</a>));
        } <span class="tok-kw">else</span> {<span class="tok-comment">
            // TODO come up with a solution for this.
            </span><span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;missing std lib enhancement: std.process.execv implementation has no way to collect the environment variables to forward to the child process&quot;</span>);
        }
    };

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.execvpeZ_expandArg0">execvpeZ_expandArg0</a>(.no_expand, argv_buf.ptr[<span class="tok-number">0</span>].?, argv_buf.ptr, envp);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TotalSystemMemoryError = <span class="tok-kw">error</span>{
    UnknownTotalSystemMemory,
};

<span class="tok-comment">/// Returns the total system memory, in bytes as a u64.</span>
<span class="tok-comment">/// We return a u64 instead of usize due to PAE on ARM</span>
<span class="tok-comment">/// and Linux's /proc/meminfo reporting more memory when</span>
<span class="tok-comment">/// using QEMU user mode emulation.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">totalSystemMemory</span>() <a href="std.process.html#std.process.TotalSystemMemoryError">TotalSystemMemoryError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">switch</span> (<a href="std.process.html#std.process.native_os">native_os</a>) {
        .linux =&gt; {
            <span class="tok-kw">return</span> <a href="std.process.html#std.process.totalSystemMemoryLinux">totalSystemMemoryLinux</a>() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory;
        },
        .freebsd =&gt; {
            <span class="tok-kw">var</span> physmem: <span class="tok-type">c_ulong</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">c_ulong</span>);
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctlbynameZ">sysctlbynameZ</a>(<span class="tok-str">&quot;hw.physmem&quot;</span>, &amp;physmem, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.NameTooLong, <span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory,
            };
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(physmem));
        },
        .openbsd =&gt; {
            <span class="tok-kw">const</span> mib: [<span class="tok-number">2</span>]<span class="tok-type">c_int</span> = [_]<span class="tok-type">c_int</span>{
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CTL">CTL</a>.<a href="#">HW</a>,
                <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.HW">HW</a>.<a href="#">PHYSMEM64</a>,
            };
            <span class="tok-kw">var</span> physmem: <span class="tok-type">i64</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(physmem));
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sysctl">sysctl</a>(&amp;mib, &amp;physmem, &amp;len, <span class="tok-null">null</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.NameTooLong =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                </span><span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // only when setting values,
                </span><span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // memory already on the stack
                </span><span class="tok-kw">error</span>.UnknownName =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // constant, known good value
                </span><span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory,
            };
            <a href="std.debug.html#std.debug.assert">assert</a>(physmem &gt;= <span class="tok-number">0</span>);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(physmem));
        },
        .windows =&gt; {
            <span class="tok-kw">var</span> sbi: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.SYSTEM_BASIC_INFORMATION.html">SYSTEM_BASIC_INFORMATION</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQuerySystemInformation">NtQuerySystemInformation</a>(
                .SystemBasicInformation,
                &amp;sbi,
                <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.SYSTEM_BASIC_INFORMATION.html">SYSTEM_BASIC_INFORMATION</a>),
                <span class="tok-null">null</span>,
            );
            <span class="tok-kw">if</span> (rc != .SUCCESS) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory;
            }
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, sbi.NumberOfPhysicalPages) * sbi.PageSize;
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownTotalSystemMemory,
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">totalSystemMemoryLinux</span>() !<span class="tok-type">u64</span> {
    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.openFileAbsoluteZ">openFileAbsoluteZ</a>(<span class="tok-str">&quot;/proc/meminfo&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">var</span> buf: [<span class="tok-number">50</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> file.read(&amp;buf);
    <span class="tok-kw">if</span> (amt != <span class="tok-number">50</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    <span class="tok-kw">var</span> it = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeAny">tokenizeAny</a>(<span class="tok-type">u8</span>, buf[<span class="tok-number">0</span>..amt], <span class="tok-str">&quot; \n&quot;</span>);
    <span class="tok-kw">const</span> label = it.next().?;
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, label, <span class="tok-str">&quot;MemTotal:&quot;</span>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    <span class="tok-kw">const</span> int_text = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    <span class="tok-kw">const</span> units = it.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, units, <span class="tok-str">&quot;kB&quot;</span>)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Unexpected;
    <span class="tok-kw">const</span> kilobytes = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, int_text, <span class="tok-number">10</span>);
    <span class="tok-kw">return</span> kilobytes * <span class="tok-number">1024</span>;
}

<span class="tok-comment">/// Indicate that we are now terminating with a successful exit code.</span>
<span class="tok-comment">/// In debug builds, this is a no-op, so that the calling code's</span>
<span class="tok-comment">/// cleanup mechanisms are tested and so that external tools that</span>
<span class="tok-comment">/// check for resource leaks can be accurate. In release builds, this</span>
<span class="tok-comment">/// calls exit(0), and does not return.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cleanExit</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.mode">mode</a> == .Debug) {
        <span class="tok-kw">return</span>;
    } <span class="tok-kw">else</span> {
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.lockStdErr">lockStdErr</a>();
        <a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">0</span>);
    }
}

<span class="tok-comment">/// Raise the open file descriptor limit.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// On some systems, this raises the limit before seeing ProcessFdQuotaExceeded</span>
<span class="tok-comment">/// errors. On other systems, this does nothing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">raiseFileDescriptorLimit</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> have_rlimit = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rlimit_resource">rlimit_resource</a> != <span class="tok-type">void</span>;
    <span class="tok-kw">if</span> (!have_rlimit) <span class="tok-kw">return</span>;

    <span class="tok-kw">var</span> lim = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getrlimit">getrlimit</a>(.NOFILE) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;<span class="tok-comment"> // Oh well; we tried.
    </span><span class="tok-kw">if</span> (<a href="std.process.html#std.process.native_os">native_os</a>.<a href="#">isDarwin</a>()) {<span class="tok-comment">
        // On Darwin, `NOFILE` is bounded by a hardcoded value `OPEN_MAX`.
        // According to the man pages for setrlimit():
        //   setrlimit() now returns with errno set to EINVAL in places that historically succeeded.
        //   It no longer accepts &quot;rlim_cur = RLIM.INFINITY&quot; for RLIM.NOFILE.
        //   Use &quot;rlim_cur = min(OPEN_MAX, rlim_max)&quot;.
        </span>lim.max = <span class="tok-builtin">@min</span>(<a href="std.html">std</a>.<a href="std.c.html">c</a>.<a href="std.c.darwin.html#std.c.darwin.OPEN_MAX">OPEN_MAX</a>, lim.max);
    }
    <span class="tok-kw">if</span> (lim.cur == lim.max) <span class="tok-kw">return</span>;<span class="tok-comment">

    // Do a binary search for the limit.
    </span><span class="tok-kw">var</span> min: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rlim_t">rlim_t</a> = lim.cur;
    <span class="tok-kw">var</span> max: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.rlim_t">rlim_t</a> = <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">20</span>;<span class="tok-comment">
    // But if there's a defined upper bound, don't search, just set it.
    </span><span class="tok-kw">if</span> (lim.max != <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.RLIM">RLIM</a>.<a href="#">INFINITY</a>) {
        min = lim.max;
        max = lim.max;
    }

    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        lim.cur = min + <span class="tok-builtin">@divTrunc</span>(max - min, <span class="tok-number">2</span>);<span class="tok-comment"> // on freebsd rlim_t is signed
        </span><span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setrlimit">setrlimit</a>(.NOFILE, lim)) |_| {
            min = lim.cur;
        } <span class="tok-kw">else</span> |_| {
            max = lim.cur;
        }
        <span class="tok-kw">if</span> (min + <span class="tok-number">1</span> &gt;= max) <span class="tok-kw">break</span>;
    }
}

<span class="tok-kw">test</span> raiseFileDescriptorLimit {
    <a href="std.process.html#std.process.raiseFileDescriptorLimit">raiseFileDescriptorLimit</a>();
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CreateEnvironOptions = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// `null` means to leave the `ZIG_PROGRESS` environment variable unmodified.</span>
    <span class="tok-comment">/// If non-null, negative means to remove the environment variable, and &gt;= 0</span>
    <span class="tok-comment">/// means to provide it with the given integer.</span>
    zig_progress_fd: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>,
};

<span class="tok-comment">/// Creates a null-delimited environment variable block in the format</span>
<span class="tok-comment">/// expected by POSIX, from a hash map plus options.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createEnvironFromMap</span>(
    arena: <a href="std.mem.Allocator.html">Allocator</a>,
    map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>,
    options: <a href="std.process.CreateEnvironOptions.html">CreateEnvironOptions</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> ZigProgressAction = <span class="tok-kw">enum</span> { nothing, edit, delete, add };
    <span class="tok-kw">const</span> zig_progress_action: ZigProgressAction = a: {
        <span class="tok-kw">const</span> fd = options.zig_progress_fd <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :a .nothing;
        <span class="tok-kw">const</span> contains = map.get(<span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>) != <span class="tok-null">null</span>;
        <span class="tok-kw">if</span> (fd &gt;= <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span> :a <span class="tok-kw">if</span> (contains) .edit <span class="tok-kw">else</span> .add;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">if</span> (contains) <span class="tok-kw">break</span> :a .delete;
        }
        <span class="tok-kw">break</span> :a .nothing;
    };

    <span class="tok-kw">const</span> envp_count: <span class="tok-type">usize</span> = c: {
        <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = map.count();
        <span class="tok-kw">switch</span> (zig_progress_action) {
            .add =&gt; count += <span class="tok-number">1</span>,
            .delete =&gt; count -= <span class="tok-number">1</span>,
            .nothing, .edit =&gt; {},
        }
        <span class="tok-kw">break</span> :c count;
    };

    <span class="tok-kw">const</span> envp_buf = <span class="tok-kw">try</span> arena.allocSentinel(?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, envp_count, <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">if</span> (zig_progress_action == .add) {
        envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;ZIG_PROGRESS={d}&quot;</span>, .{options.zig_progress_fd.?});
        i += <span class="tok-number">1</span>;
    }

    {
        <span class="tok-kw">var</span> it = map.iterator();
        <span class="tok-kw">while</span> (it.next()) |pair| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, pair.key_ptr.*, <span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>)) <span class="tok-kw">switch</span> (zig_progress_action) {
                .add =&gt; <span class="tok-kw">unreachable</span>,
                .delete =&gt; <span class="tok-kw">continue</span>,
                .edit =&gt; {
                    envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;{s}={d}&quot;</span>, .{
                        pair.key_ptr.*, options.zig_progress_fd.?,
                    });
                    i += <span class="tok-number">1</span>;
                    <span class="tok-kw">continue</span>;
                },
                .nothing =&gt; {},
            };

            envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;{s}={s}&quot;</span>, .{ pair.key_ptr.*, pair.value_ptr.* });
            i += <span class="tok-number">1</span>;
        }
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(i == envp_count);
    <span class="tok-kw">return</span> envp_buf;
}

<span class="tok-comment">/// Creates a null-delimited environment variable block in the format</span>
<span class="tok-comment">/// expected by POSIX, from a hash map plus options.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createEnvironFromExisting</span>(
    arena: <a href="std.mem.Allocator.html">Allocator</a>,
    existing: [*:<span class="tok-null">null</span>]<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.process.CreateEnvironOptions.html">CreateEnvironOptions</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> existing_count, <span class="tok-kw">const</span> contains_zig_progress = c: {
        <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> contains = <span class="tok-null">false</span>;
        <span class="tok-kw">while</span> (existing[count]) |line| : (count += <span class="tok-number">1</span>) {
            contains = contains <span class="tok-kw">or</span> mem.eql(<span class="tok-type">u8</span>, mem.sliceTo(line, <span class="tok-str">'='</span>), <span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>);
        }
        <span class="tok-kw">break</span> :c .{ count, contains };
    };
    <span class="tok-kw">const</span> ZigProgressAction = <span class="tok-kw">enum</span> { nothing, edit, delete, add };
    <span class="tok-kw">const</span> zig_progress_action: ZigProgressAction = a: {
        <span class="tok-kw">const</span> fd = options.zig_progress_fd <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :a .nothing;
        <span class="tok-kw">if</span> (fd &gt;= <span class="tok-number">0</span>) {
            <span class="tok-kw">break</span> :a <span class="tok-kw">if</span> (contains_zig_progress) .edit <span class="tok-kw">else</span> .add;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">if</span> (contains_zig_progress) <span class="tok-kw">break</span> :a .delete;
        }
        <span class="tok-kw">break</span> :a .nothing;
    };

    <span class="tok-kw">const</span> envp_count: <span class="tok-type">usize</span> = c: {
        <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = existing_count;
        <span class="tok-kw">switch</span> (zig_progress_action) {
            .add =&gt; count += <span class="tok-number">1</span>,
            .delete =&gt; count -= <span class="tok-number">1</span>,
            .nothing, .edit =&gt; {},
        }
        <span class="tok-kw">break</span> :c count;
    };

    <span class="tok-kw">const</span> envp_buf = <span class="tok-kw">try</span> arena.allocSentinel(?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span>, envp_count, <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> existing_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">if</span> (zig_progress_action == .add) {
        envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;ZIG_PROGRESS={d}&quot;</span>, .{options.zig_progress_fd.?});
        i += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">while</span> (existing[existing_index]) |line| : (existing_index += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(line, <span class="tok-str">'='</span>), <span class="tok-str">&quot;ZIG_PROGRESS&quot;</span>)) <span class="tok-kw">switch</span> (zig_progress_action) {
            .add =&gt; <span class="tok-kw">unreachable</span>,
            .delete =&gt; <span class="tok-kw">continue</span>,
            .edit =&gt; {
                envp_buf[i] = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrintZ">allocPrintZ</a>(arena, <span class="tok-str">&quot;ZIG_PROGRESS={d}&quot;</span>, .{options.zig_progress_fd.?});
                i += <span class="tok-number">1</span>;
                <span class="tok-kw">continue</span>;
            },
            .nothing =&gt; {},
        };
        envp_buf[i] = <span class="tok-kw">try</span> arena.dupeZ(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(line));
        i += <span class="tok-number">1</span>;
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(i == envp_count);
    <span class="tok-kw">return</span> envp_buf;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createNullDelimitedEnvMap</span>(arena: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, env_map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>![:<span class="tok-null">null</span>]?[*:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <a href="std.process.html#std.process.createEnvironFromMap">createEnvironFromMap</a>(arena, env_map, .{});
}

<span class="tok-kw">test</span> createNullDelimitedEnvMap {
    <span class="tok-kw">const</span> allocator = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;
    <span class="tok-kw">var</span> envmap = <a href="std.process.EnvMap.html">EnvMap</a>.<a href="std.process.EnvMap.html#std.process.EnvMap.init">init</a>(allocator);
    <span class="tok-kw">defer</span> envmap.deinit();

    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;HOME&quot;</span>, <span class="tok-str">&quot;/home/ifreund&quot;</span>);
    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;WAYLAND_DISPLAY&quot;</span>, <span class="tok-str">&quot;wayland-1&quot;</span>);
    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;DISPLAY&quot;</span>, <span class="tok-str">&quot;:1&quot;</span>);
    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;DEBUGINFOD_URLS&quot;</span>, <span class="tok-str">&quot; &quot;</span>);
    <span class="tok-kw">try</span> envmap.put(<span class="tok-str">&quot;XCURSOR_SIZE&quot;</span>, <span class="tok-str">&quot;24&quot;</span>);

    <span class="tok-kw">var</span> arena = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html">ArenaAllocator</a>.<a href="std.heap.arena_allocator.ArenaAllocator.html#std.heap.arena_allocator.ArenaAllocator.init">init</a>(allocator);
    <span class="tok-kw">defer</span> arena.deinit();
    <span class="tok-kw">const</span> environ = <span class="tok-kw">try</span> <a href="std.process.html#std.process.createNullDelimitedEnvMap">createNullDelimitedEnvMap</a>(arena.allocator(), &amp;envmap);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), environ.len);

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{
        <span class="tok-str">&quot;HOME=/home/ifreund&quot;</span>,
        <span class="tok-str">&quot;WAYLAND_DISPLAY=wayland-1&quot;</span>,
        <span class="tok-str">&quot;DISPLAY=:1&quot;</span>,
        <span class="tok-str">&quot;DEBUGINFOD_URLS= &quot;</span>,
        <span class="tok-str">&quot;XCURSOR_SIZE=24&quot;</span>,
    }) |target| {
        <span class="tok-kw">for</span> (environ) |variable| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.span">span</a>(variable <span class="tok-kw">orelse</span> <span class="tok-kw">continue</span>), target)) <span class="tok-kw">break</span>;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-null">false</span>);<span class="tok-comment"> // Environment variable not found
        </span>}
    }
}

<span class="tok-comment">/// Caller must free result.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">createWindowsEnvBlock</span>(allocator: <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, env_map: *<span class="tok-kw">const</span> <a href="std.process.EnvMap.html">EnvMap</a>) ![]<span class="tok-type">u16</span> {<span class="tok-comment">
    // count bytes needed
    </span><span class="tok-kw">const</span> max_chars_needed = x: {
        <span class="tok-kw">var</span> max_chars_needed: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;<span class="tok-comment"> // 4 for the final 4 null bytes
        </span><span class="tok-kw">var</span> it = env_map.iterator();
        <span class="tok-kw">while</span> (it.next()) |pair| {<span class="tok-comment">
            // +1 for '='
            // +1 for null byte
            </span>max_chars_needed += pair.key_ptr.len + pair.value_ptr.len + <span class="tok-number">2</span>;
        }
        <span class="tok-kw">break</span> :x max_chars_needed;
    };
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u16</span>, max_chars_needed);
    <span class="tok-kw">errdefer</span> allocator.free(result);

    <span class="tok-kw">var</span> it = env_map.iterator();
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (it.next()) |pair| {
        i += <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(result[i..], pair.key_ptr.*);
        result[i] = <span class="tok-str">'='</span>;
        i += <span class="tok-number">1</span>;
        i += <span class="tok-kw">try</span> <a href="std.unicode.html">unicode</a>.<a href="std.unicode.html#std.unicode.wtf8ToWtf16Le">wtf8ToWtf16Le</a>(result[i..], pair.value_ptr.*);
        result[i] = <span class="tok-number">0</span>;
        i += <span class="tok-number">1</span>;
    }
    result[i] = <span class="tok-number">0</span>;
    i += <span class="tok-number">1</span>;
    result[i] = <span class="tok-number">0</span>;
    i += <span class="tok-number">1</span>;
    result[i] = <span class="tok-number">0</span>;
    i += <span class="tok-number">1</span>;
    result[i] = <span class="tok-number">0</span>;
    i += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> allocator.realloc(result, i);
}

<span class="tok-comment">/// Logs an error and then terminates the process with exit code 1.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fatal</span>(<span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, format_arguments: <span class="tok-kw">anytype</span>) <span class="tok-type">noreturn</span> {
    <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.err">err</a>(format, format_arguments);
    <a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">1</span>);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
