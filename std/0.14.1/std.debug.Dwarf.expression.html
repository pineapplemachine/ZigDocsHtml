<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">debug</a></li><li><a href="std.debug.html" class="">Dwarf</a></li><li><a href="std.debug.Dwarf.expression.html" class="active">expression</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.debug.Dwarf.expression" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.debug.Dwarf.expression</span><a href="#src.zig-std.debug.Dwarf.expression">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.debug.Dwarf.expression.Context.html">std.debug.Dwarf.expression.Context</a></li><li><a href="std.debug.Dwarf.expression.Options.html">std.debug.Dwarf.expression.Options</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.debug.Dwarf.expression.StackMachine" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StackMachine</span><a href="#src.zig-std.debug.Dwarf.expression.StackMachine">[src]</a></h2><div class="tldDocs"><p>A stack machine that can decode and run DWARF expressions.
Expressions can be decoded for non-native address size and endianness,
but can only be executed if the current target matches the configuration.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.debug.Dwarf.expression.Options.html">Options</a></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>stack: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a>) = .empty</code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.debug.Dwarf.expression.StackMachine.reset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reset</span><a href="#src.zig-std.debug.Dwarf.expression.StackMachine.reset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.StackMachine.reset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>) <span class="tok-type">void</span> {
    self.stack.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.StackMachine.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.debug.Dwarf.expression.StackMachine.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.StackMachine.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.stack.deinit(allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.StackMachine.readOperand" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readOperand</span><a href="#src.zig-std.debug.Dwarf.expression.StackMachine.readOperand">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOperand</span>(stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), opcode: <span class="tok-type">u8</span>, context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>) !?<a href="std.debug.Dwarf.expression.StackMachine.Operand.html">Operand</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>)</code></pre></div><div><pre><code>opcode: <span class="tok-type">u8</span></code></pre></div><div><pre><code>context: <a href="std.debug.Dwarf.expression.Context.html">Context</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.StackMachine.readOperand">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOperand</span>(stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), opcode: <span class="tok-type">u8</span>, context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>) !?<a href="std.debug.Dwarf.expression.StackMachine.Operand.html">Operand</a> {
    <span class="tok-kw">const</span> reader = stream.reader();
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(addr_type, options.endian)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a> =&gt; <span class="tok-kw">switch</span> (context.format) {
            .@&quot;32&quot; =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
            .@&quot;64&quot; =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian)),
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>,
        =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readByte()),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
        =&gt; .{ .type_size = <span class="tok-kw">try</span> reader.readByte() },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readByteSigned()),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>,
        =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u16</span>, options.endian)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>,
        =&gt; .{ .branch_offset = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian) },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i32</span>, options.endian)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i64</span>, options.endian)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a>,
        =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a>,
        =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader)),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit31">lit31</a> =&gt; |n| <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>),
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg31">reg31</a> =&gt; |n| .{ .register = n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a> },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg31">breg31</a> =&gt; |n| .{ .base_register = .{
            .base_register = n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>,
            .offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader),
        } },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regx">regx</a> =&gt; .{ .register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader) },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a> =&gt; blk: {
            <span class="tok-kw">const</span> base_register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
            <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader);
            <span class="tok-kw">break</span> :blk .{ .base_register = .{
                .base_register = base_register,
                .offset = offset,
            } };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a> =&gt; blk: {
            <span class="tok-kw">const</span> register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
            <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader);
            <span class="tok-kw">break</span> :blk .{ .register_type = .{
                .register = register,
                .type_offset = type_offset,
            } };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.piece">piece</a> =&gt; .{
            .composite_location = .{
                .size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader),
                .offset = <span class="tok-number">0</span>,
            },
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bit_piece">bit_piece</a> =&gt; blk: {
            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
            <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader);
            <span class="tok-kw">break</span> :blk .{ .composite_location = .{
                .size = size,
                .offset = offset,
            } };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.implicit_value">implicit_value</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a> =&gt; blk: {
            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
            <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> block = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];
            stream.pos += size;
            <span class="tok-kw">break</span> :blk .{
                .block = block,
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a> =&gt; blk: {
            <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader);
            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> reader.readByte();
            <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> value_bytes = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];
            stream.pos += size;
            <span class="tok-kw">break</span> :blk .{ .const_type = .{
                .type_offset = type_offset,
                .value_bytes = value_bytes,
            } };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
        =&gt; .{
            .deref_type = .{
                .size = <span class="tok-kw">try</span> reader.readByte(),
                .type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader),
            },
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lo_user">lo_user</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.hi_user">hi_user</a> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUserOpcode,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.StackMachine.run" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">run</span><a href="#src.zig-std.debug.Dwarf.expression.StackMachine.run">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>( self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>, expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>, initial_value: ?<span class="tok-type">usize</span>, ) <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Error">Error</a>!?<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a></code></pre></div><div><pre><code>expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>context: <a href="std.debug.Dwarf.expression.Context.html">Context</a></code></pre></div><div><pre><code>initial_value: ?<span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.StackMachine.run">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(
    self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>,
    expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>,
    initial_value: ?<span class="tok-type">usize</span>,
) <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Error">Error</a>!?<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a> {
    <span class="tok-kw">if</span> (initial_value) |i| <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = i });
    <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(expression);
    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.step(&amp;stream, allocator, context)) {}
    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.StackMachine.step" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">step</span><a href="#src.zig-std.debug.Dwarf.expression.StackMachine.step">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>( self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>, stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>, context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>, ) <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Error">Error</a>!<span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Reads an opcode and its operands from <code>stream</code>, then executes it</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a></code></pre></div><div><pre><code>stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>)</code></pre></div><div><pre><code>allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>context: <a href="std.debug.Dwarf.expression.Context.html">Context</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.StackMachine.step">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(
    self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>,
    stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),
    allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
    context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>,
) <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Error">Error</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) != <span class="tok-builtin">@sizeOf</span>(addr_type) <span class="tok-kw">or</span> options.endian != <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Execution of non-native address sizes / endianness is not supported&quot;</span>);

    <span class="tok-kw">const</span> opcode = <span class="tok-kw">try</span> stream.reader().readByte();
    <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeValidInCFA">isOpcodeValidInCFA</a>(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.readOperand">readOperand</a>(stream, opcode, context);
    <span class="tok-kw">switch</span> (opcode) {<span class="tok-comment">

        // 2.5.1.1: Literal Encodings
        </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit31">lit31</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>,
        =&gt; <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = operand.?.generic }),

        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a> =&gt; {
            <span class="tok-kw">const</span> const_type = operand.?.const_type;
            <span class="tok-kw">try</span> self.stack.append(allocator, .{ .const_type = .{
                .type_offset = const_type.type_offset,
                .value_bytes = const_type.value_bytes,
            } });
        },

        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>,
        =&gt; {
            <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
            <span class="tok-kw">if</span> (context.debug_addr == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
            <span class="tok-kw">const</span> debug_addr_index = operand.?.generic;
            <span class="tok-kw">const</span> offset = context.compile_unit.?.addr_base + debug_addr_index;
            <span class="tok-kw">if</span> (offset &gt;= context.debug_addr.?.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, context.debug_addr.?[offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
            <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });
        },<span class="tok-comment">

        // 2.5.1.2: Register Values
        </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a> =&gt; {
            <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
            <span class="tok-kw">if</span> (context.compile_unit.?.frame_base == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

            <span class="tok-kw">const</span> offset: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(operand.?.generic);
            _ = offset;

            <span class="tok-kw">switch</span> (context.compile_unit.?.frame_base.?.*) {
                .exprloc =&gt; {<span class="tok-comment">
                    // TODO: Run this expression in a nested stack machine
                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                },
                .loclistx =&gt; {<span class="tok-comment">
                    // TODO: Read value from .debug_loclists
                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                },
                .sec_offset =&gt; {<span class="tok-comment">
                    // TODO: Read value from .debug_loclists
                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFrameBase,
            }
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg31">breg31</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a>,
        =&gt; {
            <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

            <span class="tok-kw">const</span> base_register = operand.?.base_register;
            <span class="tok-kw">var</span> value: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(
                context.thread_context.?,
                base_register.base_register,
                context.reg_context,
            ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>));
            value += base_register.offset;
            <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intCast</span>(value) });
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a> =&gt; {
            <span class="tok-kw">const</span> register_type = operand.?.register_type;
            <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(
                context.thread_context.?,
                register_type.register,
                context.reg_context,
            ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
            <span class="tok-kw">try</span> self.stack.append(allocator, .{
                .regval_type = .{
                    .type_offset = register_type.type_offset,
                    .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),
                    .value = value,
                },
            });
        },<span class="tok-comment">

        // 2.5.1.3: Stack Operations
        </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.dup">dup</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span>]);
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.drop">drop</a> =&gt; {
            _ = self.stack.pop();
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a> =&gt; {
            <span class="tok-kw">const</span> stack_index = <span class="tok-kw">if</span> (opcode == <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a>) <span class="tok-number">1</span> <span class="tok-kw">else</span> operand.?.generic;
            <span class="tok-kw">if</span> (stack_index &gt;= self.stack.items.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span> - stack_index]);
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.swap">swap</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a>, &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>], &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>]);
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.rot">rot</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> first = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];
            self.stack.items[self.stack.items.len - <span class="tok-number">2</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">3</span>];
            self.stack.items[self.stack.items.len - <span class="tok-number">3</span>] = first;
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
        =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> addr = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
            <span class="tok-kw">const</span> addr_space_identifier: ?<span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (opcode) {
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                =&gt; blk: {
                    _ = self.stack.pop();
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
            };<span class="tok-comment">

            // Usage of addr_space_identifier in the address calculation is implementation defined.
            // This code will need to be updated to handle any architectures that utilize this.
            </span>_ = addr_space_identifier;

            <span class="tok-kw">const</span> size = <span class="tok-kw">switch</span> (opcode) {
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                =&gt; <span class="tok-builtin">@sizeOf</span>(addr_type),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                =&gt; operand.?.type_size,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                =&gt; operand.?.deref_type.size,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            };

            <span class="tok-kw">if</span> (context.memory_accessor) |memory_accessor| {
                <span class="tok-kw">if</span> (!<span class="tok-kw">switch</span> (size) {
                    <span class="tok-number">1</span> =&gt; memory_accessor.load(<span class="tok-type">u8</span>, addr) != <span class="tok-null">null</span>,
                    <span class="tok-number">2</span> =&gt; memory_accessor.load(<span class="tok-type">u16</span>, addr) != <span class="tok-null">null</span>,
                    <span class="tok-number">4</span> =&gt; memory_accessor.load(<span class="tok-type">u32</span>, addr) != <span class="tok-null">null</span>,
                    <span class="tok-number">8</span> =&gt; memory_accessor.load(<span class="tok-type">u64</span>, addr) != <span class="tok-null">null</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression,
                }) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            }

            <span class="tok-kw">const</span> value: addr_type = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(addr_type, <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-kw">switch</span> (size) {
                <span class="tok-number">1</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                <span class="tok-number">2</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u16</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                <span class="tok-number">4</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                <span class="tok-number">8</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u64</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression,
            })) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;

            <span class="tok-kw">switch</span> (opcode) {
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                =&gt; {
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .regval_type = .{
                            .type_offset = operand.?.deref_type.type_offset,
                            .type_size = operand.?.deref_type.size,
                            .value = value,
                        },
                    };
                },
                <span class="tok-kw">else</span> =&gt; {
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = value };
                },
            }
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.push_object_address">push_object_address</a> =&gt; {<span class="tok-comment">
            // In sub-expressions, `push_object_address` is not meaningful (as per the
            // spec), so treat it like a nop
            </span><span class="tok-kw">if</span> (!context.entry_value_context) {
                <span class="tok-kw">if</span> (context.object_address == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intFromPtr</span>(context.object_address.?) });
            }
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.form_tls_address">form_tls_address</a> =&gt; {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_frame_cfa">call_frame_cfa</a> =&gt; {
            <span class="tok-kw">if</span> (context.cfa) |cfa| {
                <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = cfa });
            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
        },<span class="tok-comment">

        // 2.5.1.4: Arithmetic and Logical Operations
        </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.abs">abs</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> value: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-builtin">@abs</span>(value),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="#"and"">@&quot;and&quot;</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = a &amp; <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.div">div</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
            <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divTrunc">divTrunc</a>(<span class="tok-type">isize</span>, b, a)),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.minus">minus</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mod">mod</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
            <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mod</span>(b, a)),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mul">mul</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
            <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mulWithOverflow</span>(a, b)[<span class="tok-number">0</span>]),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.neg">neg</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-builtin">@bitCast</span>(
                    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.negate">negate</a>(
                        <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral())),
                    ),
                ),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.not">not</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = ~<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="#"or"">@&quot;or&quot;</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = a | <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus">plus</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> constant = operand.?.generic;
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), constant),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shl">shl</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
            <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<span class="tok-type">usize</span>, b, a),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shr">shr</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
            <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<span class="tok-type">usize</span>, b, a),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shra">shra</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
            <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = <span class="tok-builtin">@bitCast</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<span class="tok-type">isize</span>, b, a)),
            };
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xor">xor</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                .generic = a ^ <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
            };
        },<span class="tok-comment">

        // 2.5.1.5: Control Flow Operations
        </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a>,
        =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> a = self.stack.pop().?;
            <span class="tok-kw">const</span> b = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];

            <span class="tok-kw">if</span> (a == .generic <span class="tok-kw">and</span> b == .generic) {
                <span class="tok-kw">const</span> a_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(a.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
                <span class="tok-kw">const</span> b_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(b.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
                <span class="tok-kw">const</span> result = <span class="tok-builtin">@intFromBool</span>(<span class="tok-kw">switch</span> (opcode) {
                    <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a> =&gt; b_int &lt;= a_int,
                    <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a> =&gt; b_int &gt;= a_int,
                    <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a> =&gt; b_int == a_int,
                    <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a> =&gt; b_int &lt; a_int,
                    <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a> =&gt; b_int &gt; a_int,
                    <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a> =&gt; b_int != a_int,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                });

                self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = result };
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // TODO: Load the types referenced by these values, find their comparison operator, and run it
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypedComparison;
            }
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a> =&gt; {
            <span class="tok-kw">const</span> branch_offset = operand.?.branch_offset;
            <span class="tok-kw">const</span> condition = <span class="tok-kw">if</span> (opcode == <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>) blk: {
                <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.pop().?.asIntegral() != <span class="tok-number">0</span>;
            } <span class="tok-kw">else</span> <span class="tok-null">true</span>;

            <span class="tok-kw">if</span> (condition) {
                <span class="tok-kw">const</span> new_pos = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(
                    <span class="tok-type">usize</span>,
                    <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(stream.pos)), branch_offset),
                ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;

                <span class="tok-kw">if</span> (new_pos &lt; <span class="tok-number">0</span> <span class="tok-kw">or</span> new_pos &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                stream.pos = new_pos;
            }
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a>,
        =&gt; {
            <span class="tok-kw">const</span> debug_info_offset = operand.?.generic;
            _ = debug_info_offset;<span class="tok-comment">

            // TODO: Load a DIE entry at debug_info_offset in a .debug_info section (the spec says that it
            //       can be in a separate exe / shared object from the one containing this expression).
            //       Transfer control to the DW_AT_location attribute, with the current stack as input.

            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedExpressionCall;
        },<span class="tok-comment">

        // 2.5.1.6: Type Conversions
        </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> type_offset = operand.?.generic;<span class="tok-comment">

            // TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size
            </span><span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
            <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {
                self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // TODO: Load the DW_TAG_base_type entry in context.compile_unit, find a conversion operator
                //       from the old type to the new type, run it.
                </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypeConversion;
            }
        },
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a> =&gt; {
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
            <span class="tok-kw">const</span> type_offset = operand.?.generic;<span class="tok-comment">

            // TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size
            </span><span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
            <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {
                self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };
            } <span class="tok-kw">else</span> {
                self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = <span class="tok-kw">switch</span> (value) {
                    .generic =&gt; |v| .{
                        .regval_type = .{
                            .type_offset = type_offset,
                            .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),
                            .value = v,
                        },
                    },
                    .regval_type =&gt; |r| .{
                        .regval_type = .{
                            .type_offset = type_offset,
                            .type_size = r.type_size,
                            .value = r.value,
                        },
                    },
                    .const_type =&gt; |c| .{
                        .const_type = .{
                            .type_offset = type_offset,
                            .value_bytes = c.value_bytes,
                        },
                    },
                };
            }
        },<span class="tok-comment">

        // 2.5.1.7: Special Operations
        </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.nop">nop</a> =&gt; {},
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a> =&gt; {
            <span class="tok-kw">const</span> block = operand.?.block;
            <span class="tok-kw">if</span> (block.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression;<span class="tok-comment">

            // TODO: The spec states that this sub-expression needs to observe the state (ie. registers)
            //       as it was upon entering the current subprogram. If this isn't being called at the
            //       end of a frame unwind operation, an additional ThreadContext with this state will be needed.

            </span><span class="tok-kw">if</span> (<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeRegisterLocation">isOpcodeRegisterLocation</a>(block[<span class="tok-number">0</span>])) {
                <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

                <span class="tok-kw">var</span> block_stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(block);
                <span class="tok-kw">const</span> register = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.readOperand">readOperand</a>(&amp;block_stream, block[<span class="tok-number">0</span>], context)).?.register;
                <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context.?, register, context.reg_context))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
                <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> stack_machine: <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a> = .{};
                <span class="tok-kw">defer</span> stack_machine.deinit(allocator);

                <span class="tok-kw">var</span> sub_context = context;
                sub_context.entry_value_context = <span class="tok-null">true</span>;
                <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> stack_machine.run(block, allocator, sub_context, <span class="tok-null">null</span>);
                <span class="tok-kw">try</span> self.stack.append(allocator, result <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression);
            }
        },<span class="tok-comment">

        // These have already been handled by readOperand
        </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lo_user">lo_user</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.hi_user">hi_user</a> =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; {<span class="tok-comment">
            //std.debug.print(&quot;Unknown DWARF expression opcode: {x}\n&quot;, .{opcode});
            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownExpressionOpcode;
        },
    }

    <span class="tok-kw">return</span> stream.pos &lt; stream.buffer.len;
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.StackMachine">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StackMachine</span>(<span class="tok-kw">comptime</span> options: <a href="std.debug.Dwarf.expression.Options.html">Options</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> addr_type = <span class="tok-kw">switch</span> (options.addr_size) {
        <span class="tok-number">2</span> =&gt; <span class="tok-type">u16</span>,
        <span class="tok-number">4</span> =&gt; <span class="tok-type">u32</span>,
        <span class="tok-number">8</span> =&gt; <span class="tok-type">u64</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),
    };

    <span class="tok-kw">const</span> addr_type_signed = <span class="tok-kw">switch</span> (options.addr_size) {
        <span class="tok-number">2</span> =&gt; <span class="tok-type">i16</span>,
        <span class="tok-number">4</span> =&gt; <span class="tok-type">i32</span>,
        <span class="tok-number">8</span> =&gt; <span class="tok-type">i64</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),
    };

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">const</span> Operand = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            generic: addr_type,
            register: <span class="tok-type">u8</span>,
            type_size: <span class="tok-type">u8</span>,
            branch_offset: <span class="tok-type">i16</span>,
            base_register: <span class="tok-kw">struct</span> {
                base_register: <span class="tok-type">u8</span>,
                offset: <span class="tok-type">i64</span>,
            },
            composite_location: <span class="tok-kw">struct</span> {
                size: <span class="tok-type">u64</span>,
                offset: <span class="tok-type">i64</span>,
            },
            block: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            register_type: <span class="tok-kw">struct</span> {
                register: <span class="tok-type">u8</span>,
                type_offset: addr_type,
            },
            const_type: <span class="tok-kw">struct</span> {
                type_offset: addr_type,
                value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            },
            deref_type: <span class="tok-kw">struct</span> {
                size: <span class="tok-type">u8</span>,
                type_offset: addr_type,
            },
        };

        <span class="tok-kw">const</span> Value = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            generic: addr_type,<span class="tok-comment">

            // Typed value with a maximum size of a register
            </span>regval_type: <span class="tok-kw">struct</span> {<span class="tok-comment">
                // Offset of DW_TAG_base_type DIE
                </span>type_offset: addr_type,
                type_size: <span class="tok-type">u8</span>,
                value: addr_type,
            },<span class="tok-comment">

            // Typed value specified directly in the instruction stream
            </span>const_type: <span class="tok-kw">struct</span> {<span class="tok-comment">
                // Offset of DW_TAG_base_type DIE
                </span>type_offset: addr_type,<span class="tok-comment">
                // Backed by the instruction stream
                </span>value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            },

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asIntegral</span>(self: <a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a>) !addr_type {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
                    .generic =&gt; |v| v,<span class="tok-comment">

                    // TODO: For these two prongs, look up the type and assert it's integral?
                    </span>.regval_type =&gt; |regval_type| regval_type.value,
                    .const_type =&gt; |const_type| {
                        <span class="tok-kw">const</span> value: <span class="tok-type">u64</span> = <span class="tok-kw">switch</span> (const_type.value_bytes.len) {
                            <span class="tok-number">1</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u8</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">1</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>),
                            <span class="tok-number">2</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>),
                            <span class="tok-number">4</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>),
                            <span class="tok-number">8</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u64</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">8</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>),
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIntegralTypeSize,
                        };

                        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(addr_type, value) <span class="tok-kw">orelse</span> <span class="tok-kw">error</span>.TruncatedIntegralType;
                    },
                };
            }
        };

        stack: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a>) = .empty,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>) <span class="tok-type">void</span> {
            self.stack.clearRetainingCapacity();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.stack.deinit(allocator);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">generic</span>(value: <span class="tok-kw">anytype</span>) <a href="std.debug.Dwarf.expression.StackMachine.Operand.html">Operand</a> {
            <span class="tok-kw">const</span> int_info = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value)).int;
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value)) &gt; options.addr_size) {
                <span class="tok-kw">return</span> .{ .generic = <span class="tok-kw">switch</span> (int_info.signedness) {
                    .signed =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(addr_type_signed, <span class="tok-builtin">@truncate</span>(value))),
                    .unsigned =&gt; <span class="tok-builtin">@truncate</span>(value),
                } };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{ .generic = <span class="tok-kw">switch</span> (int_info.signedness) {
                    .signed =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(addr_type_signed, <span class="tok-builtin">@intCast</span>(value))),
                    .unsigned =&gt; <span class="tok-builtin">@intCast</span>(value),
                } };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOperand</span>(stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), opcode: <span class="tok-type">u8</span>, context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>) !?<a href="std.debug.Dwarf.expression.StackMachine.Operand.html">Operand</a> {
            <span class="tok-kw">const</span> reader = stream.reader();
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(addr_type, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a> =&gt; <span class="tok-kw">switch</span> (context.format) {
                    .@&quot;32&quot; =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
                    .@&quot;64&quot; =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian)),
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>,
                =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readByte()),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                =&gt; .{ .type_size = <span class="tok-kw">try</span> reader.readByte() },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readByteSigned()),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>,
                =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u16</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>,
                =&gt; .{ .branch_offset = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian) },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i32</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i64</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a>,
                =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a>,
                =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit31">lit31</a> =&gt; |n| <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg31">reg31</a> =&gt; |n| .{ .register = n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a> },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg31">breg31</a> =&gt; |n| .{ .base_register = .{
                    .base_register = n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>,
                    .offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader),
                } },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regx">regx</a> =&gt; .{ .register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader) },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a> =&gt; blk: {
                    <span class="tok-kw">const</span> base_register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader);
                    <span class="tok-kw">break</span> :blk .{ .base_register = .{
                        .base_register = base_register,
                        .offset = offset,
                    } };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a> =&gt; blk: {
                    <span class="tok-kw">const</span> register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader);
                    <span class="tok-kw">break</span> :blk .{ .register_type = .{
                        .register = register,
                        .type_offset = type_offset,
                    } };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.piece">piece</a> =&gt; .{
                    .composite_location = .{
                        .size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader),
                        .offset = <span class="tok-number">0</span>,
                    },
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bit_piece">bit_piece</a> =&gt; blk: {
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader);
                    <span class="tok-kw">break</span> :blk .{ .composite_location = .{
                        .size = size,
                        .offset = offset,
                    } };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.implicit_value">implicit_value</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a> =&gt; blk: {
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> block = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];
                    stream.pos += size;
                    <span class="tok-kw">break</span> :blk .{
                        .block = block,
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a> =&gt; blk: {
                    <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader);
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> reader.readByte();
                    <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> value_bytes = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];
                    stream.pos += size;
                    <span class="tok-kw">break</span> :blk .{ .const_type = .{
                        .type_offset = type_offset,
                        .value_bytes = value_bytes,
                    } };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                =&gt; .{
                    .deref_type = .{
                        .size = <span class="tok-kw">try</span> reader.readByte(),
                        .type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader),
                    },
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lo_user">lo_user</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.hi_user">hi_user</a> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUserOpcode,
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(
            self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>,
            expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
            context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>,
            initial_value: ?<span class="tok-type">usize</span>,
        ) <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Error">Error</a>!?<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a> {
            <span class="tok-kw">if</span> (initial_value) |i| <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = i });
            <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(expression);
            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.step(&amp;stream, allocator, context)) {}
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
        }

        <span class="tok-comment">/// Reads an opcode and its operands from `stream`, then executes it</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(
            self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>,
            stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),
            allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
            context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>,
        ) <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Error">Error</a>!<span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) != <span class="tok-builtin">@sizeOf</span>(addr_type) <span class="tok-kw">or</span> options.endian != <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Execution of non-native address sizes / endianness is not supported&quot;</span>);

            <span class="tok-kw">const</span> opcode = <span class="tok-kw">try</span> stream.reader().readByte();
            <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeValidInCFA">isOpcodeValidInCFA</a>(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.readOperand">readOperand</a>(stream, opcode, context);
            <span class="tok-kw">switch</span> (opcode) {<span class="tok-comment">

                // 2.5.1.1: Literal Encodings
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit31">lit31</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>,
                =&gt; <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = operand.?.generic }),

                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a> =&gt; {
                    <span class="tok-kw">const</span> const_type = operand.?.const_type;
                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .const_type = .{
                        .type_offset = const_type.type_offset,
                        .value_bytes = const_type.value_bytes,
                    } });
                },

                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>,
                =&gt; {
                    <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                    <span class="tok-kw">if</span> (context.debug_addr == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                    <span class="tok-kw">const</span> debug_addr_index = operand.?.generic;
                    <span class="tok-kw">const</span> offset = context.compile_unit.?.addr_base + debug_addr_index;
                    <span class="tok-kw">if</span> (offset &gt;= context.debug_addr.?.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, context.debug_addr.?[offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });
                },<span class="tok-comment">

                // 2.5.1.2: Register Values
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a> =&gt; {
                    <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                    <span class="tok-kw">if</span> (context.compile_unit.?.frame_base == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

                    <span class="tok-kw">const</span> offset: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(operand.?.generic);
                    _ = offset;

                    <span class="tok-kw">switch</span> (context.compile_unit.?.frame_base.?.*) {
                        .exprloc =&gt; {<span class="tok-comment">
                            // TODO: Run this expression in a nested stack machine
                            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                        },
                        .loclistx =&gt; {<span class="tok-comment">
                            // TODO: Read value from .debug_loclists
                            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                        },
                        .sec_offset =&gt; {<span class="tok-comment">
                            // TODO: Read value from .debug_loclists
                            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFrameBase,
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg31">breg31</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a>,
                =&gt; {
                    <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

                    <span class="tok-kw">const</span> base_register = operand.?.base_register;
                    <span class="tok-kw">var</span> value: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(
                        context.thread_context.?,
                        base_register.base_register,
                        context.reg_context,
                    ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>));
                    value += base_register.offset;
                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intCast</span>(value) });
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a> =&gt; {
                    <span class="tok-kw">const</span> register_type = operand.?.register_type;
                    <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(
                        context.thread_context.?,
                        register_type.register,
                        context.reg_context,
                    ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
                    <span class="tok-kw">try</span> self.stack.append(allocator, .{
                        .regval_type = .{
                            .type_offset = register_type.type_offset,
                            .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),
                            .value = value,
                        },
                    });
                },<span class="tok-comment">

                // 2.5.1.3: Stack Operations
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.dup">dup</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span>]);
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.drop">drop</a> =&gt; {
                    _ = self.stack.pop();
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a> =&gt; {
                    <span class="tok-kw">const</span> stack_index = <span class="tok-kw">if</span> (opcode == <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a>) <span class="tok-number">1</span> <span class="tok-kw">else</span> operand.?.generic;
                    <span class="tok-kw">if</span> (stack_index &gt;= self.stack.items.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span> - stack_index]);
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.swap">swap</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a>, &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>], &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>]);
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.rot">rot</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> first = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];
                    self.stack.items[self.stack.items.len - <span class="tok-number">2</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">3</span>];
                    self.stack.items[self.stack.items.len - <span class="tok-number">3</span>] = first;
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> addr = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                    <span class="tok-kw">const</span> addr_space_identifier: ?<span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (opcode) {
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                        =&gt; blk: {
                            _ = self.stack.pop();
                            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
                    };<span class="tok-comment">

                    // Usage of addr_space_identifier in the address calculation is implementation defined.
                    // This code will need to be updated to handle any architectures that utilize this.
                    </span>_ = addr_space_identifier;

                    <span class="tok-kw">const</span> size = <span class="tok-kw">switch</span> (opcode) {
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                        =&gt; <span class="tok-builtin">@sizeOf</span>(addr_type),
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                        =&gt; operand.?.type_size,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                        =&gt; operand.?.deref_type.size,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    };

                    <span class="tok-kw">if</span> (context.memory_accessor) |memory_accessor| {
                        <span class="tok-kw">if</span> (!<span class="tok-kw">switch</span> (size) {
                            <span class="tok-number">1</span> =&gt; memory_accessor.load(<span class="tok-type">u8</span>, addr) != <span class="tok-null">null</span>,
                            <span class="tok-number">2</span> =&gt; memory_accessor.load(<span class="tok-type">u16</span>, addr) != <span class="tok-null">null</span>,
                            <span class="tok-number">4</span> =&gt; memory_accessor.load(<span class="tok-type">u32</span>, addr) != <span class="tok-null">null</span>,
                            <span class="tok-number">8</span> =&gt; memory_accessor.load(<span class="tok-type">u64</span>, addr) != <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression,
                        }) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    }

                    <span class="tok-kw">const</span> value: addr_type = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(addr_type, <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-kw">switch</span> (size) {
                        <span class="tok-number">1</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                        <span class="tok-number">2</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u16</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                        <span class="tok-number">4</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                        <span class="tok-number">8</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u64</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression,
                    })) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;

                    <span class="tok-kw">switch</span> (opcode) {
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                        =&gt; {
                            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                                .regval_type = .{
                                    .type_offset = operand.?.deref_type.type_offset,
                                    .type_size = operand.?.deref_type.size,
                                    .value = value,
                                },
                            };
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = value };
                        },
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.push_object_address">push_object_address</a> =&gt; {<span class="tok-comment">
                    // In sub-expressions, `push_object_address` is not meaningful (as per the
                    // spec), so treat it like a nop
                    </span><span class="tok-kw">if</span> (!context.entry_value_context) {
                        <span class="tok-kw">if</span> (context.object_address == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intFromPtr</span>(context.object_address.?) });
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.form_tls_address">form_tls_address</a> =&gt; {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_frame_cfa">call_frame_cfa</a> =&gt; {
                    <span class="tok-kw">if</span> (context.cfa) |cfa| {
                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = cfa });
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                },<span class="tok-comment">

                // 2.5.1.4: Arithmetic and Logical Operations
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.abs">abs</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> value: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@abs</span>(value),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="#"and"">@&quot;and&quot;</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = a &amp; <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.div">div</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divTrunc">divTrunc</a>(<span class="tok-type">isize</span>, b, a)),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.minus">minus</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mod">mod</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mod</span>(b, a)),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mul">mul</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mulWithOverflow</span>(a, b)[<span class="tok-number">0</span>]),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.neg">neg</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(
                            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.negate">negate</a>(
                                <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral())),
                            ),
                        ),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.not">not</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = ~<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="#"or"">@&quot;or&quot;</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = a | <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus">plus</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> constant = operand.?.generic;
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), constant),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shl">shl</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<span class="tok-type">usize</span>, b, a),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shr">shr</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<span class="tok-type">usize</span>, b, a),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shra">shra</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<span class="tok-type">isize</span>, b, a)),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xor">xor</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = a ^ <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
                    };
                },<span class="tok-comment">

                // 2.5.1.5: Control Flow Operations
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a>,
                =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = self.stack.pop().?;
                    <span class="tok-kw">const</span> b = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];

                    <span class="tok-kw">if</span> (a == .generic <span class="tok-kw">and</span> b == .generic) {
                        <span class="tok-kw">const</span> a_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(a.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
                        <span class="tok-kw">const</span> b_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(b.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
                        <span class="tok-kw">const</span> result = <span class="tok-builtin">@intFromBool</span>(<span class="tok-kw">switch</span> (opcode) {
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a> =&gt; b_int &lt;= a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a> =&gt; b_int &gt;= a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a> =&gt; b_int == a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a> =&gt; b_int &lt; a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a> =&gt; b_int &gt; a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a> =&gt; b_int != a_int,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        });

                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = result };
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // TODO: Load the types referenced by these values, find their comparison operator, and run it
                        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypedComparison;
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a> =&gt; {
                    <span class="tok-kw">const</span> branch_offset = operand.?.branch_offset;
                    <span class="tok-kw">const</span> condition = <span class="tok-kw">if</span> (opcode == <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>) blk: {
                        <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                        <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.pop().?.asIntegral() != <span class="tok-number">0</span>;
                    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;

                    <span class="tok-kw">if</span> (condition) {
                        <span class="tok-kw">const</span> new_pos = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(
                            <span class="tok-type">usize</span>,
                            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(stream.pos)), branch_offset),
                        ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;

                        <span class="tok-kw">if</span> (new_pos &lt; <span class="tok-number">0</span> <span class="tok-kw">or</span> new_pos &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                        stream.pos = new_pos;
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a>,
                =&gt; {
                    <span class="tok-kw">const</span> debug_info_offset = operand.?.generic;
                    _ = debug_info_offset;<span class="tok-comment">

                    // TODO: Load a DIE entry at debug_info_offset in a .debug_info section (the spec says that it
                    //       can be in a separate exe / shared object from the one containing this expression).
                    //       Transfer control to the DW_AT_location attribute, with the current stack as input.

                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedExpressionCall;
                },<span class="tok-comment">

                // 2.5.1.6: Type Conversions
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> type_offset = operand.?.generic;<span class="tok-comment">

                    // TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size
                    </span><span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
                    <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {
                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // TODO: Load the DW_TAG_base_type entry in context.compile_unit, find a conversion operator
                        //       from the old type to the new type, run it.
                        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypeConversion;
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> type_offset = operand.?.generic;<span class="tok-comment">

                    // TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size
                    </span><span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
                    <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {
                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };
                    } <span class="tok-kw">else</span> {
                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = <span class="tok-kw">switch</span> (value) {
                            .generic =&gt; |v| .{
                                .regval_type = .{
                                    .type_offset = type_offset,
                                    .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),
                                    .value = v,
                                },
                            },
                            .regval_type =&gt; |r| .{
                                .regval_type = .{
                                    .type_offset = type_offset,
                                    .type_size = r.type_size,
                                    .value = r.value,
                                },
                            },
                            .const_type =&gt; |c| .{
                                .const_type = .{
                                    .type_offset = type_offset,
                                    .value_bytes = c.value_bytes,
                                },
                            },
                        };
                    }
                },<span class="tok-comment">

                // 2.5.1.7: Special Operations
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.nop">nop</a> =&gt; {},
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a> =&gt; {
                    <span class="tok-kw">const</span> block = operand.?.block;
                    <span class="tok-kw">if</span> (block.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression;<span class="tok-comment">

                    // TODO: The spec states that this sub-expression needs to observe the state (ie. registers)
                    //       as it was upon entering the current subprogram. If this isn't being called at the
                    //       end of a frame unwind operation, an additional ThreadContext with this state will be needed.

                    </span><span class="tok-kw">if</span> (<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeRegisterLocation">isOpcodeRegisterLocation</a>(block[<span class="tok-number">0</span>])) {
                        <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

                        <span class="tok-kw">var</span> block_stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(block);
                        <span class="tok-kw">const</span> register = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.readOperand">readOperand</a>(&amp;block_stream, block[<span class="tok-number">0</span>], context)).?.register;
                        <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context.?, register, context.reg_context))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">var</span> stack_machine: <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a> = .{};
                        <span class="tok-kw">defer</span> stack_machine.deinit(allocator);

                        <span class="tok-kw">var</span> sub_context = context;
                        sub_context.entry_value_context = <span class="tok-null">true</span>;
                        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> stack_machine.run(block, allocator, sub_context, <span class="tok-null">null</span>);
                        <span class="tok-kw">try</span> self.stack.append(allocator, result <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression);
                    }
                },<span class="tok-comment">

                // These have already been handled by readOperand
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lo_user">lo_user</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.hi_user">hi_user</a> =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; {<span class="tok-comment">
                    //std.debug.print(&quot;Unknown DWARF expression opcode: {x}\n&quot;, .{opcode});
                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownExpressionOpcode;
                },
            }

            <span class="tok-kw">return</span> stream.pos &lt; stream.buffer.len;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.debug.Dwarf.expression.Builder" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Builder</span><a href="#src.zig-std.debug.Dwarf.expression.Builder">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.debug.Dwarf.expression.Options.html">Options</a></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeOpcode" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeOpcode</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeOpcode">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeOpcode</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> opcode: <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Zero-operand instructions</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>opcode: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeOpcode">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeOpcode</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> opcode: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !<span class="tok-kw">comptime</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeValidInCFA">isOpcodeValidInCFA</a>(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">switch</span> (opcode) {
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.dup">dup</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.drop">drop</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.swap">swap</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.rot">rot</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.push_object_address">push_object_address</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.form_tls_address">form_tls_address</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_frame_cfa">call_frame_cfa</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.abs">abs</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="#"and"">@&quot;and&quot;</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.div">div</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.minus">minus</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mod">mod</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mul">mul</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.neg">neg</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.not">not</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="#"or"">@&quot;or&quot;</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus">plus</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shl">shl</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shr">shr</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shra">shra</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xor">xor</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.nop">nop</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.stack_value">stack_value</a>,
        =&gt; <span class="tok-kw">try</span> writer.writeByte(opcode),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;This opcode requires operands, use `write&lt;Opcode&gt;()` instead&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeLiteral" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeLiteral</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeLiteral">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeLiteral</span>(writer: <span class="tok-kw">anytype</span>, literal: <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>literal: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeLiteral">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeLiteral</span>(writer: <span class="tok-kw">anytype</span>, literal: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (literal) {
        <span class="tok-number">0</span>...<span class="tok-number">31</span> =&gt; |n| <span class="tok-kw">try</span> writer.writeByte(n + <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidLiteral,
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeConst</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeConst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConst</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>value: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeConst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConst</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T) != .int) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Constants must be integers&quot;</span>);

    <span class="tok-kw">switch</span> (T) {
        <span class="tok-type">u8</span>, <span class="tok-type">i8</span>, <span class="tok-type">u16</span>, <span class="tok-type">i16</span>, <span class="tok-type">u32</span>, <span class="tok-type">i32</span>, <span class="tok-type">u64</span>, <span class="tok-type">i64</span> =&gt; {
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-kw">switch</span> (T) {
                <span class="tok-type">u8</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
                <span class="tok-type">i8</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a>,
                <span class="tok-type">u16</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
                <span class="tok-type">i16</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a>,
                <span class="tok-type">u32</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a>,
                <span class="tok-type">i32</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a>,
                <span class="tok-type">u64</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a>,
                <span class="tok-type">i64</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            });

            <span class="tok-kw">try</span> writer.writeInt(T, value, options.endian);
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T).int.signedness) {
            .unsigned =&gt; {
                <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>);
                <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, value);
            },
            .signed =&gt; {
                <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>);
                <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, value);
            },
        },
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeConstx" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeConstx</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeConstx">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeConstx">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, debug_addr_offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeConstType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeConstType</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeConstType">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstType</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeConstType">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstType</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">if</span> (value_bytes.len &gt; <span class="tok-number">0xff</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidTypeLength;
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-builtin">@intCast</span>(value_bytes.len));
    <span class="tok-kw">try</span> writer.writeAll(value_bytes);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeAddr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeAddr</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeAddr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddr</span>(writer: <span class="tok-kw">anytype</span>, value: addr_type) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>value: addr_type</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeAddr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddr</span>(writer: <span class="tok-kw">anytype</span>, value: addr_type) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a>);
    <span class="tok-kw">try</span> writer.writeInt(addr_type, value, options.endian);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeAddrx" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeAddrx</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeAddrx">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddrx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeAddrx">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddrx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, debug_addr_offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeFbreg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeFbreg</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeFbreg">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFbreg</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeFbreg">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFbreg</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeBreg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeBreg</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeBreg">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBreg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>register: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeBreg">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBreg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (register &gt; <span class="tok-number">31</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidRegister;
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a> + register);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeBregx" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeBregx</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeBregx">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBregx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeBregx">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBregx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeRegvalType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeRegvalType</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeRegvalType">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegvalType</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeRegvalType">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegvalType</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writePick" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writePick</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writePick">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePick</span>(writer: <span class="tok-kw">anytype</span>, index: <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>index: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writePick">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePick</span>(writer: <span class="tok-kw">anytype</span>, index: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>);
    <span class="tok-kw">try</span> writer.writeByte(index);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeDerefSize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeDerefSize</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeDerefSize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>size: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeDerefSize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>);
    <span class="tok-kw">try</span> writer.writeByte(size);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeXDerefSize" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeXDerefSize</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeXDerefSize">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>size: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeXDerefSize">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>);
    <span class="tok-kw">try</span> writer.writeByte(size);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeDerefType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeDerefType</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeDerefType">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>size: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeDerefType">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>);
    <span class="tok-kw">try</span> writer.writeByte(size);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeXDerefType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeXDerefType</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeXDerefType">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>size: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeXDerefType">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>);
    <span class="tok-kw">try</span> writer.writeByte(size);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writePlusUconst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writePlusUconst</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writePlusUconst">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePlusUconst</span>(writer: <span class="tok-kw">anytype</span>, uint_value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writePlusUconst">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePlusUconst</span>(writer: <span class="tok-kw">anytype</span>, uint_value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, uint_value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeSkip" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeSkip</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeSkip">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSkip</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>offset: <span class="tok-type">i16</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeSkip">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSkip</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>);
    <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeBra" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeBra</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeBra">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBra</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>offset: <span class="tok-type">i16</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeBra">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBra</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>);
    <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeCall" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeCall</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeCall">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCall</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, offset: T) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>offset: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeCall">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCall</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, offset: T) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">switch</span> (T) {
        <span class="tok-type">u16</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>),
        <span class="tok-type">u32</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Call operand must be a 2 or 4 byte offset&quot;</span>),
    }

    <span class="tok-kw">try</span> writer.writeInt(T, offset, options.endian);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeCallRef" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeCallRef</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeCallRef">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCallRef</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> is_64: <span class="tok-type">bool</span>, value: <span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>is_64: <span class="tok-type">bool</span></code></pre></div><div><pre><code>value: <span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeCallRef">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCallRef</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> is_64: <span class="tok-type">bool</span>, value: <span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a>);
    <span class="tok-kw">try</span> writer.writeInt(<span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>, value, options.endian);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeConvert" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeConvert</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeConvert">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConvert</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeConvert">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConvert</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeReinterpret" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeReinterpret</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeReinterpret">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReinterpret</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeReinterpret">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReinterpret</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeEntryValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeEntryValue</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeEntryValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEntryValue</span>(writer: <span class="tok-kw">anytype</span>, expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeEntryValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEntryValue</span>(writer: <span class="tok-kw">anytype</span>, expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, expression.len);
    <span class="tok-kw">try</span> writer.writeAll(expression);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeReg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeReg</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeReg">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>register: <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeReg">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a> + register);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeRegx" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeRegx</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeRegx">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeRegx">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regx">regx</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
}</code></pre></details></div></div><div class="decl"><h3 id="std.debug.Dwarf.expression.Builder.writeImplicitValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeImplicitValue</span><a href="#src.zig-std.debug.Dwarf.expression.Builder.writeImplicitValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeImplicitValue</span>(writer: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder.writeImplicitValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeImplicitValue</span>(writer: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.implicit_value">implicit_value</a>);
    <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, value_bytes.len);
    <span class="tok-kw">try</span> writer.writeAll(value_bytes);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Builder">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Builder</span>(<span class="tok-kw">comptime</span> options: <a href="std.debug.Dwarf.expression.Options.html">Options</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> addr_type = <span class="tok-kw">switch</span> (options.addr_size) {
        <span class="tok-number">2</span> =&gt; <span class="tok-type">u16</span>,
        <span class="tok-number">4</span> =&gt; <span class="tok-type">u32</span>,
        <span class="tok-number">8</span> =&gt; <span class="tok-type">u64</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),
    };

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Zero-operand instructions</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeOpcode</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> opcode: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !<span class="tok-kw">comptime</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeValidInCFA">isOpcodeValidInCFA</a>(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">switch</span> (opcode) {
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.dup">dup</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.drop">drop</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.swap">swap</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.rot">rot</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.push_object_address">push_object_address</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.form_tls_address">form_tls_address</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_frame_cfa">call_frame_cfa</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.abs">abs</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="#"and"">@&quot;and&quot;</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.div">div</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.minus">minus</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mod">mod</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mul">mul</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.neg">neg</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.not">not</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="#"or"">@&quot;or&quot;</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus">plus</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shl">shl</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shr">shr</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shra">shra</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xor">xor</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.nop">nop</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.stack_value">stack_value</a>,
                =&gt; <span class="tok-kw">try</span> writer.writeByte(opcode),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;This opcode requires operands, use `write&lt;Opcode&gt;()` instead&quot;</span>),
            }
        }<span class="tok-comment">

        // 2.5.1.1: Literal Encodings
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeLiteral</span>(writer: <span class="tok-kw">anytype</span>, literal: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (literal) {
                <span class="tok-number">0</span>...<span class="tok-number">31</span> =&gt; |n| <span class="tok-kw">try</span> writer.writeByte(n + <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidLiteral,
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConst</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T) != .int) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Constants must be integers&quot;</span>);

            <span class="tok-kw">switch</span> (T) {
                <span class="tok-type">u8</span>, <span class="tok-type">i8</span>, <span class="tok-type">u16</span>, <span class="tok-type">i16</span>, <span class="tok-type">u32</span>, <span class="tok-type">i32</span>, <span class="tok-type">u64</span>, <span class="tok-type">i64</span> =&gt; {
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-kw">switch</span> (T) {
                        <span class="tok-type">u8</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
                        <span class="tok-type">i8</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a>,
                        <span class="tok-type">u16</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
                        <span class="tok-type">i16</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a>,
                        <span class="tok-type">u32</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a>,
                        <span class="tok-type">i32</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a>,
                        <span class="tok-type">u64</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a>,
                        <span class="tok-type">i64</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    });

                    <span class="tok-kw">try</span> writer.writeInt(T, value, options.endian);
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T).int.signedness) {
                    .unsigned =&gt; {
                        <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>);
                        <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, value);
                    },
                    .signed =&gt; {
                        <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>);
                        <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, value);
                    },
                },
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, debug_addr_offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstType</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">if</span> (value_bytes.len &gt; <span class="tok-number">0xff</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidTypeLength;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-builtin">@intCast</span>(value_bytes.len));
            <span class="tok-kw">try</span> writer.writeAll(value_bytes);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddr</span>(writer: <span class="tok-kw">anytype</span>, value: addr_type) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a>);
            <span class="tok-kw">try</span> writer.writeInt(addr_type, value, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddrx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, debug_addr_offset);
        }<span class="tok-comment">

        // 2.5.1.2: Register Values
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFbreg</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBreg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (register &gt; <span class="tok-number">31</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidRegister;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a> + register);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBregx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegvalType</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, offset);
        }<span class="tok-comment">

        // 2.5.1.3: Stack Operations
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePick</span>(writer: <span class="tok-kw">anytype</span>, index: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>);
            <span class="tok-kw">try</span> writer.writeByte(index);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>);
            <span class="tok-kw">try</span> writer.writeByte(size);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>);
            <span class="tok-kw">try</span> writer.writeByte(size);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>);
            <span class="tok-kw">try</span> writer.writeByte(size);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>);
            <span class="tok-kw">try</span> writer.writeByte(size);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
        }<span class="tok-comment">

        // 2.5.1.4: Arithmetic and Logical Operations

        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePlusUconst</span>(writer: <span class="tok-kw">anytype</span>, uint_value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, uint_value);
        }<span class="tok-comment">

        // 2.5.1.5: Control Flow Operations

        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSkip</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>);
            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBra</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>);
            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCall</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, offset: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">switch</span> (T) {
                <span class="tok-type">u16</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>),
                <span class="tok-type">u32</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a>),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Call operand must be a 2 or 4 byte offset&quot;</span>),
            }

            <span class="tok-kw">try</span> writer.writeInt(T, offset, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCallRef</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> is_64: <span class="tok-type">bool</span>, value: <span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a>);
            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>, value, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConvert</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReinterpret</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
        }<span class="tok-comment">

        // 2.5.1.7: Special Operations

        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEntryValue</span>(writer: <span class="tok-kw">anytype</span>, expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, expression.len);
            <span class="tok-kw">try</span> writer.writeAll(expression);
        }<span class="tok-comment">

        // 2.6: Location Descriptions
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a> + register);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regx">regx</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeImplicitValue</span>(writer: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.implicit_value">implicit_value</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, value_bytes.len);
            <span class="tok-kw">try</span> writer.writeAll(value_bytes);
        }
    };
}</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.debug.Dwarf.expression.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.debug.Dwarf.expression.Error">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>DivisionByZero</dt></div><div><dt>EndOfStream</dt></div><div><dt>IncompleteExpressionContext</dt></div><div><dt>InvalidCFAOpcode</dt></div><div><dt>InvalidExpression</dt></div><div><dt>InvalidFrameBase</dt></div><div><dt>InvalidIntegralTypeSize</dt></div><div><dt>InvalidRegister</dt></div><div><dt>InvalidSubExpression</dt></div><div><dt>InvalidTypeLength</dt></div><div><dt>OutOfMemory</dt></div><div><dt>Overflow</dt></div><div><dt>RegisterContextRequired <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.RegBytesError">RegBytesError</a></dt></div><div><dt>ThreadContextNotSupported <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.RegBytesError">RegBytesError</a></dt></div><div><dt>TruncatedIntegralType</dt></div><div><dt>UnimplementedArch <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.RegBytesError">RegBytesError</a></dt></div><div><dt>UnimplementedExpressionCall</dt></div><div><dt>UnimplementedOpcode</dt></div><div><dt>UnimplementedOs <a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.RegBytesError">RegBytesError</a></dt></div><div><dt>UnimplementedTypeConversion</dt></div><div><dt>UnimplementedTypedComparison</dt></div><div><dt>UnimplementedUserOpcode</dt></div><div><dt>UnknownExpressionOpcode</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression.Error">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{
    UnimplementedExpressionCall,
    UnimplementedOpcode,
    UnimplementedUserOpcode,
    UnimplementedTypedComparison,
    UnimplementedTypeConversion,

    UnknownExpressionOpcode,

    IncompleteExpressionContext,

    InvalidCFAOpcode,
    InvalidExpression,
    InvalidFrameBase,
    InvalidIntegralTypeSize,
    InvalidRegister,
    InvalidSubExpression,
    InvalidTypeLength,

    TruncatedIntegralType,
} || <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.RegBytesError">RegBytesError</a> || <span class="tok-kw">error</span>{ EndOfStream, Overflow, OutOfMemory, DivisionByZero }</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.debug.Dwarf.expression">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> native_arch = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.cpu">cpu</a>.<a href="#">arch</a>;
<span class="tok-kw">const</span> native_endian = <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_arch">native_arch</a>.<a href="#">endian</a>();

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> leb = <a href="std.html">std</a>.<a href="std.leb128.html">leb</a>;
<span class="tok-kw">const</span> OP = <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>.<a href="std.dwarf.OP.html">OP</a>;
<span class="tok-kw">const</span> abi = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.abi.html">abi</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;

<span class="tok-comment">/// Expressions can be evaluated in different contexts, each requiring its own set of inputs.</span>
<span class="tok-comment">/// Callers should specify all the fields relevant to their context. If a field is required</span>
<span class="tok-comment">/// by the expression and it isn't in the context, error.IncompleteExpressionContext is returned.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Context = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The dwarf format of the section this expression is in</span>
    format: <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>.<a href="std.dwarf.Format.html">Format</a> = .@&quot;32&quot;,
    <span class="tok-comment">/// If specified, any addresses will pass through before being accessed</span>
    memory_accessor: ?*<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.MemoryAccessor.html">MemoryAccessor</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// The compilation unit this expression relates to, if any</span>
    compile_unit: ?*<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// When evaluating a user-presented expression, this is the address of the object being evaluated</span>
    object_address: ?*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// .debug_addr section</span>
    debug_addr: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Thread context</span>
    thread_context: ?*<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a> = <span class="tok-null">null</span>,
    reg_context: ?<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.RegisterContext.html">RegisterContext</a> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// Call frame address, if in a CFI context</span>
    cfa: ?<span class="tok-type">usize</span> = <span class="tok-null">null</span>,
    <span class="tok-comment">/// This expression is a sub-expression from an OP.entry_value instruction</span>
    entry_value_context: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The address size of the target architecture</span>
    addr_size: <span class="tok-type">u8</span> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>),
    <span class="tok-comment">/// Endianness of the target architecture</span>
    endian: <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a> = <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>,
    <span class="tok-comment">/// Restrict the stack machine to a subset of opcodes used in call frame instructions</span>
    call_frame_context: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
};<span class="tok-comment">

// Explicitly defined to support executing sub-expressions
</span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{
    UnimplementedExpressionCall,
    UnimplementedOpcode,
    UnimplementedUserOpcode,
    UnimplementedTypedComparison,
    UnimplementedTypeConversion,

    UnknownExpressionOpcode,

    IncompleteExpressionContext,

    InvalidCFAOpcode,
    InvalidExpression,
    InvalidFrameBase,
    InvalidIntegralTypeSize,
    InvalidRegister,
    InvalidSubExpression,
    InvalidTypeLength,

    TruncatedIntegralType,
} || <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.RegBytesError">RegBytesError</a> || <span class="tok-kw">error</span>{ EndOfStream, Overflow, OutOfMemory, DivisionByZero };

<span class="tok-comment">/// A stack machine that can decode and run DWARF expressions.</span>
<span class="tok-comment">/// Expressions can be decoded for non-native address size and endianness,</span>
<span class="tok-comment">/// but can only be executed if the current target matches the configuration.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StackMachine</span>(<span class="tok-kw">comptime</span> options: <a href="std.debug.Dwarf.expression.Options.html">Options</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> addr_type = <span class="tok-kw">switch</span> (options.addr_size) {
        <span class="tok-number">2</span> =&gt; <span class="tok-type">u16</span>,
        <span class="tok-number">4</span> =&gt; <span class="tok-type">u32</span>,
        <span class="tok-number">8</span> =&gt; <span class="tok-type">u64</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),
    };

    <span class="tok-kw">const</span> addr_type_signed = <span class="tok-kw">switch</span> (options.addr_size) {
        <span class="tok-number">2</span> =&gt; <span class="tok-type">i16</span>,
        <span class="tok-number">4</span> =&gt; <span class="tok-type">i32</span>,
        <span class="tok-number">8</span> =&gt; <span class="tok-type">i64</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),
    };

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">const</span> Operand = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            generic: addr_type,
            register: <span class="tok-type">u8</span>,
            type_size: <span class="tok-type">u8</span>,
            branch_offset: <span class="tok-type">i16</span>,
            base_register: <span class="tok-kw">struct</span> {
                base_register: <span class="tok-type">u8</span>,
                offset: <span class="tok-type">i64</span>,
            },
            composite_location: <span class="tok-kw">struct</span> {
                size: <span class="tok-type">u64</span>,
                offset: <span class="tok-type">i64</span>,
            },
            block: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            register_type: <span class="tok-kw">struct</span> {
                register: <span class="tok-type">u8</span>,
                type_offset: addr_type,
            },
            const_type: <span class="tok-kw">struct</span> {
                type_offset: addr_type,
                value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            },
            deref_type: <span class="tok-kw">struct</span> {
                size: <span class="tok-type">u8</span>,
                type_offset: addr_type,
            },
        };

        <span class="tok-kw">const</span> Value = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            generic: addr_type,<span class="tok-comment">

            // Typed value with a maximum size of a register
            </span>regval_type: <span class="tok-kw">struct</span> {<span class="tok-comment">
                // Offset of DW_TAG_base_type DIE
                </span>type_offset: addr_type,
                type_size: <span class="tok-type">u8</span>,
                value: addr_type,
            },<span class="tok-comment">

            // Typed value specified directly in the instruction stream
            </span>const_type: <span class="tok-kw">struct</span> {<span class="tok-comment">
                // Offset of DW_TAG_base_type DIE
                </span>type_offset: addr_type,<span class="tok-comment">
                // Backed by the instruction stream
                </span>value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            },

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asIntegral</span>(self: <a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a>) !addr_type {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
                    .generic =&gt; |v| v,<span class="tok-comment">

                    // TODO: For these two prongs, look up the type and assert it's integral?
                    </span>.regval_type =&gt; |regval_type| regval_type.value,
                    .const_type =&gt; |const_type| {
                        <span class="tok-kw">const</span> value: <span class="tok-type">u64</span> = <span class="tok-kw">switch</span> (const_type.value_bytes.len) {
                            <span class="tok-number">1</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u8</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">1</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>),
                            <span class="tok-number">2</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u16</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>),
                            <span class="tok-number">4</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u32</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">4</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>),
                            <span class="tok-number">8</span> =&gt; <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">u64</span>, const_type.value_bytes[<span class="tok-number">0</span>..<span class="tok-number">8</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>),
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidIntegralTypeSize,
                        };

                        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(addr_type, value) <span class="tok-kw">orelse</span> <span class="tok-kw">error</span>.TruncatedIntegralType;
                    },
                };
            }
        };

        stack: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a>) = .empty,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>) <span class="tok-type">void</span> {
            self.stack.clearRetainingCapacity();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>, allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.stack.deinit(allocator);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">generic</span>(value: <span class="tok-kw">anytype</span>) <a href="std.debug.Dwarf.expression.StackMachine.Operand.html">Operand</a> {
            <span class="tok-kw">const</span> int_info = <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value)).int;
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value)) &gt; options.addr_size) {
                <span class="tok-kw">return</span> .{ .generic = <span class="tok-kw">switch</span> (int_info.signedness) {
                    .signed =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(addr_type_signed, <span class="tok-builtin">@truncate</span>(value))),
                    .unsigned =&gt; <span class="tok-builtin">@truncate</span>(value),
                } };
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> .{ .generic = <span class="tok-kw">switch</span> (int_info.signedness) {
                    .signed =&gt; <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(addr_type_signed, <span class="tok-builtin">@intCast</span>(value))),
                    .unsigned =&gt; <span class="tok-builtin">@intCast</span>(value),
                } };
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOperand</span>(stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), opcode: <span class="tok-type">u8</span>, context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>) !?<a href="std.debug.Dwarf.expression.StackMachine.Operand.html">Operand</a> {
            <span class="tok-kw">const</span> reader = stream.reader();
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(addr_type, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a> =&gt; <span class="tok-kw">switch</span> (context.format) {
                    .@&quot;32&quot; =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
                    .@&quot;64&quot; =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian)),
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>,
                =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readByte()),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                =&gt; .{ .type_size = <span class="tok-kw">try</span> reader.readByte() },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readByteSigned()),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>,
                =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u16</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>,
                =&gt; .{ .branch_offset = <span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i16</span>, options.endian) },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u32</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i32</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">u64</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a> =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> reader.readInt(<span class="tok-type">i64</span>, options.endian)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a>,
                =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u64</span>, reader)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a>,
                =&gt; <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(<span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader)),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit31">lit31</a> =&gt; |n| <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.generic">generic</a>(n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>),
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg31">reg31</a> =&gt; |n| .{ .register = n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a> },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg31">breg31</a> =&gt; |n| .{ .base_register = .{
                    .base_register = n - <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>,
                    .offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader),
                } },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regx">regx</a> =&gt; .{ .register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader) },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a> =&gt; blk: {
                    <span class="tok-kw">const</span> base_register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader);
                    <span class="tok-kw">break</span> :blk .{ .base_register = .{
                        .base_register = base_register,
                        .offset = offset,
                    } };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a> =&gt; blk: {
                    <span class="tok-kw">const</span> register = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader);
                    <span class="tok-kw">break</span> :blk .{ .register_type = .{
                        .register = register,
                        .type_offset = type_offset,
                    } };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.piece">piece</a> =&gt; .{
                    .composite_location = .{
                        .size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader),
                        .offset = <span class="tok-number">0</span>,
                    },
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bit_piece">bit_piece</a> =&gt; blk: {
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readIleb128">readIleb128</a>(<span class="tok-type">i64</span>, reader);
                    <span class="tok-kw">break</span> :blk .{ .composite_location = .{
                        .size = size,
                        .offset = offset,
                    } };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.implicit_value">implicit_value</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a> =&gt; blk: {
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(<span class="tok-type">u8</span>, reader);
                    <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> block = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];
                    stream.pos += size;
                    <span class="tok-kw">break</span> :blk .{
                        .block = block,
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a> =&gt; blk: {
                    <span class="tok-kw">const</span> type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader);
                    <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> reader.readByte();
                    <span class="tok-kw">if</span> (stream.pos + size &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> value_bytes = stream.buffer[stream.pos..][<span class="tok-number">0</span>..size];
                    stream.pos += size;
                    <span class="tok-kw">break</span> :blk .{ .const_type = .{
                        .type_offset = type_offset,
                        .value_bytes = value_bytes,
                    } };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                =&gt; .{
                    .deref_type = .{
                        .size = <span class="tok-kw">try</span> reader.readByte(),
                        .type_offset = <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.readUleb128">readUleb128</a>(addr_type, reader),
                    },
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lo_user">lo_user</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.hi_user">hi_user</a> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedUserOpcode,
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">run</span>(
            self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>,
            expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
            context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>,
            initial_value: ?<span class="tok-type">usize</span>,
        ) <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Error">Error</a>!?<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a> {
            <span class="tok-kw">if</span> (initial_value) |i| <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = i });
            <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(expression);
            <span class="tok-kw">while</span> (<span class="tok-kw">try</span> self.step(&amp;stream, allocator, context)) {}
            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
        }

        <span class="tok-comment">/// Reads an opcode and its operands from `stream`, then executes it</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">step</span>(
            self: *<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a>,
            stream: *<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.FixedBufferStream">FixedBufferStream</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),
            allocator: <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>,
            context: <a href="std.debug.Dwarf.expression.Context.html">Context</a>,
        ) <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Error">Error</a>!<span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) != <span class="tok-builtin">@sizeOf</span>(addr_type) <span class="tok-kw">or</span> options.endian != <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Execution of non-native address sizes / endianness is not supported&quot;</span>);

            <span class="tok-kw">const</span> opcode = <span class="tok-kw">try</span> stream.reader().readByte();
            <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeValidInCFA">isOpcodeValidInCFA</a>(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">const</span> operand = <span class="tok-kw">try</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.readOperand">readOperand</a>(stream, opcode, context);
            <span class="tok-kw">switch</span> (opcode) {<span class="tok-comment">

                // 2.5.1.1: Literal Encodings
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit31">lit31</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>,
                =&gt; <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = operand.?.generic }),

                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a> =&gt; {
                    <span class="tok-kw">const</span> const_type = operand.?.const_type;
                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .const_type = .{
                        .type_offset = const_type.type_offset,
                        .value_bytes = const_type.value_bytes,
                    } });
                },

                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>,
                =&gt; {
                    <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                    <span class="tok-kw">if</span> (context.debug_addr == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                    <span class="tok-kw">const</span> debug_addr_index = operand.?.generic;
                    <span class="tok-kw">const</span> offset = context.compile_unit.?.addr_base + debug_addr_index;
                    <span class="tok-kw">if</span> (offset &gt;= context.debug_addr.?.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, context.debug_addr.?[offset..][<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });
                },<span class="tok-comment">

                // 2.5.1.2: Register Values
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a> =&gt; {
                    <span class="tok-kw">if</span> (context.compile_unit == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                    <span class="tok-kw">if</span> (context.compile_unit.?.frame_base == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

                    <span class="tok-kw">const</span> offset: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(operand.?.generic);
                    _ = offset;

                    <span class="tok-kw">switch</span> (context.compile_unit.?.frame_base.?.*) {
                        .exprloc =&gt; {<span class="tok-comment">
                            // TODO: Run this expression in a nested stack machine
                            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                        },
                        .loclistx =&gt; {<span class="tok-comment">
                            // TODO: Read value from .debug_loclists
                            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                        },
                        .sec_offset =&gt; {<span class="tok-comment">
                            // TODO: Read value from .debug_loclists
                            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFrameBase,
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg31">breg31</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a>,
                =&gt; {
                    <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

                    <span class="tok-kw">const</span> base_register = operand.?.base_register;
                    <span class="tok-kw">var</span> value: <span class="tok-type">i64</span> = <span class="tok-builtin">@intCast</span>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(
                        context.thread_context.?,
                        base_register.base_register,
                        context.reg_context,
                    ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>));
                    value += base_register.offset;
                    <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intCast</span>(value) });
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a> =&gt; {
                    <span class="tok-kw">const</span> register_type = operand.?.register_type;
                    <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(
                        context.thread_context.?,
                        register_type.register,
                        context.reg_context,
                    ))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
                    <span class="tok-kw">try</span> self.stack.append(allocator, .{
                        .regval_type = .{
                            .type_offset = register_type.type_offset,
                            .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),
                            .value = value,
                        },
                    });
                },<span class="tok-comment">

                // 2.5.1.3: Stack Operations
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.dup">dup</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span>]);
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.drop">drop</a> =&gt; {
                    _ = self.stack.pop();
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a> =&gt; {
                    <span class="tok-kw">const</span> stack_index = <span class="tok-kw">if</span> (opcode == <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a>) <span class="tok-number">1</span> <span class="tok-kw">else</span> operand.?.generic;
                    <span class="tok-kw">if</span> (stack_index &gt;= self.stack.items.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">try</span> self.stack.append(allocator, self.stack.items[self.stack.items.len - <span class="tok-number">1</span> - stack_index]);
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.swap">swap</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(<a href="std.debug.Dwarf.expression.StackMachine.Value.html">Value</a>, &amp;self.stack.items[self.stack.items.len - <span class="tok-number">1</span>], &amp;self.stack.items[self.stack.items.len - <span class="tok-number">2</span>]);
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.rot">rot</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">3</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> first = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">2</span>];
                    self.stack.items[self.stack.items.len - <span class="tok-number">2</span>] = self.stack.items[self.stack.items.len - <span class="tok-number">3</span>];
                    self.stack.items[self.stack.items.len - <span class="tok-number">3</span>] = first;
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> addr = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                    <span class="tok-kw">const</span> addr_space_identifier: ?<span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (opcode) {
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                        =&gt; blk: {
                            _ = self.stack.pop();
                            <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                            <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-null">null</span>,
                    };<span class="tok-comment">

                    // Usage of addr_space_identifier in the address calculation is implementation defined.
                    // This code will need to be updated to handle any architectures that utilize this.
                    </span>_ = addr_space_identifier;

                    <span class="tok-kw">const</span> size = <span class="tok-kw">switch</span> (opcode) {
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                        =&gt; <span class="tok-builtin">@sizeOf</span>(addr_type),
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>,
                        =&gt; operand.?.type_size,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                        =&gt; operand.?.deref_type.size,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    };

                    <span class="tok-kw">if</span> (context.memory_accessor) |memory_accessor| {
                        <span class="tok-kw">if</span> (!<span class="tok-kw">switch</span> (size) {
                            <span class="tok-number">1</span> =&gt; memory_accessor.load(<span class="tok-type">u8</span>, addr) != <span class="tok-null">null</span>,
                            <span class="tok-number">2</span> =&gt; memory_accessor.load(<span class="tok-type">u16</span>, addr) != <span class="tok-null">null</span>,
                            <span class="tok-number">4</span> =&gt; memory_accessor.load(<span class="tok-type">u32</span>, addr) != <span class="tok-null">null</span>,
                            <span class="tok-number">8</span> =&gt; memory_accessor.load(<span class="tok-type">u64</span>, addr) != <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression,
                        }) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    }

                    <span class="tok-kw">const</span> value: addr_type = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(addr_type, <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-kw">switch</span> (size) {
                        <span class="tok-number">1</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                        <span class="tok-number">2</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u16</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                        <span class="tok-number">4</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u32</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                        <span class="tok-number">8</span> =&gt; <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u64</span>, <span class="tok-builtin">@ptrFromInt</span>(addr)).*,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression,
                    })) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;

                    <span class="tok-kw">switch</span> (opcode) {
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
                        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>,
                        =&gt; {
                            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                                .regval_type = .{
                                    .type_offset = operand.?.deref_type.type_offset,
                                    .type_size = operand.?.deref_type.size,
                                    .value = value,
                                },
                            };
                        },
                        <span class="tok-kw">else</span> =&gt; {
                            self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = value };
                        },
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.push_object_address">push_object_address</a> =&gt; {<span class="tok-comment">
                    // In sub-expressions, `push_object_address` is not meaningful (as per the
                    // spec), so treat it like a nop
                    </span><span class="tok-kw">if</span> (!context.entry_value_context) {
                        <span class="tok-kw">if</span> (context.object_address == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = <span class="tok-builtin">@intFromPtr</span>(context.object_address.?) });
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.form_tls_address">form_tls_address</a> =&gt; {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedOpcode;
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_frame_cfa">call_frame_cfa</a> =&gt; {
                    <span class="tok-kw">if</span> (context.cfa) |cfa| {
                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = cfa });
                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;
                },<span class="tok-comment">

                // 2.5.1.4: Arithmetic and Logical Operations
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.abs">abs</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> value: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@abs</span>(value),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="#"and"">@&quot;and&quot;</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = a &amp; <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.div">div</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divTrunc">divTrunc</a>(<span class="tok-type">isize</span>, b, a)),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.minus">minus</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mod">mod</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mod</span>(b, a)),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mul">mul</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.pop().?.asIntegral());
                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@mulWithOverflow</span>(a, b)[<span class="tok-number">0</span>]),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.neg">neg</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(
                            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.negate">negate</a>(
                                <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral())),
                            ),
                        ),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.not">not</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = ~<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="#"or"">@&quot;or&quot;</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = a | <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus">plus</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), b),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> constant = operand.?.generic;
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(addr_type, <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(), constant),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shl">shl</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<span class="tok-type">usize</span>, b, a),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shr">shr</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    <span class="tok-kw">const</span> b = <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<span class="tok-type">usize</span>, b, a),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shra">shra</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    <span class="tok-kw">const</span> b: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral());
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = <span class="tok-builtin">@bitCast</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<span class="tok-type">isize</span>, b, a)),
                    };
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xor">xor</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = <span class="tok-kw">try</span> self.stack.pop().?.asIntegral();
                    self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{
                        .generic = a ^ <span class="tok-kw">try</span> self.stack.items[self.stack.items.len - <span class="tok-number">1</span>].asIntegral(),
                    };
                },<span class="tok-comment">

                // 2.5.1.5: Control Flow Operations
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a>,
                =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> a = self.stack.pop().?;
                    <span class="tok-kw">const</span> b = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];

                    <span class="tok-kw">if</span> (a == .generic <span class="tok-kw">and</span> b == .generic) {
                        <span class="tok-kw">const</span> a_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(a.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
                        <span class="tok-kw">const</span> b_int: <span class="tok-type">isize</span> = <span class="tok-builtin">@bitCast</span>(b.asIntegral() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
                        <span class="tok-kw">const</span> result = <span class="tok-builtin">@intFromBool</span>(<span class="tok-kw">switch</span> (opcode) {
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a> =&gt; b_int &lt;= a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a> =&gt; b_int &gt;= a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a> =&gt; b_int == a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a> =&gt; b_int &lt; a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a> =&gt; b_int &gt; a_int,
                            <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a> =&gt; b_int != a_int,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        });

                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = result };
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // TODO: Load the types referenced by these values, find their comparison operator, and run it
                        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypedComparison;
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a> =&gt; {
                    <span class="tok-kw">const</span> branch_offset = operand.?.branch_offset;
                    <span class="tok-kw">const</span> condition = <span class="tok-kw">if</span> (opcode == <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>) blk: {
                        <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                        <span class="tok-kw">break</span> :blk <span class="tok-kw">try</span> self.stack.pop().?.asIntegral() != <span class="tok-number">0</span>;
                    } <span class="tok-kw">else</span> <span class="tok-null">true</span>;

                    <span class="tok-kw">if</span> (condition) {
                        <span class="tok-kw">const</span> new_pos = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(
                            <span class="tok-type">usize</span>,
                            <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.add">add</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(stream.pos)), branch_offset),
                        ) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;

                        <span class="tok-kw">if</span> (new_pos &lt; <span class="tok-number">0</span> <span class="tok-kw">or</span> new_pos &gt; stream.buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                        stream.pos = new_pos;
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a>,
                =&gt; {
                    <span class="tok-kw">const</span> debug_info_offset = operand.?.generic;
                    _ = debug_info_offset;<span class="tok-comment">

                    // TODO: Load a DIE entry at debug_info_offset in a .debug_info section (the spec says that it
                    //       can be in a separate exe / shared object from the one containing this expression).
                    //       Transfer control to the DW_AT_location attribute, with the current stack as input.

                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedExpressionCall;
                },<span class="tok-comment">

                // 2.5.1.6: Type Conversions
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> type_offset = operand.?.generic;<span class="tok-comment">

                    // TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size
                    </span><span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
                    <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {
                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };
                    } <span class="tok-kw">else</span> {<span class="tok-comment">
                        // TODO: Load the DW_TAG_base_type entry in context.compile_unit, find a conversion operator
                        //       from the old type to the new type, run it.
                        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnimplementedTypeConversion;
                    }
                },
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a> =&gt; {
                    <span class="tok-kw">if</span> (self.stack.items.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidExpression;
                    <span class="tok-kw">const</span> type_offset = operand.?.generic;<span class="tok-comment">

                    // TODO: Load the DW_TAG_base_type entries in context.compile_unit and verify both types are the same size
                    </span><span class="tok-kw">const</span> value = self.stack.items[self.stack.items.len - <span class="tok-number">1</span>];
                    <span class="tok-kw">if</span> (type_offset == <span class="tok-number">0</span>) {
                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = .{ .generic = <span class="tok-kw">try</span> value.asIntegral() };
                    } <span class="tok-kw">else</span> {
                        self.stack.items[self.stack.items.len - <span class="tok-number">1</span>] = <span class="tok-kw">switch</span> (value) {
                            .generic =&gt; |v| .{
                                .regval_type = .{
                                    .type_offset = type_offset,
                                    .type_size = <span class="tok-builtin">@sizeOf</span>(addr_type),
                                    .value = v,
                                },
                            },
                            .regval_type =&gt; |r| .{
                                .regval_type = .{
                                    .type_offset = type_offset,
                                    .type_size = r.type_size,
                                    .value = r.value,
                                },
                            },
                            .const_type =&gt; |c| .{
                                .const_type = .{
                                    .type_offset = type_offset,
                                    .value_bytes = c.value_bytes,
                                },
                            },
                        };
                    }
                },<span class="tok-comment">

                // 2.5.1.7: Special Operations
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.nop">nop</a> =&gt; {},
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a> =&gt; {
                    <span class="tok-kw">const</span> block = operand.?.block;
                    <span class="tok-kw">if</span> (block.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression;<span class="tok-comment">

                    // TODO: The spec states that this sub-expression needs to observe the state (ie. registers)
                    //       as it was upon entering the current subprogram. If this isn't being called at the
                    //       end of a frame unwind operation, an additional ThreadContext with this state will be needed.

                    </span><span class="tok-kw">if</span> (<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeRegisterLocation">isOpcodeRegisterLocation</a>(block[<span class="tok-number">0</span>])) {
                        <span class="tok-kw">if</span> (context.thread_context == <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IncompleteExpressionContext;

                        <span class="tok-kw">var</span> block_stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.fixed_buffer_stream.html#std.io.fixed_buffer_stream.fixedBufferStream">fixedBufferStream</a>(block);
                        <span class="tok-kw">const</span> register = (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine.readOperand">readOperand</a>(&amp;block_stream, block[<span class="tok-number">0</span>], context)).?.register;
                        <span class="tok-kw">const</span> value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(<span class="tok-type">usize</span>, (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(context.thread_context.?, register, context.reg_context))[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
                        <span class="tok-kw">try</span> self.stack.append(allocator, .{ .generic = value });
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">var</span> stack_machine: <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">Self</a> = .{};
                        <span class="tok-kw">defer</span> stack_machine.deinit(allocator);

                        <span class="tok-kw">var</span> sub_context = context;
                        sub_context.entry_value_context = <span class="tok-null">true</span>;
                        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> stack_machine.run(block, allocator, sub_context, <span class="tok-null">null</span>);
                        <span class="tok-kw">try</span> self.stack.append(allocator, result <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidSubExpression);
                    }
                },<span class="tok-comment">

                // These have already been handled by readOperand
                </span><a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lo_user">lo_user</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.hi_user">hi_user</a> =&gt; <span class="tok-kw">unreachable</span>,
                <span class="tok-kw">else</span> =&gt; {<span class="tok-comment">
                    //std.debug.print(&quot;Unknown DWARF expression opcode: {x}\n&quot;, .{opcode});
                    </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnknownExpressionOpcode;
                },
            }

            <span class="tok-kw">return</span> stream.pos &lt; stream.buffer.len;
        }
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Builder</span>(<span class="tok-kw">comptime</span> options: <a href="std.debug.Dwarf.expression.Options.html">Options</a>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> addr_type = <span class="tok-kw">switch</span> (options.addr_size) {
        <span class="tok-number">2</span> =&gt; <span class="tok-type">u16</span>,
        <span class="tok-number">4</span> =&gt; <span class="tok-type">u32</span>,
        <span class="tok-number">8</span> =&gt; <span class="tok-type">u64</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported address size of &quot;</span> ++ options.addr_size),
    };

    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// Zero-operand instructions</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeOpcode</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> opcode: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context <span class="tok-kw">and</span> !<span class="tok-kw">comptime</span> <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.isOpcodeValidInCFA">isOpcodeValidInCFA</a>(opcode)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">switch</span> (opcode) {
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.dup">dup</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.drop">drop</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.swap">swap</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.rot">rot</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.push_object_address">push_object_address</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.form_tls_address">form_tls_address</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_frame_cfa">call_frame_cfa</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.abs">abs</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="#"and"">@&quot;and&quot;</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.div">div</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.minus">minus</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mod">mod</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mul">mul</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.neg">neg</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.not">not</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="#"or"">@&quot;or&quot;</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus">plus</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shl">shl</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shr">shr</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shra">shra</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xor">xor</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.nop">nop</a>,
                <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.stack_value">stack_value</a>,
                =&gt; <span class="tok-kw">try</span> writer.writeByte(opcode),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;This opcode requires operands, use `write&lt;Opcode&gt;()` instead&quot;</span>),
            }
        }<span class="tok-comment">

        // 2.5.1.1: Literal Encodings
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeLiteral</span>(writer: <span class="tok-kw">anytype</span>, literal: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (literal) {
                <span class="tok-number">0</span>...<span class="tok-number">31</span> =&gt; |n| <span class="tok-kw">try</span> writer.writeByte(n + <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lit0">lit0</a>),
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidLiteral,
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConst</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(T) != .int) <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Constants must be integers&quot;</span>);

            <span class="tok-kw">switch</span> (T) {
                <span class="tok-type">u8</span>, <span class="tok-type">i8</span>, <span class="tok-type">u16</span>, <span class="tok-type">i16</span>, <span class="tok-type">u32</span>, <span class="tok-type">i32</span>, <span class="tok-type">u64</span>, <span class="tok-type">i64</span> =&gt; {
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-kw">switch</span> (T) {
                        <span class="tok-type">u8</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1u">const1u</a>,
                        <span class="tok-type">i8</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const1s">const1s</a>,
                        <span class="tok-type">u16</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2u">const2u</a>,
                        <span class="tok-type">i16</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const2s">const2s</a>,
                        <span class="tok-type">u32</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4u">const4u</a>,
                        <span class="tok-type">i32</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const4s">const4s</a>,
                        <span class="tok-type">u64</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8u">const8u</a>,
                        <span class="tok-type">i64</span> =&gt; <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const8s">const8s</a>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    });

                    <span class="tok-kw">try</span> writer.writeInt(T, value, options.endian);
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T).int.signedness) {
                    .unsigned =&gt; {
                        <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constu">constu</a>);
                        <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, value);
                    },
                    .signed =&gt; {
                        <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.consts">consts</a>);
                        <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, value);
                    },
                },
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, debug_addr_offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConstType</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">if</span> (value_bytes.len &gt; <span class="tok-number">0xff</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidTypeLength;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-builtin">@intCast</span>(value_bytes.len));
            <span class="tok-kw">try</span> writer.writeAll(value_bytes);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddr</span>(writer: <span class="tok-kw">anytype</span>, value: addr_type) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addr">addr</a>);
            <span class="tok-kw">try</span> writer.writeInt(addr_type, value, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAddrx</span>(writer: <span class="tok-kw">anytype</span>, debug_addr_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, debug_addr_offset);
        }<span class="tok-comment">

        // 2.5.1.2: Register Values
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFbreg</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.fbreg">fbreg</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBreg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (register &gt; <span class="tok-number">31</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidRegister;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.breg0">breg0</a> + register);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBregx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bregx">bregx</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeIleb128">writeIleb128</a>(writer, offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegvalType</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>, offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, offset);
        }<span class="tok-comment">

        // 2.5.1.3: Stack Operations
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePick</span>(writer: <span class="tok-kw">anytype</span>, index: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.pick">pick</a>);
            <span class="tok-kw">try</span> writer.writeByte(index);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_size">deref_size</a>);
            <span class="tok-kw">try</span> writer.writeByte(size);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefSize</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_size">xderef_size</a>);
            <span class="tok-kw">try</span> writer.writeByte(size);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>);
            <span class="tok-kw">try</span> writer.writeByte(size);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeXDerefType</span>(writer: <span class="tok-kw">anytype</span>, size: <span class="tok-type">u8</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef_type">xderef_type</a>);
            <span class="tok-kw">try</span> writer.writeByte(size);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
        }<span class="tok-comment">

        // 2.5.1.4: Arithmetic and Logical Operations

        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writePlusUconst</span>(writer: <span class="tok-kw">anytype</span>, uint_value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus_uconst">plus_uconst</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, uint_value);
        }<span class="tok-comment">

        // 2.5.1.5: Control Flow Operations

        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSkip</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.skip">skip</a>);
            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeBra</span>(writer: <span class="tok-kw">anytype</span>, offset: <span class="tok-type">i16</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.bra">bra</a>);
            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-type">i16</span>, offset, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCall</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, offset: T) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">switch</span> (T) {
                <span class="tok-type">u16</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>),
                <span class="tok-type">u32</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a>),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Call operand must be a 2 or 4 byte offset&quot;</span>),
            }

            <span class="tok-kw">try</span> writer.writeInt(T, offset, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeCallRef</span>(writer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> is_64: <span class="tok-type">bool</span>, value: <span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a>);
            <span class="tok-kw">try</span> writer.writeInt(<span class="tok-kw">if</span> (is_64) <span class="tok-type">u64</span> <span class="tok-kw">else</span> <span class="tok-type">u32</span>, value, options.endian);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeConvert</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReinterpret</span>(writer: <span class="tok-kw">anytype</span>, die_offset: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (options.call_frame_context) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidCFAOpcode;
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, die_offset);
        }<span class="tok-comment">

        // 2.5.1.7: Special Operations

        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeEntryValue</span>(writer: <span class="tok-kw">anytype</span>, expression: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.entry_value">entry_value</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, expression.len);
            <span class="tok-kw">try</span> writer.writeAll(expression);
        }<span class="tok-comment">

        // 2.6: Location Descriptions
        </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeReg</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a> + register);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeRegx</span>(writer: <span class="tok-kw">anytype</span>, register: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regx">regx</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, register);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeImplicitValue</span>(writer: <span class="tok-kw">anytype</span>, value_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.writeByte(<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.implicit_value">implicit_value</a>);
            <span class="tok-kw">try</span> <a href="std.leb128.html">leb</a>.<a href="std.leb128.html#std.leb128.writeUleb128">writeUleb128</a>(writer, value_bytes.len);
            <span class="tok-kw">try</span> writer.writeAll(value_bytes);
        }
    };
}<span class="tok-comment">

// Certain opcodes are not allowed in a CFA context, see 6.4.2
</span><span class="tok-kw">fn</span> <span class="tok-fn">isOpcodeValidInCFA</span>(opcode: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.addrx">addrx</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call2">call2</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call4">call4</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_ref">call_ref</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.const_type">const_type</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.constx">constx</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.convert">convert</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref_type">deref_type</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regval_type">regval_type</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reinterpret">reinterpret</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.push_object_address">push_object_address</a>,
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_frame_cfa">call_frame_cfa</a>,
        =&gt; <span class="tok-null">false</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">isOpcodeRegisterLocation</span>(opcode: <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (opcode) {
        <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg0">reg0</a>...<a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.reg31">reg31</a>, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.regx">regx</a> =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
}

<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">test</span> <span class="tok-str">&quot;DWARF expressions&quot;</span> {
    <span class="tok-kw">const</span> allocator = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;

    <span class="tok-kw">const</span> options = <a href="std.debug.Dwarf.expression.Options.html">Options</a>{};
    <span class="tok-kw">var</span> stack_machine = <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.StackMachine">StackMachine</a>(options){};
    <span class="tok-kw">defer</span> stack_machine.deinit(allocator);

    <span class="tok-kw">const</span> b = <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.Builder">Builder</a>(options);

    <span class="tok-kw">var</span> program = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
    <span class="tok-kw">defer</span> program.deinit();

    <span class="tok-kw">const</span> writer = program.writer();<span class="tok-comment">

    // Literals
    </span>{
        <span class="tok-kw">const</span> context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{};
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">32</span>) |i| {
            <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-builtin">@intCast</span>(i));
        }

        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);

        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">32</span>) |i| {
            <span class="tok-kw">const</span> expected = <span class="tok-number">31</span> - i;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(expected, stack_machine.stack.pop().?.generic);
        }
    }<span class="tok-comment">

    // Constants
    </span>{
        stack_machine.reset();
        program.clearRetainingCapacity();

        <span class="tok-kw">const</span> input = [_]<span class="tok-type">comptime_int</span>{
            <span class="tok-number">1</span>,
            -<span class="tok-number">1</span>,
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fff</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fff</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fffffff</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fffffff</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x0fffffffffffffff</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x0fffffffffffffff</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x8000000</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@truncate</span>(-<span class="tok-number">0x8000000</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0x12345678_12345678</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffffffff_ffffffff</span>)),
            <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xeeeeeeee_eeeeeeee</span>)),
        };

        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, input[<span class="tok-number">0</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i8</span>, input[<span class="tok-number">1</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, input[<span class="tok-number">2</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, input[<span class="tok-number">3</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u32</span>, input[<span class="tok-number">4</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i32</span>, input[<span class="tok-number">5</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u64</span>, input[<span class="tok-number">6</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i64</span>, input[<span class="tok-number">7</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u28</span>, input[<span class="tok-number">8</span>]);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i28</span>, input[<span class="tok-number">9</span>]);
        <span class="tok-kw">try</span> b.writeAddr(writer, input[<span class="tok-number">10</span>]);

        <span class="tok-kw">var</span> mock_compile_unit: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.Dwarf.html">Dwarf</a>.<a href="std.debug.Dwarf.CompileUnit.html">CompileUnit</a> = <span class="tok-null">undefined</span>;
        mock_compile_unit.addr_base = <span class="tok-number">1</span>;

        <span class="tok-kw">var</span> mock_debug_addr = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
        <span class="tok-kw">defer</span> mock_debug_addr.deinit();

        <span class="tok-kw">try</span> mock_debug_addr.writer().writeInt(<span class="tok-type">u16</span>, <span class="tok-number">0</span>, <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
        <span class="tok-kw">try</span> mock_debug_addr.writer().writeInt(<span class="tok-type">usize</span>, input[<span class="tok-number">11</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
        <span class="tok-kw">try</span> mock_debug_addr.writer().writeInt(<span class="tok-type">usize</span>, input[<span class="tok-number">12</span>], <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);

        <span class="tok-kw">const</span> context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{
            .compile_unit = &amp;mock_compile_unit,
            .debug_addr = mock_debug_addr.items,
        };

        <span class="tok-kw">try</span> b.writeConstx(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>));
        <span class="tok-kw">try</span> b.writeAddrx(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> + <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)));

        <span class="tok-kw">const</span> die_offset: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xaabbccdd</span>);
        <span class="tok-kw">const</span> type_bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
        <span class="tok-kw">try</span> b.writeConstType(writer, die_offset, type_bytes);

        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);

        <span class="tok-kw">const</span> const_type = stack_machine.stack.pop().?.const_type;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(die_offset, const_type.type_offset);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, type_bytes, const_type.value_bytes);

        <span class="tok-kw">const</span> expected = .{
            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">12</span>], <span class="tok-type">usize</span> },
            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">11</span>], <span class="tok-type">usize</span> },
            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">10</span>], <span class="tok-type">usize</span> },
            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">9</span>], <span class="tok-type">isize</span> },
            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">8</span>], <span class="tok-type">usize</span> },
            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">7</span>], <span class="tok-type">isize</span> },
            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">6</span>], <span class="tok-type">usize</span> },
            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">5</span>], <span class="tok-type">isize</span> },
            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">4</span>], <span class="tok-type">usize</span> },
            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">3</span>], <span class="tok-type">isize</span> },
            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">2</span>], <span class="tok-type">usize</span> },
            .{ <span class="tok-type">isize</span>, input[<span class="tok-number">1</span>], <span class="tok-type">isize</span> },
            .{ <span class="tok-type">usize</span>, input[<span class="tok-number">0</span>], <span class="tok-type">usize</span> },
        };

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (expected) |e| {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(e[<span class="tok-number">0</span>], e[<span class="tok-number">1</span>]), <span class="tok-builtin">@as</span>(e[<span class="tok-number">2</span>], <span class="tok-builtin">@bitCast</span>(stack_machine.stack.pop().?.generic)));
        }
    }<span class="tok-comment">

    // Register values
    </span><span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a>) != <span class="tok-number">0</span>) {
        stack_machine.reset();
        program.clearRetainingCapacity();

        <span class="tok-kw">const</span> reg_context = <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.RegisterContext.html">RegisterContext</a>{
            .eh_frame = <span class="tok-null">true</span>,
            .is_macho = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .macos,
        };
        <span class="tok-kw">var</span> thread_context: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a> = <span class="tok-null">undefined</span>;
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.relocateContext">relocateContext</a>(&amp;thread_context);
        <span class="tok-kw">const</span> context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{
            .thread_context = &amp;thread_context,
            .reg_context = reg_context,
        };<span class="tok-comment">

        // Only test register operations on arch / os that have them implemented
        </span><span class="tok-kw">if</span> (<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(&amp;thread_context, <span class="tok-number">0</span>, reg_context)) |reg_bytes| {<span class="tok-comment">

            // TODO: Test fbreg (once implemented): mock a DIE and point compile_unit.frame_base at it

            </span><a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">usize</span>, reg_bytes[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <span class="tok-number">0xee</span>, <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);
            (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(&amp;thread_context, <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.fpRegNum">fpRegNum</a>(<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_arch">native_arch</a>, reg_context), reg_context)).* = <span class="tok-number">1</span>;
            (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(&amp;thread_context, <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.spRegNum">spRegNum</a>(<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_arch">native_arch</a>, reg_context), reg_context)).* = <span class="tok-number">2</span>;
            (<span class="tok-kw">try</span> <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regValueNative">regValueNative</a>(&amp;thread_context, <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.ipRegNum">ipRegNum</a>(<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_arch">native_arch</a>).?, reg_context)).* = <span class="tok-number">3</span>;

            <span class="tok-kw">try</span> b.writeBreg(writer, <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.fpRegNum">fpRegNum</a>(<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_arch">native_arch</a>, reg_context), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">100</span>));
            <span class="tok-kw">try</span> b.writeBreg(writer, <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.spRegNum">spRegNum</a>(<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_arch">native_arch</a>, reg_context), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">200</span>));
            <span class="tok-kw">try</span> b.writeBregx(writer, <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.ipRegNum">ipRegNum</a>(<a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_arch">native_arch</a>).?, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">300</span>));
            <span class="tok-kw">try</span> b.writeRegvalType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">400</span>));

            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-number">0</span>);

            <span class="tok-kw">const</span> regval_type = stack_machine.stack.pop().?.regval_type;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">400</span>), regval_type.type_offset);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)), regval_type.type_size);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xee</span>), regval_type.value);

            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">303</span>), stack_machine.stack.pop().?.generic);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">202</span>), stack_machine.stack.pop().?.generic);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">101</span>), stack_machine.stack.pop().?.generic);
        } <span class="tok-kw">else</span> |err| {
            <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnimplementedArch,
                <span class="tok-kw">error</span>.UnimplementedOs,
                <span class="tok-kw">error</span>.ThreadContextNotSupported,
                =&gt; {},
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            }
        }
    }<span class="tok-comment">

    // Stack operations
    </span>{
        <span class="tok-kw">var</span> context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{};

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.dup">dup</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), stack_machine.stack.pop().?.generic);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.drop">drop</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(stack_machine.stack.pop() == <span class="tok-null">null</span>);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> b.writePick(writer, <span class="tok-number">2</span>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.over">over</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.swap">swap</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.pop().?.generic);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">4</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">5</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u8</span>, <span class="tok-number">6</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.rot">rot</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.pop().?.generic);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.pop().?.generic);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.pop().?.generic);

        <span class="tok-kw">const</span> deref_target: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffeeffee_ffeeffee</span>);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.deref">deref</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(deref_target, stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xderef">xderef</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(deref_target, stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));
        <span class="tok-kw">try</span> b.writeDerefSize(writer, <span class="tok-number">1</span>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));
        <span class="tok-kw">try</span> b.writeXDerefSize(writer, <span class="tok-number">1</span>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), stack_machine.stack.pop().?.generic);

        <span class="tok-kw">const</span> type_offset: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xaabbaabb_aabbaabb</span>);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));
        <span class="tok-kw">try</span> b.writeDerefType(writer, <span class="tok-number">1</span>, type_offset);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> deref_type = stack_machine.stack.pop().?.regval_type;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(type_offset, deref_type.type_offset);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), deref_type.type_size);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), deref_type.value);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> b.writeAddr(writer, <span class="tok-builtin">@intFromPtr</span>(&amp;deref_target));
        <span class="tok-kw">try</span> b.writeXDerefType(writer, <span class="tok-number">1</span>, type_offset);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> xderef_type = stack_machine.stack.pop().?.regval_type;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(type_offset, xderef_type.type_offset);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), xderef_type.type_size);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;deref_target)).*), xderef_type.value);

        context.object_address = &amp;deref_target;

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.push_object_address">push_object_address</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intFromPtr</span>(context.object_address.?)), stack_machine.stack.pop().?.generic);<span class="tok-comment">

        // TODO: Test OP.form_tls_address

        </span>context.cfa = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xccddccdd_ccddccdd</span>);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.call_frame_cfa">call_frame_cfa</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(context.cfa.?, stack_machine.stack.pop().?.generic);
    }<span class="tok-comment">

    // Arithmetic and Logical Operations
    </span>{
        <span class="tok-kw">const</span> context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{};

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">4096</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.abs">abs</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4096</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="#"and"">@&quot;and&quot;</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xf00f</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">404</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">100</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.div">div</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">404</span> / <span class="tok-number">100</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(stack_machine.stack.pop().?.generic)));

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">200</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">50</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.minus">minus</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">150</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">123</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">100</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mod">mod</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">23</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xee</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.mul">mul</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xed12</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">5</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.neg">neg</a>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, -<span class="tok-number">6</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.neg">neg</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">6</span>), stack_machine.stack.pop().?.generic);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, -<span class="tok-number">5</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@bitCast</span>(stack_machine.stack.pop().?.generic)));

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.not">not</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(~<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xff0f</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="#"or"">@&quot;or&quot;</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xffff</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">402</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">i16</span>, <span class="tok-number">100</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.plus">plus</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">502</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">4096</span>);
        <span class="tok-kw">try</span> b.writePlusUconst(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">8192</span>));
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4096</span> + <span class="tok-number">8192</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shl">shl</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xfff</span> &lt;&lt; <span class="tok-number">1</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shr">shr</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xfff</span> &gt;&gt; <span class="tok-number">1</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xfff</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.shr">shr</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-number">0xfff</span>) &gt;&gt; <span class="tok-number">1</span>)), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xf0ff</span>);
        <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0xff0f</span>);
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.xor">xor</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0x0ff0</span>), stack_machine.stack.pop().?.generic);
    }<span class="tok-comment">

    // Control Flow Operations
    </span>{
        <span class="tok-kw">const</span> context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{};
        <span class="tok-kw">const</span> expected = .{
            .{ <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.le">le</a>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> },
            .{ <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ge">ge</a>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span> },
            .{ <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.eq">eq</a>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span> },
            .{ <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.lt">lt</a>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> },
            .{ <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.gt">gt</a>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span> },
            .{ <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.ne">ne</a>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span> },
        };

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (expected) |e| {
            stack_machine.reset();
            program.clearRetainingCapacity();

            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);
            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);
            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);
            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">1</span>);
            <span class="tok-kw">try</span> b.writeConst(writer, <span class="tok-type">u16</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> b.writeOpcode(writer, e[<span class="tok-number">0</span>]);
            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">3</span>]), stack_machine.stack.pop().?.generic);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">2</span>]), stack_machine.stack.pop().?.generic);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, e[<span class="tok-number">1</span>]), stack_machine.stack.pop().?.generic);
        }

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> b.writeSkip(writer, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">3</span>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">2</span>), stack_machine.stack.pop().?.generic);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">2</span>);
        <span class="tok-kw">try</span> b.writeBra(writer, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> b.writeBra(writer, <span class="tok-number">1</span>);
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">4</span>);
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">5</span>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">5</span>), stack_machine.stack.pop().?.generic);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">4</span>), stack_machine.stack.pop().?.generic);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(stack_machine.stack.pop() == <span class="tok-null">null</span>);<span class="tok-comment">

        // TODO: Test call2, call4, call_ref once implemented

    </span>}<span class="tok-comment">

    // Type conversions
    </span>{
        <span class="tok-kw">const</span> context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{};
        stack_machine.reset();
        program.clearRetainingCapacity();<span class="tok-comment">

        // TODO: Test typed OP.convert once implemented

        </span><span class="tok-kw">const</span> value: <span class="tok-type">usize</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-number">0xffeeffee_ffeeffee</span>);
        <span class="tok-kw">var</span> value_bytes: [options.addr_size]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">usize</span>, &amp;value_bytes, value, <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);<span class="tok-comment">

        // Convert to generic type
        </span>stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);
        <span class="tok-kw">try</span> b.writeConvert(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>));
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(value, stack_machine.stack.pop().?.generic);<span class="tok-comment">

        // Reinterpret to generic type
        </span>stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);
        <span class="tok-kw">try</span> b.writeReinterpret(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>));
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(value, stack_machine.stack.pop().?.generic);<span class="tok-comment">

        // Reinterpret to new type
        </span><span class="tok-kw">const</span> die_offset: <span class="tok-type">usize</span> = <span class="tok-number">0xffee</span>;

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeConstType(writer, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>), &amp;value_bytes);
        <span class="tok-kw">try</span> b.writeReinterpret(writer, die_offset);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> const_type = stack_machine.stack.pop().?.const_type;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(die_offset, const_type.type_offset);

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeLiteral(writer, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> b.writeReinterpret(writer, die_offset);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> regval_type = stack_machine.stack.pop().?.regval_type;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(die_offset, regval_type.type_offset);
    }<span class="tok-comment">

    // Special operations
    </span>{
        <span class="tok-kw">var</span> context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{};

        stack_machine.reset();
        program.clearRetainingCapacity();
        <span class="tok-kw">try</span> b.writeOpcode(writer, <a href="std.dwarf.OP.html">OP</a>.<a href="std.dwarf.OP.html#std.dwarf.OP.nop">nop</a>);
        _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(stack_machine.stack.pop() == <span class="tok-null">null</span>);<span class="tok-comment">

        // Sub-expression
        </span>{
            <span class="tok-kw">var</span> sub_program = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
            <span class="tok-kw">defer</span> sub_program.deinit();
            <span class="tok-kw">const</span> sub_writer = sub_program.writer();
            <span class="tok-kw">try</span> b.writeLiteral(sub_writer, <span class="tok-number">3</span>);

            stack_machine.reset();
            program.clearRetainingCapacity();
            <span class="tok-kw">try</span> b.writeEntryValue(writer, sub_program.items);
            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>), stack_machine.stack.pop().?.generic);
        }<span class="tok-comment">

        // Register location description
        </span><span class="tok-kw">const</span> reg_context = <a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.RegisterContext.html">RegisterContext</a>{
            .eh_frame = <span class="tok-null">true</span>,
            .is_macho = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .macos,
        };
        <span class="tok-kw">var</span> thread_context: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.ThreadContext">ThreadContext</a> = <span class="tok-null">undefined</span>;
        <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.relocateContext">relocateContext</a>(&amp;thread_context);
        context = <a href="std.debug.Dwarf.expression.Context.html">Context</a>{
            .thread_context = &amp;thread_context,
            .reg_context = reg_context,
        };

        <span class="tok-kw">if</span> (<a href="std.debug.Dwarf.abi.html">abi</a>.<a href="std.debug.Dwarf.abi.html#std.debug.Dwarf.abi.regBytes">regBytes</a>(&amp;thread_context, <span class="tok-number">0</span>, reg_context)) |reg_bytes| {
            <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.writeInt">writeInt</a>(<span class="tok-type">usize</span>, reg_bytes[<span class="tok-number">0</span>..<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>)], <span class="tok-number">0xee</span>, <a href="std.debug.Dwarf.expression.html#std.debug.Dwarf.expression.native_endian">native_endian</a>);

            <span class="tok-kw">var</span> sub_program = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(allocator);
            <span class="tok-kw">defer</span> sub_program.deinit();
            <span class="tok-kw">const</span> sub_writer = sub_program.writer();
            <span class="tok-kw">try</span> b.writeReg(sub_writer, <span class="tok-number">0</span>);

            stack_machine.reset();
            program.clearRetainingCapacity();
            <span class="tok-kw">try</span> b.writeEntryValue(writer, sub_program.items);
            _ = <span class="tok-kw">try</span> stack_machine.run(program.items, allocator, context, <span class="tok-null">null</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0xee</span>), stack_machine.stack.pop().?.generic);
        } <span class="tok-kw">else</span> |err| {
            <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.UnimplementedArch,
                <span class="tok-kw">error</span>.UnimplementedOs,
                <span class="tok-kw">error</span>.ThreadContextNotSupported,
                =&gt; {},
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
            }
        }
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
