<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">Build</a></li><li><a href="std.Build.Cache.html" class="active">Cache</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Build.Cache" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Build.Cache</span><a href="#src.zig-std.Build.Cache">[src]</a></h1><div class="tldDocs"><p>Manages <code>zig-cache</code> directories.
This is not a general-purpose cache. It is designed to be fast and simple,
not to withstand attacks using specially-crafted input.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.Build.Cache.Path.html">std.Build.Cache.Path</a></li><li><a href="std.Build.Cache.Directory.html">std.Build.Cache.Directory</a></li><li><a href="std.Build.Cache.DepTokenizer.html">std.Build.Cache.DepTokenizer</a></li><li><a href="std.Build.Cache.File.html">std.Build.Cache.File</a></li><li><a href="std.Build.Cache.HashHelper.html">std.Build.Cache.HashHelper</a></li><li><a href="std.Build.Cache.Lock.html">std.Build.Cache.Lock</a></li><li><a href="std.Build.Cache.Manifest.html">std.Build.Cache.Manifest</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.Build.Cache.BinDigest" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">BinDigest</span><a href="#src.zig-std.Build.Cache.BinDigest">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.BinDigest">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> BinDigest = [<a href="std.Build.Cache.html#std.Build.Cache.bin_digest_len">bin_digest_len</a>]<span class="tok-type">u8</span></code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.HexDigest" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">HexDigest</span><a href="#src.zig-std.Build.Cache.HexDigest">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.HexDigest">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> HexDigest = [<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>]<span class="tok-type">u8</span></code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.Hasher" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hasher</span><a href="#src.zig-std.Build.Cache.Hasher">[src]</a></h2><div class="tldDocs"><p>The type used for hashing file contents. Currently, this is SipHash128(1, 3), because it
provides enough collision resistance for the Manifest use cases, while being one of our
fastest options right now.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.Hasher">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hasher = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.auth.html">auth</a>.<a href="std.crypto.siphash.html">siphash</a>.<a href="std.crypto.siphash.html#std.crypto.siphash.SipHash128">SipHash128</a>(<span class="tok-number">1</span>, <span class="tok-number">3</span>)</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>manifest_dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>hash: <a href="std.Build.Cache.HashHelper.html">HashHelper</a> = .{}</code></pre></div><div><pre><code>recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span></code></pre><div class="fieldDocs"><p>This value is accessed from multiple threads, protected by mutex.</p>
</div></div><div><pre><code>mutex: <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a> = .{}</code></pre></div><div><pre><code>prefixes_buffer: [<span class="tok-number">4</span>]<a href="std.Build.Cache.Directory.html">Directory</a> = <span class="tok-null">undefined</span></code></pre><div class="fieldDocs"><p>A set of strings such as the zig library directory or project source root, which
are stripped from the file paths before putting into the cache. They
are replaced with single-character indicators. This is not to save
space but to eliminate absolute file paths. This improves portability
and usefulness of the cache for advanced use cases.</p>
</div></div><div><pre><code>prefixes_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span></code></pre></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.Build.Cache.bin_digest_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">bin_digest_len</span><a href="#src.zig-std.Build.Cache.bin_digest_len">[src]</a></h2><div class="tldDocs"><p>This is 128 bits - Even with 2^54 cache entries, the probably of a collision would be under 10^-6</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.bin_digest_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> bin_digest_len = <span class="tok-number">16</span></code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.hex_digest_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">hex_digest_len</span><a href="#src.zig-std.Build.Cache.hex_digest_len">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.hex_digest_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hex_digest_len = <a href="std.Build.Cache.html#std.Build.Cache.bin_digest_len">bin_digest_len</a> * <span class="tok-number">2</span></code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.hasher_init" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">hasher_init</span><a href="#src.zig-std.Build.Cache.hasher_init">[src]</a></h2><div class="tldDocs"><p>Initial state with random bytes, that can be copied.
Refresh this with new random bytes when the manifest
format is modified in a non-backwards-compatible way.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.hasher_init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hasher_init: <a href="std.Build.Cache.html#std.Build.Cache.Hasher">Hasher</a> = <a href="std.Build.Cache.html#std.Build.Cache.Hasher">Hasher</a>.<a href="#">init</a>(&amp;[_]<span class="tok-type">u8</span>{
    <span class="tok-number">0x33</span>, <span class="tok-number">0x52</span>, <span class="tok-number">0xa2</span>, <span class="tok-number">0x84</span>,
    <span class="tok-number">0xcf</span>, <span class="tok-number">0x17</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x57</span>,
    <span class="tok-number">0x01</span>, <span class="tok-number">0xbb</span>, <span class="tok-number">0xcd</span>, <span class="tok-number">0xe4</span>,
    <span class="tok-number">0x77</span>, <span class="tok-number">0xd6</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x60</span>,
})</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Build.Cache.addPrefix" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addPrefix</span><a href="#src.zig-std.Build.Cache.addPrefix">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addPrefix</span>(cache: *<a href="std.Build.Cache.html">Cache</a>, directory: <a href="std.Build.Cache.Directory.html">Directory</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cache: *<a href="std.Build.Cache.html">Cache</a></code></pre></div><div><pre><code>directory: <a href="std.Build.Cache.Directory.html">Directory</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.addPrefix">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addPrefix</span>(cache: *<a href="std.Build.Cache.html">Cache</a>, directory: <a href="std.Build.Cache.Directory.html">Directory</a>) <span class="tok-type">void</span> {
    cache.prefixes_buffer[cache.prefixes_len] = directory;
    cache.prefixes_len += <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.obtain" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">obtain</span><a href="#src.zig-std.Build.Cache.obtain">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">obtain</span>(cache: *<a href="std.Build.Cache.html">Cache</a>) <a href="std.Build.Cache.Manifest.html">Manifest</a></code></pre></div><div class="tldDocs"><p>Be sure to call <code><a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.deinit">Manifest.deinit</a></code> after successful initialization.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cache: *<a href="std.Build.Cache.html">Cache</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.obtain">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">obtain</span>(cache: *<a href="std.Build.Cache.html">Cache</a>) <a href="std.Build.Cache.Manifest.html">Manifest</a> {
    <span class="tok-kw">return</span> .{
        .cache = cache,
        .hash = cache.hash,
        .manifest_file = <span class="tok-null">null</span>,
        .manifest_dirty = <span class="tok-null">false</span>,
        .hex_digest = <span class="tok-null">undefined</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.prefixes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">prefixes</span><a href="#src.zig-std.Build.Cache.prefixes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixes</span>(cache: *<span class="tok-kw">const</span> <a href="std.Build.Cache.html">Cache</a>) []<span class="tok-kw">const</span> <a href="std.Build.Cache.Directory.html">Directory</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>cache: *<span class="tok-kw">const</span> <a href="std.Build.Cache.html">Cache</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.prefixes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixes</span>(cache: *<span class="tok-kw">const</span> <a href="std.Build.Cache.html">Cache</a>) []<span class="tok-kw">const</span> <a href="std.Build.Cache.Directory.html">Directory</a> {
    <span class="tok-kw">return</span> cache.prefixes_buffer[<span class="tok-number">0</span>..cache.prefixes_len];
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.binToHex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">binToHex</span><a href="#src.zig-std.Build.Cache.binToHex">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binToHex</span>(bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a>) <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.binToHex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binToHex</span>(bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a>) <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> {
    <span class="tok-kw">var</span> out_digest: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;
    _ = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(
        &amp;out_digest,
        <span class="tok-str">&quot;{s}&quot;</span>,
        .{<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(&amp;bin_digest)},
    ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> out_digest;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.readSmallFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readSmallFile</span><a href="#src.zig-std.Build.Cache.readSmallFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readSmallFile</span>(dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>On operating systems that support symlinks, does a readlink. On other operating systems,
uses the file contents. Windows supports symlinks but only with elevated privileges, so
it is treated as not supporting symlinks.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.readSmallFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readSmallFile</span>(dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">return</span> dir.readFile(sub_path, buffer);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> dir.readLink(sub_path, buffer);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Cache.writeSmallFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeSmallFile</span><a href="#src.zig-std.Build.Cache.writeSmallFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSmallFile</span>(dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On operating systems that support symlinks, does a symlink. On other operating systems,
uses the file contents. Windows supports symlinks but only with elevated privileges, so
it is treated as not supporting symlinks.
<code>data</code> must be a valid UTF-8 encoded file path and 255 bytes or fewer.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Cache.writeSmallFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSmallFile</span>(dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(data.len &lt;= <span class="tok-number">255</span>);
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">return</span> dir.writeFile(.{ .sub_path = sub_path, .data = data });
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> dir.symLink(data, sub_path, .{});
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Build.Cache">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Manages `zig-cache` directories.</span>
<span class="tok-comment">//! This is not a general-purpose cache. It is designed to be fast and simple,</span>
<span class="tok-comment">//! not to withstand attacks using specially-crafted input.</span>

gpa: <a href="std.mem.Allocator.html">Allocator</a>,
manifest_dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>,
hash: <a href="std.Build.Cache.HashHelper.html">HashHelper</a> = .{},
<span class="tok-comment">/// This value is accessed from multiple threads, protected by mutex.</span>
recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,
mutex: <a href="std.html">std</a>.<a href="std.Thread.html">Thread</a>.<a href="std.Thread.Mutex.html">Mutex</a> = .{},

<span class="tok-comment">/// A set of strings such as the zig library directory or project source root, which</span>
<span class="tok-comment">/// are stripped from the file paths before putting into the cache. They</span>
<span class="tok-comment">/// are replaced with single-character indicators. This is not to save</span>
<span class="tok-comment">/// space but to eliminate absolute file paths. This improves portability</span>
<span class="tok-comment">/// and usefulness of the cache for advanced use cases.</span>
prefixes_buffer: [<span class="tok-number">4</span>]<a href="std.Build.Cache.Directory.html">Directory</a> = <span class="tok-null">undefined</span>,
prefixes_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Path = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Cache/Path.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Directory = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Cache/Directory.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DepTokenizer = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Cache/DepTokenizer.zig&quot;</span>);

<span class="tok-kw">const</span> Cache = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> crypto = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> fmt = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> log = <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.scoped">scoped</a>(.cache);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addPrefix</span>(cache: *<a href="std.Build.Cache.html">Cache</a>, directory: <a href="std.Build.Cache.Directory.html">Directory</a>) <span class="tok-type">void</span> {
    cache.prefixes_buffer[cache.prefixes_len] = directory;
    cache.prefixes_len += <span class="tok-number">1</span>;
}

<span class="tok-comment">/// Be sure to call `Manifest.deinit` after successful initialization.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">obtain</span>(cache: *<a href="std.Build.Cache.html">Cache</a>) <a href="std.Build.Cache.Manifest.html">Manifest</a> {
    <span class="tok-kw">return</span> .{
        .cache = cache,
        .hash = cache.hash,
        .manifest_file = <span class="tok-null">null</span>,
        .manifest_dirty = <span class="tok-null">false</span>,
        .hex_digest = <span class="tok-null">undefined</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">prefixes</span>(cache: *<span class="tok-kw">const</span> <a href="std.Build.Cache.html">Cache</a>) []<span class="tok-kw">const</span> <a href="std.Build.Cache.Directory.html">Directory</a> {
    <span class="tok-kw">return</span> cache.prefixes_buffer[<span class="tok-number">0</span>..cache.prefixes_len];
}

<span class="tok-kw">const</span> PrefixedPath = <span class="tok-kw">struct</span> {
    prefix: <span class="tok-type">u8</span>,
    sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(a: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>, b: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> a.prefix == b.prefix <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a.sub_path, b.sub_path);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(pp: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>) <span class="tok-type">u32</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(pp.prefix, pp.sub_path));
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">findPrefix</span>(cache: *<span class="tok-kw">const</span> <a href="std.Build.Cache.html">Cache</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a> {
    <span class="tok-kw">const</span> gpa = cache.gpa;
    <span class="tok-kw">const</span> resolved_path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(gpa, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{file_path});
    <span class="tok-kw">errdefer</span> gpa.free(resolved_path);
    <span class="tok-kw">return</span> <a href="std.Build.Cache.html#std.Build.Cache.findPrefixResolved">findPrefixResolved</a>(cache, resolved_path);
}

<span class="tok-comment">/// Takes ownership of `resolved_path` on success.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">findPrefixResolved</span>(cache: *<span class="tok-kw">const</span> <a href="std.Build.Cache.html">Cache</a>, resolved_path: []<span class="tok-type">u8</span>) !<a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a> {
    <span class="tok-kw">const</span> gpa = cache.gpa;
    <span class="tok-kw">const</span> prefixes_slice = cache.prefixes();
    <span class="tok-kw">var</span> i: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;<span class="tok-comment"> // Start at 1 to skip over checking the null prefix.
    </span><span class="tok-kw">while</span> (i &lt; prefixes_slice.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> p = prefixes_slice[i].path.?;
        <span class="tok-kw">const</span> sub_path = <a href="std.Build.Cache.html#std.Build.Cache.getPrefixSubpath">getPrefixSubpath</a>(gpa, p, resolved_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.NotASubPath =&gt; <span class="tok-kw">continue</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };<span class="tok-comment">
        // Free the resolved path since we're not going to return it
        </span>gpa.free(resolved_path);
        <span class="tok-kw">return</span> <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>{
            .prefix = i,
            .sub_path = sub_path,
        };
    }

    <span class="tok-kw">return</span> <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>{
        .prefix = <span class="tok-number">0</span>,
        .sub_path = resolved_path,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">getPrefixSubpath</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, path: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> relative = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.relative">relative</a>(allocator, prefix, path);
    <span class="tok-kw">errdefer</span> allocator.free(relative);
    <span class="tok-kw">var</span> component_iterator = <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.NativeComponentIterator">NativeComponentIterator</a>.<a href="#">init</a>(relative) <span class="tok-kw">catch</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotASubPath;
    };
    <span class="tok-kw">if</span> (component_iterator.root() != <span class="tok-null">null</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotASubPath;
    }
    <span class="tok-kw">const</span> first_component = component_iterator.first();
    <span class="tok-kw">if</span> (first_component != <span class="tok-null">null</span> <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, first_component.?.name, <span class="tok-str">&quot;..&quot;</span>)) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotASubPath;
    }
    <span class="tok-kw">return</span> relative;
}

<span class="tok-comment">/// This is 128 bits - Even with 2^54 cache entries, the probably of a collision would be under 10^-6</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> bin_digest_len = <span class="tok-number">16</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> hex_digest_len = <a href="std.Build.Cache.html#std.Build.Cache.bin_digest_len">bin_digest_len</a> * <span class="tok-number">2</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BinDigest = [<a href="std.Build.Cache.html#std.Build.Cache.bin_digest_len">bin_digest_len</a>]<span class="tok-type">u8</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HexDigest = [<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>]<span class="tok-type">u8</span>;

<span class="tok-comment">/// This is currently just an arbitrary non-empty string that can't match another manifest line.</span>
<span class="tok-kw">const</span> manifest_header = <span class="tok-str">&quot;0&quot;</span>;
<span class="tok-kw">const</span> manifest_file_size_max = <span class="tok-number">100</span> * <span class="tok-number">1024</span> * <span class="tok-number">1024</span>;

<span class="tok-comment">/// The type used for hashing file contents. Currently, this is SipHash128(1, 3), because it</span>
<span class="tok-comment">/// provides enough collision resistance for the Manifest use cases, while being one of our</span>
<span class="tok-comment">/// fastest options right now.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hasher = <a href="std.crypto.html">crypto</a>.<a href="std.crypto.auth.html">auth</a>.<a href="std.crypto.siphash.html">siphash</a>.<a href="std.crypto.siphash.html#std.crypto.siphash.SipHash128">SipHash128</a>(<span class="tok-number">1</span>, <span class="tok-number">3</span>);

<span class="tok-comment">/// Initial state with random bytes, that can be copied.</span>
<span class="tok-comment">/// Refresh this with new random bytes when the manifest</span>
<span class="tok-comment">/// format is modified in a non-backwards-compatible way.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> hasher_init: <a href="std.Build.Cache.html#std.Build.Cache.Hasher">Hasher</a> = <a href="std.Build.Cache.html#std.Build.Cache.Hasher">Hasher</a>.<a href="#">init</a>(&amp;[_]<span class="tok-type">u8</span>{
    <span class="tok-number">0x33</span>, <span class="tok-number">0x52</span>, <span class="tok-number">0xa2</span>, <span class="tok-number">0x84</span>,
    <span class="tok-number">0xcf</span>, <span class="tok-number">0x17</span>, <span class="tok-number">0x56</span>, <span class="tok-number">0x57</span>,
    <span class="tok-number">0x01</span>, <span class="tok-number">0xbb</span>, <span class="tok-number">0xcd</span>, <span class="tok-number">0xe4</span>,
    <span class="tok-number">0x77</span>, <span class="tok-number">0xd6</span>, <span class="tok-number">0xf0</span>, <span class="tok-number">0x60</span>,
});

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {
    prefixed_path: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>,
    max_file_size: ?<span class="tok-type">usize</span>,
    <span class="tok-comment">/// Populated if the user calls `addOpenedFile`.</span>
    <span class="tok-comment">/// The handle is not owned here.</span>
    handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,
    stat: <a href="std.Build.Cache.File.Stat.html">Stat</a>,
    bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a>,
    contents: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = <span class="tok-kw">struct</span> {
        inode: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.ino_t">INode</a>,
        size: <span class="tok-type">u64</span>,
        mtime: <span class="tok-type">i128</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromFs</span>(fs_stat: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.Stat.html">Stat</a>) <a href="std.Build.Cache.File.Stat.html">Stat</a> {
            <span class="tok-kw">return</span> .{
                .inode = fs_stat.inode,
                .size = fs_stat.size,
                .mtime = fs_stat.mtime,
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.Build.Cache.File.html">File</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        gpa.free(self.prefixed_path.sub_path);
        <span class="tok-kw">if</span> (self.contents) |contents| {
            gpa.free(contents);
            self.contents = <span class="tok-null">null</span>;
        }
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateMaxSize</span>(file: *<a href="std.Build.Cache.File.html">File</a>, new_max_size: ?<span class="tok-type">usize</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> new = new_max_size <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        file.max_file_size = <span class="tok-kw">if</span> (file.max_file_size) |old| <span class="tok-builtin">@max</span>(old, new) <span class="tok-kw">else</span> new;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateHandle</span>(file: *<a href="std.Build.Cache.File.html">File</a>, new_handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> handle = new_handle <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        file.handle = handle;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> HashHelper = <span class="tok-kw">struct</span> {
    hasher: <a href="std.Build.Cache.html#std.Build.Cache.Hasher">Hasher</a> = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>,

    <span class="tok-comment">/// Record a slice of bytes as a dependency of the process being cached.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addBytes</span>(hh: *<a href="std.Build.Cache.HashHelper.html">HashHelper</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
        hh.hasher.update(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;bytes.len));
        hh.hasher.update(bytes);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalBytes</span>(hh: *<a href="std.Build.Cache.HashHelper.html">HashHelper</a>, optional_bytes: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
        hh.add(optional_bytes != <span class="tok-null">null</span>);
        hh.addBytes(optional_bytes <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfBytes</span>(hh: *<a href="std.Build.Cache.HashHelper.html">HashHelper</a>, list_of_bytes: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
        hh.add(list_of_bytes.len);
        <span class="tok-kw">for</span> (list_of_bytes) |bytes| hh.addBytes(bytes);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalListOfBytes</span>(hh: *<a href="std.Build.Cache.HashHelper.html">HashHelper</a>, optional_list_of_bytes: ?[]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
        hh.add(optional_list_of_bytes != <span class="tok-null">null</span>);
        hh.addListOfBytes(optional_list_of_bytes <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);
    }

    <span class="tok-comment">/// Convert the input value into bytes and record it as a dependency of the process being cached.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(hh: *<a href="std.Build.Cache.HashHelper.html">HashHelper</a>, x: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(x)) {
            <a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a> =&gt; {
                hh.add(x.major);
                hh.add(x.minor);
                hh.add(x.patch);
            },
            <a href="std.html">std</a>.<a href="std.Target.html">Target</a>.<a href="std.Target.Os.html">Os</a>.<a href="std.Target.Os.TaggedVersionRange.html">TaggedVersionRange</a> =&gt; {
                <span class="tok-kw">switch</span> (x) {
                    .hurd =&gt; |hurd| {
                        hh.add(hurd.range.min);
                        hh.add(hurd.range.max);
                        hh.add(hurd.glibc);
                    },
                    .linux =&gt; |linux| {
                        hh.add(linux.range.min);
                        hh.add(linux.range.max);
                        hh.add(linux.glibc);
                        hh.add(linux.android);
                    },
                    .windows =&gt; |windows| {
                        hh.add(windows.min);
                        hh.add(windows.max);
                    },
                    .semver =&gt; |semver| {
                        hh.add(semver.min);
                        hh.add(semver.max);
                    },
                    .none =&gt; {},
                }
            },
            <a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.BuildId.html">BuildId</a> =&gt; <span class="tok-kw">switch</span> (x) {
                .none, .fast, .uuid, .sha1, .md5 =&gt; hh.add(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.activeTag">activeTag</a>(x)),
                .hexstring =&gt; |hex_string| hh.addBytes(hex_string.toSlice()),
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(x))) {
                .<span class="tok-type">bool</span>, .int, .@&quot;enum&quot;, .array =&gt; hh.addBytes(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;x)),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unable to hash type &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(x))),
            },
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptional</span>(hh: *<a href="std.Build.Cache.HashHelper.html">HashHelper</a>, optional: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
        hh.add(optional != <span class="tok-null">null</span>);
        hh.add(optional <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>);
    }

    <span class="tok-comment">/// Returns a hex encoded hash of the inputs, without modifying state.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peek</span>(hh: <a href="std.Build.Cache.HashHelper.html">HashHelper</a>) [<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>]<span class="tok-type">u8</span> {
        <span class="tok-kw">var</span> copy = hh;
        <span class="tok-kw">return</span> copy.final();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">peekBin</span>(hh: <a href="std.Build.Cache.HashHelper.html">HashHelper</a>) <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> {
        <span class="tok-kw">var</span> copy = hh;
        <span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
        copy.hasher.final(&amp;bin_digest);
        <span class="tok-kw">return</span> bin_digest;
    }

    <span class="tok-comment">/// Returns a hex encoded hash of the inputs, mutating the state of the hasher.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(hh: *<a href="std.Build.Cache.HashHelper.html">HashHelper</a>) <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> {
        <span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
        hh.hasher.final(&amp;bin_digest);
        <span class="tok-kw">return</span> <a href="std.Build.Cache.html#std.Build.Cache.binToHex">binToHex</a>(bin_digest);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">oneShot</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) [<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>]<span class="tok-type">u8</span> {
        <span class="tok-kw">var</span> hasher: <a href="std.Build.Cache.html#std.Build.Cache.Hasher">Hasher</a> = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
        hasher.update(bytes);
        <span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
        hasher.final(&amp;bin_digest);
        <span class="tok-kw">return</span> <a href="std.Build.Cache.html#std.Build.Cache.binToHex">binToHex</a>(bin_digest);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binToHex</span>(bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a>) <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> {
    <span class="tok-kw">var</span> out_digest: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;
    _ = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(
        &amp;out_digest,
        <span class="tok-str">&quot;{s}&quot;</span>,
        .{<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(&amp;bin_digest)},
    ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> out_digest;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Lock = <span class="tok-kw">struct</span> {
    manifest_file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">release</span>(lock: *<a href="std.Build.Cache.Lock.html">Lock</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {<span class="tok-comment">
            // Windows does not guarantee that locks are immediately unlocked when
            // the file handle is closed. See LockFileEx documentation.
            </span>lock.manifest_file.unlock();
        }

        lock.manifest_file.close();
        lock.* = <span class="tok-null">undefined</span>;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Manifest = <span class="tok-kw">struct</span> {
    cache: *<a href="std.Build.Cache.html">Cache</a>,
    <span class="tok-comment">/// Current state for incremental hashing.</span>
    hash: <a href="std.Build.Cache.HashHelper.html">HashHelper</a>,
    manifest_file: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>,
    manifest_dirty: <span class="tok-type">bool</span>,
    <span class="tok-comment">/// Set this flag to true before calling hit() in order to indicate that</span>
    <span class="tok-comment">/// upon a cache hit, the code using the cache will not modify the files</span>
    <span class="tok-comment">/// within the cache directory. This allows multiple processes to utilize</span>
    <span class="tok-comment">/// the same cache directory at the same time.</span>
    want_shared_lock: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    have_exclusive_lock: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,<span class="tok-comment">
    // Indicate that we want isProblematicTimestamp to perform a filesystem write in
    // order to obtain a problematic timestamp for the next call. Calls after that
    // will then use the same timestamp, to avoid unnecessary filesystem writes.
    </span>want_refresh_timestamp: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    files: <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.Files">Files</a> = .{},
    hex_digest: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a>,
    diagnostic: <a href="std.Build.Cache.Manifest.Diagnostic.html">Diagnostic</a> = .none,
    <span class="tok-comment">/// Keeps track of the last time we performed a file system write to observe</span>
    <span class="tok-comment">/// what time the file system thinks it is, according to its own granularity.</span>
    recent_problematic_timestamp: <span class="tok-type">i128</span> = <span class="tok-number">0</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostic = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        none,
        manifest_create: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.OpenError">OpenError</a>,
        manifest_read: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a>,
        manifest_lock: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.fs.File.html#std.fs.File.LockError">LockError</a>,
        manifest_seek: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.SeekError">SeekError</a>,
        file_open: <a href="std.Build.Cache.Manifest.Diagnostic.FileOp.html">FileOp</a>,
        file_stat: <a href="std.Build.Cache.Manifest.Diagnostic.FileOp.html">FileOp</a>,
        file_read: <a href="std.Build.Cache.Manifest.Diagnostic.FileOp.html">FileOp</a>,
        file_hash: <a href="std.Build.Cache.Manifest.Diagnostic.FileOp.html">FileOp</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FileOp = <span class="tok-kw">struct</span> {
            file_index: <span class="tok-type">usize</span>,
            err: <span class="tok-type">anyerror</span>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Files = <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(<a href="std.Build.Cache.File.html">File</a>, <span class="tok-type">void</span>, <a href="std.Build.Cache.Manifest.FilesContext.html">FilesContext</a>, <span class="tok-null">false</span>);

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FilesContext = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(fc: <a href="std.Build.Cache.Manifest.FilesContext.html">FilesContext</a>, file: <a href="std.Build.Cache.File.html">File</a>) <span class="tok-type">u32</span> {
            _ = fc;
            <span class="tok-kw">return</span> file.prefixed_path.hash();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(fc: <a href="std.Build.Cache.Manifest.FilesContext.html">FilesContext</a>, a: <a href="std.Build.Cache.File.html">File</a>, b: <a href="std.Build.Cache.File.html">File</a>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            _ = fc;
            _ = b_index;
            <span class="tok-kw">return</span> a.prefixed_path.eql(b.prefixed_path);
        }
    };

    <span class="tok-kw">const</span> FilesAdapter = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(context: <span class="tok-builtin">@This</span>(), a: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>, b: <a href="std.Build.Cache.File.html">File</a>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            _ = context;
            _ = b_index;
            <span class="tok-kw">return</span> a.eql(b.prefixed_path);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(context: <span class="tok-builtin">@This</span>(), key: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>) <span class="tok-type">u32</span> {
            _ = context;
            <span class="tok-kw">return</span> key.hash();
        }
    };

    <span class="tok-comment">/// Add a file as a dependency of process being cached. When `hit` is</span>
    <span class="tok-comment">/// called, the file's contents will be checked to ensure that it matches</span>
    <span class="tok-comment">/// the contents from previous times.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Max file size will be used to determine the amount of space the file contents</span>
    <span class="tok-comment">/// are allowed to take up in memory. If max_file_size is null, then the contents</span>
    <span class="tok-comment">/// will not be loaded into memory.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Returns the index of the entry in the `files` array list. You can use it</span>
    <span class="tok-comment">/// to access the contents of the file after calling `hit()` like so:</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// ```</span>
    <span class="tok-comment">/// var file_contents = cache_hash.files.keys()[file_index].contents.?;</span>
    <span class="tok-comment">/// ```</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePath</span>(m: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: <a href="std.Build.Cache.Path.html">Path</a>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addOpenedFile">addOpenedFile</a>(m, file_path, <span class="tok-null">null</span>, max_file_size);
    }

    <span class="tok-comment">/// Same as `addFilePath` except the file has already been opened.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOpenedFile</span>(m: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, path: <a href="std.Build.Cache.Path.html">Path</a>, handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> gpa = m.cache.gpa;
        <span class="tok-kw">try</span> m.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> resolved_path = <span class="tok-kw">try</span> <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.resolve">resolve</a>(gpa, &amp;.{
            path.root_dir.path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;.&quot;</span>,
            path.subPathOrDot(),
        });
        <span class="tok-kw">errdefer</span> gpa.free(resolved_path);
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> m.cache.findPrefixResolved(resolved_path);
        <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addFileInner">addFileInner</a>(m, prefixed_path, handle, max_file_size);
    }

    <span class="tok-comment">/// Deprecated; use `addFilePath`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: ?<span class="tok-type">usize</span>) !<span class="tok-type">usize</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);

        <span class="tok-kw">const</span> gpa = self.cache.gpa;
        <span class="tok-kw">try</span> self.files.ensureUnusedCapacity(gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.addFileInner">addFileInner</a>(self, prefixed_path, <span class="tok-null">null</span>, max_file_size);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addFileInner</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, prefixed_path: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a>, handle: ?<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, max_file_size: ?<span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> gop = self.files.getOrPutAssumeCapacityAdapted(prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">if</span> (gop.found_existing) {
            gop.key_ptr.updateMaxSize(max_file_size);
            gop.key_ptr.updateHandle(handle);
            <span class="tok-kw">return</span> gop.index;
        }
        gop.key_ptr.* = .{
            .prefixed_path = prefixed_path,
            .contents = <span class="tok-null">null</span>,
            .max_file_size = max_file_size,
            .stat = <span class="tok-null">undefined</span>,
            .bin_digest = <span class="tok-null">undefined</span>,
            .handle = handle,
        };

        self.hash.add(prefixed_path.prefix);
        self.hash.addBytes(prefixed_path.sub_path);

        <span class="tok-kw">return</span> gop.index;
    }

    <span class="tok-comment">/// Deprecated, use `addOptionalFilePath`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, optional_file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        self.hash.add(optional_file_path != <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addOptionalFilePath</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, optional_file_path: ?<a href="std.Build.Cache.Path.html">Path</a>) !<span class="tok-type">void</span> {
        self.hash.add(optional_file_path != <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> file_path = optional_file_path <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
        _ = <span class="tok-kw">try</span> self.addFilePath(file_path, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addListOfFiles</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, list_of_files: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        self.hash.add(list_of_files.len);
        <span class="tok-kw">for</span> (list_of_files) |file_path| {
            _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFile</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);
        <span class="tok-kw">return</span> self.addDepFileMaybePost(dir, dep_file_basename);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> HitError = <span class="tok-kw">error</span>{
        <span class="tok-comment">/// Unable to check the cache for a reason that has been recorded into</span>
        <span class="tok-comment">/// the `diagnostic` field.</span>
        CacheCheckFailed,
        <span class="tok-comment">/// A cache manifest file exists however it could not be parsed.</span>
        InvalidFormat,
        OutOfMemory,
    };

    <span class="tok-comment">/// Check the cache to see if the input exists in it. If it exists, returns `true`.</span>
    <span class="tok-comment">/// A hex encoding of its hash is available by calling `final`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This function will also acquire an exclusive lock to the manifest file. This means</span>
    <span class="tok-comment">/// that a process holding a Manifest will block any other process attempting to</span>
    <span class="tok-comment">/// acquire the lock. If `want_shared_lock` is `true`, a cache hit guarantees the</span>
    <span class="tok-comment">/// manifest file to be locked in shared mode, and a cache miss guarantees the manifest</span>
    <span class="tok-comment">/// file to be locked in exclusive mode.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The lock on the manifest file is released when `deinit` is called. As another</span>
    <span class="tok-comment">/// option, one may call `toOwnedLock` to obtain a smaller object which can represent</span>
    <span class="tok-comment">/// the lock. `deinit` is safe to call whether or not `toOwnedLock` has been called.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.HitError">HitError</a>!<span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file == <span class="tok-null">null</span>);

        self.diagnostic = .none;

        <span class="tok-kw">const</span> ext = <span class="tok-str">&quot;.txt&quot;</span>;
        <span class="tok-kw">var</span> manifest_file_path: [<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a> + ext.len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

        <span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
        self.hash.hasher.final(&amp;bin_digest);

        self.hex_digest = <a href="std.Build.Cache.html#std.Build.Cache.binToHex">binToHex</a>(bin_digest);

        <span class="tok-builtin">@memcpy</span>(manifest_file_path[<span class="tok-number">0</span>..self.hex_digest.len], &amp;self.hex_digest);
        manifest_file_path[<a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>..][<span class="tok-number">0</span>..ext.len].* = ext.*;<span class="tok-comment">

        // We'll try to open the cache with an exclusive lock, but if that would block
        // and `want_shared_lock` is set, a shared lock might be sufficient, so we'll
        // open with a shared lock instead.
        </span><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{
                .read = <span class="tok-null">true</span>,
                .truncate = <span class="tok-null">false</span>,
                .lock = .exclusive,
                .lock_nonblocking = self.want_shared_lock,
            })) |manifest_file| {
                self.manifest_file = manifest_file;
                self.have_exclusive_lock = <span class="tok-null">true</span>;
                <span class="tok-kw">break</span>;
            } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.WouldBlock =&gt; {
                    self.manifest_file = self.cache.manifest_dir.openFile(&amp;manifest_file_path, .{
                        .mode = .read_write,
                        .lock = .shared,
                    }) <span class="tok-kw">catch</span> |e| {
                        self.diagnostic = .{ .manifest_create = e };
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                    };
                    <span class="tok-kw">break</span>;
                },
                <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                    // There are no dir components, so the only possibility
                    // should be that the directory behind the handle has been
                    // deleted, however we have observed on macOS two processes
                    // racing to do openat() with O_CREAT manifest in ENOENT.
                    //
                    // As a workaround, we retry with exclusive=true which
                    // disambiguates by returning EEXIST, indicating original
                    // failure was a race, or ENOENT, indicating deletion of
                    // the directory of our open handle.
                    </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .macos) {
                        self.diagnostic = .{ .manifest_create = <span class="tok-kw">error</span>.FileNotFound };
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                    }

                    <span class="tok-kw">if</span> (self.cache.manifest_dir.createFile(&amp;manifest_file_path, .{
                        .read = <span class="tok-null">true</span>,
                        .truncate = <span class="tok-null">false</span>,
                        .lock = .exclusive,
                        .lock_nonblocking = self.want_shared_lock,
                        .exclusive = <span class="tok-null">true</span>,
                    })) |manifest_file| {
                        self.manifest_file = manifest_file;
                        self.have_exclusive_lock = <span class="tok-null">true</span>;
                        <span class="tok-kw">break</span>;
                    } <span class="tok-kw">else</span> |excl_err| <span class="tok-kw">switch</span> (excl_err) {
                        <span class="tok-kw">error</span>.WouldBlock, <span class="tok-kw">error</span>.PathAlreadyExists =&gt; <span class="tok-kw">continue</span>,
                        <span class="tok-kw">error</span>.FileNotFound =&gt; {
                            self.diagnostic = .{ .manifest_create = <span class="tok-kw">error</span>.FileNotFound };
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                        },
                        <span class="tok-kw">else</span> =&gt; |e| {
                            self.diagnostic = .{ .manifest_create = e };
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                        },
                    }
                },
                <span class="tok-kw">else</span> =&gt; |e| {
                    self.diagnostic = .{ .manifest_create = e };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                },
            }
        }

        self.want_refresh_timestamp = <span class="tok-null">true</span>;

        <span class="tok-kw">const</span> input_file_count = self.files.entries.len;<span class="tok-comment">

        // We're going to construct a second hash. Its input will begin with the digest we've
        // already computed (`bin_digest`), and then it'll have the digests of each input file,
        // including &quot;post&quot; files (see `addFilePost`). If this is a hit, we learn the set of &quot;post&quot;
        // files from the manifest on disk. If this is a miss, we'll learn those from future calls
        // to `addFilePost` etc. As such, the state of `self.hash.hasher` after this function
        // depends on whether this is a hit or a miss.
        //
        // If we return `true` indicating a cache hit, then `self.hash.hasher` must already include
        // the digests of the &quot;post&quot; files, so the caller can call `final`. Otherwise, on a cache
        // miss, `self.hash.hasher` will include the digests of all non-&quot;post&quot; files -- that is,
        // the ones we've already been told about. The rest will be discovered through calls to
        // `addFilePost` etc, which will update the hasher. After all files are added, the user can
        // use `final`, and will at some point `writeManifest` the file list to disk.

        </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
        self.hash.hasher.update(&amp;bin_digest);

        hit: {
            <span class="tok-kw">const</span> file_digests_populated: <span class="tok-type">usize</span> = digests: {
                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.hitWithCurrentLock()) {
                    .hit =&gt; <span class="tok-kw">break</span> :hit,
                    .miss =&gt; |m| <span class="tok-kw">if</span> (!<span class="tok-kw">try</span> self.upgradeToExclusiveLock()) {
                        <span class="tok-kw">break</span> :digests m.file_digests_populated;
                    },
                }<span class="tok-comment">
                // We've just had a miss with the shared lock, and upgraded to an exclusive lock. Someone
                // else might have modified the digest, so we need to check again before deciding to miss.
                // Before trying again, we must reset `self.hash.hasher` and `self.files`.
                // This is basically just the first half of `unhit`.
                </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
                self.hash.hasher.update(&amp;bin_digest);
                <span class="tok-kw">while</span> (self.files.count() != input_file_count) {
                    <span class="tok-kw">var</span> file = self.files.pop().?;
                    file.key.deinit(self.cache.gpa);
                }<span class="tok-comment">
                // Also, seek the file back to the start.
                </span>self.manifest_file.?.seekTo(<span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| {
                    self.diagnostic = .{ .manifest_seek = err };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                };

                <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> self.hitWithCurrentLock()) {
                    .hit =&gt; <span class="tok-kw">break</span> :hit,
                    .miss =&gt; |m| <span class="tok-kw">break</span> :digests m.file_digests_populated,
                }
            };<span class="tok-comment">

            // This is a guaranteed cache miss. We're almost ready to return `false`, but there's a
            // little bookkeeping to do first. The first `file_digests_populated` entries in `files`
            // have their `bin_digest` populated; there may be some left in `input_file_count` which
            // we'll need to populate ourselves. Other than that, this is basically `unhit`.
            </span>self.manifest_dirty = <span class="tok-null">true</span>;
            self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
            self.hash.hasher.update(&amp;bin_digest);
            <span class="tok-kw">while</span> (self.files.count() != input_file_count) {
                <span class="tok-kw">var</span> file = self.files.pop().?;
                file.key.deinit(self.cache.gpa);
            }
            <span class="tok-kw">for</span> (self.files.keys(), <span class="tok-number">0</span>..) |*file, idx| {
                <span class="tok-kw">if</span> (idx &lt; file_digests_populated) {<span class="tok-comment">
                    // `bin_digest` is already populated by `hitWithCurrentLock`, so we can use it directly.
                    </span>self.hash.hasher.update(&amp;file.bin_digest);
                } <span class="tok-kw">else</span> {
                    self.populateFileHash(file) <span class="tok-kw">catch</span> |err| {
                        self.diagnostic = .{ .file_hash = .{
                            .file_index = idx,
                            .err = err,
                        } };
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                    };
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        }

        <span class="tok-kw">if</span> (self.want_shared_lock) {
            self.downgradeToSharedLock() <span class="tok-kw">catch</span> |err| {
                self.diagnostic = .{ .manifest_lock = err };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            };
        }

        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Assumes that `self.hash.hasher` has been updated only with the original digest, that</span>
    <span class="tok-comment">/// `self.files` contains only the original input files, and that `self.manifest_file.?` is</span>
    <span class="tok-comment">/// seeked to the start of the file.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">hitWithCurrentLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.HitError">HitError</a>!<span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.hit">hit</a>,
        miss: <span class="tok-kw">struct</span> {
            file_digests_populated: <span class="tok-type">usize</span>,
        },
    } {
        <span class="tok-kw">const</span> gpa = self.cache.gpa;
        <span class="tok-kw">const</span> input_file_count = self.files.entries.len;

        <span class="tok-kw">const</span> file_contents = self.manifest_file.?.reader().readAllAlloc(gpa, <a href="std.Build.Cache.html#std.Build.Cache.manifest_file_size_max">manifest_file_size_max</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">error</span>.StreamTooLong =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory,
            <span class="tok-kw">else</span> =&gt; |e| {
                self.diagnostic = .{ .manifest_read = e };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            },
        };
        <span class="tok-kw">defer</span> gpa.free(file_contents);

        <span class="tok-kw">var</span> any_file_changed = <span class="tok-null">false</span>;
        <span class="tok-kw">var</span> line_iter = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, file_contents, <span class="tok-str">'\n'</span>);
        <span class="tok-kw">var</span> idx: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">const</span> header_valid = valid: {
            <span class="tok-kw">const</span> line = line_iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">break</span> :valid <span class="tok-null">false</span>;
            <span class="tok-kw">break</span> :valid <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, line, <a href="std.Build.Cache.html#std.Build.Cache.manifest_header">manifest_header</a>);
        };
        <span class="tok-kw">if</span> (!header_valid) {
            <span class="tok-kw">return</span> .{ .miss = .{ .file_digests_populated = <span class="tok-number">0</span> } };
        }
        <span class="tok-kw">while</span> (line_iter.next()) |line| {
            <span class="tok-kw">defer</span> idx += <span class="tok-number">1</span>;

            <span class="tok-kw">var</span> iter = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">' '</span>);
            <span class="tok-kw">const</span> size = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> inode = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> mtime_nsec_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> digest_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> prefix_str = iter.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> file_path = iter.rest();

            <span class="tok-kw">const</span> stat_size = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, size, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> stat_inode = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.ino_t">INode</a>, inode, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> stat_mtime = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">i64</span>, mtime_nsec_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">const</span> file_bin_digest = b: {
                <span class="tok-kw">if</span> (digest_str.len != <a href="std.Build.Cache.html#std.Build.Cache.hex_digest_len">hex_digest_len</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
                <span class="tok-kw">var</span> bd: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
                _ = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.hexToBytes">hexToBytes</a>(&amp;bd, digest_str) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
                <span class="tok-kw">break</span> :b bd;
            };

            <span class="tok-kw">const</span> prefix = <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u8</span>, prefix_str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;
            <span class="tok-kw">if</span> (prefix &gt;= self.cache.prefixes_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;

            <span class="tok-kw">if</span> (file_path.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;

            <span class="tok-kw">const</span> cache_hash_file = f: {
                <span class="tok-kw">const</span> prefixed_path: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a> = .{
                    .prefix = prefix,
                    .sub_path = file_path,<span class="tok-comment"> // expires with file_contents
                </span>};
                <span class="tok-kw">if</span> (idx &lt; input_file_count) {
                    <span class="tok-kw">const</span> file = &amp;self.files.keys()[idx];
                    <span class="tok-kw">if</span> (!file.prefixed_path.eql(prefixed_path))
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidFormat;

                    file.stat = .{
                        .size = stat_size,
                        .inode = stat_inode,
                        .mtime = stat_mtime,
                    };
                    file.bin_digest = file_bin_digest;
                    <span class="tok-kw">break</span> :f file;
                }
                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
                <span class="tok-kw">errdefer</span> _ = self.files.pop();
                <span class="tok-kw">if</span> (!gop.found_existing) {
                    gop.key_ptr.* = .{
                        .prefixed_path = .{
                            .prefix = prefix,
                            .sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, file_path),
                        },
                        .contents = <span class="tok-null">null</span>,
                        .max_file_size = <span class="tok-null">null</span>,
                        .handle = <span class="tok-null">null</span>,
                        .stat = .{
                            .size = stat_size,
                            .inode = stat_inode,
                            .mtime = stat_mtime,
                        },
                        .bin_digest = file_bin_digest,
                    };
                }
                <span class="tok-kw">break</span> :f gop.key_ptr;
            };

            <span class="tok-kw">const</span> pp = cache_hash_file.prefixed_path;
            <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;
            <span class="tok-kw">const</span> this_file = dir.openFile(pp.sub_path, .{ .mode = .read_only }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
                <span class="tok-kw">error</span>.FileNotFound =&gt; {<span class="tok-comment">
                    // Every digest before this one has been populated successfully.
                    </span><span class="tok-kw">return</span> .{ .miss = .{ .file_digests_populated = idx } };
                },
                <span class="tok-kw">else</span> =&gt; |e| {
                    self.diagnostic = .{ .file_open = .{
                        .file_index = idx,
                        .err = e,
                    } };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                },
            };
            <span class="tok-kw">defer</span> this_file.close();

            <span class="tok-kw">const</span> actual_stat = this_file.stat() <span class="tok-kw">catch</span> |err| {
                self.diagnostic = .{ .file_stat = .{
                    .file_index = idx,
                    .err = err,
                } };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            };
            <span class="tok-kw">const</span> size_match = actual_stat.size == cache_hash_file.stat.size;
            <span class="tok-kw">const</span> mtime_match = actual_stat.mtime == cache_hash_file.stat.mtime;
            <span class="tok-kw">const</span> inode_match = actual_stat.inode == cache_hash_file.stat.inode;

            <span class="tok-kw">if</span> (!size_match <span class="tok-kw">or</span> !mtime_match <span class="tok-kw">or</span> !inode_match) {
                cache_hash_file.stat = .{
                    .size = actual_stat.size,
                    .mtime = actual_stat.mtime,
                    .inode = actual_stat.inode,
                };

                <span class="tok-kw">if</span> (self.isProblematicTimestamp(cache_hash_file.stat.mtime)) {<span class="tok-comment">
                    // The actual file has an unreliable timestamp, force it to be hashed
                    </span>cache_hash_file.stat.mtime = <span class="tok-number">0</span>;
                    cache_hash_file.stat.inode = <span class="tok-number">0</span>;
                }

                <span class="tok-kw">var</span> actual_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
                <a href="std.Build.Cache.html#std.Build.Cache.hashFile">hashFile</a>(this_file, &amp;actual_digest) <span class="tok-kw">catch</span> |err| {
                    self.diagnostic = .{ .file_read = .{
                        .file_index = idx,
                        .err = err,
                    } };
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
                };

                <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;cache_hash_file.bin_digest, &amp;actual_digest)) {
                    cache_hash_file.bin_digest = actual_digest;<span class="tok-comment">
                    // keep going until we have the input file digests
                    </span>any_file_changed = <span class="tok-null">true</span>;
                }
            }

            <span class="tok-kw">if</span> (!any_file_changed) {
                self.hash.hasher.update(&amp;cache_hash_file.bin_digest);
            }
        }<span class="tok-comment">

        // If the manifest was somehow missing one of our input files, or if any file hash has changed,
        // then this is a cache miss. However, we have successfully populated some or all of the file
        // digests.
        </span><span class="tok-kw">if</span> (any_file_changed <span class="tok-kw">or</span> idx &lt; input_file_count) {
            <span class="tok-kw">return</span> .{ .miss = .{ .file_digests_populated = idx } };
        }

        <span class="tok-kw">return</span> .hit;
    }

    <span class="tok-comment">/// Reset `self.hash.hasher` to the state it should be in after `hit` returns `false`.</span>
    <span class="tok-comment">/// The hasher contains the original input digest, and all original input file digests (i.e.</span>
    <span class="tok-comment">/// not including post files).</span>
    <span class="tok-comment">/// Assumes that `bin_digest` is populated for all files up to `input_file_count`. As such,</span>
    <span class="tok-comment">/// this is not necessarily safe to call within `hit`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unhit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a>, input_file_count: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {<span class="tok-comment">
        // Reset the hash.
        </span>self.hash.hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
        self.hash.hasher.update(&amp;bin_digest);<span class="tok-comment">

        // Remove files not in the initial hash.
        </span><span class="tok-kw">while</span> (self.files.count() != input_file_count) {
            <span class="tok-kw">var</span> file = self.files.pop().?;
            file.key.deinit(self.cache.gpa);
        }

        <span class="tok-kw">for</span> (self.files.keys()) |file| {
            self.hash.hasher.update(&amp;file.bin_digest);
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">isProblematicTimestamp</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_time: <span class="tok-type">i128</span>) <span class="tok-type">bool</span> {<span class="tok-comment">
        // If the file_time is prior to the most recent problematic timestamp
        // then we don't need to access the filesystem.
        </span><span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment">

        // Next we will check the globally shared Cache timestamp, which is accessed
        // from multiple threads.
        </span>man.cache.mutex.lock();
        <span class="tok-kw">defer</span> man.cache.mutex.unlock();<span class="tok-comment">

        // Save the global one to our local one to avoid locking next time.
        </span>man.recent_problematic_timestamp = man.cache.recent_problematic_timestamp;
        <span class="tok-kw">if</span> (file_time &lt; man.recent_problematic_timestamp)
            <span class="tok-kw">return</span> <span class="tok-null">false</span>;<span class="tok-comment">

        // This flag prevents multiple filesystem writes for the same hit() call.
        </span><span class="tok-kw">if</span> (man.want_refresh_timestamp) {
            man.want_refresh_timestamp = <span class="tok-null">false</span>;

            <span class="tok-kw">var</span> file = man.cache.manifest_dir.createFile(<span class="tok-str">&quot;timestamp&quot;</span>, .{
                .read = <span class="tok-null">true</span>,
                .truncate = <span class="tok-null">true</span>,
            }) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            <span class="tok-kw">defer</span> file.close();<span class="tok-comment">

            // Save locally and also save globally (we still hold the global lock).
            </span>man.recent_problematic_timestamp = (file.stat() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">true</span>).mtime;
            man.cache.recent_problematic_timestamp = man.recent_problematic_timestamp;
        }

        <span class="tok-kw">return</span> file_time &gt;= man.recent_problematic_timestamp;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">populateFileHash</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, ch_file: *<a href="std.Build.Cache.File.html">File</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (ch_file.handle) |handle| {
            <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.populateFileHashHandle">populateFileHashHandle</a>(self, ch_file, handle);
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">const</span> pp = ch_file.prefixed_path;
            <span class="tok-kw">const</span> dir = self.cache.prefixes()[pp.prefix].handle;
            <span class="tok-kw">const</span> handle = <span class="tok-kw">try</span> dir.openFile(pp.sub_path, .{});
            <span class="tok-kw">defer</span> handle.close();
            <span class="tok-kw">return</span> <a href="std.Build.Cache.Manifest.html#std.Build.Cache.Manifest.populateFileHashHandle">populateFileHashHandle</a>(self, ch_file, handle);
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">populateFileHashHandle</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, ch_file: *<a href="std.Build.Cache.File.html">File</a>, handle: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> actual_stat = <span class="tok-kw">try</span> handle.stat();
        ch_file.stat = .{
            .size = actual_stat.size,
            .mtime = actual_stat.mtime,
            .inode = actual_stat.inode,
        };

        <span class="tok-kw">if</span> (self.isProblematicTimestamp(ch_file.stat.mtime)) {<span class="tok-comment">
            // The actual file has an unreliable timestamp, force it to be hashed
            </span>ch_file.stat.mtime = <span class="tok-number">0</span>;
            ch_file.stat.inode = <span class="tok-number">0</span>;
        }

        <span class="tok-kw">if</span> (ch_file.max_file_size) |max_file_size| {
            <span class="tok-kw">if</span> (ch_file.stat.size &gt; max_file_size) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig;
            }

            <span class="tok-kw">const</span> contents = <span class="tok-kw">try</span> self.cache.gpa.alloc(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(ch_file.stat.size)));
            <span class="tok-kw">errdefer</span> self.cache.gpa.free(contents);<span class="tok-comment">

            // Hash while reading from disk, to keep the contents in the cpu cache while
            // doing hashing.
            </span><span class="tok-kw">var</span> hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
            <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> handle.pread(contents[off..], off);
                <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                hasher.update(contents[off..][<span class="tok-number">0</span>..bytes_read]);
                off += bytes_read;
            }
            hasher.final(&amp;ch_file.bin_digest);

            ch_file.contents = contents;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.hashFile">hashFile</a>(handle, &amp;ch_file.bin_digest);
        }

        self.hash.hasher.update(&amp;ch_file.bin_digest);
    }

    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span>
    <span class="tok-comment">/// calculated. This is useful for processes that don't know all the files that</span>
    <span class="tok-comment">/// are depended on ahead of time. For example, a source file that can import other files</span>
    <span class="tok-comment">/// will need to be recompiled if the imported file is changed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostFetch</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, max_file_size: <span class="tok-type">usize</span>) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);

        <span class="tok-kw">const</span> gpa = self.cache.gpa;
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">errdefer</span> _ = self.files.pop();

        <span class="tok-kw">if</span> (gop.found_existing) {
            gpa.free(prefixed_path.sub_path);
            <span class="tok-kw">return</span> gop.key_ptr.contents.?;
        }

        gop.key_ptr.* = .{
            .prefixed_path = prefixed_path,
            .max_file_size = max_file_size,
            .stat = <span class="tok-null">undefined</span>,
            .bin_digest = <span class="tok-null">undefined</span>,
            .contents = <span class="tok-null">null</span>,
        };

        self.files.lockPointers();
        <span class="tok-kw">defer</span> self.files.unlockPointers();

        <span class="tok-kw">try</span> self.populateFileHash(gop.key_ptr);
        <span class="tok-kw">return</span> gop.key_ptr.contents.?;
    }

    <span class="tok-comment">/// Add a file as a dependency of process being cached, after the initial hash has been</span>
    <span class="tok-comment">/// calculated.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// This is useful for processes that don't know the all the files that are</span>
    <span class="tok-comment">/// depended on ahead of time. For example, a source file that can import</span>
    <span class="tok-comment">/// other files will need to be recompiled if the imported file is changed.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);

        <span class="tok-kw">const</span> gpa = self.cache.gpa;
        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefix(file_path);
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">errdefer</span> _ = self.files.pop();

        <span class="tok-kw">if</span> (gop.found_existing) {
            gpa.free(prefixed_path.sub_path);
            <span class="tok-kw">return</span>;
        }

        gop.key_ptr.* = .{
            .prefixed_path = prefixed_path,
            .max_file_size = <span class="tok-null">null</span>,
            .handle = <span class="tok-null">null</span>,
            .stat = <span class="tok-null">undefined</span>,
            .bin_digest = <span class="tok-null">undefined</span>,
            .contents = <span class="tok-null">null</span>,
        };

        self.files.lockPointers();
        <span class="tok-kw">defer</span> self.files.unlockPointers();

        <span class="tok-kw">try</span> self.populateFileHash(gop.key_ptr);
    }

    <span class="tok-comment">/// Like `addFilePost` but when the file contents have already been loaded from disk.</span>
    <span class="tok-comment">/// On success, cache takes ownership of `resolved_path`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFilePostContents</span>(
        self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>,
        resolved_path: []<span class="tok-type">u8</span>,
        bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        stat: <a href="std.Build.Cache.File.html">File</a>.<a href="std.Build.Cache.File.Stat.html">Stat</a>,
    ) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);
        <span class="tok-kw">const</span> gpa = self.cache.gpa;

        <span class="tok-kw">const</span> prefixed_path = <span class="tok-kw">try</span> self.cache.findPrefixResolved(resolved_path);
        <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
        <span class="tok-kw">errdefer</span> _ = self.files.pop();

        <span class="tok-kw">if</span> (gop.found_existing) {
            gpa.free(prefixed_path.sub_path);
            <span class="tok-kw">return</span>;
        }

        <span class="tok-kw">const</span> new_file = gop.key_ptr;

        new_file.* = .{
            .prefixed_path = prefixed_path,
            .max_file_size = <span class="tok-null">null</span>,
            .handle = <span class="tok-null">null</span>,
            .stat = stat,
            .bin_digest = <span class="tok-null">undefined</span>,
            .contents = <span class="tok-null">null</span>,
        };

        <span class="tok-kw">if</span> (self.isProblematicTimestamp(new_file.stat.mtime)) {<span class="tok-comment">
            // The actual file has an unreliable timestamp, force it to be hashed
            </span>new_file.stat.mtime = <span class="tok-number">0</span>;
            new_file.stat.inode = <span class="tok-number">0</span>;
        }

        {
            <span class="tok-kw">var</span> hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
            hasher.update(bytes);
            hasher.final(&amp;new_file.bin_digest);
        }

        self.hash.hasher.update(&amp;new_file.bin_digest);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addDepFilePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);
        <span class="tok-kw">return</span> self.addDepFileMaybePost(dir, dep_file_basename);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addDepFileMaybePost</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, dep_file_basename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> dep_file_contents = <span class="tok-kw">try</span> dir.readFileAlloc(self.cache.gpa, dep_file_basename, <a href="std.Build.Cache.html#std.Build.Cache.manifest_file_size_max">manifest_file_size_max</a>);
        <span class="tok-kw">defer</span> self.cache.gpa.free(dep_file_contents);

        <span class="tok-kw">var</span> error_buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(self.cache.gpa);
        <span class="tok-kw">defer</span> error_buf.deinit();

        <span class="tok-kw">var</span> it: <a href="std.Build.Cache.DepTokenizer.html">DepTokenizer</a> = .{ .bytes = dep_file_contents };

        <span class="tok-kw">while</span> (it.next()) |token| {
            <span class="tok-kw">switch</span> (token) {<span class="tok-comment">
                // We don't care about targets, we only want the prereqs
                // Clang is invoked in single-source mode but other programs may not
                </span>.target, .target_must_resolve =&gt; {},
                .prereq =&gt; |file_path| <span class="tok-kw">if</span> (self.manifest_file == <span class="tok-null">null</span>) {
                    _ = <span class="tok-kw">try</span> self.addFile(file_path, <span class="tok-null">null</span>);
                } <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.addFilePost(file_path),
                .prereq_must_resolve =&gt; {
                    <span class="tok-kw">var</span> resolve_buf = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(self.cache.gpa);
                    <span class="tok-kw">defer</span> resolve_buf.deinit();

                    <span class="tok-kw">try</span> token.resolve(resolve_buf.writer());
                    <span class="tok-kw">if</span> (self.manifest_file == <span class="tok-null">null</span>) {
                        _ = <span class="tok-kw">try</span> self.addFile(resolve_buf.items, <span class="tok-null">null</span>);
                    } <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.addFilePost(resolve_buf.items);
                },
                <span class="tok-kw">else</span> =&gt; |err| {
                    <span class="tok-kw">try</span> err.printError(error_buf.writer());
                    <a href="std.Build.Cache.html#std.Build.Cache.log">log</a>.<a href="#">err</a>(<span class="tok-str">&quot;failed parsing {s}: {s}&quot;</span>, .{ dep_file_basename, error_buf.items });
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidDepFile;
                },
            }
        }
    }

    <span class="tok-comment">/// Returns a binary hash of the inputs.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finalBin</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);<span class="tok-comment">

        // We don't close the manifest file yet, because we want to
        // keep it locked until the API user is done using it.
        // We also don't write out the manifest yet, because until
        // cache_release is called we still might be working on creating
        // the artifacts to cache.

        </span><span class="tok-kw">var</span> bin_digest: <a href="std.Build.Cache.html#std.Build.Cache.BinDigest">BinDigest</a> = <span class="tok-null">undefined</span>;
        self.hash.hasher.final(&amp;bin_digest);
        <span class="tok-kw">return</span> bin_digest;
    }

    <span class="tok-comment">/// Returns a hex encoded hash of the inputs.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">final</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> {
        <span class="tok-kw">const</span> bin_digest = self.finalBin();
        <span class="tok-kw">return</span> <a href="std.Build.Cache.html#std.Build.Cache.binToHex">binToHex</a>(bin_digest);
    }

    <span class="tok-comment">/// If `want_shared_lock` is true, this function automatically downgrades the</span>
    <span class="tok-comment">/// lock from exclusive to shared.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeManifest</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) !<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self.have_exclusive_lock);

        <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;
        <span class="tok-kw">if</span> (self.manifest_dirty) {
            self.manifest_dirty = <span class="tok-null">false</span>;

            <span class="tok-kw">var</span> contents = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<span class="tok-type">u8</span>).init(self.cache.gpa);
            <span class="tok-kw">defer</span> contents.deinit();

            <span class="tok-kw">const</span> writer = contents.writer();
            <span class="tok-kw">try</span> writer.writeAll(<a href="std.Build.Cache.html#std.Build.Cache.manifest_header">manifest_header</a> ++ <span class="tok-str">&quot;\n&quot;</span>);
            <span class="tok-kw">for</span> (self.files.keys()) |file| {
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{d} {d} {d} {} {d} {s}\n&quot;</span>, .{
                    file.stat.size,
                    file.stat.inode,
                    file.stat.mtime,
                    <a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.fmtSliceHexLower">fmtSliceHexLower</a>(&amp;file.bin_digest),
                    file.prefixed_path.prefix,
                    file.prefixed_path.sub_path,
                });
            }

            <span class="tok-kw">try</span> manifest_file.setEndPos(contents.items.len);
            <span class="tok-kw">try</span> manifest_file.pwriteAll(contents.items, <span class="tok-number">0</span>);
        }

        <span class="tok-kw">if</span> (self.want_shared_lock) {
            <span class="tok-kw">try</span> self.downgradeToSharedLock();
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">downgradeToSharedLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) !<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (!self.have_exclusive_lock) <span class="tok-kw">return</span>;<span class="tok-comment">

        // WASI does not currently support flock, so we bypass it here.
        // TODO: If/when flock is supported on WASI, this check should be removed.
        //       See https://github.com/WebAssembly/wasi-filesystem/issues/2
        </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .wasi <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a> <span class="tok-kw">or</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;
            <span class="tok-kw">try</span> manifest_file.downgradeLock();
        }

        self.have_exclusive_lock = <span class="tok-null">false</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">upgradeToExclusiveLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <span class="tok-kw">error</span>{CacheCheckFailed}!<span class="tok-type">bool</span> {
        <span class="tok-kw">if</span> (self.have_exclusive_lock) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(self.manifest_file != <span class="tok-null">null</span>);<span class="tok-comment">

        // WASI does not currently support flock, so we bypass it here.
        // TODO: If/when flock is supported on WASI, this check should be removed.
        //       See https://github.com/WebAssembly/wasi-filesystem/issues/2
        </span><span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .wasi <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.process.html">process</a>.<a href="std.process.html#std.process.can_spawn">can_spawn</a> <span class="tok-kw">or</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.single_threaded">single_threaded</a>) {
            <span class="tok-kw">const</span> manifest_file = self.manifest_file.?;<span class="tok-comment">
            // Here we intentionally have a period where the lock is released, in case there are
            // other processes holding a shared lock.
            </span>manifest_file.unlock();
            manifest_file.lock(.exclusive) <span class="tok-kw">catch</span> |err| {
                self.diagnostic = .{ .manifest_lock = err };
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CacheCheckFailed;
            };
        }
        self.have_exclusive_lock = <span class="tok-null">true</span>;
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }

    <span class="tok-comment">/// Obtain only the data needed to maintain a lock on the manifest file.</span>
    <span class="tok-comment">/// The `Manifest` remains safe to deinit.</span>
    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toOwnedLock</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <a href="std.Build.Cache.Lock.html">Lock</a> {
        <span class="tok-kw">const</span> lock: <a href="std.Build.Cache.Lock.html">Lock</a> = .{
            .manifest_file = self.manifest_file.?,
        };

        self.manifest_file = <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> lock;
    }

    <span class="tok-comment">/// Releases the manifest file and frees any memory the Manifest was using.</span>
    <span class="tok-comment">/// `Manifest.hit` must be called first.</span>
    <span class="tok-comment">/// Don't forget to call `writeManifest` before this!</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.Build.Cache.Manifest.html">Manifest</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self.manifest_file) |file| {
            <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {<span class="tok-comment">
                // See Lock.release for why this is required on Windows
                </span>file.unlock();
            }

            file.close();
        }
        <span class="tok-kw">for</span> (self.files.keys()) |*file| {
            file.deinit(self.cache.gpa);
        }
        self.files.deinit(self.cache.gpa);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateFileSystemInputs</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, buf: *<a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Server.html">Server</a>.<a href="std.zig.Server.Message.html">Message</a>.<a href="std.zig.Server.Message.PathPrefix.html">PathPrefix</a>).@&quot;enum&quot;.fields.len == man.cache.prefixes_len);
        buf.clearRetainingCapacity();
        <span class="tok-kw">const</span> gpa = man.cache.gpa;
        <span class="tok-kw">const</span> files = man.files.keys();
        <span class="tok-kw">if</span> (files.len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">for</span> (files) |file| {
                <span class="tok-kw">try</span> buf.ensureUnusedCapacity(gpa, file.prefixed_path.sub_path.len + <span class="tok-number">2</span>);
                buf.appendAssumeCapacity(file.prefixed_path.prefix + <span class="tok-number">1</span>);
                buf.appendSliceAssumeCapacity(file.prefixed_path.sub_path);
                buf.appendAssumeCapacity(<span class="tok-number">0</span>);
            }<span class="tok-comment">
            // The null byte is a separator, not a terminator.
            </span>buf.items.len -= <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">populateOtherManifest</span>(man: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, other: *<a href="std.Build.Cache.Manifest.html">Manifest</a>, prefix_map: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> gpa = other.cache.gpa;
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(<a href="std.html">std</a>.<a href="std.zig.html">zig</a>.<a href="std.zig.Server.html">Server</a>.<a href="std.zig.Server.Message.html">Message</a>.<a href="std.zig.Server.Message.PathPrefix.html">PathPrefix</a>).@&quot;enum&quot;.fields.len == man.cache.prefixes_len);
        <a href="std.debug.html#std.debug.assert">assert</a>(man.cache.prefixes_len == <span class="tok-number">4</span>);
        <span class="tok-kw">for</span> (man.files.keys()) |file| {
            <span class="tok-kw">const</span> prefixed_path: <a href="std.Build.Cache.PrefixedPath.html">PrefixedPath</a> = .{
                .prefix = prefix_map[file.prefixed_path.prefix],
                .sub_path = <span class="tok-kw">try</span> gpa.dupe(<span class="tok-type">u8</span>, file.prefixed_path.sub_path),
            };
            <span class="tok-kw">errdefer</span> gpa.free(prefixed_path.sub_path);

            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> other.files.getOrPutAdapted(gpa, prefixed_path, <a href="std.Build.Cache.Manifest.FilesAdapter.html">FilesAdapter</a>{});
            <span class="tok-kw">errdefer</span> _ = other.files.pop();

            <span class="tok-kw">if</span> (gop.found_existing) {
                gpa.free(prefixed_path.sub_path);
                <span class="tok-kw">continue</span>;
            }

            gop.key_ptr.* = .{
                .prefixed_path = prefixed_path,
                .max_file_size = file.max_file_size,
                .handle = file.handle,
                .stat = file.stat,
                .bin_digest = file.bin_digest,
                .contents = <span class="tok-null">null</span>,
            };

            other.hash.hasher.update(&amp;gop.key_ptr.bin_digest);
        }
    }
};

<span class="tok-comment">/// On operating systems that support symlinks, does a readlink. On other operating systems,</span>
<span class="tok-comment">/// uses the file contents. Windows supports symlinks but only with elevated privileges, so</span>
<span class="tok-comment">/// it is treated as not supporting symlinks.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readSmallFile</span>(dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, buffer: []<span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">return</span> dir.readFile(sub_path, buffer);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> dir.readLink(sub_path, buffer);
    }
}

<span class="tok-comment">/// On operating systems that support symlinks, does a symlink. On other operating systems,</span>
<span class="tok-comment">/// uses the file contents. Windows supports symlinks but only with elevated privileges, so</span>
<span class="tok-comment">/// it is treated as not supporting symlinks.</span>
<span class="tok-comment">/// `data` must be a valid UTF-8 encoded file path and 255 bytes or fewer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeSmallFile</span>(dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, data: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(data.len &lt;= <span class="tok-number">255</span>);
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">return</span> dir.writeFile(.{ .sub_path = sub_path, .data = data });
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> dir.symLink(data, sub_path, .{});
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">hashFile</span>(file: <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>, bin_digest: *[<a href="std.Build.Cache.html#std.Build.Cache.Hasher">Hasher</a>.<a href="#">mac_length</a>]<span class="tok-type">u8</span>) <a href="std.fs.html">fs</a>.<a href="std.fs.File.html">File</a>.<a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> hasher = <a href="std.Build.Cache.html#std.Build.Cache.hasher_init">hasher_init</a>;
    <span class="tok-kw">var</span> off: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> file.pread(&amp;buf, off);
        <span class="tok-kw">if</span> (bytes_read == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        hasher.update(buf[<span class="tok-number">0</span>..bytes_read]);
        off += bytes_read;
    }
    hasher.final(bin_digest);
}<span class="tok-comment">

// Create/Write a file, close it, then grab its stat.mtime timestamp.
</span><span class="tok-kw">fn</span> <span class="tok-fn">testGetCurrentFileTimestamp</span>(dir: <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>) !<span class="tok-type">i128</span> {
    <span class="tok-kw">const</span> test_out_file = <span class="tok-str">&quot;test-filetimestamp.tmp&quot;</span>;

    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> dir.createFile(test_out_file, .{
        .read = <span class="tok-null">true</span>,
        .truncate = <span class="tok-null">true</span>,
    });
    <span class="tok-kw">defer</span> {
        file.close();
        dir.deleteFile(test_out_file) <span class="tok-kw">catch</span> {};
    }

    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> file.stat()).mtime;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;cache file and then recall it&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi) {<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/5437
        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> temp_file = <span class="tok-str">&quot;test.txt&quot;</span>;
    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;temp_manifest_dir&quot;</span>;

    <span class="tok-kw">try</span> tmp.dir.writeFile(.{ .sub_path = temp_file, .data = <span class="tok-str">&quot;Hello, world!\n&quot;</span> });<span class="tok-comment">

    // Wait for file timestamps to tick
    </span><span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.testGetCurrentFileTimestamp">testGetCurrentFileTimestamp</a>(tmp.dir);
    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.testGetCurrentFileTimestamp">testGetCurrentFileTimestamp</a>(tmp.dir)) == initial_time) {
        <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.Thread.html#std.Thread.sleep">sleep</a>(<span class="tok-number">1</span>);
    }

    <span class="tok-kw">var</span> digest1: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> digest2: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;

    {
        <span class="tok-kw">var</span> cache = <a href="std.Build.Cache.html">Cache</a>{
            .gpa = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),
        };
        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });
        <span class="tok-kw">defer</span> cache.manifest_dir.close();

        {
            <span class="tok-kw">var</span> ch = cache.obtain();
            <span class="tok-kw">defer</span> ch.deinit();

            ch.hash.add(<span class="tok-null">true</span>);
            ch.hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1234</span>));
            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);
            _ = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-null">null</span>);<span class="tok-comment">

            // There should be nothing in the cache
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());

            digest1 = ch.final();
            <span class="tok-kw">try</span> ch.writeManifest();
        }
        {
            <span class="tok-kw">var</span> ch = cache.obtain();
            <span class="tok-kw">defer</span> ch.deinit();

            ch.hash.add(<span class="tok-null">true</span>);
            ch.hash.add(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-number">1234</span>));
            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);
            _ = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-null">null</span>);<span class="tok-comment">

            // Cache hit! We just &quot;built&quot; the same file
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">try</span> ch.hit());
            digest2 = ch.final();

            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, ch.have_exclusive_lock);
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(digest1, digest2);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;check that changing a file makes cache fail&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi) {<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/5437
        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> temp_file = <span class="tok-str">&quot;cache_hash_change_file_test.txt&quot;</span>;
    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;cache_hash_change_file_manifest_dir&quot;</span>;
    <span class="tok-kw">const</span> original_temp_file_contents = <span class="tok-str">&quot;Hello, world!\n&quot;</span>;
    <span class="tok-kw">const</span> updated_temp_file_contents = <span class="tok-str">&quot;Hello, world; but updated!\n&quot;</span>;

    <span class="tok-kw">try</span> tmp.dir.writeFile(.{ .sub_path = temp_file, .data = original_temp_file_contents });<span class="tok-comment">

    // Wait for file timestamps to tick
    </span><span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.testGetCurrentFileTimestamp">testGetCurrentFileTimestamp</a>(tmp.dir);
    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.testGetCurrentFileTimestamp">testGetCurrentFileTimestamp</a>(tmp.dir)) == initial_time) {
        <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.Thread.html#std.Thread.sleep">sleep</a>(<span class="tok-number">1</span>);
    }

    <span class="tok-kw">var</span> digest1: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> digest2: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;

    {
        <span class="tok-kw">var</span> cache = <a href="std.Build.Cache.html">Cache</a>{
            .gpa = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),
        };
        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });
        <span class="tok-kw">defer</span> cache.manifest_dir.close();

        {
            <span class="tok-kw">var</span> ch = cache.obtain();
            <span class="tok-kw">defer</span> ch.deinit();

            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);
            <span class="tok-kw">const</span> temp_file_idx = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-number">100</span>);<span class="tok-comment">

            // There should be nothing in the cache
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());

            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, original_temp_file_contents, ch.files.keys()[temp_file_idx].contents.?));

            digest1 = ch.final();

            <span class="tok-kw">try</span> ch.writeManifest();
        }

        <span class="tok-kw">try</span> tmp.dir.writeFile(.{ .sub_path = temp_file, .data = updated_temp_file_contents });

        {
            <span class="tok-kw">var</span> ch = cache.obtain();
            <span class="tok-kw">defer</span> ch.deinit();

            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);
            <span class="tok-kw">const</span> temp_file_idx = <span class="tok-kw">try</span> ch.addFile(temp_file, <span class="tok-number">100</span>);<span class="tok-comment">

            // A file that we depend on has been updated, so the cache should not contain an entry for it
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());<span class="tok-comment">

            // The cache system does not keep the contents of re-hashed input files.
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(ch.files.keys()[temp_file_idx].contents == <span class="tok-null">null</span>);

            digest2 = ch.final();

            <span class="tok-kw">try</span> ch.writeManifest();
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, digest1[<span class="tok-number">0</span>..], digest2[<span class="tok-number">0</span>..]));
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;no file inputs&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi) {<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/5437
        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;no_file_inputs_manifest_dir&quot;</span>;

    <span class="tok-kw">var</span> digest1: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> digest2: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">var</span> cache = <a href="std.Build.Cache.html">Cache</a>{
        .gpa = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
        .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),
    };
    cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });
    <span class="tok-kw">defer</span> cache.manifest_dir.close();

    {
        <span class="tok-kw">var</span> man = cache.obtain();
        <span class="tok-kw">defer</span> man.deinit();

        man.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);<span class="tok-comment">

        // There should be nothing in the cache
        </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <span class="tok-kw">try</span> man.hit());

        digest1 = man.final();

        <span class="tok-kw">try</span> man.writeManifest();
    }
    {
        <span class="tok-kw">var</span> man = cache.obtain();
        <span class="tok-kw">defer</span> man.deinit();

        man.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">try</span> man.hit());
        digest2 = man.final();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, man.have_exclusive_lock);
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(digest1, digest2);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;Manifest with files added after initial hash work&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi) {<span class="tok-comment">
        // https://github.com/ziglang/zig/issues/5437
        </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">var</span> tmp = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> temp_file1 = <span class="tok-str">&quot;cache_hash_post_file_test1.txt&quot;</span>;
    <span class="tok-kw">const</span> temp_file2 = <span class="tok-str">&quot;cache_hash_post_file_test2.txt&quot;</span>;
    <span class="tok-kw">const</span> temp_manifest_dir = <span class="tok-str">&quot;cache_hash_post_file_manifest_dir&quot;</span>;

    <span class="tok-kw">try</span> tmp.dir.writeFile(.{ .sub_path = temp_file1, .data = <span class="tok-str">&quot;Hello, world!\n&quot;</span> });
    <span class="tok-kw">try</span> tmp.dir.writeFile(.{ .sub_path = temp_file2, .data = <span class="tok-str">&quot;Hello world the second!\n&quot;</span> });<span class="tok-comment">

    // Wait for file timestamps to tick
    </span><span class="tok-kw">const</span> initial_time = <span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.testGetCurrentFileTimestamp">testGetCurrentFileTimestamp</a>(tmp.dir);
    <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.testGetCurrentFileTimestamp">testGetCurrentFileTimestamp</a>(tmp.dir)) == initial_time) {
        <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.Thread.html#std.Thread.sleep">sleep</a>(<span class="tok-number">1</span>);
    }

    <span class="tok-kw">var</span> digest1: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> digest2: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> digest3: <a href="std.Build.Cache.html#std.Build.Cache.HexDigest">HexDigest</a> = <span class="tok-null">undefined</span>;

    {
        <span class="tok-kw">var</span> cache = <a href="std.Build.Cache.html">Cache</a>{
            .gpa = <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>,
            .manifest_dir = <span class="tok-kw">try</span> tmp.dir.makeOpenPath(temp_manifest_dir, .{}),
        };
        cache.addPrefix(.{ .path = <span class="tok-null">null</span>, .handle = tmp.dir });
        <span class="tok-kw">defer</span> cache.manifest_dir.close();

        {
            <span class="tok-kw">var</span> ch = cache.obtain();
            <span class="tok-kw">defer</span> ch.deinit();

            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);
            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);<span class="tok-comment">

            // There should be nothing in the cache
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());

            _ = <span class="tok-kw">try</span> ch.addFilePost(temp_file2);

            digest1 = ch.final();
            <span class="tok-kw">try</span> ch.writeManifest();
        }
        {
            <span class="tok-kw">var</span> ch = cache.obtain();
            <span class="tok-kw">defer</span> ch.deinit();

            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);
            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);

            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">try</span> ch.hit());
            digest2 = ch.final();

            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, ch.have_exclusive_lock);
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;digest1, &amp;digest2));<span class="tok-comment">

        // Modify the file added after initial hash
        </span><span class="tok-kw">try</span> tmp.dir.writeFile(.{ .sub_path = temp_file2, .data = <span class="tok-str">&quot;Hello world the second, updated\n&quot;</span> });<span class="tok-comment">

        // Wait for file timestamps to tick
        </span><span class="tok-kw">const</span> initial_time2 = <span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.testGetCurrentFileTimestamp">testGetCurrentFileTimestamp</a>(tmp.dir);
        <span class="tok-kw">while</span> ((<span class="tok-kw">try</span> <a href="std.Build.Cache.html#std.Build.Cache.testGetCurrentFileTimestamp">testGetCurrentFileTimestamp</a>(tmp.dir)) == initial_time2) {
            <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.Thread.html#std.Thread.sleep">sleep</a>(<span class="tok-number">1</span>);
        }

        {
            <span class="tok-kw">var</span> ch = cache.obtain();
            <span class="tok-kw">defer</span> ch.deinit();

            ch.hash.addBytes(<span class="tok-str">&quot;1234&quot;</span>);
            _ = <span class="tok-kw">try</span> ch.addFile(temp_file1, <span class="tok-null">null</span>);<span class="tok-comment">

            // A file that we depend on has been updated, so the cache should not contain an entry for it
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, <span class="tok-kw">try</span> ch.hit());

            _ = <span class="tok-kw">try</span> ch.addFilePost(temp_file2);

            digest3 = ch.final();

            <span class="tok-kw">try</span> ch.writeManifest();
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;digest1, &amp;digest3));
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
