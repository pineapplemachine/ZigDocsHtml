<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.Random.html" class="active">Random</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Random" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Random</span><a href="#src.zig-std.Random">[src]</a></h1><div class="tldDocs"><p>The engines provided here should be initialized from an external source.
For a thread-local cryptographically secure pseudo random number generator,
use <code><a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">std.crypto.random</a></code>.
Be sure to use a CSPRNG when required, otherwise using a normal PRNG will
be faster and use substantially less stack space.</p>
</div><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.Random.ziggurat.html">std.Random.ziggurat</a></li></ul></div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.Random.Xoshiro256.html">std.Random.Xoshiro256</a></li><li><a href="std.Random.ChaCha.html">std.Random.ChaCha</a></li><li><a href="std.Random.Ascon.html">std.Random.Ascon</a></li><li><a href="std.Random.ChaCha.html">std.Random.ChaCha</a></li><li><a href="std.Random.Isaac64.html">std.Random.Isaac64</a></li><li><a href="std.Random.Pcg.html">std.Random.Pcg</a></li><li><a href="std.Random.Xoroshiro128.html">std.Random.Xoroshiro128</a></li><li><a href="std.Random.Xoshiro256.html">std.Random.Xoshiro256</a></li><li><a href="std.Random.Sfc64.html">std.Random.Sfc64</a></li><li><a href="std.Random.RomuTrio.html">std.Random.RomuTrio</a></li><li><a href="std.Random.SplitMix64.html">std.Random.SplitMix64</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>ptr: *<span class="tok-type">anyopaque</span></code></pre><div class="fieldDocs"><p>Any comparison of this field may result in illegal behavior, since it may be set to
<code>undefined</code> in cases where the random implementation does not have any associated
state.</p>
</div></div><div><pre><code>fillFn: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (ptr: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Random.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.Random.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(pointer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> fillFn: <span class="tok-kw">fn</span> (ptr: <span class="tok-builtin">@TypeOf</span>(pointer), buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span>) <a href="std.Random.html">Random</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fillFn: <span class="tok-kw">fn</span> (ptr: <span class="tok-builtin">@TypeOf</span>(pointer), buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(pointer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> fillFn: <span class="tok-kw">fn</span> (ptr: <span class="tok-builtin">@TypeOf</span>(pointer), buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span>) <a href="std.Random.html">Random</a> {
    <span class="tok-kw">const</span> Ptr = <span class="tok-builtin">@TypeOf</span>(pointer);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(Ptr) == .pointer);<span class="tok-comment"> // Must be a pointer
    </span><a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(Ptr).pointer.size == .one);<span class="tok-comment"> // Must be a single-item pointer
    </span><a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(Ptr).pointer.child) == .@&quot;struct&quot;);<span class="tok-comment"> // Must point to a struct
    </span><span class="tok-kw">const</span> gen = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">fill</span>(ptr: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> self: Ptr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr));
            fillFn(self, buf);
        }
    };

    <span class="tok-kw">return</span> .{
        .ptr = pointer,
        .fillFn = gen.fill,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.bytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bytes</span><a href="#src.zig-std.Random.bytes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytes</span>(r: <a href="std.Random.html">Random</a>, buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Read random bytes into the specified buffer until full.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>buf: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.bytes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytes</span>(r: <a href="std.Random.html">Random</a>, buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    r.fillFn(r.ptr, buf);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.boolean" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">boolean</span><a href="#src.zig-std.Random.boolean">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">boolean</span>(r: <a href="std.Random.html">Random</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.boolean">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">boolean</span>(r: <a href="std.Random.html">Random</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> r.int(<span class="tok-type">u1</span>) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.enumValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">enumValue</span><a href="#src.zig-std.Random.enumValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">enumValue</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> EnumType: <span class="tok-type">type</span>) EnumType</code></pre></div><div class="tldDocs"><p>Returns a random value from an enum, evenly distributed.</p>
<p>Note that this will not yield consistent results across all targets
due to dependence on the representation of <code>usize</code> as an index.
See <code><a href="std.Random.html#std.Random.enumValueWithIndex">enumValueWithIndex</a></code> for further commentary.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>EnumType: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.enumValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">enumValue</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> EnumType: <span class="tok-type">type</span>) EnumType {
    <span class="tok-kw">return</span> r.enumValueWithIndex(EnumType, <span class="tok-type">usize</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.enumValueWithIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">enumValueWithIndex</span><a href="#src.zig-std.Random.enumValueWithIndex">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enumValueWithIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> EnumType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Index: <span class="tok-type">type</span>) EnumType</code></pre></div><div class="tldDocs"><p>Returns a random value from an enum, evenly distributed.</p>
<p>An index into an array of all named values is generated using the
specified <code>Index</code> type to determine the return value.
This allows for results to be independent of <code>usize</code> representation.</p>
<p>Prefer <code><a href="std.Random.html#std.Random.enumValue">enumValue</a></code> if this isn't important.</p>
<p>See <code><a href="std.Random.html#std.Random.uintLessThan">uintLessThan</a></code>, which this function uses in most cases,
for commentary on the runtime of this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>EnumType: <span class="tok-type">type</span></code></pre></div><div><pre><code>Index: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.enumValueWithIndex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enumValueWithIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> EnumType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Index: <span class="tok-type">type</span>) EnumType {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(EnumType) == .@&quot;enum&quot;);<span class="tok-comment">

    // We won't use int -&gt; enum casting because enum elements can have
    //  arbitrary values.  Instead we'll randomly pick one of the type's values.
    </span><span class="tok-kw">const</span> values = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.values">values</a>(EnumType);
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(values.len &gt; <span class="tok-number">0</span>);<span class="tok-comment"> // can't return anything
    </span><span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.math.html#std.math.maxInt">maxInt</a>(Index) &gt;= values.len - <span class="tok-number">1</span>);<span class="tok-comment"> // can't access all values
    </span><span class="tok-kw">if</span> (values.len == <span class="tok-number">1</span>) <span class="tok-kw">return</span> values[<span class="tok-number">0</span>];

    <span class="tok-kw">const</span> index = <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> values.len - <span class="tok-number">1</span> == <a href="std.math.html#std.math.maxInt">maxInt</a>(Index))
        r.int(Index)
    <span class="tok-kw">else</span>
        r.uintLessThan(Index, values.len);

    <span class="tok-kw">const</span> MinInt = <a href="std.Random.html#std.Random.MinArrayIndex">MinArrayIndex</a>(Index);
    <span class="tok-kw">return</span> values[<span class="tok-builtin">@as</span>(MinInt, <span class="tok-builtin">@intCast</span>(index))];
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.int" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">int</span><a href="#src.zig-std.Random.int">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">int</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre></div><div class="tldDocs"><p>Returns a random int <code>i</code> such that <code>minInt(T) &lt;= i &lt;= maxInt(T)</code>.
<code>i</code> is evenly distributed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.int">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">int</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">const</span> bits = <span class="tok-builtin">@typeInfo</span>(T).int.bits;
    <span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, bits);
    <span class="tok-kw">const</span> ceil_bytes = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">u16</span>, bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">const</span> ByteAlignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, ceil_bytes * <span class="tok-number">8</span>);

    <span class="tok-kw">var</span> rand_bytes: [ceil_bytes]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    r.bytes(&amp;rand_bytes);<span class="tok-comment">

    // use LE instead of native endian for better portability maybe?
    // TODO: endian portability is pointless if the underlying prng isn't endian portable.
    // TODO: document the endian portability of this library.
    </span><span class="tok-kw">const</span> byte_aligned_result = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(ByteAlignedT, &amp;rand_bytes, .little);
    <span class="tok-kw">const</span> unsigned_result: UnsignedT = <span class="tok-builtin">@truncate</span>(byte_aligned_result);
    <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(unsigned_result);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.uintLessThanBiased" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">uintLessThanBiased</span><a href="#src.zig-std.Random.uintLessThanBiased">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintLessThanBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, less_than: T) T</code></pre></div><div class="tldDocs"><p>Constant-time implementation off <code><a href="std.Random.html#std.Random.uintLessThan">uintLessThan</a></code>.
The results of this function may be biased.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>less_than: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.uintLessThanBiased">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintLessThanBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, less_than: T) T {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-number">0</span> &lt; less_than);
    <span class="tok-kw">return</span> <a href="std.Random.html#std.Random.limitRangeBiased">limitRangeBiased</a>(T, r.int(T), less_than);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.uintLessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">uintLessThan</span><a href="#src.zig-std.Random.uintLessThan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintLessThan</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, less_than: T) T</code></pre></div><div class="tldDocs"><p>Returns an evenly distributed random unsigned integer <code>0 &lt;= i &lt; less_than</code>.
This function assumes that the underlying <code>fillFn</code> produces evenly distributed values.
Within this assumption, the runtime of this function is exponentially distributed.
If <code>fillFn</code> were backed by a true random generator,
the runtime of this function would technically be unbounded.
However, if <code>fillFn</code> is backed by any evenly distributed pseudo random number generator,
this function is guaranteed to return.
If you need deterministic runtime bounds, use <code><a href="std.Random.html#std.Random.uintLessThanBiased">uintLessThanBiased</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>less_than: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.uintLessThan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintLessThan</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, less_than: T) T {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <span class="tok-kw">const</span> bits = <span class="tok-builtin">@typeInfo</span>(T).int.bits;
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-number">0</span> &lt; less_than);<span class="tok-comment">

    // adapted from:
    //   http://www.pcg-random.org/posts/bounded-rands.html
    //   &quot;Lemire's (with an extra tweak from me)&quot;
    </span><span class="tok-kw">var</span> x = r.int(T);
    <span class="tok-kw">var</span> m = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(T, x, less_than);
    <span class="tok-kw">var</span> l: T = <span class="tok-builtin">@truncate</span>(m);
    <span class="tok-kw">if</span> (l &lt; less_than) {
        <span class="tok-kw">var</span> t = -%less_than;

        <span class="tok-kw">if</span> (t &gt;= less_than) {
            t -= less_than;
            <span class="tok-kw">if</span> (t &gt;= less_than) {
                t %= less_than;
            }
        }
        <span class="tok-kw">while</span> (l &lt; t) {
            x = r.int(T);
            m = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(T, x, less_than);
            l = <span class="tok-builtin">@truncate</span>(m);
        }
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(m &gt;&gt; bits);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.uintAtMostBiased" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">uintAtMostBiased</span><a href="#src.zig-std.Random.uintAtMostBiased">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintAtMostBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_most: T) T</code></pre></div><div class="tldDocs"><p>Constant-time implementation off <code><a href="std.Random.html#std.Random.uintAtMost">uintAtMost</a></code>.
The results of this function may be biased.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>at_most: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.uintAtMostBiased">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintAtMostBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_most: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <span class="tok-kw">if</span> (at_most == <a href="std.math.html#std.math.maxInt">maxInt</a>(T)) {<span class="tok-comment">
        // have the full range
        </span><span class="tok-kw">return</span> r.int(T);
    }
    <span class="tok-kw">return</span> r.uintLessThanBiased(T, at_most + <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.uintAtMost" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">uintAtMost</span><a href="#src.zig-std.Random.uintAtMost">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintAtMost</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_most: T) T</code></pre></div><div class="tldDocs"><p>Returns an evenly distributed random unsigned integer <code>0 &lt;= i &lt;= at_most</code>.
See <code><a href="std.Random.html#std.Random.uintLessThan">uintLessThan</a></code>, which this function uses in most cases,
for commentary on the runtime of this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>at_most: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.uintAtMost">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintAtMost</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_most: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <span class="tok-kw">if</span> (at_most == <a href="std.math.html#std.math.maxInt">maxInt</a>(T)) {<span class="tok-comment">
        // have the full range
        </span><span class="tok-kw">return</span> r.int(T);
    }
    <span class="tok-kw">return</span> r.uintLessThan(T, at_most + <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.intRangeLessThanBiased" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intRangeLessThanBiased</span><a href="#src.zig-std.Random.intRangeLessThanBiased">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeLessThanBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, less_than: T) T</code></pre></div><div class="tldDocs"><p>Constant-time implementation off <code><a href="std.Random.html#std.Random.intRangeLessThan">intRangeLessThan</a></code>.
The results of this function may be biased.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>at_least: T</code></pre></div><div><pre><code>less_than: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.intRangeLessThanBiased">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeLessThanBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, less_than: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(at_least &lt; less_than);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
    <span class="tok-kw">if</span> (info.signedness == .signed) {<span class="tok-comment">
        // Two's complement makes this math pretty easy.
        </span><span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);
        <span class="tok-kw">const</span> lo: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_least);
        <span class="tok-kw">const</span> hi: UnsignedT = <span class="tok-builtin">@bitCast</span>(less_than);
        <span class="tok-kw">const</span> result = lo +% r.uintLessThanBiased(UnsignedT, hi -% lo);
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(result);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The signed implementation would work fine, but we can use stricter arithmetic operators here.
        </span><span class="tok-kw">return</span> at_least + r.uintLessThanBiased(T, less_than - at_least);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.intRangeLessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intRangeLessThan</span><a href="#src.zig-std.Random.intRangeLessThan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeLessThan</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, less_than: T) T</code></pre></div><div class="tldDocs"><p>Returns an evenly distributed random integer <code>at_least &lt;= i &lt; less_than</code>.
See <code><a href="std.Random.html#std.Random.uintLessThan">uintLessThan</a></code>, which this function uses in most cases,
for commentary on the runtime of this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>at_least: T</code></pre></div><div><pre><code>less_than: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.intRangeLessThan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeLessThan</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, less_than: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(at_least &lt; less_than);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
    <span class="tok-kw">if</span> (info.signedness == .signed) {<span class="tok-comment">
        // Two's complement makes this math pretty easy.
        </span><span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);
        <span class="tok-kw">const</span> lo: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_least);
        <span class="tok-kw">const</span> hi: UnsignedT = <span class="tok-builtin">@bitCast</span>(less_than);
        <span class="tok-kw">const</span> result = lo +% r.uintLessThan(UnsignedT, hi -% lo);
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(result);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The signed implementation would work fine, but we can use stricter arithmetic operators here.
        </span><span class="tok-kw">return</span> at_least + r.uintLessThan(T, less_than - at_least);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.intRangeAtMostBiased" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intRangeAtMostBiased</span><a href="#src.zig-std.Random.intRangeAtMostBiased">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeAtMostBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, at_most: T) T</code></pre></div><div class="tldDocs"><p>Constant-time implementation off <code><a href="std.Random.html#std.Random.intRangeAtMostBiased">intRangeAtMostBiased</a></code>.
The results of this function may be biased.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>at_least: T</code></pre></div><div><pre><code>at_most: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.intRangeAtMostBiased">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeAtMostBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, at_most: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(at_least &lt;= at_most);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
    <span class="tok-kw">if</span> (info.signedness == .signed) {<span class="tok-comment">
        // Two's complement makes this math pretty easy.
        </span><span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);
        <span class="tok-kw">const</span> lo: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_least);
        <span class="tok-kw">const</span> hi: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_most);
        <span class="tok-kw">const</span> result = lo +% r.uintAtMostBiased(UnsignedT, hi -% lo);
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(result);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The signed implementation would work fine, but we can use stricter arithmetic operators here.
        </span><span class="tok-kw">return</span> at_least + r.uintAtMostBiased(T, at_most - at_least);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.intRangeAtMost" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intRangeAtMost</span><a href="#src.zig-std.Random.intRangeAtMost">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeAtMost</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, at_most: T) T</code></pre></div><div class="tldDocs"><p>Returns an evenly distributed random integer <code>at_least &lt;= i &lt;= at_most</code>.
See <code><a href="std.Random.html#std.Random.uintLessThan">uintLessThan</a></code>, which this function uses in most cases,
for commentary on the runtime of this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>at_least: T</code></pre></div><div><pre><code>at_most: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.intRangeAtMost">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeAtMost</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, at_most: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(at_least &lt;= at_most);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
    <span class="tok-kw">if</span> (info.signedness == .signed) {<span class="tok-comment">
        // Two's complement makes this math pretty easy.
        </span><span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);
        <span class="tok-kw">const</span> lo: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_least);
        <span class="tok-kw">const</span> hi: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_most);
        <span class="tok-kw">const</span> result = lo +% r.uintAtMost(UnsignedT, hi -% lo);
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(result);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The signed implementation would work fine, but we can use stricter arithmetic operators here.
        </span><span class="tok-kw">return</span> at_least + r.uintAtMost(T, at_most - at_least);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.float" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">float</span><a href="#src.zig-std.Random.float">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">float</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre></div><div class="tldDocs"><p>Return a floating point value evenly distributed in the range [0, 1).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.float">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">float</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {<span class="tok-comment">
    // Generate a uniformly random value for the mantissa.
    // Then generate an exponentially biased random value for the exponent.
    // This covers every possible value in the range.
    </span><span class="tok-kw">switch</span> (T) {
        <span class="tok-type">f32</span> =&gt; {<span class="tok-comment">
            // Use 23 random bits for the mantissa, and the rest for the exponent.
            // If all 41 bits are zero, generate additional random bits, until a
            // set bit is found, or 126 bits have been generated.
            </span><span class="tok-kw">const</span> rand = r.int(<span class="tok-type">u64</span>);
            <span class="tok-kw">var</span> rand_lz = <span class="tok-builtin">@clz</span>(rand);
            <span class="tok-kw">if</span> (rand_lz &gt;= <span class="tok-number">41</span>) {
                <span class="tok-builtin">@branchHint</span>(.unlikely);
                rand_lz = <span class="tok-number">41</span> + <span class="tok-builtin">@clz</span>(r.int(<span class="tok-type">u64</span>));
                <span class="tok-kw">if</span> (rand_lz == <span class="tok-number">41</span> + <span class="tok-number">64</span>) {
                    <span class="tok-builtin">@branchHint</span>(.unlikely);<span class="tok-comment">
                    // It is astronomically unlikely to reach this point.
                    </span>rand_lz += <span class="tok-builtin">@clz</span>(r.int(<span class="tok-type">u32</span>) | <span class="tok-number">0x7FF</span>);
                }
            }
            <span class="tok-kw">const</span> mantissa: <span class="tok-type">u23</span> = <span class="tok-builtin">@truncate</span>(rand);
            <span class="tok-kw">const</span> exponent = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">126</span> - rand_lz) &lt;&lt; <span class="tok-number">23</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(exponent | mantissa);
        },
        <span class="tok-type">f64</span> =&gt; {<span class="tok-comment">
            // Use 52 random bits for the mantissa, and the rest for the exponent.
            // If all 12 bits are zero, generate additional random bits, until a
            // set bit is found, or 1022 bits have been generated.
            </span><span class="tok-kw">const</span> rand = r.int(<span class="tok-type">u64</span>);
            <span class="tok-kw">var</span> rand_lz: <span class="tok-type">u64</span> = <span class="tok-builtin">@clz</span>(rand);
            <span class="tok-kw">if</span> (rand_lz &gt;= <span class="tok-number">12</span>) {
                rand_lz = <span class="tok-number">12</span>;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
                    // It is astronomically unlikely for this loop to execute more than once.
                    </span><span class="tok-kw">const</span> addl_rand_lz = <span class="tok-builtin">@clz</span>(r.int(<span class="tok-type">u64</span>));
                    rand_lz += addl_rand_lz;
                    <span class="tok-kw">if</span> (addl_rand_lz != <span class="tok-number">64</span>) {
                        <span class="tok-builtin">@branchHint</span>(.likely);
                        <span class="tok-kw">break</span>;
                    }
                    <span class="tok-kw">if</span> (rand_lz &gt;= <span class="tok-number">1022</span>) {
                        rand_lz = <span class="tok-number">1022</span>;
                        <span class="tok-kw">break</span>;
                    }
                }
            }
            <span class="tok-kw">const</span> mantissa = rand &amp; <span class="tok-number">0xFFFFFFFFFFFFF</span>;
            <span class="tok-kw">const</span> exponent = (<span class="tok-number">1022</span> - rand_lz) &lt;&lt; <span class="tok-number">52</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(exponent | mantissa);
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown floating point type&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.floatNorm" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">floatNorm</span><a href="#src.zig-std.Random.floatNorm">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatNorm</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre></div><div class="tldDocs"><p>Return a floating point value normally distributed with mean = 0, stddev = 1.</p>
<p>To use different parameters, use: floatNorm(...) * desiredStddev + desiredMean.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.floatNorm">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatNorm</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">const</span> value = <a href="std.Random.ziggurat.html">ziggurat</a>.<a href="std.Random.ziggurat.html#std.Random.ziggurat.next_f64">next_f64</a>(r, <a href="std.Random.ziggurat.html">ziggurat</a>.<a href="std.Random.ziggurat.html#std.Random.ziggurat.NormDist">NormDist</a>);
    <span class="tok-kw">switch</span> (T) {
        <span class="tok-type">f32</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@floatCast</span>(value),
        <span class="tok-type">f64</span> =&gt; <span class="tok-kw">return</span> value,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown floating point type&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.floatExp" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">floatExp</span><a href="#src.zig-std.Random.floatExp">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatExp</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre></div><div class="tldDocs"><p>Return an exponentially distributed float with a rate parameter of 1.</p>
<p>To use a different rate parameter, use: floatExp(...) / desiredRate.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.floatExp">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatExp</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">const</span> value = <a href="std.Random.ziggurat.html">ziggurat</a>.<a href="std.Random.ziggurat.html#std.Random.ziggurat.next_f64">next_f64</a>(r, <a href="std.Random.ziggurat.html">ziggurat</a>.<a href="std.Random.ziggurat.html#std.Random.ziggurat.ExpDist">ExpDist</a>);
    <span class="tok-kw">switch</span> (T) {
        <span class="tok-type">f32</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@floatCast</span>(value),
        <span class="tok-type">f64</span> =&gt; <span class="tok-kw">return</span> value,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown floating point type&quot;</span>),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.shuffle" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shuffle</span><a href="#src.zig-std.Random.shuffle">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffle</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buf: []T) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shuffle a slice into a random order.</p>
<p>Note that this will not yield consistent results across all targets
due to dependence on the representation of <code>usize</code> as an index.
See <code><a href="std.Random.html#std.Random.shuffleWithIndex">shuffleWithIndex</a></code> for further commentary.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buf: []T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.shuffle">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffle</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buf: []T) <span class="tok-type">void</span> {
    r.shuffleWithIndex(T, buf, <span class="tok-type">usize</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.shuffleWithIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shuffleWithIndex</span><a href="#src.zig-std.Random.shuffleWithIndex">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffleWithIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buf: []T, <span class="tok-kw">comptime</span> Index: <span class="tok-type">type</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shuffle a slice into a random order, using an index of a
specified type to maintain distribution across targets.
Asserts the index type can represent <code>buf.len</code>.</p>
<p>Indexes into the slice are generated using the specified <code>Index</code>
type, which determines distribution properties. This allows for
results to be independent of <code>usize</code> representation.</p>
<p>Prefer <code><a href="std.Random.html#std.Random.shuffle">shuffle</a></code> if this isn't important.</p>
<p>See <code><a href="std.Random.html#std.Random.intRangeLessThan">intRangeLessThan</a></code>, which this function uses,
for commentary on the runtime of this function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>buf: []T</code></pre></div><div><pre><code>Index: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.shuffleWithIndex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffleWithIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buf: []T, <span class="tok-kw">comptime</span> Index: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> MinInt = <a href="std.Random.html#std.Random.MinArrayIndex">MinArrayIndex</a>(Index);
    <span class="tok-kw">if</span> (buf.len &lt; <span class="tok-number">2</span>) {
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // `i &lt;= j &lt; max &lt;= maxInt(MinInt)`
    </span><span class="tok-kw">const</span> max: MinInt = <span class="tok-builtin">@intCast</span>(buf.len);
    <span class="tok-kw">var</span> i: MinInt = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; max - <span class="tok-number">1</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> j: MinInt = <span class="tok-builtin">@intCast</span>(r.intRangeLessThan(Index, i, max));
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;buf[i], &amp;buf[j]);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.weightedIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">weightedIndex</span><a href="#src.zig-std.Random.weightedIndex">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">weightedIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, proportions: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Randomly selects an index into <code>proportions</code>, where the likelihood of each
index is weighted by that proportion.
It is more likely for the index of the last proportion to be returned
than the index of the first proportion in the slice, and vice versa.</p>
<p>This is useful for selecting an item from a slice where weights are not equal.
<code>T</code> must be a numeric type capable of holding the sum of <code>proportions</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: <a href="std.Random.html">Random</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>proportions: []<span class="tok-kw">const</span> T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.weightedIndex">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">weightedIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, proportions: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {<span class="tok-comment">
    // This implementation works by summing the proportions and picking a
    // random point in [0, sum).  We then loop over the proportions,
    // accumulating until our accumulator is greater than the random point.

    </span><span class="tok-kw">const</span> sum = s: {
        <span class="tok-kw">var</span> sum: T = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (proportions) |v| sum += v;
        <span class="tok-kw">break</span> :s sum;
    };

    <span class="tok-kw">const</span> point = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .int =&gt; |int_info| <span class="tok-kw">switch</span> (int_info.signedness) {
            .signed =&gt; r.intRangeLessThan(T, <span class="tok-number">0</span>, sum),
            .unsigned =&gt; r.uintLessThan(T, sum),
        },<span class="tok-comment">
        // take care that imprecision doesn't lead to a value slightly greater than sum
        </span>.float =&gt; <span class="tok-builtin">@min</span>(r.float(T) * sum, sum - <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatEps">floatEps</a>(T)),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;weightedIndex does not support proportions of type &quot;</span> ++
            <span class="tok-builtin">@typeName</span>(T)),
    };

    <a href="std.debug.html#std.debug.assert">assert</a>(point &lt; sum);

    <span class="tok-kw">var</span> accumulator: T = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (proportions, <span class="tok-number">0</span>..) |p, index| {
        accumulator += p;
        <span class="tok-kw">if</span> (point &lt; accumulator) <span class="tok-kw">return</span> index;
    } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Random.limitRangeBiased" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">limitRangeBiased</span><a href="#src.zig-std.Random.limitRangeBiased">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">limitRangeBiased</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, random_int: T, less_than: T) T</code></pre></div><div class="tldDocs"><p>Convert a random integer 0 &lt;= random_int &lt;= maxValue(T),
into an integer 0 &lt;= result &lt; less_than.
This function introduces a minor bias.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>random_int: T</code></pre></div><div><pre><code>less_than: T</code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Random.limitRangeBiased">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">limitRangeBiased</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, random_int: T, less_than: T) T {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <span class="tok-kw">const</span> bits = <span class="tok-builtin">@typeInfo</span>(T).int.bits;<span class="tok-comment">

    // adapted from:
    //   http://www.pcg-random.org/posts/bounded-rands.html
    //   &quot;Integer Multiplication (Biased)&quot;
    </span><span class="tok-kw">const</span> m = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(T, random_int, less_than);
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(m &gt;&gt; bits);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Random">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! The engines provided here should be initialized from an external source.</span>
<span class="tok-comment">//! For a thread-local cryptographically secure pseudo random number generator,</span>
<span class="tok-comment">//! use `std.crypto.random`.</span>
<span class="tok-comment">//! Be sure to use a CSPRNG when required, otherwise using a normal PRNG will</span>
<span class="tok-comment">//! be faster and use substantially less stack space.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> maxInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>;
<span class="tok-kw">const</span> Random = <span class="tok-builtin">@This</span>();

<span class="tok-comment">/// Fast unbiased random numbers.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DefaultPrng = <a href="std.Random.Xoshiro256.html">Xoshiro256</a>;

<span class="tok-comment">/// Cryptographically secure random numbers.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DefaultCsprng = <a href="std.Random.ChaCha.html">ChaCha</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Ascon = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/Ascon.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChaCha = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/ChaCha.zig&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Isaac64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/Isaac64.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Pcg = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/Pcg.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Xoroshiro128 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/Xoroshiro128.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Xoshiro256 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/Xoshiro256.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Sfc64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/Sfc64.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RomuTrio = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/RomuTrio.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SplitMix64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/SplitMix64.zig&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ziggurat = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/ziggurat.zig&quot;</span>);

<span class="tok-comment">/// Any comparison of this field may result in illegal behavior, since it may be set to</span>
<span class="tok-comment">/// `undefined` in cases where the random implementation does not have any associated</span>
<span class="tok-comment">/// state.</span>
ptr: *<span class="tok-type">anyopaque</span>,
fillFn: *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (ptr: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span>,

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(pointer: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> fillFn: <span class="tok-kw">fn</span> (ptr: <span class="tok-builtin">@TypeOf</span>(pointer), buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span>) <a href="std.Random.html">Random</a> {
    <span class="tok-kw">const</span> Ptr = <span class="tok-builtin">@TypeOf</span>(pointer);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(Ptr) == .pointer);<span class="tok-comment"> // Must be a pointer
    </span><a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(Ptr).pointer.size == .one);<span class="tok-comment"> // Must be a single-item pointer
    </span><a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@typeInfo</span>(Ptr).pointer.child) == .@&quot;struct&quot;);<span class="tok-comment"> // Must point to a struct
    </span><span class="tok-kw">const</span> gen = <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">fill</span>(ptr: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> self: Ptr = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr));
            fillFn(self, buf);
        }
    };

    <span class="tok-kw">return</span> .{
        .ptr = pointer,
        .fillFn = gen.fill,
    };
}

<span class="tok-comment">/// Read random bytes into the specified buffer until full.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bytes</span>(r: <a href="std.Random.html">Random</a>, buf: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    r.fillFn(r.ptr, buf);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">boolean</span>(r: <a href="std.Random.html">Random</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> r.int(<span class="tok-type">u1</span>) != <span class="tok-number">0</span>;
}

<span class="tok-comment">/// Returns a random value from an enum, evenly distributed.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Note that this will not yield consistent results across all targets</span>
<span class="tok-comment">/// due to dependence on the representation of `usize` as an index.</span>
<span class="tok-comment">/// See `enumValueWithIndex` for further commentary.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">enumValue</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> EnumType: <span class="tok-type">type</span>) EnumType {
    <span class="tok-kw">return</span> r.enumValueWithIndex(EnumType, <span class="tok-type">usize</span>);
}

<span class="tok-comment">/// Returns a random value from an enum, evenly distributed.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// An index into an array of all named values is generated using the</span>
<span class="tok-comment">/// specified `Index` type to determine the return value.</span>
<span class="tok-comment">/// This allows for results to be independent of `usize` representation.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Prefer `enumValue` if this isn't important.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See `uintLessThan`, which this function uses in most cases,</span>
<span class="tok-comment">/// for commentary on the runtime of this function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enumValueWithIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> EnumType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Index: <span class="tok-type">type</span>) EnumType {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(EnumType) == .@&quot;enum&quot;);<span class="tok-comment">

    // We won't use int -&gt; enum casting because enum elements can have
    //  arbitrary values.  Instead we'll randomly pick one of the type's values.
    </span><span class="tok-kw">const</span> values = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.values">values</a>(EnumType);
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(values.len &gt; <span class="tok-number">0</span>);<span class="tok-comment"> // can't return anything
    </span><span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.math.html#std.math.maxInt">maxInt</a>(Index) &gt;= values.len - <span class="tok-number">1</span>);<span class="tok-comment"> // can't access all values
    </span><span class="tok-kw">if</span> (values.len == <span class="tok-number">1</span>) <span class="tok-kw">return</span> values[<span class="tok-number">0</span>];

    <span class="tok-kw">const</span> index = <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> values.len - <span class="tok-number">1</span> == <a href="std.math.html#std.math.maxInt">maxInt</a>(Index))
        r.int(Index)
    <span class="tok-kw">else</span>
        r.uintLessThan(Index, values.len);

    <span class="tok-kw">const</span> MinInt = <a href="std.Random.html#std.Random.MinArrayIndex">MinArrayIndex</a>(Index);
    <span class="tok-kw">return</span> values[<span class="tok-builtin">@as</span>(MinInt, <span class="tok-builtin">@intCast</span>(index))];
}

<span class="tok-comment">/// Returns a random int `i` such that `minInt(T) &lt;= i &lt;= maxInt(T)`.</span>
<span class="tok-comment">/// `i` is evenly distributed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">int</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">const</span> bits = <span class="tok-builtin">@typeInfo</span>(T).int.bits;
    <span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, bits);
    <span class="tok-kw">const</span> ceil_bytes = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">u16</span>, bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">const</span> ByteAlignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, ceil_bytes * <span class="tok-number">8</span>);

    <span class="tok-kw">var</span> rand_bytes: [ceil_bytes]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    r.bytes(&amp;rand_bytes);<span class="tok-comment">

    // use LE instead of native endian for better portability maybe?
    // TODO: endian portability is pointless if the underlying prng isn't endian portable.
    // TODO: document the endian portability of this library.
    </span><span class="tok-kw">const</span> byte_aligned_result = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.readInt">readInt</a>(ByteAlignedT, &amp;rand_bytes, .little);
    <span class="tok-kw">const</span> unsigned_result: UnsignedT = <span class="tok-builtin">@truncate</span>(byte_aligned_result);
    <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(unsigned_result);
}

<span class="tok-comment">/// Constant-time implementation off `uintLessThan`.</span>
<span class="tok-comment">/// The results of this function may be biased.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintLessThanBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, less_than: T) T {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-number">0</span> &lt; less_than);
    <span class="tok-kw">return</span> <a href="std.Random.html#std.Random.limitRangeBiased">limitRangeBiased</a>(T, r.int(T), less_than);
}

<span class="tok-comment">/// Returns an evenly distributed random unsigned integer `0 &lt;= i &lt; less_than`.</span>
<span class="tok-comment">/// This function assumes that the underlying `fillFn` produces evenly distributed values.</span>
<span class="tok-comment">/// Within this assumption, the runtime of this function is exponentially distributed.</span>
<span class="tok-comment">/// If `fillFn` were backed by a true random generator,</span>
<span class="tok-comment">/// the runtime of this function would technically be unbounded.</span>
<span class="tok-comment">/// However, if `fillFn` is backed by any evenly distributed pseudo random number generator,</span>
<span class="tok-comment">/// this function is guaranteed to return.</span>
<span class="tok-comment">/// If you need deterministic runtime bounds, use `uintLessThanBiased`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintLessThan</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, less_than: T) T {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <span class="tok-kw">const</span> bits = <span class="tok-builtin">@typeInfo</span>(T).int.bits;
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-number">0</span> &lt; less_than);<span class="tok-comment">

    // adapted from:
    //   http://www.pcg-random.org/posts/bounded-rands.html
    //   &quot;Lemire's (with an extra tweak from me)&quot;
    </span><span class="tok-kw">var</span> x = r.int(T);
    <span class="tok-kw">var</span> m = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(T, x, less_than);
    <span class="tok-kw">var</span> l: T = <span class="tok-builtin">@truncate</span>(m);
    <span class="tok-kw">if</span> (l &lt; less_than) {
        <span class="tok-kw">var</span> t = -%less_than;

        <span class="tok-kw">if</span> (t &gt;= less_than) {
            t -= less_than;
            <span class="tok-kw">if</span> (t &gt;= less_than) {
                t %= less_than;
            }
        }
        <span class="tok-kw">while</span> (l &lt; t) {
            x = r.int(T);
            m = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(T, x, less_than);
            l = <span class="tok-builtin">@truncate</span>(m);
        }
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(m &gt;&gt; bits);
}

<span class="tok-comment">/// Constant-time implementation off `uintAtMost`.</span>
<span class="tok-comment">/// The results of this function may be biased.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintAtMostBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_most: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <span class="tok-kw">if</span> (at_most == <a href="std.math.html#std.math.maxInt">maxInt</a>(T)) {<span class="tok-comment">
        // have the full range
        </span><span class="tok-kw">return</span> r.int(T);
    }
    <span class="tok-kw">return</span> r.uintLessThanBiased(T, at_most + <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Returns an evenly distributed random unsigned integer `0 &lt;= i &lt;= at_most`.</span>
<span class="tok-comment">/// See `uintLessThan`, which this function uses in most cases,</span>
<span class="tok-comment">/// for commentary on the runtime of this function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">uintAtMost</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_most: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <span class="tok-kw">if</span> (at_most == <a href="std.math.html#std.math.maxInt">maxInt</a>(T)) {<span class="tok-comment">
        // have the full range
        </span><span class="tok-kw">return</span> r.int(T);
    }
    <span class="tok-kw">return</span> r.uintLessThan(T, at_most + <span class="tok-number">1</span>);
}

<span class="tok-comment">/// Constant-time implementation off `intRangeLessThan`.</span>
<span class="tok-comment">/// The results of this function may be biased.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeLessThanBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, less_than: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(at_least &lt; less_than);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
    <span class="tok-kw">if</span> (info.signedness == .signed) {<span class="tok-comment">
        // Two's complement makes this math pretty easy.
        </span><span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);
        <span class="tok-kw">const</span> lo: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_least);
        <span class="tok-kw">const</span> hi: UnsignedT = <span class="tok-builtin">@bitCast</span>(less_than);
        <span class="tok-kw">const</span> result = lo +% r.uintLessThanBiased(UnsignedT, hi -% lo);
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(result);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The signed implementation would work fine, but we can use stricter arithmetic operators here.
        </span><span class="tok-kw">return</span> at_least + r.uintLessThanBiased(T, less_than - at_least);
    }
}

<span class="tok-comment">/// Returns an evenly distributed random integer `at_least &lt;= i &lt; less_than`.</span>
<span class="tok-comment">/// See `uintLessThan`, which this function uses in most cases,</span>
<span class="tok-comment">/// for commentary on the runtime of this function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeLessThan</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, less_than: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(at_least &lt; less_than);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
    <span class="tok-kw">if</span> (info.signedness == .signed) {<span class="tok-comment">
        // Two's complement makes this math pretty easy.
        </span><span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);
        <span class="tok-kw">const</span> lo: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_least);
        <span class="tok-kw">const</span> hi: UnsignedT = <span class="tok-builtin">@bitCast</span>(less_than);
        <span class="tok-kw">const</span> result = lo +% r.uintLessThan(UnsignedT, hi -% lo);
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(result);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The signed implementation would work fine, but we can use stricter arithmetic operators here.
        </span><span class="tok-kw">return</span> at_least + r.uintLessThan(T, less_than - at_least);
    }
}

<span class="tok-comment">/// Constant-time implementation off `intRangeAtMostBiased`.</span>
<span class="tok-comment">/// The results of this function may be biased.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeAtMostBiased</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, at_most: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(at_least &lt;= at_most);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
    <span class="tok-kw">if</span> (info.signedness == .signed) {<span class="tok-comment">
        // Two's complement makes this math pretty easy.
        </span><span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);
        <span class="tok-kw">const</span> lo: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_least);
        <span class="tok-kw">const</span> hi: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_most);
        <span class="tok-kw">const</span> result = lo +% r.uintAtMostBiased(UnsignedT, hi -% lo);
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(result);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The signed implementation would work fine, but we can use stricter arithmetic operators here.
        </span><span class="tok-kw">return</span> at_least + r.uintAtMostBiased(T, at_most - at_least);
    }
}

<span class="tok-comment">/// Returns an evenly distributed random integer `at_least &lt;= i &lt;= at_most`.</span>
<span class="tok-comment">/// See `uintLessThan`, which this function uses in most cases,</span>
<span class="tok-comment">/// for commentary on the runtime of this function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intRangeAtMost</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, at_least: T, at_most: T) T {
    <a href="std.debug.html#std.debug.assert">assert</a>(at_least &lt;= at_most);
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(T).int;
    <span class="tok-kw">if</span> (info.signedness == .signed) {<span class="tok-comment">
        // Two's complement makes this math pretty easy.
        </span><span class="tok-kw">const</span> UnsignedT = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, info.bits);
        <span class="tok-kw">const</span> lo: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_least);
        <span class="tok-kw">const</span> hi: UnsignedT = <span class="tok-builtin">@bitCast</span>(at_most);
        <span class="tok-kw">const</span> result = lo +% r.uintAtMost(UnsignedT, hi -% lo);
        <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(result);
    } <span class="tok-kw">else</span> {<span class="tok-comment">
        // The signed implementation would work fine, but we can use stricter arithmetic operators here.
        </span><span class="tok-kw">return</span> at_least + r.uintAtMost(T, at_most - at_least);
    }
}

<span class="tok-comment">/// Return a floating point value evenly distributed in the range [0, 1).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">float</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {<span class="tok-comment">
    // Generate a uniformly random value for the mantissa.
    // Then generate an exponentially biased random value for the exponent.
    // This covers every possible value in the range.
    </span><span class="tok-kw">switch</span> (T) {
        <span class="tok-type">f32</span> =&gt; {<span class="tok-comment">
            // Use 23 random bits for the mantissa, and the rest for the exponent.
            // If all 41 bits are zero, generate additional random bits, until a
            // set bit is found, or 126 bits have been generated.
            </span><span class="tok-kw">const</span> rand = r.int(<span class="tok-type">u64</span>);
            <span class="tok-kw">var</span> rand_lz = <span class="tok-builtin">@clz</span>(rand);
            <span class="tok-kw">if</span> (rand_lz &gt;= <span class="tok-number">41</span>) {
                <span class="tok-builtin">@branchHint</span>(.unlikely);
                rand_lz = <span class="tok-number">41</span> + <span class="tok-builtin">@clz</span>(r.int(<span class="tok-type">u64</span>));
                <span class="tok-kw">if</span> (rand_lz == <span class="tok-number">41</span> + <span class="tok-number">64</span>) {
                    <span class="tok-builtin">@branchHint</span>(.unlikely);<span class="tok-comment">
                    // It is astronomically unlikely to reach this point.
                    </span>rand_lz += <span class="tok-builtin">@clz</span>(r.int(<span class="tok-type">u32</span>) | <span class="tok-number">0x7FF</span>);
                }
            }
            <span class="tok-kw">const</span> mantissa: <span class="tok-type">u23</span> = <span class="tok-builtin">@truncate</span>(rand);
            <span class="tok-kw">const</span> exponent = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">126</span> - rand_lz) &lt;&lt; <span class="tok-number">23</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(exponent | mantissa);
        },
        <span class="tok-type">f64</span> =&gt; {<span class="tok-comment">
            // Use 52 random bits for the mantissa, and the rest for the exponent.
            // If all 12 bits are zero, generate additional random bits, until a
            // set bit is found, or 1022 bits have been generated.
            </span><span class="tok-kw">const</span> rand = r.int(<span class="tok-type">u64</span>);
            <span class="tok-kw">var</span> rand_lz: <span class="tok-type">u64</span> = <span class="tok-builtin">@clz</span>(rand);
            <span class="tok-kw">if</span> (rand_lz &gt;= <span class="tok-number">12</span>) {
                rand_lz = <span class="tok-number">12</span>;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {<span class="tok-comment">
                    // It is astronomically unlikely for this loop to execute more than once.
                    </span><span class="tok-kw">const</span> addl_rand_lz = <span class="tok-builtin">@clz</span>(r.int(<span class="tok-type">u64</span>));
                    rand_lz += addl_rand_lz;
                    <span class="tok-kw">if</span> (addl_rand_lz != <span class="tok-number">64</span>) {
                        <span class="tok-builtin">@branchHint</span>(.likely);
                        <span class="tok-kw">break</span>;
                    }
                    <span class="tok-kw">if</span> (rand_lz &gt;= <span class="tok-number">1022</span>) {
                        rand_lz = <span class="tok-number">1022</span>;
                        <span class="tok-kw">break</span>;
                    }
                }
            }
            <span class="tok-kw">const</span> mantissa = rand &amp; <span class="tok-number">0xFFFFFFFFFFFFF</span>;
            <span class="tok-kw">const</span> exponent = (<span class="tok-number">1022</span> - rand_lz) &lt;&lt; <span class="tok-number">52</span>;
            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(exponent | mantissa);
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown floating point type&quot;</span>),
    }
}

<span class="tok-comment">/// Return a floating point value normally distributed with mean = 0, stddev = 1.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// To use different parameters, use: floatNorm(...) * desiredStddev + desiredMean.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatNorm</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">const</span> value = <a href="std.Random.ziggurat.html">ziggurat</a>.<a href="std.Random.ziggurat.html#std.Random.ziggurat.next_f64">next_f64</a>(r, <a href="std.Random.ziggurat.html">ziggurat</a>.<a href="std.Random.ziggurat.html#std.Random.ziggurat.NormDist">NormDist</a>);
    <span class="tok-kw">switch</span> (T) {
        <span class="tok-type">f32</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@floatCast</span>(value),
        <span class="tok-type">f64</span> =&gt; <span class="tok-kw">return</span> value,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown floating point type&quot;</span>),
    }
}

<span class="tok-comment">/// Return an exponentially distributed float with a rate parameter of 1.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// To use a different rate parameter, use: floatExp(...) / desiredRate.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatExp</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T {
    <span class="tok-kw">const</span> value = <a href="std.Random.ziggurat.html">ziggurat</a>.<a href="std.Random.ziggurat.html#std.Random.ziggurat.next_f64">next_f64</a>(r, <a href="std.Random.ziggurat.html">ziggurat</a>.<a href="std.Random.ziggurat.html#std.Random.ziggurat.ExpDist">ExpDist</a>);
    <span class="tok-kw">switch</span> (T) {
        <span class="tok-type">f32</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@floatCast</span>(value),
        <span class="tok-type">f64</span> =&gt; <span class="tok-kw">return</span> value,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown floating point type&quot;</span>),
    }
}

<span class="tok-comment">/// Shuffle a slice into a random order.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Note that this will not yield consistent results across all targets</span>
<span class="tok-comment">/// due to dependence on the representation of `usize` as an index.</span>
<span class="tok-comment">/// See `shuffleWithIndex` for further commentary.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffle</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buf: []T) <span class="tok-type">void</span> {
    r.shuffleWithIndex(T, buf, <span class="tok-type">usize</span>);
}

<span class="tok-comment">/// Shuffle a slice into a random order, using an index of a</span>
<span class="tok-comment">/// specified type to maintain distribution across targets.</span>
<span class="tok-comment">/// Asserts the index type can represent `buf.len`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Indexes into the slice are generated using the specified `Index`</span>
<span class="tok-comment">/// type, which determines distribution properties. This allows for</span>
<span class="tok-comment">/// results to be independent of `usize` representation.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Prefer `shuffle` if this isn't important.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See `intRangeLessThan`, which this function uses,</span>
<span class="tok-comment">/// for commentary on the runtime of this function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffleWithIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, buf: []T, <span class="tok-kw">comptime</span> Index: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> MinInt = <a href="std.Random.html#std.Random.MinArrayIndex">MinArrayIndex</a>(Index);
    <span class="tok-kw">if</span> (buf.len &lt; <span class="tok-number">2</span>) {
        <span class="tok-kw">return</span>;
    }<span class="tok-comment">

    // `i &lt;= j &lt; max &lt;= maxInt(MinInt)`
    </span><span class="tok-kw">const</span> max: MinInt = <span class="tok-builtin">@intCast</span>(buf.len);
    <span class="tok-kw">var</span> i: MinInt = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; max - <span class="tok-number">1</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> j: MinInt = <span class="tok-builtin">@intCast</span>(r.intRangeLessThan(Index, i, max));
        <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.swap">swap</a>(T, &amp;buf[i], &amp;buf[j]);
    }
}

<span class="tok-comment">/// Randomly selects an index into `proportions`, where the likelihood of each</span>
<span class="tok-comment">/// index is weighted by that proportion.</span>
<span class="tok-comment">/// It is more likely for the index of the last proportion to be returned</span>
<span class="tok-comment">/// than the index of the first proportion in the slice, and vice versa.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This is useful for selecting an item from a slice where weights are not equal.</span>
<span class="tok-comment">/// `T` must be a numeric type capable of holding the sum of `proportions`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">weightedIndex</span>(r: <a href="std.Random.html">Random</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, proportions: []<span class="tok-kw">const</span> T) <span class="tok-type">usize</span> {<span class="tok-comment">
    // This implementation works by summing the proportions and picking a
    // random point in [0, sum).  We then loop over the proportions,
    // accumulating until our accumulator is greater than the random point.

    </span><span class="tok-kw">const</span> sum = s: {
        <span class="tok-kw">var</span> sum: T = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (proportions) |v| sum += v;
        <span class="tok-kw">break</span> :s sum;
    };

    <span class="tok-kw">const</span> point = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {
        .int =&gt; |int_info| <span class="tok-kw">switch</span> (int_info.signedness) {
            .signed =&gt; r.intRangeLessThan(T, <span class="tok-number">0</span>, sum),
            .unsigned =&gt; r.uintLessThan(T, sum),
        },<span class="tok-comment">
        // take care that imprecision doesn't lead to a value slightly greater than sum
        </span>.float =&gt; <span class="tok-builtin">@min</span>(r.float(T) * sum, sum - <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatEps">floatEps</a>(T)),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;weightedIndex does not support proportions of type &quot;</span> ++
            <span class="tok-builtin">@typeName</span>(T)),
    };

    <a href="std.debug.html#std.debug.assert">assert</a>(point &lt; sum);

    <span class="tok-kw">var</span> accumulator: T = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (proportions, <span class="tok-number">0</span>..) |p, index| {
        accumulator += p;
        <span class="tok-kw">if</span> (point &lt; accumulator) <span class="tok-kw">return</span> index;
    } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;
}

<span class="tok-comment">/// Convert a random integer 0 &lt;= random_int &lt;= maxValue(T),</span>
<span class="tok-comment">/// into an integer 0 &lt;= result &lt; less_than.</span>
<span class="tok-comment">/// This function introduces a minor bias.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">limitRangeBiased</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, random_int: T, less_than: T) T {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@typeInfo</span>(T).int.signedness == .unsigned);
    <span class="tok-kw">const</span> bits = <span class="tok-builtin">@typeInfo</span>(T).int.bits;<span class="tok-comment">

    // adapted from:
    //   http://www.pcg-random.org/posts/bounded-rands.html
    //   &quot;Integer Multiplication (Biased)&quot;
    </span><span class="tok-kw">const</span> m = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(T, random_int, less_than);
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(m &gt;&gt; bits);
}

<span class="tok-comment">/// Returns the smallest of `Index` and `usize`.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">MinArrayIndex</span>(<span class="tok-kw">comptime</span> Index: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">const</span> index_info = <span class="tok-builtin">@typeInfo</span>(Index).int;
    <a href="std.debug.html#std.debug.assert">assert</a>(index_info.signedness == .unsigned);
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (index_info.bits &gt;= <span class="tok-builtin">@typeInfo</span>(<span class="tok-type">usize</span>).int.bits) <span class="tok-type">usize</span> <span class="tok-kw">else</span> Index;
}

<span class="tok-kw">test</span> {
    <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.refAllDecls">refAllDecls</a>(<span class="tok-builtin">@This</span>());
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;Random/test.zig&quot;</span>);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
