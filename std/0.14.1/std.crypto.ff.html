<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">crypto</a></li><li><a href="std.crypto.ff.html" class="active">ff</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.crypto.ff" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.crypto.ff</span><a href="#src.zig-std.crypto.ff">[src]</a></h1><div class="tldDocs"><p>Allocation-free, (best-effort) constant-time, finite field arithmetic for large integers.</p>
<p>Unlike <code><a href="std.math.big.html">std.math.big</a></code>, these integers have a fixed maximum length and are only designed to be used for modular arithmetic.
Arithmetic operations are meant to run in constant-time for a given modulus, making them suitable for cryptography.</p>
<p>Parts of that code was ported from the BSD-licensed crypto/internal/bigmod/nat.go file in the Go language, itself inspired from BearSSL.</p>
</div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.crypto.ff.Uint" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Uint</span><a href="#src.zig-std.crypto.ff.Uint">[src]</a></h2><div class="tldDocs"><p>An unsigned big integer with a fixed maximum size (<code>max_bits</code>), suitable for cryptographic operations.
Unless side-channels mitigations are explicitly disabled, operations are designed to be constant-time.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>max_bits: <span class="tok-type">comptime_int</span></code></pre></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>limbs_buffer: [<a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a></code></pre></div><div><pre><code>limbs_len: <span class="tok-type">usize</span></code></pre><div class="fieldDocs"><p>The number of active limbs.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.crypto.ff.Uint.encoded_bytes" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">encoded_bytes</span><a href="#src.zig-std.crypto.ff.Uint.encoded_bytes">[src]</a></h3><div class="tldDocs"><p>Number of bytes required to serialize an integer.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.encoded_bytes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> encoded_bytes = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, max_bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.zero" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">zero</span><a href="#src.zig-std.crypto.ff.Uint.zero">[src]</a></h3><div class="tldDocs"><p>The zero integer.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.zero">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> zero: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> = .{
    .limbs_buffer = [<span class="tok-number">1</span>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>{<span class="tok-number">0</span>} ** <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
    .limbs_len = <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.ff.Uint.fromPrimitive" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromPrimitive</span><a href="#src.zig-std.crypto.ff.Uint.fromPrimitive">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, init_value: T) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div><div class="tldDocs"><p>Creates a new big integer from a primitive type.
This function may not run in constant time.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>init_value: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.fromPrimitive">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, init_value: T) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> {
    <span class="tok-kw">var</span> x = init_value;
    <span class="tok-kw">var</span> out: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> = .{
        .limbs_buffer = <span class="tok-null">undefined</span>,
        .limbs_len = <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
    };
    <span class="tok-kw">for</span> (&amp;out.limbs_buffer) |*limb| {
        limb.* = <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(x)) <span class="tok-kw">else</span> x;
        x = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(T, x, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
    }
    <span class="tok-kw">if</span> (x != <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    }
    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.toPrimitive" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toPrimitive</span><a href="#src.zig-std.crypto.ff.Uint.toPrimitive">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toPrimitive</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!T</code></pre></div><div class="tldDocs"><p>Converts a big integer to a primitive type.
This function may not run in constant time.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div><div><pre><code>T: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.toPrimitive">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toPrimitive</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!T {
    <span class="tok-kw">var</span> x: T = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> i = self.limbs_len - <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt;= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a> <span class="tok-kw">and</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(T, x, <span class="tok-builtin">@bitSizeOf</span>(T) - <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) != <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
        }
        x = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(T, x, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
        <span class="tok-kw">const</span> v = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(T, self.limbsConst()[i]) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
        x |= v;
        <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
    }
    <span class="tok-kw">return</span> x;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.toBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toBytes</span><a href="#src.zig-std.crypto.ff.Uint.toBytes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Encodes a big integer into a byte array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div><div><pre><code>bytes: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.toBytes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (self.isZero()) <span class="tok-kw">return</span>;
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    }
    <span class="tok-builtin">@memset</span>(bytes, <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> shift: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> out_i: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (endian) {
        .big =&gt; bytes.len - <span class="tok-number">1</span>,
        .little =&gt; <span class="tok-number">0</span>,
    };
    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.limbs_len) |i| {
        <span class="tok-kw">var</span> remaining_bits = <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>;
        <span class="tok-kw">var</span> limb = self.limbsConst()[i];
        <span class="tok-kw">while</span> (remaining_bits &gt;= <span class="tok-number">8</span>) {
            bytes[out_i] |= <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(limb)), shift);
            <span class="tok-kw">const</span> consumed = <span class="tok-number">8</span> - shift;
            limb &gt;&gt;= <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@truncate</span>(consumed));
            remaining_bits -= consumed;
            shift = <span class="tok-number">0</span>;
            <span class="tok-kw">switch</span> (endian) {
                .big =&gt; {
                    <span class="tok-kw">if</span> (out_i == <span class="tok-number">0</span>) {
                        <span class="tok-kw">if</span> (i != self.limbs_len - <span class="tok-number">1</span> <span class="tok-kw">or</span> limb != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                        }
                        <span class="tok-kw">return</span>;
                    }
                    out_i -= <span class="tok-number">1</span>;
                },
                .little =&gt; {
                    out_i += <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (out_i == bytes.len) {
                        <span class="tok-kw">if</span> (i != self.limbs_len - <span class="tok-number">1</span> <span class="tok-kw">or</span> limb != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                        }
                        <span class="tok-kw">return</span>;
                    }
                },
            }
        }
        bytes[out_i] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(limb));
        shift = remaining_bits;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.fromBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromBytes</span><a href="#src.zig-std.crypto.ff.Uint.fromBytes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div><div class="tldDocs"><p>Creates a new big integer from a byte array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.fromBytes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> {
    <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Uint.zero">zero</a>;
    <span class="tok-kw">var</span> shift: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> out = <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Uint.zero">zero</a>;
    <span class="tok-kw">var</span> out_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (endian) {
        .big =&gt; bytes.len - <span class="tok-number">1</span>,
        .little =&gt; <span class="tok-number">0</span>,
    };
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> bi = bytes[i];
        out.limbs()[out_i] |= <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, bi, shift);
        shift += <span class="tok-number">8</span>;
        <span class="tok-kw">if</span> (shift &gt;= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) {
            shift -= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>;
            out.limbs()[out_i] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(out.limbs()[out_i]));
            <span class="tok-kw">const</span> overflow = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, bi, <span class="tok-number">8</span> - shift);
            out_i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (out_i &gt;= out.limbs_len) {
                <span class="tok-kw">if</span> (overflow != <span class="tok-number">0</span> <span class="tok-kw">or</span> i != <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                }
                <span class="tok-kw">break</span>;
            }
            out.limbs()[out_i] = overflow;
        }
        <span class="tok-kw">switch</span> (endian) {
            .big =&gt; {
                <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                i -= <span class="tok-number">1</span>;
            },
            .little =&gt; {
                i += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (i == bytes.len) <span class="tok-kw">break</span>;
            },
        }
    }
    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.eql" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.crypto.ff.Uint.eql">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns <code>true</code> if both integers are equal.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div><div><pre><code>y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.eql">eql</a>([<a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, x.limbs_buffer, y.limbs_buffer);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.compare" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">compare</span><a href="#src.zig-std.crypto.ff.Uint.compare">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compare</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a></code></pre></div><div class="tldDocs"><p>Compares two integers.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div><div><pre><code>y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.compare">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compare</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
    <span class="tok-kw">return</span> <a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.compare">compare</a>(
        <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
        x.limbsConst(),
        y.limbsConst(),
        .little,
    );
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.isZero" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isZero</span><a href="#src.zig-std.crypto.ff.Uint.isZero">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isZero</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns <code>true</code> if the integer is zero.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.isZero">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isZero</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> t: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (x.limbsConst()) |elem| {
        t |= elem;
    }
    <span class="tok-kw">return</span> <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(t, <span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.isOdd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isOdd</span><a href="#src.zig-std.crypto.ff.Uint.isOdd">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns <code>true</code> if the integer is odd.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.isOdd">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-builtin">@truncate</span>(x.limbsConst()[<span class="tok-number">0</span>])) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.addWithOverflow" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addWithOverflow</span><a href="#src.zig-std.crypto.ff.Uint.addWithOverflow">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span></code></pre></div><div class="tldDocs"><p>Adds <code>y</code> to <code>x</code>, and returns <code>true</code> if the operation overflowed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div><div><pre><code>y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.addWithOverflow">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
    <span class="tok-kw">return</span> x.conditionalAddWithOverflow(<span class="tok-null">true</span>, y);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Uint.subWithOverflow" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">subWithOverflow</span><a href="#src.zig-std.crypto.ff.Uint.subWithOverflow">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span></code></pre></div><div class="tldDocs"><p>Subtracts <code>y</code> from <code>x</code>, and returns <code>true</code> if the operation overflowed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div><div><pre><code>y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Uint.subWithOverflow">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
    <span class="tok-kw">return</span> x.conditionalSubWithOverflow(<span class="tok-null">true</span>, y);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.ff.Uint">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Uint</span>(<span class="tok-kw">comptime</span> max_bits: <span class="tok-type">comptime_int</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@bitSizeOf</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) % <span class="tok-number">8</span> == <span class="tok-number">0</span>);<span class="tok-comment"> // Limb size must be a multiple of 8

    </span><span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-kw">const</span> max_limbs_count = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, max_bits, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

        limbs_buffer: [<a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
        <span class="tok-comment">/// The number of active limbs.</span>
        limbs_len: <span class="tok-type">usize</span>,

        <span class="tok-comment">/// Number of bytes required to serialize an integer.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> encoded_bytes = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, max_bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-comment">/// Constant slice of active limbs.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">limbsConst</span>(self: *<span class="tok-kw">const</span> <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) []<span class="tok-kw">const</span> <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> {
            <span class="tok-kw">return</span> self.limbs_buffer[<span class="tok-number">0</span>..self.limbs_len];
        }

        <span class="tok-comment">/// Mutable slice of active limbs.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">limbs</span>(self: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) []<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> {
            <span class="tok-kw">return</span> self.limbs_buffer[<span class="tok-number">0</span>..self.limbs_len];
        }<span class="tok-comment">

        // Removes limbs whose value is zero from the active limbs.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> {
            <span class="tok-kw">var</span> res = self;
            <span class="tok-kw">if</span> (self.limbs_len &lt; <span class="tok-number">2</span>) {
                <span class="tok-kw">return</span> res;
            }
            <span class="tok-kw">var</span> i = self.limbs_len - <span class="tok-number">1</span>;
            <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> res.limbsConst()[i] == <span class="tok-number">0</span>) : (i -= <span class="tok-number">1</span>) {}
            res.limbs_len = i + <span class="tok-number">1</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(res.limbs_len &lt;= res.limbs_buffer.len);
            <span class="tok-kw">return</span> res;
        }

        <span class="tok-comment">/// The zero integer.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> zero: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> = .{
            .limbs_buffer = [<span class="tok-number">1</span>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>{<span class="tok-number">0</span>} ** <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
            .limbs_len = <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
        };

        <span class="tok-comment">/// Creates a new big integer from a primitive type.</span>
        <span class="tok-comment">/// This function may not run in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, init_value: T) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> {
            <span class="tok-kw">var</span> x = init_value;
            <span class="tok-kw">var</span> out: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> = .{
                .limbs_buffer = <span class="tok-null">undefined</span>,
                .limbs_len = <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
            };
            <span class="tok-kw">for</span> (&amp;out.limbs_buffer) |*limb| {
                limb.* = <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(x)) <span class="tok-kw">else</span> x;
                x = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(T, x, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
            }
            <span class="tok-kw">if</span> (x != <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            }
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Converts a big integer to a primitive type.</span>
        <span class="tok-comment">/// This function may not run in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toPrimitive</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!T {
            <span class="tok-kw">var</span> x: T = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> i = self.limbs_len - <span class="tok-number">1</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt;= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a> <span class="tok-kw">and</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(T, x, <span class="tok-builtin">@bitSizeOf</span>(T) - <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) != <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                }
                x = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(T, x, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
                <span class="tok-kw">const</span> v = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(T, self.limbsConst()[i]) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                x |= v;
                <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            }
            <span class="tok-kw">return</span> x;
        }

        <span class="tok-comment">/// Encodes a big integer into a byte array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (self.isZero()) <span class="tok-kw">return</span>;
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            }
            <span class="tok-builtin">@memset</span>(bytes, <span class="tok-number">0</span>);
            <span class="tok-kw">var</span> shift: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> out_i: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (endian) {
                .big =&gt; bytes.len - <span class="tok-number">1</span>,
                .little =&gt; <span class="tok-number">0</span>,
            };
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.limbs_len) |i| {
                <span class="tok-kw">var</span> remaining_bits = <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>;
                <span class="tok-kw">var</span> limb = self.limbsConst()[i];
                <span class="tok-kw">while</span> (remaining_bits &gt;= <span class="tok-number">8</span>) {
                    bytes[out_i] |= <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(limb)), shift);
                    <span class="tok-kw">const</span> consumed = <span class="tok-number">8</span> - shift;
                    limb &gt;&gt;= <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@truncate</span>(consumed));
                    remaining_bits -= consumed;
                    shift = <span class="tok-number">0</span>;
                    <span class="tok-kw">switch</span> (endian) {
                        .big =&gt; {
                            <span class="tok-kw">if</span> (out_i == <span class="tok-number">0</span>) {
                                <span class="tok-kw">if</span> (i != self.limbs_len - <span class="tok-number">1</span> <span class="tok-kw">or</span> limb != <span class="tok-number">0</span>) {
                                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                                }
                                <span class="tok-kw">return</span>;
                            }
                            out_i -= <span class="tok-number">1</span>;
                        },
                        .little =&gt; {
                            out_i += <span class="tok-number">1</span>;
                            <span class="tok-kw">if</span> (out_i == bytes.len) {
                                <span class="tok-kw">if</span> (i != self.limbs_len - <span class="tok-number">1</span> <span class="tok-kw">or</span> limb != <span class="tok-number">0</span>) {
                                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                                }
                                <span class="tok-kw">return</span>;
                            }
                        },
                    }
                }
                bytes[out_i] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(limb));
                shift = remaining_bits;
            }
        }

        <span class="tok-comment">/// Creates a new big integer from a byte array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> {
            <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Uint.zero">zero</a>;
            <span class="tok-kw">var</span> shift: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> out = <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Uint.zero">zero</a>;
            <span class="tok-kw">var</span> out_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (endian) {
                .big =&gt; bytes.len - <span class="tok-number">1</span>,
                .little =&gt; <span class="tok-number">0</span>,
            };
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> bi = bytes[i];
                out.limbs()[out_i] |= <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, bi, shift);
                shift += <span class="tok-number">8</span>;
                <span class="tok-kw">if</span> (shift &gt;= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) {
                    shift -= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>;
                    out.limbs()[out_i] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(out.limbs()[out_i]));
                    <span class="tok-kw">const</span> overflow = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, bi, <span class="tok-number">8</span> - shift);
                    out_i += <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (out_i &gt;= out.limbs_len) {
                        <span class="tok-kw">if</span> (overflow != <span class="tok-number">0</span> <span class="tok-kw">or</span> i != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                        }
                        <span class="tok-kw">break</span>;
                    }
                    out.limbs()[out_i] = overflow;
                }
                <span class="tok-kw">switch</span> (endian) {
                    .big =&gt; {
                        <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                        i -= <span class="tok-number">1</span>;
                    },
                    .little =&gt; {
                        i += <span class="tok-number">1</span>;
                        <span class="tok-kw">if</span> (i == bytes.len) <span class="tok-kw">break</span>;
                    },
                }
            }
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Returns `true` if both integers are equal.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.eql">eql</a>([<a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, x.limbs_buffer, y.limbs_buffer);
        }

        <span class="tok-comment">/// Compares two integers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compare</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.compare">compare</a>(
                <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
                x.limbsConst(),
                y.limbsConst(),
                .little,
            );
        }

        <span class="tok-comment">/// Returns `true` if the integer is zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isZero</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">var</span> t: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (x.limbsConst()) |elem| {
                t |= elem;
            }
            <span class="tok-kw">return</span> <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(t, <span class="tok-number">0</span>);
        }

        <span class="tok-comment">/// Returns `true` if the integer is odd.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-builtin">@truncate</span>(x.limbsConst()[<span class="tok-number">0</span>])) != <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Adds `y` to `x`, and returns `true` if the operation overflowed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
            <span class="tok-kw">return</span> x.conditionalAddWithOverflow(<span class="tok-null">true</span>, y);
        }

        <span class="tok-comment">/// Subtracts `y` from `x`, and returns `true` if the operation overflowed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
            <span class="tok-kw">return</span> x.conditionalSubWithOverflow(<span class="tok-null">true</span>, y);
        }<span class="tok-comment">

        // Replaces the limbs of `x` with the limbs of `y` if `on` is `true`.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">cmov</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, on: <span class="tok-type">bool</span>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (x.limbs(), y.limbsConst()) |*x_limb, y_limb| {
                x_limb.* = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">select</a>(on, y_limb, x_limb.*);
            }
        }<span class="tok-comment">

        // Adds `y` to `x` if `on` is `true`, and returns `true` if the
        // operation overflowed.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">conditionalAddWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, on: <span class="tok-type">bool</span>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
            <span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (x.limbs(), y.limbsConst()) |*x_limb, y_limb| {
                <span class="tok-kw">const</span> res = x_limb.* + y_limb + carry;
                x_limb.* = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">select</a>(on, <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(res)), x_limb.*);
                carry = <span class="tok-builtin">@truncate</span>(res &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
            }
            <span class="tok-kw">return</span> carry;
        }<span class="tok-comment">

        // Subtracts `y` from `x` if `on` is `true`, and returns `true` if the
        // operation overflowed.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">conditionalSubWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, on: <span class="tok-type">bool</span>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
            <span class="tok-kw">var</span> borrow: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (x.limbs(), y.limbsConst()) |*x_limb, y_limb| {
                <span class="tok-kw">const</span> res = x_limb.* -% y_limb -% borrow;
                x_limb.* = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">select</a>(on, <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(res)), x_limb.*);
                borrow = <span class="tok-builtin">@truncate</span>(res &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
            }
            <span class="tok-kw">return</span> borrow;
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.ff.Modulus" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">Modulus</span><a href="#src.zig-std.crypto.ff.Modulus">[src]</a></h2><div class="tldDocs"><p>A modulus, defining a finite field.
All operations within the field are performed modulo this modulus, without heap allocations.
<code>max_bits</code> represents the number of bits in the maximum value the modulus can be set to.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>max_bits: <span class="tok-type">comptime_int</span></code></pre></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.crypto.ff.Modulus.Fe" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Fe</span><a href="#src.zig-std.crypto.ff.Modulus.Fe">[src]</a></h3><div class="tldDocs"><p>A field element, representing a value within the field defined by this modulus.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.Fe">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fe = <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Fe_</a>(max_bits)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>zero: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre><div class="fieldDocs"><p>The neutral element.</p>
</div></div><div><pre><code>v: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a></code></pre><div class="fieldDocs"><p>The modulus value.</p>
</div></div><div><pre><code>rr: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre><div class="fieldDocs"><p>R^2 for the Montgomery representation.</p>
</div></div><div><pre><code>m0inv: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a></code></pre><div class="fieldDocs"><p>Inverse of the first limb</p>
</div></div><div><pre><code>leading: <span class="tok-type">usize</span></code></pre><div class="fieldDocs"><p>Number of leading zero bits in the modulus.</p>
</div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.crypto.ff.Modulus.bits" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bits</span><a href="#src.zig-std.crypto.ff.Modulus.bits">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bits</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Actual size of the modulus, in bits.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.bits">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bits</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.limbs_count() * <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a> - self.leading;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.one" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">one</span><a href="#src.zig-std.crypto.ff.Modulus.one">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">one</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Returns the element <code>1</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.one">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">one</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">var</span> fe = self.zero;
    fe.v.limbs()[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> fe;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.fromUint" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromUint</span><a href="#src.zig-std.crypto.ff.Modulus.fromUint">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromUint</span>(v_: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>) <a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div class="tldDocs"><p>Creates a new modulus from a <code>Uint</code> value.
The modulus must be odd and larger than 2.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>v_: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.fromUint">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromUint</span>(v_: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>) <a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
    <span class="tok-kw">if</span> (!v_.isOdd()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EvenModulus;

    <span class="tok-kw">var</span> v = v_.normalize();
    <span class="tok-kw">const</span> hi = v.limbsConst()[v.limbs_len - <span class="tok-number">1</span>];
    <span class="tok-kw">const</span> lo = v.limbsConst()[<span class="tok-number">0</span>];

    <span class="tok-kw">if</span> (v.limbs_len &lt; <span class="tok-number">2</span> <span class="tok-kw">and</span> lo &lt; <span class="tok-number">3</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ModulusTooSmall;
    }

    <span class="tok-kw">const</span> leading = <span class="tok-builtin">@clz</span>(hi) - <a href="std.crypto.ff.html#std.crypto.ff.carry_bits">carry_bits</a>;

    <span class="tok-kw">var</span> y = lo;

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-kw">comptime</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int">log2_int</a>(<span class="tok-type">usize</span>, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>)) |_| {
        y = y *% (<span class="tok-number">2</span> -% lo *% y);
    }
    <span class="tok-kw">const</span> m0inv = (<span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) - (<span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(y)));

    <span class="tok-kw">const</span> zero = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{ .v = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">zero</a> };

    <span class="tok-kw">var</span> m = <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>{
        .zero = zero,
        .v = v,
        .leading = leading,
        .m0inv = m0inv,
        .rr = <span class="tok-null">undefined</span>,<span class="tok-comment"> // will be computed right after
    </span>};
    m.shrink(&amp;m.zero) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <a href="std.crypto.ff.html#std.crypto.ff.Modulus.computeRR">computeRR</a>(&amp;m);

    <span class="tok-kw">return</span> m;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.fromPrimitive" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromPrimitive</span><a href="#src.zig-std.crypto.ff.Modulus.fromPrimitive">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) (<a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div class="tldDocs"><p>Creates a new modulus from a primitive value.
The modulus must be odd and larger than 2.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>T: <span class="tok-type">type</span></code></pre></div><div><pre><code>x: T</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.fromPrimitive">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) (<a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@bitSizeOf</span>(T) &lt;= max_bits);<span class="tok-comment"> // Primitive type is larger than the modulus type.
    </span><span class="tok-kw">const</span> v = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">fromPrimitive</a>(T, x);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Modulus.fromUint">fromUint</a>(v);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.fromBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromBytes</span><a href="#src.zig-std.crypto.ff.Modulus.fromBytes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div class="tldDocs"><p>Creates a new modulus from a byte string.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.fromBytes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
    <span class="tok-kw">const</span> v = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">fromBytes</a>(bytes, endian);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Modulus.fromUint">fromUint</a>(v);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.toBytes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toBytes</span><a href="#src.zig-std.crypto.ff.Modulus.toBytes">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Serializes the modulus to a byte string.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>bytes: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.toBytes">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.v.toBytes(bytes, endian);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.rejectNonCanonical" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">rejectNonCanonical</span><a href="#src.zig-std.crypto.ff.Modulus.rejectNonCanonical">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rejectNonCanonical</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, fe: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <span class="tok-kw">error</span>{NonCanonical}!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Rejects field elements that are not in the canonical form.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>fe: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.rejectNonCanonical">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rejectNonCanonical</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, fe: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <span class="tok-kw">error</span>{NonCanonical}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (fe.limbs_count() != self.limbs_count() <span class="tok-kw">or</span> <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpGeq</a>(fe.v, self.v)) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonCanonical;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.crypto.ff.Modulus.add">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Adds two field elements (mod m).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div><pre><code>y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.add">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">var</span> out = x;
    <span class="tok-kw">const</span> overflow = out.v.addWithOverflow(y.v);
    <span class="tok-kw">const</span> underflow: <span class="tok-type">u1</span> = <span class="tok-builtin">@bitCast</span>(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpLt</a>(out.v, self.v));
    <span class="tok-kw">const</span> need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(overflow, underflow);
    _ = out.v.conditionalSubWithOverflow(need_sub, self.v);
    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.sub" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sub</span><a href="#src.zig-std.crypto.ff.Modulus.sub">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Subtracts two field elements (mod m).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div><pre><code>y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.sub">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">var</span> out = x;
    <span class="tok-kw">const</span> underflow: <span class="tok-type">bool</span> = <span class="tok-builtin">@bitCast</span>(out.v.subWithOverflow(y.v));
    _ = out.v.conditionalAddWithOverflow(underflow, self.v);
    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.toMontgomery" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toMontgomery</span><a href="#src.zig-std.crypto.ff.Modulus.toMontgomery">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMontgomery</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Converts a field element to the Montgomery form.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.toMontgomery">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMontgomery</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x.montgomery) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedRepresentation;
    }
    self.shrink(x) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    x.* = self.montgomeryMul(x.*, self.rr);
    x.montgomery = <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.fromMontgomery" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromMontgomery</span><a href="#src.zig-std.crypto.ff.Modulus.fromMontgomery">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromMontgomery</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Takes a field element out of the Montgomery form.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.fromMontgomery">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromMontgomery</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!x.montgomery) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedRepresentation;
    }
    self.shrink(x) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    x.* = self.montgomeryMul(x.*, self.one());
    x.montgomery = <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.reduce" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reduce</span><a href="#src.zig-std.crypto.ff.Modulus.reduce">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reduce</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <span class="tok-kw">anytype</span>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Reduces an arbitrary <code>Uint</code>, converting it to a field element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.reduce">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reduce</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <span class="tok-kw">anytype</span>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">var</span> out = self.zero;
    <span class="tok-kw">var</span> i = x.limbs_len - <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (self.limbs_count() &gt;= <span class="tok-number">2</span>) {
        <span class="tok-kw">const</span> start = <span class="tok-builtin">@min</span>(i, self.limbs_count() - <span class="tok-number">2</span>);
        <span class="tok-kw">var</span> j = start;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (j -= <span class="tok-number">1</span>) {
            out.v.limbs()[j] = x.limbsConst()[i];
            i -= <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (j == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        }
    }
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
        self.shiftIn(&amp;out, x.limbsConst()[i]);
        <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
    }
    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.mul" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mul</span><a href="#src.zig-std.crypto.ff.Modulus.mul">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Multiplies two field elements.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div><pre><code>y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.mul">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">if</span> (x.montgomery != y.montgomery) {
        <span class="tok-kw">return</span> self.montgomeryMul(x, y);
    }
    <span class="tok-kw">var</span> a_ = x;
    <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">false</span>) {
        self.toMontgomery(&amp;a_) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        self.fromMontgomery(&amp;a_) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }
    <span class="tok-kw">return</span> self.montgomeryMul(a_, y);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.sq" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sq</span><a href="#src.zig-std.crypto.ff.Modulus.sq">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Squares a field element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.sq">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">var</span> out = x;
    <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">true</span>) {
        self.fromMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }
    out = self.montgomerySq(out);
    out.montgomery = <span class="tok-null">false</span>;
    self.toMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> out;
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.pow" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pow</span><a href="#src.zig-std.crypto.ff.Modulus.pow">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Returns x^e (mod m) in constant time.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div><pre><code>e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.pow">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">var</span> buf: [<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>.<a href="#">encoded_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    e.toBytes(&amp;buf, <a href="std.crypto.ff.html#std.crypto.ff.native_endian">native_endian</a>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> self.powWithEncodedExponent(x, &amp;buf, <a href="std.crypto.ff.html#std.crypto.ff.native_endian">native_endian</a>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.powPublic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">powPublic</span><a href="#src.zig-std.crypto.ff.Modulus.powPublic">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powPublic</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Returns x^e (mod m), assuming that the exponent is public.
The function remains constant time with respect to <code>x</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div><pre><code>e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.powPublic">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powPublic</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">var</span> e_normalized = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{ .v = e.v.normalize() };
    <span class="tok-kw">var</span> buf_: [<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>.<a href="#">encoded_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> buf = buf_[<span class="tok-number">0</span> .. <a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, e_normalized.v.limbs_len * <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>];
    e_normalized.toBytes(buf, .little) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">const</span> leading = <span class="tok-builtin">@clz</span>(e_normalized.v.limbsConst()[e_normalized.v.limbs_len - <a href="std.crypto.ff.html#std.crypto.ff.carry_bits">carry_bits</a>]);
    buf = buf[<span class="tok-number">0</span> .. buf.len - leading / <span class="tok-number">8</span>];
    <span class="tok-kw">return</span> self.powWithEncodedPublicExponent(x, buf, .little);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.powWithEncodedExponent" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">powWithEncodedExponent</span><a href="#src.zig-std.crypto.ff.Modulus.powWithEncodedExponent">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedExponent</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Returns x^e (mod m), with the exponent provided as a byte string.
Exponents are usually small, so this function is faster than <code>powPublic</code> as a field element
doesn't have to be created if a serialized representation is already available.</p>
<p>If the exponent is public, <code>powWithEncodedPublicExponent()</code> can be used instead for a slight speedup.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div><pre><code>e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.powWithEncodedExponent">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedExponent</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">return</span> self.powWithEncodedExponentInternal(x, e, endian, <span class="tok-null">false</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.crypto.ff.Modulus.powWithEncodedPublicExponent" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">powWithEncodedPublicExponent</span><a href="#src.zig-std.crypto.ff.Modulus.powWithEncodedPublicExponent">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedPublicExponent</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div class="tldDocs"><p>Returns x^e (mod m), the exponent being public and provided as a byte string.
Exponents are usually small, so this function is faster than <code>powPublic</code> as a field element
doesn't have to be created if a serialized representation is already available.</p>
<p>If the exponent is secret, <code>powWithEncodedExponent</code> must be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a></code></pre></div><div><pre><code>x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a></code></pre></div><div><pre><code>e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>endian: <a href="std.builtin.Endian.html">Endian</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus.powWithEncodedPublicExponent">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedPublicExponent</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
    <span class="tok-kw">return</span> self.powWithEncodedExponentInternal(x, e, endian, <span class="tok-null">true</span>);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.ff.Modulus">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Modulus</span>(<span class="tok-kw">comptime</span> max_bits: <span class="tok-type">comptime_int</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// A field element, representing a value within the field defined by this modulus.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fe = <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Fe_</a>(max_bits);

        <span class="tok-kw">const</span> FeUint = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>.<a href="#">FeUint</a>;

        <span class="tok-comment">/// The neutral element.</span>
        zero: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>,

        <span class="tok-comment">/// The modulus value.</span>
        v: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>,

        <span class="tok-comment">/// R^2 for the Montgomery representation.</span>
        rr: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>,
        <span class="tok-comment">/// Inverse of the first limb</span>
        m0inv: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
        <span class="tok-comment">/// Number of leading zero bits in the modulus.</span>
        leading: <span class="tok-type">usize</span>,<span class="tok-comment">

        // Number of active limbs in the modulus.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">limbs_count</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.v.limbs_len;
        }

        <span class="tok-comment">/// Actual size of the modulus, in bits.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bits</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.limbs_count() * <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a> - self.leading;
        }

        <span class="tok-comment">/// Returns the element `1`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">one</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> fe = self.zero;
            fe.v.limbs()[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> fe;
        }

        <span class="tok-comment">/// Creates a new modulus from a `Uint` value.</span>
        <span class="tok-comment">/// The modulus must be odd and larger than 2.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromUint</span>(v_: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>) <a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
            <span class="tok-kw">if</span> (!v_.isOdd()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EvenModulus;

            <span class="tok-kw">var</span> v = v_.normalize();
            <span class="tok-kw">const</span> hi = v.limbsConst()[v.limbs_len - <span class="tok-number">1</span>];
            <span class="tok-kw">const</span> lo = v.limbsConst()[<span class="tok-number">0</span>];

            <span class="tok-kw">if</span> (v.limbs_len &lt; <span class="tok-number">2</span> <span class="tok-kw">and</span> lo &lt; <span class="tok-number">3</span>) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ModulusTooSmall;
            }

            <span class="tok-kw">const</span> leading = <span class="tok-builtin">@clz</span>(hi) - <a href="std.crypto.ff.html#std.crypto.ff.carry_bits">carry_bits</a>;

            <span class="tok-kw">var</span> y = lo;

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-kw">comptime</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int">log2_int</a>(<span class="tok-type">usize</span>, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>)) |_| {
                y = y *% (<span class="tok-number">2</span> -% lo *% y);
            }
            <span class="tok-kw">const</span> m0inv = (<span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) - (<span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(y)));

            <span class="tok-kw">const</span> zero = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{ .v = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">zero</a> };

            <span class="tok-kw">var</span> m = <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>{
                .zero = zero,
                .v = v,
                .leading = leading,
                .m0inv = m0inv,
                .rr = <span class="tok-null">undefined</span>,<span class="tok-comment"> // will be computed right after
            </span>};
            m.shrink(&amp;m.zero) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <a href="std.crypto.ff.html#std.crypto.ff.Modulus.computeRR">computeRR</a>(&amp;m);

            <span class="tok-kw">return</span> m;
        }

        <span class="tok-comment">/// Creates a new modulus from a primitive value.</span>
        <span class="tok-comment">/// The modulus must be odd and larger than 2.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) (<a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@bitSizeOf</span>(T) &lt;= max_bits);<span class="tok-comment"> // Primitive type is larger than the modulus type.
            </span><span class="tok-kw">const</span> v = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">fromPrimitive</a>(T, x);
            <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Modulus.fromUint">fromUint</a>(v);
        }

        <span class="tok-comment">/// Creates a new modulus from a byte string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
            <span class="tok-kw">const</span> v = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">fromBytes</a>(bytes, endian);
            <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Modulus.fromUint">fromUint</a>(v);
        }

        <span class="tok-comment">/// Serializes the modulus to a byte string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.v.toBytes(bytes, endian);
        }

        <span class="tok-comment">/// Rejects field elements that are not in the canonical form.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rejectNonCanonical</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, fe: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <span class="tok-kw">error</span>{NonCanonical}!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (fe.limbs_count() != self.limbs_count() <span class="tok-kw">or</span> <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpGeq</a>(fe.v, self.v)) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonCanonical;
            }
        }<span class="tok-comment">

        // Makes the number of active limbs in a field element match the one of the modulus.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">shrink</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, fe: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_len = self.limbs_count();
            <span class="tok-kw">if</span> (fe.limbs_count() &lt; new_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            <span class="tok-kw">var</span> acc: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (fe.v.limbsConst()[new_len..]) |limb| {
                acc |= limb;
            }
            <span class="tok-kw">if</span> (acc != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            <span class="tok-kw">if</span> (new_len &gt; fe.v.limbs_buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            fe.v.limbs_len = new_len;
        }<span class="tok-comment">

        // Computes R^2 for the Montgomery representation.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">computeRR</span>(self: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <span class="tok-type">void</span> {
            self.rr = self.zero;
            <span class="tok-kw">const</span> n = self.rr.limbs_count();
            self.rr.v.limbs()[n - <span class="tok-number">1</span>] = <span class="tok-number">1</span>;
            <span class="tok-kw">for</span> ((n - <span class="tok-number">1</span>)..(<span class="tok-number">2</span> * n)) |_| {
                self.shiftIn(&amp;self.rr, <span class="tok-number">0</span>);
            }
            self.shrink(&amp;self.rr) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-comment">/// Computes x &lt;&lt; t_bits + y (mod m)</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">shiftIn</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> d = self.zero;
            <span class="tok-kw">const</span> x_limbs = x.v.limbs();
            <span class="tok-kw">const</span> d_limbs = d.v.limbs();
            <span class="tok-kw">const</span> m_limbs = self.v.limbsConst();

            <span class="tok-kw">var</span> need_sub = <span class="tok-null">false</span>;
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a> - <span class="tok-number">1</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
                <span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-builtin">@truncate</span>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, y, i));
                <span class="tok-kw">var</span> borrow: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.limbs_count()) |j| {
                    <span class="tok-kw">const</span> l = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">select</a>(need_sub, d_limbs[j], x_limbs[j]);
                    <span class="tok-kw">var</span> res = (l &lt;&lt; <span class="tok-number">1</span>) + carry;
                    x_limbs[j] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(res));
                    carry = <span class="tok-builtin">@truncate</span>(res &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);

                    res = x_limbs[j] -% m_limbs[j] -% borrow;
                    d_limbs[j] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(res));

                    borrow = <span class="tok-builtin">@truncate</span>(res &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
                }
                need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(carry, borrow);
                <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            }
            x.v.cmov(need_sub, d.v);
        }

        <span class="tok-comment">/// Adds two field elements (mod m).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> out = x;
            <span class="tok-kw">const</span> overflow = out.v.addWithOverflow(y.v);
            <span class="tok-kw">const</span> underflow: <span class="tok-type">u1</span> = <span class="tok-builtin">@bitCast</span>(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpLt</a>(out.v, self.v));
            <span class="tok-kw">const</span> need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(overflow, underflow);
            _ = out.v.conditionalSubWithOverflow(need_sub, self.v);
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Subtracts two field elements (mod m).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> out = x;
            <span class="tok-kw">const</span> underflow: <span class="tok-type">bool</span> = <span class="tok-builtin">@bitCast</span>(out.v.subWithOverflow(y.v));
            _ = out.v.conditionalAddWithOverflow(underflow, self.v);
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Converts a field element to the Montgomery form.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMontgomery</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (x.montgomery) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedRepresentation;
            }
            self.shrink(x) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            x.* = self.montgomeryMul(x.*, self.rr);
            x.montgomery = <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Takes a field element out of the Montgomery form.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromMontgomery</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!x.montgomery) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedRepresentation;
            }
            self.shrink(x) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            x.* = self.montgomeryMul(x.*, self.one());
            x.montgomery = <span class="tok-null">false</span>;
        }

        <span class="tok-comment">/// Reduces an arbitrary `Uint`, converting it to a field element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reduce</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <span class="tok-kw">anytype</span>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> out = self.zero;
            <span class="tok-kw">var</span> i = x.limbs_len - <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (self.limbs_count() &gt;= <span class="tok-number">2</span>) {
                <span class="tok-kw">const</span> start = <span class="tok-builtin">@min</span>(i, self.limbs_count() - <span class="tok-number">2</span>);
                <span class="tok-kw">var</span> j = start;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (j -= <span class="tok-number">1</span>) {
                    out.v.limbs()[j] = x.limbsConst()[i];
                    i -= <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (j == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                }
            }
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
                self.shiftIn(&amp;out, x.limbsConst()[i]);
                <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            }
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">montgomeryLoop</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, d: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <span class="tok-type">u1</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(d.limbs_count() == x.limbs_count());
            <a href="std.debug.html#std.debug.assert">assert</a>(d.limbs_count() == y.limbs_count());
            <a href="std.debug.html#std.debug.assert">assert</a>(d.limbs_count() == self.limbs_count());

            <span class="tok-kw">const</span> a_limbs = x.v.limbsConst();
            <span class="tok-kw">const</span> b_limbs = y.v.limbsConst();
            <span class="tok-kw">const</span> d_limbs = d.v.limbs();
            <span class="tok-kw">const</span> m_limbs = self.v.limbsConst();

            <span class="tok-kw">var</span> overflow: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.limbs_count()) |i| {
                <span class="tok-kw">var</span> carry: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">0</span>;

                <span class="tok-kw">var</span> wide = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">mulWide</a>(a_limbs[i], b_limbs[<span class="tok-number">0</span>]);
                <span class="tok-kw">var</span> z_lo = <span class="tok-builtin">@addWithOverflow</span>(d_limbs[<span class="tok-number">0</span>], wide.lo);
                <span class="tok-kw">const</span> f = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(z_lo[<span class="tok-number">0</span>] *% self.m0inv));
                <span class="tok-kw">var</span> z_hi = wide.hi +% z_lo[<span class="tok-number">1</span>];
                wide = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">mulWide</a>(f, m_limbs[<span class="tok-number">0</span>]);
                z_lo = <span class="tok-builtin">@addWithOverflow</span>(z_lo[<span class="tok-number">0</span>], wide.lo);
                z_hi +%= z_lo[<span class="tok-number">1</span>];
                z_hi +%= wide.hi;
                carry = (z_hi &lt;&lt; <span class="tok-number">1</span>) | (z_lo[<span class="tok-number">0</span>] &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);

                <span class="tok-kw">for</span> (<span class="tok-number">1</span>..self.limbs_count()) |j| {
                    wide = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">mulWide</a>(a_limbs[i], b_limbs[j]);
                    z_lo = <span class="tok-builtin">@addWithOverflow</span>(d_limbs[j], wide.lo);
                    z_hi = wide.hi +% z_lo[<span class="tok-number">1</span>];
                    wide = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">mulWide</a>(f, m_limbs[j]);
                    z_lo = <span class="tok-builtin">@addWithOverflow</span>(z_lo[<span class="tok-number">0</span>], wide.lo);
                    z_hi +%= z_lo[<span class="tok-number">1</span>];
                    z_hi +%= wide.hi;
                    z_lo = <span class="tok-builtin">@addWithOverflow</span>(z_lo[<span class="tok-number">0</span>], carry);
                    z_hi +%= z_lo[<span class="tok-number">1</span>];
                    <span class="tok-kw">if</span> (j &gt; <span class="tok-number">0</span>) {
                        d_limbs[j - <span class="tok-number">1</span>] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(z_lo[<span class="tok-number">0</span>]));
                    }
                    carry = (z_hi &lt;&lt; <span class="tok-number">1</span>) | (z_lo[<span class="tok-number">0</span>] &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
                }
                <span class="tok-kw">const</span> z = overflow + carry;
                d_limbs[self.limbs_count() - <span class="tok-number">1</span>] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(z));
                overflow = <span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-builtin">@truncate</span>(z &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>));
            }
            <span class="tok-kw">return</span> overflow;
        }<span class="tok-comment">

        // Montgomery multiplication.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">montgomeryMul</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> d = self.zero;
            <a href="std.debug.html#std.debug.assert">assert</a>(x.limbs_count() == self.limbs_count());
            <a href="std.debug.html#std.debug.assert">assert</a>(y.limbs_count() == self.limbs_count());
            <span class="tok-kw">const</span> overflow = self.montgomeryLoop(&amp;d, x, y);
            <span class="tok-kw">const</span> underflow = <span class="tok-number">1</span> -% <span class="tok-builtin">@intFromBool</span>(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpGeq</a>(d.v, self.v));
            <span class="tok-kw">const</span> need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(overflow, underflow);
            _ = d.v.conditionalSubWithOverflow(need_sub, self.v);
            d.montgomery = x.montgomery == y.montgomery;
            <span class="tok-kw">return</span> d;
        }<span class="tok-comment">

        // Montgomery squaring.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">montgomerySq</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> d = self.zero;
            <a href="std.debug.html#std.debug.assert">assert</a>(x.limbs_count() == self.limbs_count());
            <span class="tok-kw">const</span> overflow = self.montgomeryLoop(&amp;d, x, x);
            <span class="tok-kw">const</span> underflow = <span class="tok-number">1</span> -% <span class="tok-builtin">@intFromBool</span>(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpGeq</a>(d.v, self.v));
            <span class="tok-kw">const</span> need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(overflow, underflow);
            _ = d.v.conditionalSubWithOverflow(need_sub, self.v);
            d.montgomery = <span class="tok-null">true</span>;
            <span class="tok-kw">return</span> d;
        }<span class="tok-comment">

        // Returns x^e (mod m), with the exponent provided as a byte string.
        // `public` must be set to `false` if the exponent it secret.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedExponentInternal</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>, <span class="tok-kw">comptime</span> public: <span class="tok-type">bool</span>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> acc: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (e) |b| acc |= b;
            <span class="tok-kw">if</span> (acc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NullExponent;

            <span class="tok-kw">var</span> out = self.one();
            self.toMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

            <span class="tok-kw">if</span> (public <span class="tok-kw">and</span> e.len &lt; <span class="tok-number">3</span> <span class="tok-kw">or</span> (e.len == <span class="tok-number">3</span> <span class="tok-kw">and</span> e[<span class="tok-kw">if</span> (endian == .big) <span class="tok-number">0</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>] &lt;= <span class="tok-number">0b1111</span>)) {<span class="tok-comment">
                // Do not use a precomputation table for short, public exponents
                </span><span class="tok-kw">var</span> x_m = x;
                <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">false</span>) {
                    self.toMontgomery(&amp;x_m) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                }
                <span class="tok-kw">var</span> s = <span class="tok-kw">switch</span> (endian) {
                    .big =&gt; <span class="tok-number">0</span>,
                    .little =&gt; e.len - <span class="tok-number">1</span>,
                };
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> b = e[s];
                    <span class="tok-kw">var</span> j: <span class="tok-type">u3</span> = <span class="tok-number">7</span>;
                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (j -= <span class="tok-number">1</span>) {
                        out = self.montgomerySq(out);
                        <span class="tok-kw">const</span> k: <span class="tok-type">u1</span> = <span class="tok-builtin">@truncate</span>(b &gt;&gt; j);
                        <span class="tok-kw">if</span> (k != <span class="tok-number">0</span>) {
                            <span class="tok-kw">const</span> t = self.montgomeryMul(out, x_m);
                            <span class="tok-builtin">@memcpy</span>(out.v.limbs(), t.v.limbsConst());
                        }
                        <span class="tok-kw">if</span> (j == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                    }
                    <span class="tok-kw">switch</span> (endian) {
                        .big =&gt; {
                            s += <span class="tok-number">1</span>;
                            <span class="tok-kw">if</span> (s == e.len) <span class="tok-kw">break</span>;
                        },
                        .little =&gt; {
                            <span class="tok-kw">if</span> (s == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                            s -= <span class="tok-number">1</span>;
                        },
                    }
                }
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Use a precomputation table for large exponents
                </span><span class="tok-kw">var</span> pc = [<span class="tok-number">1</span>]<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{x} ++ [_]<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{self.zero} ** <span class="tok-number">14</span>;
                <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">false</span>) {
                    self.toMontgomery(&amp;pc[<span class="tok-number">0</span>]) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                }
                <span class="tok-kw">for</span> (<span class="tok-number">1</span>..pc.len) |i| {
                    pc[i] = self.montgomeryMul(pc[i - <span class="tok-number">1</span>], pc[<span class="tok-number">0</span>]);
                }
                <span class="tok-kw">var</span> t0 = self.zero;
                <span class="tok-kw">var</span> s = <span class="tok-kw">switch</span> (endian) {
                    .big =&gt; <span class="tok-number">0</span>,
                    .little =&gt; e.len - <span class="tok-number">1</span>,
                };
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> b = e[s];
                    <span class="tok-kw">for</span> ([_]<span class="tok-type">u3</span>{ <span class="tok-number">4</span>, <span class="tok-number">0</span> }) |j| {
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">4</span>) |_| {
                            out = self.montgomerySq(out);
                        }
                        <span class="tok-kw">const</span> k = (b &gt;&gt; j) &amp; <span class="tok-number">0b1111</span>;
                        <span class="tok-kw">if</span> (public <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">side_channels_mitigations</a> == .none) {
                            <span class="tok-kw">if</span> (k == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                            t0 = pc[k - <span class="tok-number">1</span>];
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">for</span> (pc, <span class="tok-number">0</span>..) |t, i| {
                                t0.v.cmov(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(k, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(i + <span class="tok-number">1</span>))), t.v);
                            }
                        }
                        <span class="tok-kw">const</span> t1 = self.montgomeryMul(out, t0);
                        <span class="tok-kw">if</span> (public) {
                            <span class="tok-builtin">@memcpy</span>(out.v.limbs(), t1.v.limbsConst());
                        } <span class="tok-kw">else</span> {
                            out.v.cmov(!<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(k, <span class="tok-number">0</span>), t1.v);
                        }
                    }
                    <span class="tok-kw">switch</span> (endian) {
                        .big =&gt; {
                            s += <span class="tok-number">1</span>;
                            <span class="tok-kw">if</span> (s == e.len) <span class="tok-kw">break</span>;
                        },
                        .little =&gt; {
                            <span class="tok-kw">if</span> (s == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                            s -= <span class="tok-number">1</span>;
                        },
                    }
                }
            }
            self.fromMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Multiplies two field elements.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">if</span> (x.montgomery != y.montgomery) {
                <span class="tok-kw">return</span> self.montgomeryMul(x, y);
            }
            <span class="tok-kw">var</span> a_ = x;
            <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">false</span>) {
                self.toMontgomery(&amp;a_) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            } <span class="tok-kw">else</span> {
                self.fromMontgomery(&amp;a_) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            }
            <span class="tok-kw">return</span> self.montgomeryMul(a_, y);
        }

        <span class="tok-comment">/// Squares a field element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> out = x;
            <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">true</span>) {
                self.fromMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            }
            out = self.montgomerySq(out);
            out.montgomery = <span class="tok-null">false</span>;
            self.toMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Returns x^e (mod m) in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> buf: [<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>.<a href="#">encoded_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            e.toBytes(&amp;buf, <a href="std.crypto.ff.html#std.crypto.ff.native_endian">native_endian</a>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> self.powWithEncodedExponent(x, &amp;buf, <a href="std.crypto.ff.html#std.crypto.ff.native_endian">native_endian</a>);
        }

        <span class="tok-comment">/// Returns x^e (mod m), assuming that the exponent is public.</span>
        <span class="tok-comment">/// The function remains constant time with respect to `x`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powPublic</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> e_normalized = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{ .v = e.v.normalize() };
            <span class="tok-kw">var</span> buf_: [<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>.<a href="#">encoded_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> buf = buf_[<span class="tok-number">0</span> .. <a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, e_normalized.v.limbs_len * <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>];
            e_normalized.toBytes(buf, .little) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">const</span> leading = <span class="tok-builtin">@clz</span>(e_normalized.v.limbsConst()[e_normalized.v.limbs_len - <a href="std.crypto.ff.html#std.crypto.ff.carry_bits">carry_bits</a>]);
            buf = buf[<span class="tok-number">0</span> .. buf.len - leading / <span class="tok-number">8</span>];
            <span class="tok-kw">return</span> self.powWithEncodedPublicExponent(x, buf, .little);
        }

        <span class="tok-comment">/// Returns x^e (mod m), with the exponent provided as a byte string.</span>
        <span class="tok-comment">/// Exponents are usually small, so this function is faster than `powPublic` as a field element</span>
        <span class="tok-comment">/// doesn't have to be created if a serialized representation is already available.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// If the exponent is public, `powWithEncodedPublicExponent()` can be used instead for a slight speedup.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedExponent</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">return</span> self.powWithEncodedExponentInternal(x, e, endian, <span class="tok-null">false</span>);
        }

        <span class="tok-comment">/// Returns x^e (mod m), the exponent being public and provided as a byte string.</span>
        <span class="tok-comment">/// Exponents are usually small, so this function is faster than `powPublic` as a field element</span>
        <span class="tok-comment">/// doesn't have to be created if a serialized representation is already available.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// If the exponent is secret, `powWithEncodedExponent` must be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedPublicExponent</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">return</span> self.powWithEncodedExponentInternal(x, e, endian, <span class="tok-null">true</span>);
        }
    };
}</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.crypto.ff.OverflowError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">OverflowError</span><a href="#src.zig-std.crypto.ff.OverflowError">[src]</a></h2><div class="tldDocs"><p>Value is too large for the destination.</p>
</div><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>Overflow</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.ff.OverflowError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OverflowError = <span class="tok-kw">error</span>{Overflow}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.ff.InvalidModulusError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">InvalidModulusError</span><a href="#src.zig-std.crypto.ff.InvalidModulusError">[src]</a></h2><div class="tldDocs"><p>Invalid modulus. Modulus must be odd.</p>
</div><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>EvenModulus</dt></div><div><dt>ModulusTooSmall</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.ff.InvalidModulusError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> InvalidModulusError = <span class="tok-kw">error</span>{ EvenModulus, ModulusTooSmall }</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.ff.NullExponentError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">NullExponentError</span><a href="#src.zig-std.crypto.ff.NullExponentError">[src]</a></h2><div class="tldDocs"><p>Exponentiation with a null exponent.
Exponentiation in cryptographic protocols is almost always a sign of a bug which can lead to trivial attacks.
Therefore, this module returns an error when a null exponent is encountered, encouraging applications to handle this case explicitly.</p>
</div><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NullExponent</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.ff.NullExponentError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> NullExponentError = <span class="tok-kw">error</span>{NullExponent}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.ff.FieldElementError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FieldElementError</span><a href="#src.zig-std.crypto.ff.FieldElementError">[src]</a></h2><div class="tldDocs"><p>Invalid field element for the given modulus.</p>
</div><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>NonCanonical</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.ff.FieldElementError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldElementError = <span class="tok-kw">error</span>{NonCanonical}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.ff.RepresentationError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">RepresentationError</span><a href="#src.zig-std.crypto.ff.RepresentationError">[src]</a></h2><div class="tldDocs"><p>Invalid representation (Montgomery vs non-Montgomery domain.)</p>
</div><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>UnexpectedRepresentation</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.ff.RepresentationError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RepresentationError = <span class="tok-kw">error</span>{UnexpectedRepresentation}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.ff.Error" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">Error</span><a href="#src.zig-std.crypto.ff.Error">[src]</a></h2><div class="tldDocs"><p>The set of all possible errors <code><a href="std.crypto.ff.html">std.crypto.ff</a></code> functions can return.</p>
</div><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>EvenModulus <a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a></dt></div><div><dt>ModulusTooSmall <a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a></dt></div><div><dt>NonCanonical <a href="std.crypto.ff.html#std.crypto.ff.FieldElementError">FieldElementError</a></dt></div><div><dt>NullExponent <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a></dt></div><div><dt>Overflow <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a></dt></div><div><dt>UnexpectedRepresentation <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.ff.Error">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a> || <a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a> || <a href="std.crypto.ff.html#std.crypto.ff.FieldElementError">FieldElementError</a> || <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a></code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.crypto.ff">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! Allocation-free, (best-effort) constant-time, finite field arithmetic for large integers.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! Unlike `std.math.big`, these integers have a fixed maximum length and are only designed to be used for modular arithmetic.</span>
<span class="tok-comment">//! Arithmetic operations are meant to run in constant-time for a given modulus, making them suitable for cryptography.</span>
<span class="tok-comment">//!</span>
<span class="tok-comment">//! Parts of that code was ported from the BSD-licensed crypto/internal/bigmod/nat.go file in the Go language, itself inspired from BearSSL.</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> crypto = <a href="std.html">std</a>.<a href="std.crypto.html">crypto</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> meta = <a href="std.html">std</a>.<a href="std.meta.html">meta</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> Endian = <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Endian.html">Endian</a>;<span class="tok-comment">

// A Limb is a single digit in a big integer.
</span><span class="tok-kw">const</span> Limb = <span class="tok-type">usize</span>;<span class="tok-comment">

// The number of reserved bits in a Limb.
</span><span class="tok-kw">const</span> carry_bits = <span class="tok-number">1</span>;<span class="tok-comment">

// The number of active bits in a Limb.
</span><span class="tok-kw">const</span> t_bits: <span class="tok-type">usize</span> = <span class="tok-builtin">@bitSizeOf</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) - <a href="std.crypto.ff.html#std.crypto.ff.carry_bits">carry_bits</a>;<span class="tok-comment">

// A TLimb is a Limb that is truncated to t_bits.
</span><span class="tok-kw">const</span> TLimb = <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);

<span class="tok-kw">const</span> native_endian = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>.<a href="#">cpu</a>.<a href="#">arch</a>.<a href="#">endian</a>();<span class="tok-comment">

// A WideLimb is a Limb that is twice as wide as a normal Limb.
</span><span class="tok-kw">const</span> WideLimb = <span class="tok-kw">struct</span> {
    hi: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
    lo: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
};

<span class="tok-comment">/// Value is too large for the destination.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OverflowError = <span class="tok-kw">error</span>{Overflow};

<span class="tok-comment">/// Invalid modulus. Modulus must be odd.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> InvalidModulusError = <span class="tok-kw">error</span>{ EvenModulus, ModulusTooSmall };

<span class="tok-comment">/// Exponentiation with a null exponent.</span>
<span class="tok-comment">/// Exponentiation in cryptographic protocols is almost always a sign of a bug which can lead to trivial attacks.</span>
<span class="tok-comment">/// Therefore, this module returns an error when a null exponent is encountered, encouraging applications to handle this case explicitly.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> NullExponentError = <span class="tok-kw">error</span>{NullExponent};

<span class="tok-comment">/// Invalid field element for the given modulus.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FieldElementError = <span class="tok-kw">error</span>{NonCanonical};

<span class="tok-comment">/// Invalid representation (Montgomery vs non-Montgomery domain.)</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RepresentationError = <span class="tok-kw">error</span>{UnexpectedRepresentation};

<span class="tok-comment">/// The set of all possible errors `std.crypto.ff` functions can return.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a> || <a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a> || <a href="std.crypto.ff.html#std.crypto.ff.FieldElementError">FieldElementError</a> || <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>;

<span class="tok-comment">/// An unsigned big integer with a fixed maximum size (`max_bits`), suitable for cryptographic operations.</span>
<span class="tok-comment">/// Unless side-channels mitigations are explicitly disabled, operations are designed to be constant-time.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Uint</span>(<span class="tok-kw">comptime</span> max_bits: <span class="tok-type">comptime_int</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@bitSizeOf</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) % <span class="tok-number">8</span> == <span class="tok-number">0</span>);<span class="tok-comment"> // Limb size must be a multiple of 8

    </span><span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();
        <span class="tok-kw">const</span> max_limbs_count = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, max_bits, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

        limbs_buffer: [<a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
        <span class="tok-comment">/// The number of active limbs.</span>
        limbs_len: <span class="tok-type">usize</span>,

        <span class="tok-comment">/// Number of bytes required to serialize an integer.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> encoded_bytes = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, max_bits, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-comment">/// Constant slice of active limbs.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">limbsConst</span>(self: *<span class="tok-kw">const</span> <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) []<span class="tok-kw">const</span> <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> {
            <span class="tok-kw">return</span> self.limbs_buffer[<span class="tok-number">0</span>..self.limbs_len];
        }

        <span class="tok-comment">/// Mutable slice of active limbs.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">limbs</span>(self: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) []<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> {
            <span class="tok-kw">return</span> self.limbs_buffer[<span class="tok-number">0</span>..self.limbs_len];
        }<span class="tok-comment">

        // Removes limbs whose value is zero from the active limbs.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> {
            <span class="tok-kw">var</span> res = self;
            <span class="tok-kw">if</span> (self.limbs_len &lt; <span class="tok-number">2</span>) {
                <span class="tok-kw">return</span> res;
            }
            <span class="tok-kw">var</span> i = self.limbs_len - <span class="tok-number">1</span>;
            <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> res.limbsConst()[i] == <span class="tok-number">0</span>) : (i -= <span class="tok-number">1</span>) {}
            res.limbs_len = i + <span class="tok-number">1</span>;
            <a href="std.debug.html#std.debug.assert">assert</a>(res.limbs_len &lt;= res.limbs_buffer.len);
            <span class="tok-kw">return</span> res;
        }

        <span class="tok-comment">/// The zero integer.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> zero: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> = .{
            .limbs_buffer = [<span class="tok-number">1</span>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>{<span class="tok-number">0</span>} ** <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
            .limbs_len = <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
        };

        <span class="tok-comment">/// Creates a new big integer from a primitive type.</span>
        <span class="tok-comment">/// This function may not run in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, init_value: T) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> {
            <span class="tok-kw">var</span> x = init_value;
            <span class="tok-kw">var</span> out: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> = .{
                .limbs_buffer = <span class="tok-null">undefined</span>,
                .limbs_len = <a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>,
            };
            <span class="tok-kw">for</span> (&amp;out.limbs_buffer) |*limb| {
                limb.* = <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(x)) <span class="tok-kw">else</span> x;
                x = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(T, x, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
            }
            <span class="tok-kw">if</span> (x != <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            }
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Converts a big integer to a primitive type.</span>
        <span class="tok-comment">/// This function may not run in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toPrimitive</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!T {
            <span class="tok-kw">var</span> x: T = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> i = self.limbs_len - <span class="tok-number">1</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt;= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a> <span class="tok-kw">and</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(T, x, <span class="tok-builtin">@bitSizeOf</span>(T) - <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) != <span class="tok-number">0</span>) {
                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                }
                x = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(T, x, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
                <span class="tok-kw">const</span> v = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(T, self.limbsConst()[i]) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                x |= v;
                <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            }
            <span class="tok-kw">return</span> x;
        }

        <span class="tok-comment">/// Encodes a big integer into a byte array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) {
                <span class="tok-kw">if</span> (self.isZero()) <span class="tok-kw">return</span>;
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            }
            <span class="tok-builtin">@memset</span>(bytes, <span class="tok-number">0</span>);
            <span class="tok-kw">var</span> shift: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> out_i: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (endian) {
                .big =&gt; bytes.len - <span class="tok-number">1</span>,
                .little =&gt; <span class="tok-number">0</span>,
            };
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.limbs_len) |i| {
                <span class="tok-kw">var</span> remaining_bits = <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>;
                <span class="tok-kw">var</span> limb = self.limbsConst()[i];
                <span class="tok-kw">while</span> (remaining_bits &gt;= <span class="tok-number">8</span>) {
                    bytes[out_i] |= <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(limb)), shift);
                    <span class="tok-kw">const</span> consumed = <span class="tok-number">8</span> - shift;
                    limb &gt;&gt;= <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@truncate</span>(consumed));
                    remaining_bits -= consumed;
                    shift = <span class="tok-number">0</span>;
                    <span class="tok-kw">switch</span> (endian) {
                        .big =&gt; {
                            <span class="tok-kw">if</span> (out_i == <span class="tok-number">0</span>) {
                                <span class="tok-kw">if</span> (i != self.limbs_len - <span class="tok-number">1</span> <span class="tok-kw">or</span> limb != <span class="tok-number">0</span>) {
                                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                                }
                                <span class="tok-kw">return</span>;
                            }
                            out_i -= <span class="tok-number">1</span>;
                        },
                        .little =&gt; {
                            out_i += <span class="tok-number">1</span>;
                            <span class="tok-kw">if</span> (out_i == bytes.len) {
                                <span class="tok-kw">if</span> (i != self.limbs_len - <span class="tok-number">1</span> <span class="tok-kw">or</span> limb != <span class="tok-number">0</span>) {
                                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                                }
                                <span class="tok-kw">return</span>;
                            }
                        },
                    }
                }
                bytes[out_i] |= <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(limb));
                shift = remaining_bits;
            }
        }

        <span class="tok-comment">/// Creates a new big integer from a byte array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a> {
            <span class="tok-kw">if</span> (bytes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Uint.zero">zero</a>;
            <span class="tok-kw">var</span> shift: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> out = <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Uint.zero">zero</a>;
            <span class="tok-kw">var</span> out_i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-kw">switch</span> (endian) {
                .big =&gt; bytes.len - <span class="tok-number">1</span>,
                .little =&gt; <span class="tok-number">0</span>,
            };
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> bi = bytes[i];
                out.limbs()[out_i] |= <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, bi, shift);
                shift += <span class="tok-number">8</span>;
                <span class="tok-kw">if</span> (shift &gt;= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) {
                    shift -= <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>;
                    out.limbs()[out_i] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(out.limbs()[out_i]));
                    <span class="tok-kw">const</span> overflow = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, bi, <span class="tok-number">8</span> - shift);
                    out_i += <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (out_i &gt;= out.limbs_len) {
                        <span class="tok-kw">if</span> (overflow != <span class="tok-number">0</span> <span class="tok-kw">or</span> i != <span class="tok-number">0</span>) {
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
                        }
                        <span class="tok-kw">break</span>;
                    }
                    out.limbs()[out_i] = overflow;
                }
                <span class="tok-kw">switch</span> (endian) {
                    .big =&gt; {
                        <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                        i -= <span class="tok-number">1</span>;
                    },
                    .little =&gt; {
                        i += <span class="tok-number">1</span>;
                        <span class="tok-kw">if</span> (i == bytes.len) <span class="tok-kw">break</span>;
                    },
                }
            }
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Returns `true` if both integers are equal.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.eql">eql</a>([<a href="std.crypto.ff.html#std.crypto.ff.Uint.max_limbs_count">max_limbs_count</a>]<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, x.limbs_buffer, y.limbs_buffer);
        }

        <span class="tok-comment">/// Compares two integers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compare</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> <a href="std.crypto.html">crypto</a>.<a href="std.crypto.timing_safe.html">timing_safe</a>.<a href="std.crypto.timing_safe.html#std.crypto.timing_safe.compare">compare</a>(
                <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
                x.limbsConst(),
                y.limbsConst(),
                .little,
            );
        }

        <span class="tok-comment">/// Returns `true` if the integer is zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isZero</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">var</span> t: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (x.limbsConst()) |elem| {
                t |= elem;
            }
            <span class="tok-kw">return</span> <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(t, <span class="tok-number">0</span>);
        }

        <span class="tok-comment">/// Returns `true` if the integer is odd.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-builtin">@truncate</span>(x.limbsConst()[<span class="tok-number">0</span>])) != <span class="tok-number">0</span>;
        }

        <span class="tok-comment">/// Adds `y` to `x`, and returns `true` if the operation overflowed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
            <span class="tok-kw">return</span> x.conditionalAddWithOverflow(<span class="tok-null">true</span>, y);
        }

        <span class="tok-comment">/// Subtracts `y` from `x`, and returns `true` if the operation overflowed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">subWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
            <span class="tok-kw">return</span> x.conditionalSubWithOverflow(<span class="tok-null">true</span>, y);
        }<span class="tok-comment">

        // Replaces the limbs of `x` with the limbs of `y` if `on` is `true`.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">cmov</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, on: <span class="tok-type">bool</span>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (x.limbs(), y.limbsConst()) |*x_limb, y_limb| {
                x_limb.* = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">select</a>(on, y_limb, x_limb.*);
            }
        }<span class="tok-comment">

        // Adds `y` to `x` if `on` is `true`, and returns `true` if the
        // operation overflowed.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">conditionalAddWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, on: <span class="tok-type">bool</span>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
            <span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (x.limbs(), y.limbsConst()) |*x_limb, y_limb| {
                <span class="tok-kw">const</span> res = x_limb.* + y_limb + carry;
                x_limb.* = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">select</a>(on, <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(res)), x_limb.*);
                carry = <span class="tok-builtin">@truncate</span>(res &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
            }
            <span class="tok-kw">return</span> carry;
        }<span class="tok-comment">

        // Subtracts `y` from `x` if `on` is `true`, and returns `true` if the
        // operation overflowed.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">conditionalSubWithOverflow</span>(x: *<a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>, on: <span class="tok-type">bool</span>, y: <a href="std.crypto.ff.html#std.crypto.ff.Uint">Self</a>) <span class="tok-type">u1</span> {
            <span class="tok-kw">var</span> borrow: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (x.limbs(), y.limbsConst()) |*x_limb, y_limb| {
                <span class="tok-kw">const</span> res = x_limb.* -% y_limb -% borrow;
                x_limb.* = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">select</a>(on, <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(res)), x_limb.*);
                borrow = <span class="tok-builtin">@truncate</span>(res &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
            }
            <span class="tok-kw">return</span> borrow;
        }
    };
}

<span class="tok-comment">/// A field element.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">Fe_</span>(<span class="tok-kw">comptime</span> bits: <span class="tok-type">comptime_int</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">const</span> FeUint = <a href="std.crypto.ff.html#std.crypto.ff.Uint">Uint</a>(bits);

        <span class="tok-comment">/// The element value as a `Uint`.</span>
        v: <a href="std.crypto.ff.html#std.crypto.ff.Fe_.FeUint">FeUint</a>,

        <span class="tok-comment">/// `true` if the element is in Montgomery form.</span>
        montgomery: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

        <span class="tok-comment">/// The maximum number of bytes required to encode a field element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> encoded_bytes = <a href="std.crypto.ff.html#std.crypto.ff.Fe_.FeUint">FeUint</a>.<a href="#">encoded_bytes</a>;<span class="tok-comment">

        // The number of active limbs to represent the field element.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">limbs_count</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.v.limbs_len;
        }

        <span class="tok-comment">/// Creates a field element from a primitive.</span>
        <span class="tok-comment">/// This function may not run in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, m: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Modulus</a>(bits), x: T) (<a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a> || <a href="std.crypto.ff.html#std.crypto.ff.FieldElementError">FieldElementError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a> {
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@bitSizeOf</span>(T) &lt;= bits);<span class="tok-comment"> // Primitive type is larger than the modulus type.
            </span><span class="tok-kw">const</span> v = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Fe_.FeUint">FeUint</a>.<a href="#">fromPrimitive</a>(T, x);
            <span class="tok-kw">var</span> fe = <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>{ .v = v };
            <span class="tok-kw">try</span> m.shrink(&amp;fe);
            <span class="tok-kw">try</span> m.rejectNonCanonical(fe);
            <span class="tok-kw">return</span> fe;
        }

        <span class="tok-comment">/// Converts the field element to a primitive.</span>
        <span class="tok-comment">/// This function may not run in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toPrimitive</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!T {
            <span class="tok-kw">return</span> self.v.toPrimitive(T);
        }

        <span class="tok-comment">/// Creates a field element from a byte string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(m: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Modulus</a>(bits), bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a> || <a href="std.crypto.ff.html#std.crypto.ff.FieldElementError">FieldElementError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a> {
            <span class="tok-kw">const</span> v = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Fe_.FeUint">FeUint</a>.<a href="#">fromBytes</a>(bytes, endian);
            <span class="tok-kw">var</span> fe = <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>{ .v = v };
            <span class="tok-kw">try</span> m.shrink(&amp;fe);
            <span class="tok-kw">try</span> m.rejectNonCanonical(fe);
            <span class="tok-kw">return</span> fe;
        }

        <span class="tok-comment">/// Converts the field element to a byte string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.v.toBytes(bytes, endian);
        }

        <span class="tok-comment">/// Returns `true` if the field elements are equal, in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> x.v.eql(y.v);
        }

        <span class="tok-comment">/// Compares two field elements in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compare</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>) <a href="std.math.html">math</a>.<a href="std.math.Order.html">Order</a> {
            <span class="tok-kw">return</span> x.v.compare(y.v);
        }

        <span class="tok-comment">/// Returns `true` if the element is zero.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isZero</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.v.isZero();
        }

        <span class="tok-comment">/// Returns `true` is the element is odd.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isOdd</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.v.isOdd();
        }
    };
}

<span class="tok-comment">/// A modulus, defining a finite field.</span>
<span class="tok-comment">/// All operations within the field are performed modulo this modulus, without heap allocations.</span>
<span class="tok-comment">/// `max_bits` represents the number of bits in the maximum value the modulus can be set to.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">Modulus</span>(<span class="tok-kw">comptime</span> max_bits: <span class="tok-type">comptime_int</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// A field element, representing a value within the field defined by this modulus.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fe = <a href="std.crypto.ff.html#std.crypto.ff.Fe_">Fe_</a>(max_bits);

        <span class="tok-kw">const</span> FeUint = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>.<a href="#">FeUint</a>;

        <span class="tok-comment">/// The neutral element.</span>
        zero: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>,

        <span class="tok-comment">/// The modulus value.</span>
        v: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>,

        <span class="tok-comment">/// R^2 for the Montgomery representation.</span>
        rr: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>,
        <span class="tok-comment">/// Inverse of the first limb</span>
        m0inv: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>,
        <span class="tok-comment">/// Number of leading zero bits in the modulus.</span>
        leading: <span class="tok-type">usize</span>,<span class="tok-comment">

        // Number of active limbs in the modulus.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">limbs_count</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.v.limbs_len;
        }

        <span class="tok-comment">/// Actual size of the modulus, in bits.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bits</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.limbs_count() * <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a> - self.leading;
        }

        <span class="tok-comment">/// Returns the element `1`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">one</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> fe = self.zero;
            fe.v.limbs()[<span class="tok-number">0</span>] = <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> fe;
        }

        <span class="tok-comment">/// Creates a new modulus from a `Uint` value.</span>
        <span class="tok-comment">/// The modulus must be odd and larger than 2.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromUint</span>(v_: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>) <a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
            <span class="tok-kw">if</span> (!v_.isOdd()) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EvenModulus;

            <span class="tok-kw">var</span> v = v_.normalize();
            <span class="tok-kw">const</span> hi = v.limbsConst()[v.limbs_len - <span class="tok-number">1</span>];
            <span class="tok-kw">const</span> lo = v.limbsConst()[<span class="tok-number">0</span>];

            <span class="tok-kw">if</span> (v.limbs_len &lt; <span class="tok-number">2</span> <span class="tok-kw">and</span> lo &lt; <span class="tok-number">3</span>) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ModulusTooSmall;
            }

            <span class="tok-kw">const</span> leading = <span class="tok-builtin">@clz</span>(hi) - <a href="std.crypto.ff.html#std.crypto.ff.carry_bits">carry_bits</a>;

            <span class="tok-kw">var</span> y = lo;

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-kw">comptime</span> <a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int">log2_int</a>(<span class="tok-type">usize</span>, <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>)) |_| {
                y = y *% (<span class="tok-number">2</span> -% lo *% y);
            }
            <span class="tok-kw">const</span> m0inv = (<span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, <span class="tok-number">1</span>) &lt;&lt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>) - (<span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(y)));

            <span class="tok-kw">const</span> zero = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{ .v = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">zero</a> };

            <span class="tok-kw">var</span> m = <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>{
                .zero = zero,
                .v = v,
                .leading = leading,
                .m0inv = m0inv,
                .rr = <span class="tok-null">undefined</span>,<span class="tok-comment"> // will be computed right after
            </span>};
            m.shrink(&amp;m.zero) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <a href="std.crypto.ff.html#std.crypto.ff.Modulus.computeRR">computeRR</a>(&amp;m);

            <span class="tok-kw">return</span> m;
        }

        <span class="tok-comment">/// Creates a new modulus from a primitive value.</span>
        <span class="tok-comment">/// The modulus must be odd and larger than 2.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPrimitive</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, x: T) (<a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
            <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@bitSizeOf</span>(T) &lt;= max_bits);<span class="tok-comment"> // Primitive type is larger than the modulus type.
            </span><span class="tok-kw">const</span> v = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">fromPrimitive</a>(T, x);
            <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Modulus.fromUint">fromUint</a>(v);
        }

        <span class="tok-comment">/// Creates a new modulus from a byte string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromBytes</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) (<a href="std.crypto.ff.html#std.crypto.ff.InvalidModulusError">InvalidModulusError</a> || <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>)!<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a> {
            <span class="tok-kw">const</span> v = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus.FeUint">FeUint</a>.<a href="#">fromBytes</a>(bytes, endian);
            <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>.<a href="std.crypto.ff.html#std.crypto.ff.Modulus.fromUint">fromUint</a>(v);
        }

        <span class="tok-comment">/// Serializes the modulus to a byte string.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBytes</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, bytes: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.v.toBytes(bytes, endian);
        }

        <span class="tok-comment">/// Rejects field elements that are not in the canonical form.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rejectNonCanonical</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, fe: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <span class="tok-kw">error</span>{NonCanonical}!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (fe.limbs_count() != self.limbs_count() <span class="tok-kw">or</span> <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpGeq</a>(fe.v, self.v)) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonCanonical;
            }
        }<span class="tok-comment">

        // Makes the number of active limbs in a field element match the one of the modulus.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">shrink</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, fe: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.OverflowError">OverflowError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> new_len = self.limbs_count();
            <span class="tok-kw">if</span> (fe.limbs_count() &lt; new_len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            <span class="tok-kw">var</span> acc: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (fe.v.limbsConst()[new_len..]) |limb| {
                acc |= limb;
            }
            <span class="tok-kw">if</span> (acc != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            <span class="tok-kw">if</span> (new_len &gt; fe.v.limbs_buffer.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
            fe.v.limbs_len = new_len;
        }<span class="tok-comment">

        // Computes R^2 for the Montgomery representation.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">computeRR</span>(self: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>) <span class="tok-type">void</span> {
            self.rr = self.zero;
            <span class="tok-kw">const</span> n = self.rr.limbs_count();
            self.rr.v.limbs()[n - <span class="tok-number">1</span>] = <span class="tok-number">1</span>;
            <span class="tok-kw">for</span> ((n - <span class="tok-number">1</span>)..(<span class="tok-number">2</span> * n)) |_| {
                self.shiftIn(&amp;self.rr, <span class="tok-number">0</span>);
            }
            self.shrink(&amp;self.rr) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-comment">/// Computes x &lt;&lt; t_bits + y (mod m)</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">shiftIn</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">var</span> d = self.zero;
            <span class="tok-kw">const</span> x_limbs = x.v.limbs();
            <span class="tok-kw">const</span> d_limbs = d.v.limbs();
            <span class="tok-kw">const</span> m_limbs = self.v.limbsConst();

            <span class="tok-kw">var</span> need_sub = <span class="tok-null">false</span>;
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a> - <span class="tok-number">1</span>;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
                <span class="tok-kw">var</span> carry: <span class="tok-type">u1</span> = <span class="tok-builtin">@truncate</span>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shr">shr</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, y, i));
                <span class="tok-kw">var</span> borrow: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
                <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.limbs_count()) |j| {
                    <span class="tok-kw">const</span> l = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">select</a>(need_sub, d_limbs[j], x_limbs[j]);
                    <span class="tok-kw">var</span> res = (l &lt;&lt; <span class="tok-number">1</span>) + carry;
                    x_limbs[j] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(res));
                    carry = <span class="tok-builtin">@truncate</span>(res &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);

                    res = x_limbs[j] -% m_limbs[j] -% borrow;
                    d_limbs[j] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(res));

                    borrow = <span class="tok-builtin">@truncate</span>(res &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
                }
                need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(carry, borrow);
                <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            }
            x.v.cmov(need_sub, d.v);
        }

        <span class="tok-comment">/// Adds two field elements (mod m).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> out = x;
            <span class="tok-kw">const</span> overflow = out.v.addWithOverflow(y.v);
            <span class="tok-kw">const</span> underflow: <span class="tok-type">u1</span> = <span class="tok-builtin">@bitCast</span>(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpLt</a>(out.v, self.v));
            <span class="tok-kw">const</span> need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(overflow, underflow);
            _ = out.v.conditionalSubWithOverflow(need_sub, self.v);
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Subtracts two field elements (mod m).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> out = x;
            <span class="tok-kw">const</span> underflow: <span class="tok-type">bool</span> = <span class="tok-builtin">@bitCast</span>(out.v.subWithOverflow(y.v));
            _ = out.v.conditionalAddWithOverflow(underflow, self.v);
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Converts a field element to the Montgomery form.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMontgomery</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (x.montgomery) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedRepresentation;
            }
            self.shrink(x) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            x.* = self.montgomeryMul(x.*, self.rr);
            x.montgomery = <span class="tok-null">true</span>;
        }

        <span class="tok-comment">/// Takes a field element out of the Montgomery form.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromMontgomery</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.RepresentationError">RepresentationError</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (!x.montgomery) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnexpectedRepresentation;
            }
            self.shrink(x) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            x.* = self.montgomeryMul(x.*, self.one());
            x.montgomery = <span class="tok-null">false</span>;
        }

        <span class="tok-comment">/// Reduces an arbitrary `Uint`, converting it to a field element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reduce</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <span class="tok-kw">anytype</span>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> out = self.zero;
            <span class="tok-kw">var</span> i = x.limbs_len - <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (self.limbs_count() &gt;= <span class="tok-number">2</span>) {
                <span class="tok-kw">const</span> start = <span class="tok-builtin">@min</span>(i, self.limbs_count() - <span class="tok-number">2</span>);
                <span class="tok-kw">var</span> j = start;
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (j -= <span class="tok-number">1</span>) {
                    out.v.limbs()[j] = x.limbsConst()[i];
                    i -= <span class="tok-number">1</span>;
                    <span class="tok-kw">if</span> (j == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                }
            }
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (i -= <span class="tok-number">1</span>) {
                self.shiftIn(&amp;out, x.limbsConst()[i]);
                <span class="tok-kw">if</span> (i == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            }
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">montgomeryLoop</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, d: *<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <span class="tok-type">u1</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(d.limbs_count() == x.limbs_count());
            <a href="std.debug.html#std.debug.assert">assert</a>(d.limbs_count() == y.limbs_count());
            <a href="std.debug.html#std.debug.assert">assert</a>(d.limbs_count() == self.limbs_count());

            <span class="tok-kw">const</span> a_limbs = x.v.limbsConst();
            <span class="tok-kw">const</span> b_limbs = y.v.limbsConst();
            <span class="tok-kw">const</span> d_limbs = d.v.limbs();
            <span class="tok-kw">const</span> m_limbs = self.v.limbsConst();

            <span class="tok-kw">var</span> overflow: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.limbs_count()) |i| {
                <span class="tok-kw">var</span> carry: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">0</span>;

                <span class="tok-kw">var</span> wide = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">mulWide</a>(a_limbs[i], b_limbs[<span class="tok-number">0</span>]);
                <span class="tok-kw">var</span> z_lo = <span class="tok-builtin">@addWithOverflow</span>(d_limbs[<span class="tok-number">0</span>], wide.lo);
                <span class="tok-kw">const</span> f = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(z_lo[<span class="tok-number">0</span>] *% self.m0inv));
                <span class="tok-kw">var</span> z_hi = wide.hi +% z_lo[<span class="tok-number">1</span>];
                wide = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">mulWide</a>(f, m_limbs[<span class="tok-number">0</span>]);
                z_lo = <span class="tok-builtin">@addWithOverflow</span>(z_lo[<span class="tok-number">0</span>], wide.lo);
                z_hi +%= z_lo[<span class="tok-number">1</span>];
                z_hi +%= wide.hi;
                carry = (z_hi &lt;&lt; <span class="tok-number">1</span>) | (z_lo[<span class="tok-number">0</span>] &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);

                <span class="tok-kw">for</span> (<span class="tok-number">1</span>..self.limbs_count()) |j| {
                    wide = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">mulWide</a>(a_limbs[i], b_limbs[j]);
                    z_lo = <span class="tok-builtin">@addWithOverflow</span>(d_limbs[j], wide.lo);
                    z_hi = wide.hi +% z_lo[<span class="tok-number">1</span>];
                    wide = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">mulWide</a>(f, m_limbs[j]);
                    z_lo = <span class="tok-builtin">@addWithOverflow</span>(z_lo[<span class="tok-number">0</span>], wide.lo);
                    z_hi +%= z_lo[<span class="tok-number">1</span>];
                    z_hi +%= wide.hi;
                    z_lo = <span class="tok-builtin">@addWithOverflow</span>(z_lo[<span class="tok-number">0</span>], carry);
                    z_hi +%= z_lo[<span class="tok-number">1</span>];
                    <span class="tok-kw">if</span> (j &gt; <span class="tok-number">0</span>) {
                        d_limbs[j - <span class="tok-number">1</span>] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(z_lo[<span class="tok-number">0</span>]));
                    }
                    carry = (z_hi &lt;&lt; <span class="tok-number">1</span>) | (z_lo[<span class="tok-number">0</span>] &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
                }
                <span class="tok-kw">const</span> z = overflow + carry;
                d_limbs[self.limbs_count() - <span class="tok-number">1</span>] = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.TLimb">TLimb</a>, <span class="tok-builtin">@truncate</span>(z));
                overflow = <span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-builtin">@truncate</span>(z &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>));
            }
            <span class="tok-kw">return</span> overflow;
        }<span class="tok-comment">

        // Montgomery multiplication.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">montgomeryMul</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> d = self.zero;
            <a href="std.debug.html#std.debug.assert">assert</a>(x.limbs_count() == self.limbs_count());
            <a href="std.debug.html#std.debug.assert">assert</a>(y.limbs_count() == self.limbs_count());
            <span class="tok-kw">const</span> overflow = self.montgomeryLoop(&amp;d, x, y);
            <span class="tok-kw">const</span> underflow = <span class="tok-number">1</span> -% <span class="tok-builtin">@intFromBool</span>(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpGeq</a>(d.v, self.v));
            <span class="tok-kw">const</span> need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(overflow, underflow);
            _ = d.v.conditionalSubWithOverflow(need_sub, self.v);
            d.montgomery = x.montgomery == y.montgomery;
            <span class="tok-kw">return</span> d;
        }<span class="tok-comment">

        // Montgomery squaring.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">montgomerySq</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> d = self.zero;
            <a href="std.debug.html#std.debug.assert">assert</a>(x.limbs_count() == self.limbs_count());
            <span class="tok-kw">const</span> overflow = self.montgomeryLoop(&amp;d, x, x);
            <span class="tok-kw">const</span> underflow = <span class="tok-number">1</span> -% <span class="tok-builtin">@intFromBool</span>(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">limbsCmpGeq</a>(d.v, self.v));
            <span class="tok-kw">const</span> need_sub = <a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(overflow, underflow);
            _ = d.v.conditionalSubWithOverflow(need_sub, self.v);
            d.montgomery = <span class="tok-null">true</span>;
            <span class="tok-kw">return</span> d;
        }<span class="tok-comment">

        // Returns x^e (mod m), with the exponent provided as a byte string.
        // `public` must be set to `false` if the exponent it secret.
        </span><span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedExponentInternal</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>, <span class="tok-kw">comptime</span> public: <span class="tok-type">bool</span>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> acc: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">for</span> (e) |b| acc |= b;
            <span class="tok-kw">if</span> (acc == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NullExponent;

            <span class="tok-kw">var</span> out = self.one();
            self.toMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

            <span class="tok-kw">if</span> (public <span class="tok-kw">and</span> e.len &lt; <span class="tok-number">3</span> <span class="tok-kw">or</span> (e.len == <span class="tok-number">3</span> <span class="tok-kw">and</span> e[<span class="tok-kw">if</span> (endian == .big) <span class="tok-number">0</span> <span class="tok-kw">else</span> <span class="tok-number">2</span>] &lt;= <span class="tok-number">0b1111</span>)) {<span class="tok-comment">
                // Do not use a precomputation table for short, public exponents
                </span><span class="tok-kw">var</span> x_m = x;
                <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">false</span>) {
                    self.toMontgomery(&amp;x_m) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                }
                <span class="tok-kw">var</span> s = <span class="tok-kw">switch</span> (endian) {
                    .big =&gt; <span class="tok-number">0</span>,
                    .little =&gt; e.len - <span class="tok-number">1</span>,
                };
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> b = e[s];
                    <span class="tok-kw">var</span> j: <span class="tok-type">u3</span> = <span class="tok-number">7</span>;
                    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) : (j -= <span class="tok-number">1</span>) {
                        out = self.montgomerySq(out);
                        <span class="tok-kw">const</span> k: <span class="tok-type">u1</span> = <span class="tok-builtin">@truncate</span>(b &gt;&gt; j);
                        <span class="tok-kw">if</span> (k != <span class="tok-number">0</span>) {
                            <span class="tok-kw">const</span> t = self.montgomeryMul(out, x_m);
                            <span class="tok-builtin">@memcpy</span>(out.v.limbs(), t.v.limbsConst());
                        }
                        <span class="tok-kw">if</span> (j == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                    }
                    <span class="tok-kw">switch</span> (endian) {
                        .big =&gt; {
                            s += <span class="tok-number">1</span>;
                            <span class="tok-kw">if</span> (s == e.len) <span class="tok-kw">break</span>;
                        },
                        .little =&gt; {
                            <span class="tok-kw">if</span> (s == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                            s -= <span class="tok-number">1</span>;
                        },
                    }
                }
            } <span class="tok-kw">else</span> {<span class="tok-comment">
                // Use a precomputation table for large exponents
                </span><span class="tok-kw">var</span> pc = [<span class="tok-number">1</span>]<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{x} ++ [_]<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{self.zero} ** <span class="tok-number">14</span>;
                <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">false</span>) {
                    self.toMontgomery(&amp;pc[<span class="tok-number">0</span>]) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                }
                <span class="tok-kw">for</span> (<span class="tok-number">1</span>..pc.len) |i| {
                    pc[i] = self.montgomeryMul(pc[i - <span class="tok-number">1</span>], pc[<span class="tok-number">0</span>]);
                }
                <span class="tok-kw">var</span> t0 = self.zero;
                <span class="tok-kw">var</span> s = <span class="tok-kw">switch</span> (endian) {
                    .big =&gt; <span class="tok-number">0</span>,
                    .little =&gt; e.len - <span class="tok-number">1</span>,
                };
                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                    <span class="tok-kw">const</span> b = e[s];
                    <span class="tok-kw">for</span> ([_]<span class="tok-type">u3</span>{ <span class="tok-number">4</span>, <span class="tok-number">0</span> }) |j| {
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">4</span>) |_| {
                            out = self.montgomerySq(out);
                        }
                        <span class="tok-kw">const</span> k = (b &gt;&gt; j) &amp; <span class="tok-number">0b1111</span>;
                        <span class="tok-kw">if</span> (public <span class="tok-kw">or</span> <a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">side_channels_mitigations</a> == .none) {
                            <span class="tok-kw">if</span> (k == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;
                            t0 = pc[k - <span class="tok-number">1</span>];
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">for</span> (pc, <span class="tok-number">0</span>..) |t, i| {
                                t0.v.cmov(<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(k, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@truncate</span>(i + <span class="tok-number">1</span>))), t.v);
                            }
                        }
                        <span class="tok-kw">const</span> t1 = self.montgomeryMul(out, t0);
                        <span class="tok-kw">if</span> (public) {
                            <span class="tok-builtin">@memcpy</span>(out.v.limbs(), t1.v.limbsConst());
                        } <span class="tok-kw">else</span> {
                            out.v.cmov(!<a href="std.crypto.ff.html#std.crypto.ff.ct">ct</a>.<a href="#">eql</a>(k, <span class="tok-number">0</span>), t1.v);
                        }
                    }
                    <span class="tok-kw">switch</span> (endian) {
                        .big =&gt; {
                            s += <span class="tok-number">1</span>;
                            <span class="tok-kw">if</span> (s == e.len) <span class="tok-kw">break</span>;
                        },
                        .little =&gt; {
                            <span class="tok-kw">if</span> (s == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
                            s -= <span class="tok-number">1</span>;
                        },
                    }
                }
            }
            self.fromMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Multiplies two field elements.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mul</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">if</span> (x.montgomery != y.montgomery) {
                <span class="tok-kw">return</span> self.montgomeryMul(x, y);
            }
            <span class="tok-kw">var</span> a_ = x;
            <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">false</span>) {
                self.toMontgomery(&amp;a_) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            } <span class="tok-kw">else</span> {
                self.fromMontgomery(&amp;a_) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            }
            <span class="tok-kw">return</span> self.montgomeryMul(a_, y);
        }

        <span class="tok-comment">/// Squares a field element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> out = x;
            <span class="tok-kw">if</span> (x.montgomery == <span class="tok-null">true</span>) {
                self.fromMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            }
            out = self.montgomerySq(out);
            out.montgomery = <span class="tok-null">false</span>;
            self.toMontgomery(&amp;out) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> out;
        }

        <span class="tok-comment">/// Returns x^e (mod m) in constant time.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pow</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> buf: [<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>.<a href="#">encoded_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            e.toBytes(&amp;buf, <a href="std.crypto.ff.html#std.crypto.ff.native_endian">native_endian</a>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">return</span> self.powWithEncodedExponent(x, &amp;buf, <a href="std.crypto.ff.html#std.crypto.ff.native_endian">native_endian</a>);
        }

        <span class="tok-comment">/// Returns x^e (mod m), assuming that the exponent is public.</span>
        <span class="tok-comment">/// The function remains constant time with respect to `x`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powPublic</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">var</span> e_normalized = <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>{ .v = e.v.normalize() };
            <span class="tok-kw">var</span> buf_: [<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>.<a href="#">encoded_bytes</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> buf = buf_[<span class="tok-number">0</span> .. <a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">usize</span>, e_normalized.v.limbs_len * <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>, <span class="tok-number">8</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>];
            e_normalized.toBytes(buf, .little) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            <span class="tok-kw">const</span> leading = <span class="tok-builtin">@clz</span>(e_normalized.v.limbsConst()[e_normalized.v.limbs_len - <a href="std.crypto.ff.html#std.crypto.ff.carry_bits">carry_bits</a>]);
            buf = buf[<span class="tok-number">0</span> .. buf.len - leading / <span class="tok-number">8</span>];
            <span class="tok-kw">return</span> self.powWithEncodedPublicExponent(x, buf, .little);
        }

        <span class="tok-comment">/// Returns x^e (mod m), with the exponent provided as a byte string.</span>
        <span class="tok-comment">/// Exponents are usually small, so this function is faster than `powPublic` as a field element</span>
        <span class="tok-comment">/// doesn't have to be created if a serialized representation is already available.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// If the exponent is public, `powWithEncodedPublicExponent()` can be used instead for a slight speedup.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedExponent</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">return</span> self.powWithEncodedExponentInternal(x, e, endian, <span class="tok-null">false</span>);
        }

        <span class="tok-comment">/// Returns x^e (mod m), the exponent being public and provided as a byte string.</span>
        <span class="tok-comment">/// Exponents are usually small, so this function is faster than `powPublic` as a field element</span>
        <span class="tok-comment">/// doesn't have to be created if a serialized representation is already available.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// If the exponent is secret, `powWithEncodedExponent` must be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">powWithEncodedPublicExponent</span>(self: <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Self</a>, x: <a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a>, e: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, endian: <a href="std.builtin.Endian.html">Endian</a>) <a href="std.crypto.ff.html#std.crypto.ff.NullExponentError">NullExponentError</a>!<a href="std.crypto.ff.html#std.crypto.ff.Modulus.Fe">Fe</a> {
            <span class="tok-kw">return</span> self.powWithEncodedExponentInternal(x, e, endian, <span class="tok-null">true</span>);
        }
    };
}

<span class="tok-kw">const</span> ct = <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.html#std.options">options</a>.<a href="#">side_channels_mitigations</a> == .none) <a href="std.crypto.ff.ct_unprotected.html">ct_unprotected</a> <span class="tok-kw">else</span> <a href="std.crypto.ff.ct_protected.html">ct_protected</a>;

<span class="tok-kw">const</span> ct_protected = <span class="tok-kw">struct</span> {<span class="tok-comment">
    // Returns x if on is true, otherwise y.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">select</span>(on: <span class="tok-type">bool</span>, x: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> {
        <span class="tok-kw">const</span> mask = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, <span class="tok-number">0</span>) -% <span class="tok-builtin">@intFromBool</span>(on);
        <span class="tok-kw">return</span> y ^ (mask &amp; (y ^ x));
    }<span class="tok-comment">

    // Compares two values in constant time.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(x: <span class="tok-kw">anytype</span>, y: <span class="tok-builtin">@TypeOf</span>(x)) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> c1 = <span class="tok-builtin">@subWithOverflow</span>(x, y)[<span class="tok-number">1</span>];
        <span class="tok-kw">const</span> c2 = <span class="tok-builtin">@subWithOverflow</span>(y, x)[<span class="tok-number">1</span>];
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">bool</span>, <span class="tok-builtin">@bitCast</span>(<span class="tok-number">1</span> - (c1 | c2)));
    }<span class="tok-comment">

    // Compares two big integers in constant time, returning true if x &lt; y.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">limbsCmpLt</span>(x: <span class="tok-kw">anytype</span>, y: <span class="tok-builtin">@TypeOf</span>(x)) <span class="tok-type">bool</span> {
        <span class="tok-kw">var</span> c: <span class="tok-type">u1</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (x.limbsConst(), y.limbsConst()) |x_limb, y_limb| {
            c = <span class="tok-builtin">@truncate</span>((x_limb -% y_limb -% c) &gt;&gt; <a href="std.crypto.ff.html#std.crypto.ff.t_bits">t_bits</a>);
        }
        <span class="tok-kw">return</span> c != <span class="tok-number">0</span>;
    }<span class="tok-comment">

    // Compares two big integers in constant time, returning true if x &gt;= y.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">limbsCmpGeq</span>(x: <span class="tok-kw">anytype</span>, y: <span class="tok-builtin">@TypeOf</span>(x)) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> !<a href="std.crypto.ff.ct_protected.html#std.crypto.ff.ct_protected.limbsCmpLt">limbsCmpLt</a>(x, y);
    }<span class="tok-comment">

    // Multiplies two limbs and returns the result as a wide limb.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">mulWide</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) <a href="std.crypto.ff.WideLimb.html">WideLimb</a> {
        <span class="tok-kw">const</span> half_bits = <span class="tok-builtin">@typeInfo</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>).int.bits / <span class="tok-number">2</span>;
        <span class="tok-kw">const</span> Half = <a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, half_bits);
        <span class="tok-kw">const</span> x0 = <span class="tok-builtin">@as</span>(Half, <span class="tok-builtin">@truncate</span>(x));
        <span class="tok-kw">const</span> x1 = <span class="tok-builtin">@as</span>(Half, <span class="tok-builtin">@truncate</span>(x &gt;&gt; half_bits));
        <span class="tok-kw">const</span> y0 = <span class="tok-builtin">@as</span>(Half, <span class="tok-builtin">@truncate</span>(y));
        <span class="tok-kw">const</span> y1 = <span class="tok-builtin">@as</span>(Half, <span class="tok-builtin">@truncate</span>(y &gt;&gt; half_bits));
        <span class="tok-kw">const</span> w0 = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(Half, x0, y0);
        <span class="tok-kw">const</span> t = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(Half, x1, y0) + (w0 &gt;&gt; half_bits);
        <span class="tok-kw">var</span> w1: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-builtin">@as</span>(Half, <span class="tok-builtin">@truncate</span>(t));
        <span class="tok-kw">const</span> w2 = <span class="tok-builtin">@as</span>(Half, <span class="tok-builtin">@truncate</span>(t &gt;&gt; half_bits));
        w1 += <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(Half, x0, y1);
        <span class="tok-kw">const</span> hi = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(Half, x1, y1) + w2 + (w1 &gt;&gt; half_bits);
        <span class="tok-kw">const</span> lo = x *% y;
        <span class="tok-kw">return</span> .{ .hi = hi, .lo = lo };
    }
};

<span class="tok-kw">const</span> ct_unprotected = <span class="tok-kw">struct</span> {<span class="tok-comment">
    // Returns x if on is true, otherwise y.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">select</span>(on: <span class="tok-type">bool</span>, x: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (on) x <span class="tok-kw">else</span> y;
    }<span class="tok-comment">

    // Compares two values in constant time.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(x: <span class="tok-kw">anytype</span>, y: <span class="tok-builtin">@TypeOf</span>(x)) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> x == y;
    }<span class="tok-comment">

    // Compares two big integers in constant time, returning true if x &lt; y.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">limbsCmpLt</span>(x: <span class="tok-kw">anytype</span>, y: <span class="tok-builtin">@TypeOf</span>(x)) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> x_limbs = x.limbsConst();
        <span class="tok-kw">const</span> y_limbs = y.limbsConst();
        <a href="std.debug.html#std.debug.assert">assert</a>(x_limbs.len == y_limbs.len);

        <span class="tok-kw">var</span> i = x_limbs.len;
        <span class="tok-kw">while</span> (i != <span class="tok-number">0</span>) {
            i -= <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (x_limbs[i] != y_limbs[i]) {
                <span class="tok-kw">return</span> x_limbs[i] &lt; y_limbs[i];
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }<span class="tok-comment">

    // Compares two big integers in constant time, returning true if x &gt;= y.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">limbsCmpGeq</span>(x: <span class="tok-kw">anytype</span>, y: <span class="tok-builtin">@TypeOf</span>(x)) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> !<a href="std.crypto.ff.ct_unprotected.html#std.crypto.ff.ct_unprotected.limbsCmpLt">limbsCmpLt</a>(x, y);
    }<span class="tok-comment">

    // Multiplies two limbs and returns the result as a wide limb.
    </span><span class="tok-kw">fn</span> <span class="tok-fn">mulWide</span>(x: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, y: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>) <a href="std.crypto.ff.WideLimb.html">WideLimb</a> {
        <span class="tok-kw">const</span> wide = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.mulWide">mulWide</a>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, x, y);
        <span class="tok-kw">return</span> .{
            .hi = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(wide &gt;&gt; <span class="tok-builtin">@typeInfo</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>).int.bits)),
            .lo = <span class="tok-builtin">@as</span>(<a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a>, <span class="tok-builtin">@truncate</span>(wide)),
        };
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;finite field arithmetic&quot;</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> M = <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Modulus</a>(<span class="tok-number">256</span>);
    <span class="tok-kw">const</span> m = <span class="tok-kw">try</span> M.fromPrimitive(<span class="tok-type">u256</span>, <span class="tok-number">3429938563481314093726330772853735541133072814650493833233</span>);
    <span class="tok-kw">var</span> x = <span class="tok-kw">try</span> M.Fe.fromPrimitive(<span class="tok-type">u256</span>, m, <span class="tok-number">80169837251094269539116136208111827396136208141182357733</span>);
    <span class="tok-kw">var</span> y = <span class="tok-kw">try</span> M.Fe.fromPrimitive(<span class="tok-type">u256</span>, m, <span class="tok-number">24620149608466364616251608466389896540098571</span>);

    <span class="tok-kw">const</span> x_ = <span class="tok-kw">try</span> x.toPrimitive(<span class="tok-type">u256</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> M.Fe.fromPrimitive(<span class="tok-builtin">@TypeOf</span>(x_), m, x_)).eql(x));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.Overflow, x.toPrimitive(<span class="tok-type">u50</span>));

    <span class="tok-kw">const</span> bits = m.bits();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(bits, <span class="tok-number">192</span>);

    <span class="tok-kw">var</span> x_y = m.mul(x, y);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(x_y.toPrimitive(<span class="tok-type">u256</span>), <span class="tok-number">1666576607955767413750776202132407807424848069716933450241</span>);

    <span class="tok-kw">try</span> m.toMontgomery(&amp;x);
    x_y = m.mul(x, y);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(x_y.toPrimitive(<span class="tok-type">u256</span>), <span class="tok-number">1666576607955767413750776202132407807424848069716933450241</span>);
    <span class="tok-kw">try</span> m.fromMontgomery(&amp;x);

    x = m.add(x, y);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(x.toPrimitive(<span class="tok-type">u256</span>), <span class="tok-number">80169837251118889688724602572728079004602598037722456304</span>);
    x = m.sub(x, y);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(x.toPrimitive(<span class="tok-type">u256</span>), <span class="tok-number">80169837251094269539116136208111827396136208141182357733</span>);

    <span class="tok-kw">const</span> big = <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.Uint">Uint</a>(<span class="tok-number">512</span>).fromPrimitive(<span class="tok-type">u495</span>, <span class="tok-number">77285373554113307281465049383342993856348131409372633077285373554113307281465049383323332333429938563481314093726330772853735541133072814650493833233</span>);
    <span class="tok-kw">const</span> reduced = m.reduce(big);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(reduced.toPrimitive(<span class="tok-type">u495</span>), <span class="tok-number">858047099884257670294681641776170038885500210968322054970</span>);

    <span class="tok-kw">const</span> x_pow_y = <span class="tok-kw">try</span> m.powPublic(x, y);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(x_pow_y.toPrimitive(<span class="tok-type">u256</span>), <span class="tok-number">1631933139300737762906024873185789093007782131928298618473</span>);
    <span class="tok-kw">try</span> m.toMontgomery(&amp;x);
    <span class="tok-kw">const</span> x_pow_y2 = <span class="tok-kw">try</span> m.powPublic(x, y);
    <span class="tok-kw">try</span> m.fromMontgomery(&amp;x);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(x_pow_y2.eql(x_pow_y));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.NullExponent, m.powPublic(x, m.zero));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!x.isZero());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!y.isZero());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(m.v.isOdd());

    <span class="tok-kw">const</span> x_sq = m.sq(x);
    <span class="tok-kw">const</span> x_sq2 = m.mul(x, x);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(x_sq.eql(x_sq2));
    <span class="tok-kw">try</span> m.toMontgomery(&amp;x);
    <span class="tok-kw">const</span> x_sq3 = m.sq(x);
    <span class="tok-kw">const</span> x_sq4 = m.mul(x, x);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(x_sq.eql(x_sq3));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(x_sq3.eql(x_sq4));
    <span class="tok-kw">try</span> m.fromMontgomery(&amp;x);
}

<span class="tok-kw">fn</span> <span class="tok-fn">testCt</span>(ct_: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_c) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> l0: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> l1: <a href="std.crypto.ff.html#std.crypto.ff.Limb">Limb</a> = <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(l1, ct_.select(<span class="tok-null">true</span>, l1, l0));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(l0, ct_.select(<span class="tok-null">false</span>, l1, l0));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, ct_.eql(l1, l0));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, ct_.eql(l1, l1));

    <span class="tok-kw">const</span> M = <a href="std.crypto.ff.html#std.crypto.ff.Modulus">Modulus</a>(<span class="tok-number">256</span>);
    <span class="tok-kw">const</span> m = <span class="tok-kw">try</span> M.fromPrimitive(<span class="tok-type">u256</span>, <span class="tok-number">3429938563481314093726330772853735541133072814650493833233</span>);
    <span class="tok-kw">const</span> x = <span class="tok-kw">try</span> M.Fe.fromPrimitive(<span class="tok-type">u256</span>, m, <span class="tok-number">80169837251094269539116136208111827396136208141182357733</span>);
    <span class="tok-kw">const</span> y = <span class="tok-kw">try</span> M.Fe.fromPrimitive(<span class="tok-type">u256</span>, m, <span class="tok-number">24620149608466364616251608466389896540098571</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, ct_.limbsCmpLt(x.v, y.v));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, ct_.limbsCmpGeq(x.v, y.v));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.crypto.ff.WideLimb.html">WideLimb</a>{ .hi = <span class="tok-number">0</span>, .lo = <span class="tok-number">0x88</span> }, ct_.mulWide(<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">3</span>, (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">4</span>) + <span class="tok-number">1</span>));
}

<span class="tok-kw">test</span> ct {
    <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.testCt">testCt</a>(<a href="std.crypto.ff.ct_protected.html">ct_protected</a>);
    <span class="tok-kw">try</span> <a href="std.crypto.ff.html#std.crypto.ff.testCt">testCt</a>(<a href="std.crypto.ff.ct_unprotected.html">ct_unprotected</a>);
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
