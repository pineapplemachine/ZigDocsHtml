<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">Build</a></li><li><a href="std.Build.html" class="">Step</a></li><li><a href="std.Build.Step.WriteFile.html" class="active">WriteFile</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.Build.Step.WriteFile" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.Build.Step.WriteFile</span><a href="#src.zig-std.Build.Step.WriteFile">[src]</a></h1><div class="tldDocs"><p>WriteFile is used to create a directory in an appropriate location inside
the local cache which has a set of files that have either been generated
during the build, or are copied from the source package.</p>
</div><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.Build.Step.WriteFile.File.html">std.Build.Step.WriteFile.File</a></li><li><a href="std.Build.Step.WriteFile.Directory.html">std.Build.Step.WriteFile.Directory</a></li><li><a href="std.Build.Step.WriteFile.Contents.html">std.Build.Step.WriteFile.Contents</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>step: <a href="std.Build.Step.html">Step</a></code></pre></div><div><pre><code>files: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.Build.Step.WriteFile.File.html">File</a>)</code></pre></div><div><pre><code>directories: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.Build.Step.WriteFile.Directory.html">Directory</a>)</code></pre></div><div><pre><code>generated_directory: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.GeneratedFile.html">GeneratedFile</a></code></pre></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.Build.Step.WriteFile.base_id" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">base_id</span><a href="#src.zig-std.Build.Step.WriteFile.base_id">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.WriteFile.base_id">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Id.html">Id</a> = .write_file</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.Build.Step.WriteFile.create" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">create</span><a href="#src.zig-std.Build.Step.WriteFile.create">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.WriteFile.html">WriteFile</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.WriteFile.create">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
    <span class="tok-kw">const</span> write_file = owner.allocator.create(<a href="std.Build.Step.WriteFile.html">WriteFile</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    write_file.* = .{
        .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
            .id = <a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.base_id">base_id</a>,
            .name = <span class="tok-str">&quot;WriteFile&quot;</span>,
            .owner = owner,
            .makeFn = <a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.make">make</a>,
        }),
        .files = .{},
        .directories = .{},
        .generated_directory = .{ .step = &amp;write_file.step },
    };
    <span class="tok-kw">return</span> write_file;
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.WriteFile.add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">add</span><a href="#src.zig-std.Build.Step.WriteFile.add">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.WriteFile.add">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">const</span> b = write_file.step.owner;
    <span class="tok-kw">const</span> gpa = b.allocator;
    <span class="tok-kw">const</span> file = <a href="std.Build.Step.WriteFile.File.html">File</a>{
        .sub_path = b.dupePath(sub_path),
        .contents = .{ .bytes = b.dupe(bytes) },
    };
    write_file.files.append(gpa, file) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    write_file.maybeUpdateName();
    <span class="tok-kw">return</span> .{
        .generated = .{
            .file = &amp;write_file.generated_directory,
            .sub_path = file.sub_path,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.WriteFile.addCopyFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCopyFile</span><a href="#src.zig-std.Build.Step.WriteFile.addCopyFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCopyFile</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>, source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Place the file into the generated directory within the local cache,
along with all the rest of the files added to this step. The parameter
here is the destination path relative to the local cache directory
associated with this WriteFile. It may be a basename, or it may
include sub-directories, in which case this step will ensure the
required sub-path exists.
This is the option expected to be used most commonly with <code><a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.addCopyFile">addCopyFile</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a></code></pre></div><div><pre><code>source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.WriteFile.addCopyFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCopyFile</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>, source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">const</span> b = write_file.step.owner;
    <span class="tok-kw">const</span> gpa = b.allocator;
    <span class="tok-kw">const</span> file = <a href="std.Build.Step.WriteFile.File.html">File</a>{
        .sub_path = b.dupePath(sub_path),
        .contents = .{ .copy = source },
    };
    write_file.files.append(gpa, file) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    write_file.maybeUpdateName();
    source.addStepDependencies(&amp;write_file.step);
    <span class="tok-kw">return</span> .{
        .generated = .{
            .file = &amp;write_file.generated_directory,
            .sub_path = file.sub_path,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.WriteFile.addCopyDirectory" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addCopyDirectory</span><a href="#src.zig-std.Build.Step.WriteFile.addCopyDirectory">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCopyDirectory</span>( write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>, source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.Build.Step.WriteFile.Directory.html">Directory</a>.<a href="std.Build.Step.WriteFile.Directory.Options.html">Options</a>, ) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Copy files matching the specified exclude/include patterns to the specified subdirectory
relative to this step's generated directory.
The returned value is a lazy path to the generated subdirectory.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a></code></pre></div><div><pre><code>source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div><pre><code>sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.Build.Step.WriteFile.Directory.html">Directory</a>.<a href="std.Build.Step.WriteFile.Directory.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.WriteFile.addCopyDirectory">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCopyDirectory</span>(
    write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>,
    source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
    sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.Build.Step.WriteFile.Directory.html">Directory</a>.<a href="std.Build.Step.WriteFile.Directory.Options.html">Options</a>,
) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">const</span> b = write_file.step.owner;
    <span class="tok-kw">const</span> gpa = b.allocator;
    <span class="tok-kw">const</span> dir = <a href="std.Build.Step.WriteFile.Directory.html">Directory</a>{
        .source = source.dupe(b),
        .sub_path = b.dupePath(sub_path),
        .options = options.dupe(b),
    };
    write_file.directories.append(gpa, dir) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    write_file.maybeUpdateName();
    source.addStepDependencies(&amp;write_file.step);
    <span class="tok-kw">return</span> .{
        .generated = .{
            .file = &amp;write_file.generated_directory,
            .sub_path = dir.sub_path,
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.Build.Step.WriteFile.getDirectory" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getDirectory</span><a href="#src.zig-std.Build.Step.WriteFile.getDirectory">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDirectory</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a></code></pre></div><div class="tldDocs"><p>Returns a <code>LazyPath</code> representing the base directory that contains all the
files from this <code><a href="std.Build.Step.WriteFile.html">WriteFile</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.Build.Step.WriteFile.getDirectory">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDirectory</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> .{ .generated = .{ .file = &amp;write_file.generated_directory } };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.Build.Step.WriteFile">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">//! WriteFile is used to create a directory in an appropriate location inside</span>
<span class="tok-comment">//! the local cache which has a set of files that have either been generated</span>
<span class="tok-comment">//! during the build, or are copied from the source package.</span>
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> Step = <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.Step.html">Step</a>;
<span class="tok-kw">const</span> fs = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>;
<span class="tok-kw">const</span> ArrayList = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>;
<span class="tok-kw">const</span> WriteFile = <span class="tok-builtin">@This</span>();

step: <a href="std.Build.Step.html">Step</a>,<span class="tok-comment">

// The elements here are pointers because we need stable pointers for the GeneratedFile field.
</span>files: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.Build.Step.WriteFile.File.html">File</a>),
directories: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.Build.Step.WriteFile.Directory.html">Directory</a>),
generated_directory: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.GeneratedFile.html">GeneratedFile</a>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> base_id: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.Id.html">Id</a> = .write_file;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {
    sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    contents: <a href="std.Build.Step.WriteFile.Contents.html">Contents</a>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Directory = <span class="tok-kw">struct</span> {
    source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
    sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.Build.Step.WriteFile.Directory.Options.html">Options</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// File paths that end in any of these suffixes will be excluded from copying.</span>
        exclude_extensions: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},
        <span class="tok-comment">/// Only file paths that end in any of these suffixes will be included in copying.</span>
        <span class="tok-comment">/// `null` means that all suffixes will be included.</span>
        <span class="tok-comment">/// `exclude_extensions` takes precedence over `include_extensions`.</span>
        include_extensions: ?[]<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dupe</span>(opts: <a href="std.Build.Step.WriteFile.Directory.Options.html">Options</a>, b: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) <a href="std.Build.Step.WriteFile.Directory.Options.html">Options</a> {
            <span class="tok-kw">return</span> .{
                .exclude_extensions = b.dupeStrings(opts.exclude_extensions),
                .include_extensions = <span class="tok-kw">if</span> (opts.include_extensions) |incs| b.dupeStrings(incs) <span class="tok-kw">else</span> <span class="tok-null">null</span>,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pathIncluded</span>(opts: <a href="std.Build.Step.WriteFile.Directory.Options.html">Options</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">for</span> (opts.exclude_extensions) |ext| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, path, ext))
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
            <span class="tok-kw">if</span> (opts.include_extensions) |incs| {
                <span class="tok-kw">for</span> (incs) |inc| {
                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.endsWith">endsWith</a>(<span class="tok-type">u8</span>, path, inc))
                        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Contents = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    copy: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">create</span>(owner: *<a href="std.html">std</a>.<a href="std.Build.html">Build</a>) *<a href="std.Build.Step.WriteFile.html">WriteFile</a> {
    <span class="tok-kw">const</span> write_file = owner.allocator.create(<a href="std.Build.Step.WriteFile.html">WriteFile</a>) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    write_file.* = .{
        .step = <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.html#std.Build.Step.init">init</a>(.{
            .id = <a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.base_id">base_id</a>,
            .name = <span class="tok-str">&quot;WriteFile&quot;</span>,
            .owner = owner,
            .makeFn = <a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.make">make</a>,
        }),
        .files = .{},
        .directories = .{},
        .generated_directory = .{ .step = &amp;write_file.step },
    };
    <span class="tok-kw">return</span> write_file;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">const</span> b = write_file.step.owner;
    <span class="tok-kw">const</span> gpa = b.allocator;
    <span class="tok-kw">const</span> file = <a href="std.Build.Step.WriteFile.File.html">File</a>{
        .sub_path = b.dupePath(sub_path),
        .contents = .{ .bytes = b.dupe(bytes) },
    };
    write_file.files.append(gpa, file) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);
    write_file.maybeUpdateName();
    <span class="tok-kw">return</span> .{
        .generated = .{
            .file = &amp;write_file.generated_directory,
            .sub_path = file.sub_path,
        },
    };
}

<span class="tok-comment">/// Place the file into the generated directory within the local cache,</span>
<span class="tok-comment">/// along with all the rest of the files added to this step. The parameter</span>
<span class="tok-comment">/// here is the destination path relative to the local cache directory</span>
<span class="tok-comment">/// associated with this WriteFile. It may be a basename, or it may</span>
<span class="tok-comment">/// include sub-directories, in which case this step will ensure the</span>
<span class="tok-comment">/// required sub-path exists.</span>
<span class="tok-comment">/// This is the option expected to be used most commonly with `addCopyFile`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCopyFile</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>, source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>, sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">const</span> b = write_file.step.owner;
    <span class="tok-kw">const</span> gpa = b.allocator;
    <span class="tok-kw">const</span> file = <a href="std.Build.Step.WriteFile.File.html">File</a>{
        .sub_path = b.dupePath(sub_path),
        .contents = .{ .copy = source },
    };
    write_file.files.append(gpa, file) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    write_file.maybeUpdateName();
    source.addStepDependencies(&amp;write_file.step);
    <span class="tok-kw">return</span> .{
        .generated = .{
            .file = &amp;write_file.generated_directory,
            .sub_path = file.sub_path,
        },
    };
}

<span class="tok-comment">/// Copy files matching the specified exclude/include patterns to the specified subdirectory</span>
<span class="tok-comment">/// relative to this step's generated directory.</span>
<span class="tok-comment">/// The returned value is a lazy path to the generated subdirectory.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCopyDirectory</span>(
    write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>,
    source: <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a>,
    sub_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.Build.Step.WriteFile.Directory.html">Directory</a>.<a href="std.Build.Step.WriteFile.Directory.Options.html">Options</a>,
) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">const</span> b = write_file.step.owner;
    <span class="tok-kw">const</span> gpa = b.allocator;
    <span class="tok-kw">const</span> dir = <a href="std.Build.Step.WriteFile.Directory.html">Directory</a>{
        .source = source.dupe(b),
        .sub_path = b.dupePath(sub_path),
        .options = options.dupe(b),
    };
    write_file.directories.append(gpa, dir) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;OOM&quot;</span>);

    write_file.maybeUpdateName();
    source.addStepDependencies(&amp;write_file.step);
    <span class="tok-kw">return</span> .{
        .generated = .{
            .file = &amp;write_file.generated_directory,
            .sub_path = dir.sub_path,
        },
    };
}

<span class="tok-comment">/// Returns a `LazyPath` representing the base directory that contains all the</span>
<span class="tok-comment">/// files from this `WriteFile`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getDirectory</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>) <a href="std.html">std</a>.<a href="std.Build.html">Build</a>.<a href="std.Build.LazyPath.html">LazyPath</a> {
    <span class="tok-kw">return</span> .{ .generated = .{ .file = &amp;write_file.generated_directory } };
}

<span class="tok-kw">fn</span> <span class="tok-fn">maybeUpdateName</span>(write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (write_file.files.items.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> write_file.directories.items.len == <span class="tok-number">0</span>) {<span class="tok-comment">
        // First time adding a file; update name.
        </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, write_file.step.name, <span class="tok-str">&quot;WriteFile&quot;</span>)) {
            write_file.step.name = write_file.step.owner.fmt(<span class="tok-str">&quot;WriteFile {s}&quot;</span>, .{write_file.files.items[<span class="tok-number">0</span>].sub_path});
        }
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (write_file.directories.items.len == <span class="tok-number">1</span> <span class="tok-kw">and</span> write_file.files.items.len == <span class="tok-number">0</span>) {<span class="tok-comment">
        // First time adding a directory; update name.
        </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, write_file.step.name, <span class="tok-str">&quot;WriteFile&quot;</span>)) {
            write_file.step.name = write_file.step.owner.fmt(<span class="tok-str">&quot;WriteFile {s}&quot;</span>, .{write_file.directories.items[<span class="tok-number">0</span>].sub_path});
        }
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">make</span>(step: *<a href="std.Build.Step.html">Step</a>, options: <a href="std.Build.Step.html">Step</a>.<a href="std.Build.Step.MakeOptions.html">MakeOptions</a>) !<span class="tok-type">void</span> {
    _ = options;
    <span class="tok-kw">const</span> b = step.owner;
    <span class="tok-kw">const</span> arena = b.allocator;
    <span class="tok-kw">const</span> gpa = arena;
    <span class="tok-kw">const</span> write_file: *<a href="std.Build.Step.WriteFile.html">WriteFile</a> = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;step&quot;</span>, step);
    step.clearWatchInputs();<span class="tok-comment">

    // The cache is used here not really as a way to speed things up - because writing
    // the data to a file would probably be very fast - but as a way to find a canonical
    // location to put build artifacts.

    // If, for example, a hard-coded path was used as the location to put WriteFile
    // files, then two WriteFiles executing in parallel might clobber each other.

    </span><span class="tok-kw">var</span> man = b.graph.cache.obtain();
    <span class="tok-kw">defer</span> man.deinit();

    <span class="tok-kw">for</span> (write_file.files.items) |file| {
        man.hash.addBytes(file.sub_path);

        <span class="tok-kw">switch</span> (file.contents) {
            .bytes =&gt; |bytes| {
                man.hash.addBytes(bytes);
            },
            .copy =&gt; |lazy_path| {
                <span class="tok-kw">const</span> path = lazy_path.getPath3(b, step);
                _ = <span class="tok-kw">try</span> man.addFilePath(path, <span class="tok-null">null</span>);
                <span class="tok-kw">try</span> step.addWatchInput(lazy_path);
            },
        }
    }

    <span class="tok-kw">const</span> open_dir_cache = <span class="tok-kw">try</span> arena.alloc(<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>, write_file.directories.items.len);
    <span class="tok-kw">var</span> open_dirs_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">defer</span> <a href="std.Build.Step.WriteFile.html#std.Build.Step.WriteFile.closeDirs">closeDirs</a>(open_dir_cache[<span class="tok-number">0</span>..open_dirs_count]);

    <span class="tok-kw">for</span> (write_file.directories.items, open_dir_cache) |dir, *open_dir_cache_elem| {
        man.hash.addBytes(dir.sub_path);
        <span class="tok-kw">for</span> (dir.options.exclude_extensions) |ext| man.hash.addBytes(ext);
        <span class="tok-kw">if</span> (dir.options.include_extensions) |incs| <span class="tok-kw">for</span> (incs) |inc| man.hash.addBytes(inc);

        <span class="tok-kw">const</span> need_derived_inputs = <span class="tok-kw">try</span> step.addDirectoryWatchInput(dir.source);
        <span class="tok-kw">const</span> src_dir_path = dir.source.getPath3(b, step);

        <span class="tok-kw">var</span> src_dir = src_dir_path.root_dir.handle.openDir(src_dir_path.subPathOrDot(), .{ .iterate = <span class="tok-null">true</span> }) <span class="tok-kw">catch</span> |err| {
            <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to open source directory '{}': {s}&quot;</span>, .{
                src_dir_path, <span class="tok-builtin">@errorName</span>(err),
            });
        };
        open_dir_cache_elem.* = src_dir;
        open_dirs_count += <span class="tok-number">1</span>;

        <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> src_dir.walk(gpa);
        <span class="tok-kw">defer</span> it.deinit();
        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> it.next()) |entry| {
            <span class="tok-kw">if</span> (!dir.options.pathIncluded(entry.path)) <span class="tok-kw">continue</span>;

            <span class="tok-kw">switch</span> (entry.kind) {
                .directory =&gt; {
                    <span class="tok-kw">if</span> (need_derived_inputs) {
                        <span class="tok-kw">const</span> entry_path = <span class="tok-kw">try</span> src_dir_path.join(arena, entry.path);
                        <span class="tok-kw">try</span> step.addDirectoryWatchInputFromPath(entry_path);
                    }
                },
                .file =&gt; {
                    <span class="tok-kw">const</span> entry_path = <span class="tok-kw">try</span> src_dir_path.join(arena, entry.path);
                    _ = <span class="tok-kw">try</span> man.addFilePath(entry_path, <span class="tok-null">null</span>);
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
            }
        }
    }

    <span class="tok-kw">if</span> (<span class="tok-kw">try</span> step.cacheHit(&amp;man)) {
        <span class="tok-kw">const</span> digest = man.final();
        write_file.generated_directory.path = <span class="tok-kw">try</span> b.cache_root.join(arena, &amp;.{ <span class="tok-str">&quot;o&quot;</span>, &amp;digest });
        step.result_cached = <span class="tok-null">true</span>;
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">const</span> digest = man.final();
    <span class="tok-kw">const</span> cache_path = <span class="tok-str">&quot;o&quot;</span> ++ <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep_str">sep_str</a> ++ digest;

    write_file.generated_directory.path = <span class="tok-kw">try</span> b.cache_root.join(arena, &amp;.{ <span class="tok-str">&quot;o&quot;</span>, &amp;digest });

    <span class="tok-kw">var</span> cache_dir = b.cache_root.handle.makeOpenPath(cache_path, .{}) <span class="tok-kw">catch</span> |err| {
        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to make path '{}{s}': {s}&quot;</span>, .{
            b.cache_root, cache_path, <span class="tok-builtin">@errorName</span>(err),
        });
    };
    <span class="tok-kw">defer</span> cache_dir.close();

    <span class="tok-kw">const</span> cwd = <a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>();

    <span class="tok-kw">for</span> (write_file.files.items) |file| {
        <span class="tok-kw">if</span> (<a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.dirname">dirname</a>(file.sub_path)) |dirname| {
            cache_dir.makePath(dirname) <span class="tok-kw">catch</span> |err| {
                <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to make path '{}{s}{c}{s}': {s}&quot;</span>, .{
                    b.cache_root, cache_path, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>, dirname, <span class="tok-builtin">@errorName</span>(err),
                });
            };
        }
        <span class="tok-kw">switch</span> (file.contents) {
            .bytes =&gt; |bytes| {
                cache_dir.writeFile(.{ .sub_path = file.sub_path, .data = bytes }) <span class="tok-kw">catch</span> |err| {
                    <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to write file '{}{s}{c}{s}': {s}&quot;</span>, .{
                        b.cache_root, cache_path, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>, file.sub_path, <span class="tok-builtin">@errorName</span>(err),
                    });
                };
            },
            .copy =&gt; |file_source| {
                <span class="tok-kw">const</span> source_path = file_source.getPath2(b, step);
                <span class="tok-kw">const</span> prev_status = <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.updateFile">updateFile</a>(
                    cwd,
                    source_path,
                    cache_dir,
                    file.sub_path,
                    .{},
                ) <span class="tok-kw">catch</span> |err| {
                    <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to update file from '{s}' to '{}{s}{c}{s}': {s}&quot;</span>, .{
                        source_path,
                        b.cache_root,
                        cache_path,
                        <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>,
                        file.sub_path,
                        <span class="tok-builtin">@errorName</span>(err),
                    });
                };<span class="tok-comment">
                // At this point we already will mark the step as a cache miss.
                // But this is kind of a partial cache hit since individual
                // file copies may be avoided. Oh well, this information is
                // discarded.
                </span>_ = prev_status;
            },
        }
    }

    <span class="tok-kw">for</span> (write_file.directories.items, open_dir_cache) |dir, already_open_dir| {
        <span class="tok-kw">const</span> src_dir_path = dir.source.getPath3(b, step);
        <span class="tok-kw">const</span> dest_dirname = dir.sub_path;

        <span class="tok-kw">if</span> (dest_dirname.len != <span class="tok-number">0</span>) {
            cache_dir.makePath(dest_dirname) <span class="tok-kw">catch</span> |err| {
                <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to make path '{}{s}{c}{s}': {s}&quot;</span>, .{
                    b.cache_root, cache_path, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>, dest_dirname, <span class="tok-builtin">@errorName</span>(err),
                });
            };
        }

        <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> already_open_dir.walk(gpa);
        <span class="tok-kw">defer</span> it.deinit();
        <span class="tok-kw">while</span> (<span class="tok-kw">try</span> it.next()) |entry| {
            <span class="tok-kw">if</span> (!dir.options.pathIncluded(entry.path)) <span class="tok-kw">continue</span>;

            <span class="tok-kw">const</span> src_entry_path = <span class="tok-kw">try</span> src_dir_path.join(arena, entry.path);
            <span class="tok-kw">const</span> dest_path = b.pathJoin(&amp;.{ dest_dirname, entry.path });
            <span class="tok-kw">switch</span> (entry.kind) {
                .directory =&gt; <span class="tok-kw">try</span> cache_dir.makePath(dest_path),
                .file =&gt; {
                    <span class="tok-kw">const</span> prev_status = <a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>.<a href="std.fs.Dir.html#std.fs.Dir.updateFile">updateFile</a>(
                        src_entry_path.root_dir.handle,
                        src_entry_path.sub_path,
                        cache_dir,
                        dest_path,
                        .{},
                    ) <span class="tok-kw">catch</span> |err| {
                        <span class="tok-kw">return</span> step.fail(<span class="tok-str">&quot;unable to update file from '{}' to '{}{s}{c}{s}': {s}&quot;</span>, .{
                            src_entry_path, b.cache_root, cache_path, <a href="std.fs.html">fs</a>.<a href="std.fs.path.html">path</a>.<a href="std.fs.path.html#std.fs.path.sep">sep</a>, dest_path, <span class="tok-builtin">@errorName</span>(err),
                        });
                    };
                    _ = prev_status;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
            }
        }
    }

    <span class="tok-kw">try</span> step.writeManifest(&amp;man);
}

<span class="tok-kw">fn</span> <span class="tok-fn">closeDirs</span>(dirs: []<a href="std.fs.html">fs</a>.<a href="std.fs.Dir.html">Dir</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">for</span> (dirs) |*d| d.close();
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
