<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">os</a></li><li><a href="std.os.html" class="">linux</a></li><li><a href="std.os.linux.IoUring.html" class="active">IoUring</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.os.linux.IoUring" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.os.linux.IoUring</span><a href="#src.zig-std.os.linux.IoUring">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.os.linux.IoUring.ReadBuffer.html">std.os.linux.IoUring.ReadBuffer</a></li><li><a href="std.os.linux.IoUring.RecvBuffer.html">std.os.linux.IoUring.RecvBuffer</a></li><li><a href="std.os.linux.IoUring.SubmissionQueue.html">std.os.linux.IoUring.SubmissionQueue</a></li><li><a href="std.os.linux.IoUring.CompletionQueue.html">std.os.linux.IoUring.CompletionQueue</a></li><li><a href="std.os.linux.IoUring.BufferGroup.html">std.os.linux.IoUring.BufferGroup</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a> = -<span class="tok-number">1</span></code></pre></div><div><pre><code>sq: <a href="std.os.linux.IoUring.SubmissionQueue.html">SubmissionQueue</a></code></pre></div><div><pre><code>cq: <a href="std.os.linux.IoUring.CompletionQueue.html">CompletionQueue</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>features: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.os.linux.IoUring.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.os.linux.IoUring.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(entries: <span class="tok-type">u16</span>, flags: <span class="tok-type">u32</span>) !<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div class="tldDocs"><p>A friendly way to setup an io_uring, with default linux.io_uring_params.
<code>entries</code> must be a power of two between 1 and 32768, although the kernel will make the final
call on how many entries the submission and completion queues will ultimately have,
see <a href="https://github.com/torvalds/linux/blob/v5.8/fs/io_uring.c#L8027-L8050">https://github.com/torvalds/linux/blob/v5.8/fs/io_uring.c#L8027-L8050</a>.
Matches the interface of io_uring_queue_init() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>entries: <span class="tok-type">u16</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(entries: <span class="tok-type">u16</span>, flags: <span class="tok-type">u32</span>) !<a href="std.os.linux.IoUring.html">IoUring</a> {
    <span class="tok-kw">var</span> params = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a>, .{
        .flags = flags,
        .sq_thread_idle = <span class="tok-number">1000</span>,
    });
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init_params">init_params</a>(entries, &amp;params);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.init_params" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init_params</span><a href="#src.zig-std.os.linux.IoUring.init_params">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init_params</span>(entries: <span class="tok-type">u16</span>, p: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a>) !<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div class="tldDocs"><p>A powerful way to setup an io_uring, if you want to tweak linux.io_uring_params such as submission
queue thread cpu affinity or thread idle timeout (the kernel and our default is 1 second).
<code>params</code> is passed by reference because the kernel needs to modify the parameters.
Matches the interface of io_uring_queue_init_params() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>entries: <span class="tok-type">u16</span></code></pre></div><div><pre><code>p: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.init_params">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init_params</span>(entries: <span class="tok-type">u16</span>, p: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a>) !<a href="std.os.linux.IoUring.html">IoUring</a> {
    <span class="tok-kw">if</span> (entries == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EntriesZero;
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(entries)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EntriesNotPowerOfTwo;

    <a href="std.debug.html#std.debug.assert">assert</a>(p.sq_entries == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.cq_entries == <span class="tok-number">0</span> <span class="tok-kw">or</span> p.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SETUP_CQSIZE">IORING_SETUP_CQSIZE</a> != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.features == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.wq_fd == <span class="tok-number">0</span> <span class="tok-kw">or</span> p.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SETUP_ATTACH_WQ">IORING_SETUP_ATTACH_WQ</a> != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.resv[<span class="tok-number">0</span>] == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.resv[<span class="tok-number">1</span>] == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.resv[<span class="tok-number">2</span>] == <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_setup">io_uring_setup</a>(entries, p);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},
        .FAULT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParamsOutsideAccessibleAddressSpace,<span class="tok-comment">
        // The resv array contains non-zero data, p.flags contains an unsupported flag,
        // entries out of bounds, IORING_SETUP_SQ_AFF was specified without IORING_SETUP_SQPOLL,
        // or IORING_SETUP_CQSIZE was specified but linux.io_uring_params.cq_entries was invalid:
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ArgumentsInvalid,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,<span class="tok-comment">
        // IORING_SETUP_SQPOLL was specified but effective user ID lacks sufficient privileges,
        // or a container seccomp policy prohibits io_uring syscalls:
        </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemOutdated,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
    <span class="tok-kw">const</span> fd = <span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, <span class="tok-builtin">@intCast</span>(res));
    <a href="std.debug.html#std.debug.assert">assert</a>(fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);<span class="tok-comment">

    // Kernel versions 5.4 and up use only one mmap() for the submission and completion queues.
    // This is not an optional feature for us... if the kernel does it, we have to do it.
    // The thinking on this by the kernel developers was that both the submission and the
    // completion queue rings have sizes just over a power of two, but the submission queue ring
    // is significantly smaller with u32 slots. By bundling both in a single mmap, the kernel
    // gets the submission queue ring for free.
    // See https://patchwork.kernel.org/patch/11115257 for the kernel patch.
    // We do not support the double mmap() done before 5.4, because we want to keep the
    // init/deinit mmap paths simple and because io_uring has had many bug fixes even since 5.4.
    </span><span class="tok-kw">if</span> ((p.features &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_FEAT_SINGLE_MMAP">IORING_FEAT_SINGLE_MMAP</a>) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemOutdated;
    }<span class="tok-comment">

    // Check that the kernel has actually set params and that &quot;impossible is nothing&quot;.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(p.sq_entries != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.cq_entries != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.cq_entries &gt;= p.sq_entries);<span class="tok-comment">

    // From here on, we only need to read from params, so pass `p` by value as immutable.
    // The completion queue shares the mmap with the submission queue, so pass `sq` there too.
    </span><span class="tok-kw">var</span> sq = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.SubmissionQueue.html">SubmissionQueue</a>.<a href="std.os.linux.IoUring.SubmissionQueue.html#std.os.linux.IoUring.SubmissionQueue.init">init</a>(fd, p.*);
    <span class="tok-kw">errdefer</span> sq.deinit();
    <span class="tok-kw">var</span> cq = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.CompletionQueue.html">CompletionQueue</a>.<a href="std.os.linux.IoUring.CompletionQueue.html#std.os.linux.IoUring.CompletionQueue.init">init</a>(fd, p.*, sq);
    <span class="tok-kw">errdefer</span> cq.deinit();<span class="tok-comment">

    // Check that our starting state is as we expect.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(sq.head.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.tail.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.mask == p.sq_entries - <span class="tok-number">1</span>);<span class="tok-comment">
    // Allow flags.* to be non-zero, since the kernel may set IORING_SQ_NEED_WAKEUP at any time.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(sq.dropped.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.array.len == p.sq_entries);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.sqes.len == p.sq_entries);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.sqe_head == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.sqe_tail == <span class="tok-number">0</span>);

    <a href="std.debug.html#std.debug.assert">assert</a>(cq.head.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(cq.tail.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(cq.mask == p.cq_entries - <span class="tok-number">1</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(cq.overflow.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(cq.cqes.len == p.cq_entries);

    <span class="tok-kw">return</span> <a href="std.os.linux.IoUring.html">IoUring</a>{
        .fd = fd,
        .sq = sq,
        .cq = cq,
        .flags = p.flags,
        .features = p.features,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.os.linux.IoUring.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);<span class="tok-comment">
    // The mmaps depend on the fd, so the order of these calls is important:
    </span>self.cq.deinit();
    self.sq.deinit();
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.fd);
    self.fd = -<span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.get_sqe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get_sqe</span><a href="#src.zig-std.os.linux.IoUring.get_sqe">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get_sqe</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Returns a pointer to a vacant SQE, or an error if the submission queue is full.
We follow the implementation (and atomics) of liburing's <code>io_uring_get_sqe()</code> exactly.
However, instead of a null we return an error to force safe handling.
Any situation where the submission queue is full tends more towards a control flow error,
and the null return in liburing is more a C idiom than anything else, for lack of a better
alternative. In Zig, we have first-class error handling... so let's use it.
Matches the implementation of io_uring_get_sqe() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.get_sqe">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get_sqe</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> head = <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.sq.head, .acquire);<span class="tok-comment">
    // Remember that these head and tail offsets wrap around every four billion operations.
    // We must therefore use wrapping addition and subtraction to avoid a runtime crash.
    </span><span class="tok-kw">const</span> next = self.sq.sqe_tail +% <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (next -% head &gt; self.sq.sqes.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SubmissionQueueFull;
    <span class="tok-kw">const</span> sqe = &amp;self.sq.sqes[self.sq.sqe_tail &amp; self.sq.mask];
    self.sq.sqe_tail = next;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.submit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">submit</span><a href="#src.zig-std.os.linux.IoUring.submit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">submit</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Submits the SQEs acquired via get_sqe() to the kernel. You can call this once after you have
called get_sqe() multiple times to setup multiple I/O requests.
Returns the number of SQEs submitted, if not used alongside IORING_SETUP_SQPOLL.
If the io_uring instance is uses IORING_SETUP_SQPOLL, the value returned on success is not
guaranteed to match the amount of actually submitted sqes during this call. A value higher
or lower, including 0, may be returned.
Matches the implementation of io_uring_submit() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.submit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">submit</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> self.submit_and_wait(<span class="tok-number">0</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.submit_and_wait" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">submit_and_wait</span><a href="#src.zig-std.os.linux.IoUring.submit_and_wait">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">submit_and_wait</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, wait_nr: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Like submit(), but allows waiting for events as well.
Returns the number of SQEs submitted.
Matches the implementation of io_uring_submit_and_wait() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>wait_nr: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.submit_and_wait">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">submit_and_wait</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, wait_nr: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> submitted = self.flush_sq();
    <span class="tok-kw">var</span> flags: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (self.sq_ring_needs_enter(&amp;flags) <span class="tok-kw">or</span> wait_nr &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (wait_nr &gt; <span class="tok-number">0</span> <span class="tok-kw">or</span> (self.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SETUP_IOPOLL">IORING_SETUP_IOPOLL</a>) != <span class="tok-number">0</span>) {
            flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_ENTER_GETEVENTS">IORING_ENTER_GETEVENTS</a>;
        }
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.enter(submitted, wait_nr, flags);
    }
    <span class="tok-kw">return</span> submitted;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.enter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">enter</span><a href="#src.zig-std.os.linux.IoUring.enter">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enter</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, to_submit: <span class="tok-type">u32</span>, min_complete: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Tell the kernel we have submitted SQEs and/or want to wait for CQEs.
Returns the number of SQEs submitted.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>to_submit: <span class="tok-type">u32</span></code></pre></div><div><pre><code>min_complete: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.enter">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enter</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, to_submit: <span class="tok-type">u32</span>, min_complete: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_enter">io_uring_enter</a>(self.fd, to_submit, min_complete, flags, <span class="tok-null">null</span>);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // The kernel was unable to allocate memory or ran out of resources for the request.
        // The application should wait for some completions and try again:
        </span>.AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,<span class="tok-comment">
        // The SQE `fd` is invalid, or IOSQE_FIXED_FILE was set but no files were registered:
        </span>.BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorInvalid,<span class="tok-comment">
        // The file descriptor is valid, but the ring is not in the right state.
        // See io_uring_register(2) for how to enable the ring.
        </span>.BADFD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorInBadState,<span class="tok-comment">
        // The application attempted to overcommit the number of requests it can have pending.
        // The application should wait for some completions and try again:
        </span>.BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CompletionQueueOvercommitted,<span class="tok-comment">
        // The SQE is invalid, or valid but the ring was setup with IORING_SETUP_IOPOLL:
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SubmissionQueueEntryInvalid,<span class="tok-comment">
        // The buffer is outside the process' accessible address space, or IORING_OP_READ_FIXED
        // or IORING_OP_WRITE_FIXED was specified but no buffers were registered, or the range
        // described by `addr` and `len` is not within the buffer registered at `buf_index`:
        </span>.FAULT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferInvalid,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RingShuttingDown,<span class="tok-comment">
        // The kernel believes our `self.fd` does not refer to an io_uring instance,
        // or the opcode is valid but not supported by this kernel (more likely):
        </span>.OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OpcodeNotSupported,<span class="tok-comment">
        // The operation was interrupted by a delivery of a signal before it could complete.
        // This can happen while waiting for events with IORING_ENTER_GETEVENTS:
        </span>.INTR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SignalInterrupt,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(res));
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.flush_sq" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">flush_sq</span><a href="#src.zig-std.os.linux.IoUring.flush_sq">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flush_sq</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Sync internal state with kernel ring state on the SQ side.
Returns the number of all pending events in the SQ ring, for the shared ring.
This return value includes previously flushed SQEs, as per liburing.
The rationale is to suggest that an io_uring_enter() call is needed rather than not.
Matches the implementation of __io_uring_flush_sq() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.flush_sq">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flush_sq</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (self.sq.sqe_head != self.sq.sqe_tail) {<span class="tok-comment">
        // Fill in SQEs that we have queued up, adding them to the kernel ring.
        </span><span class="tok-kw">const</span> to_submit = self.sq.sqe_tail -% self.sq.sqe_head;
        <span class="tok-kw">var</span> tail = self.sq.tail.*;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; to_submit) : (i += <span class="tok-number">1</span>) {
            self.sq.array[tail &amp; self.sq.mask] = self.sq.sqe_head &amp; self.sq.mask;
            tail +%= <span class="tok-number">1</span>;
            self.sq.sqe_head +%= <span class="tok-number">1</span>;
        }<span class="tok-comment">
        // Ensure that the kernel can actually see the SQE updates when it sees the tail update.
        </span><span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, self.sq.tail, tail, .release);
    }
    <span class="tok-kw">return</span> self.sq_ready();
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.sq_ring_needs_enter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sq_ring_needs_enter</span><a href="#src.zig-std.os.linux.IoUring.sq_ring_needs_enter">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq_ring_needs_enter</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, flags: *<span class="tok-type">u32</span>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns true if we are not using an SQ thread (thus nobody submits but us),
or if IORING_SQ_NEED_WAKEUP is set and the SQ thread must be explicitly awakened.
For the latter case, we set the SQ thread wakeup flag.
Matches the implementation of sq_ring_needs_enter() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>flags: *<span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.sq_ring_needs_enter">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq_ring_needs_enter</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, flags: *<span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(flags.* == <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> ((self.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SETUP_SQPOLL">IORING_SETUP_SQPOLL</a>) == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> ((<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.sq.flags, .unordered) &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SQ_NEED_WAKEUP">IORING_SQ_NEED_WAKEUP</a>) != <span class="tok-number">0</span>) {
        flags.* |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_ENTER_SQ_WAKEUP">IORING_ENTER_SQ_WAKEUP</a>;
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.sq_ready" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sq_ready</span><a href="#src.zig-std.os.linux.IoUring.sq_ready">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq_ready</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Returns the number of flushed and unflushed SQEs pending in the submission queue.
In other words, this is the number of SQEs in the submission queue, i.e. its length.
These are SQEs that the kernel is yet to consume.
Matches the implementation of io_uring_sq_ready in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.sq_ready">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq_ready</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span> {<span class="tok-comment">
    // Always use the shared ring state (i.e. head and not sqe_head) to avoid going out of sync,
    // see https://github.com/axboe/liburing/issues/92.
    </span><span class="tok-kw">return</span> self.sq.sqe_tail -% <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.sq.head, .acquire);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.cq_ready" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cq_ready</span><a href="#src.zig-std.os.linux.IoUring.cq_ready">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_ready</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Returns the number of CQEs in the completion queue, i.e. its length.
These are CQEs that the application is yet to consume.
Matches the implementation of io_uring_cq_ready in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.cq_ready">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_ready</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.cq.tail, .acquire) -% self.cq.head.*;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.copy_cqes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copy_cqes</span><a href="#src.zig-std.os.linux.IoUring.copy_cqes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_cqes</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, cqes: []<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>, wait_nr: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span></code></pre></div><div class="tldDocs"><p>Copies as many CQEs as are ready, and that can fit into the destination <code>cqes</code> slice.
If none are available, enters into the kernel to wait for at most <code>wait_nr</code> CQEs.
Returns the number of CQEs copied, advancing the CQ ring.
Provides all the wait/peek methods found in liburing, but with batching and a single method.
The rationale for copying CQEs rather than copying pointers is that pointers are 8 bytes
whereas CQEs are not much more at only 16 bytes, and this provides a safer faster interface.
Safer, because you no longer need to call cqe_seen(), avoiding idempotency bugs.
Faster, because we can now amortize the atomic store release to <code>cq.head</code> across the batch.
See <a href="https://github.com/axboe/liburing/issues/103#issuecomment-686665007">https://github.com/axboe/liburing/issues/103#issuecomment-686665007</a>.
Matches the implementation of io_uring_peek_batch_cqe() in liburing, but supports waiting.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>cqes: []<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a></code></pre></div><div><pre><code>wait_nr: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.copy_cqes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_cqes</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, cqes: []<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>, wait_nr: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> count = self.copy_cqes_ready(cqes);
    <span class="tok-kw">if</span> (count &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> count;
    <span class="tok-kw">if</span> (self.cq_ring_needs_flush() <span class="tok-kw">or</span> wait_nr &gt; <span class="tok-number">0</span>) {
        _ = <span class="tok-kw">try</span> self.enter(<span class="tok-number">0</span>, wait_nr, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_ENTER_GETEVENTS">IORING_ENTER_GETEVENTS</a>);
        <span class="tok-kw">return</span> self.copy_cqes_ready(cqes);
    }
    <span class="tok-kw">return</span> <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.copy_cqe" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copy_cqe</span><a href="#src.zig-std.os.linux.IoUring.copy_cqe">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_cqe</span>(ring: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a></code></pre></div><div class="tldDocs"><p>Returns a copy of an I/O completion, waiting for it if necessary, and advancing the CQ ring.
A convenience method for <code>copy_cqes()</code> for when you don't need to batch or peek.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ring: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.copy_cqe">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_cqe</span>(ring: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> {
    <span class="tok-kw">var</span> cqes: [<span class="tok-number">1</span>]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> count = <span class="tok-kw">try</span> ring.copy_cqes(&amp;cqes, <span class="tok-number">1</span>);
        <span class="tok-kw">if</span> (count &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> cqes[<span class="tok-number">0</span>];
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.cq_ring_needs_flush" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cq_ring_needs_flush</span><a href="#src.zig-std.os.linux.IoUring.cq_ring_needs_flush">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_ring_needs_flush</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Matches the implementation of cq_ring_needs_flush() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.cq_ring_needs_flush">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_ring_needs_flush</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> (<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.sq.flags, .unordered) &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SQ_CQ_OVERFLOW">IORING_SQ_CQ_OVERFLOW</a>) != <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.cqe_seen" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cqe_seen</span><a href="#src.zig-std.os.linux.IoUring.cqe_seen">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cqe_seen</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, cqe: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>For advanced use cases only that implement custom completion queue methods.
If you use copy_cqes() or copy_cqe() you must not call cqe_seen() or cq_advance().
Must be called exactly once after a zero-copy CQE has been processed by your application.
Not idempotent, calling more than once will result in other CQEs being lost.
Matches the implementation of cqe_seen() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>cqe: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.cqe_seen">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cqe_seen</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, cqe: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>) <span class="tok-type">void</span> {
    _ = cqe;
    self.cq_advance(<span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.cq_advance" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cq_advance</span><a href="#src.zig-std.os.linux.IoUring.cq_advance">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_advance</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, count: <span class="tok-type">u32</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>For advanced use cases only that implement custom completion queue methods.
Matches the implementation of cq_advance() in liburing.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>count: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.cq_advance">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_advance</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, count: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (count &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
        // Ensure the kernel only sees the new head value after the CQEs have been read.
        </span><span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, self.cq.head, self.cq.head.* +% count, .release);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.fsync" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fsync</span><a href="#src.zig-std.os.linux.IoUring.fsync">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fsync</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, flags: <span class="tok-type">u32</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform an <code>fsync(2)</code>.
Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.
For example, for <code>fdatasync()</code> you can set <code>IORING_FSYNC_DATASYNC</code> in the SQE's <code>rw_flags</code>.
N.B. While SQEs are initiated in the order in which they appear in the submission queue,
operations execute in parallel and completions are unordered. Therefore, an application that
submits a write followed by an fsync in the submission queue cannot expect the fsync to
apply to the write, since the fsync may complete before the write is issued to the disk.
You should preferably use <code>link_with_next_sqe()</code> on a write's SQE to link it with an fsync,
or else insert a full write barrier using <code>drain_previous_sqes()</code> when queueing an fsync.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.fsync">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fsync</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, flags: <span class="tok-type">u32</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_fsync(fd, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.nop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nop</span><a href="#src.zig-std.os.linux.IoUring.nop">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nop</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a no-op.
Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.
A no-op is more useful than may appear at first glance.
For example, you could call <code>drain_previous_sqes()</code> on the returned SQE, to use the no-op to
know when the ring is idle before acting on a kill signal.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.nop">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nop</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_nop();
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.read" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">read</span><a href="#src.zig-std.os.linux.IoUring.read">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, buffer: <a href="std.os.linux.IoUring.ReadBuffer.html">ReadBuffer</a>, offset: <span class="tok-type">u64</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>read(2)</code> or <code>preadv(2)</code> depending on the buffer type.</p>
<ul>
<li>Reading into a <code>ReadBuffer.buffer</code> uses <code>read(2)</code></li>
<li>Reading into a <code>ReadBuffer.iovecs</code> uses <code>preadv(2)</code>
If you want to do a <code>preadv2(2)</code> then set <code>rw_flags</code> on the returned SQE. See <a href="https://man7.org/linux/man-pages/man2/preadv2.2.html">https://man7.org/linux/man-pages/man2/preadv2.2.html</a></li>
</ul>
<p>Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buffer: <a href="std.os.linux.IoUring.ReadBuffer.html">ReadBuffer</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.read">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: <a href="std.os.linux.IoUring.ReadBuffer.html">ReadBuffer</a>,
    offset: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    <span class="tok-kw">switch</span> (buffer) {
        .buffer =&gt; |slice| sqe.prep_read(fd, slice, offset),
        .iovecs =&gt; |vecs| sqe.prep_readv(fd, vecs, offset),
        .buffer_selection =&gt; |selection| {
            sqe.prep_rw(.READ, fd, <span class="tok-number">0</span>, selection.len, offset);
            sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>;
            sqe.buf_index = selection.group_id;
        },
    }
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.write" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">write</span><a href="#src.zig-std.os.linux.IoUring.write">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>write(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.write">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    offset: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_write(fd, buffer, offset);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.splice" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splice</span><a href="#src.zig-std.os.linux.IoUring.splice">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splice</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd_in: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_in: <span class="tok-type">u64</span>, fd_out: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_out: <span class="tok-type">u64</span>, len: <span class="tok-type">usize</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>splice(2)</code>
Either <code>fd_in</code> or <code>fd_out</code> must be a pipe.
If <code>fd_in</code> refers to a pipe, <code>off_in</code> is ignored and must be set to std.math.maxInt(u64).
If <code>fd_in</code> does not refer to a pipe and <code>off_in</code> is maxInt(u64), then <code>len</code> are read
from <code>fd_in</code> starting from the file offset, which is incremented by the number of bytes read.
If <code>fd_in</code> does not refer to a pipe and <code>off_in</code> is not maxInt(u64), then the starting offset of <code>fd_in</code> will be <code>off_in</code>.
This splice operation can be used to implement sendfile by splicing to an intermediate pipe first,
then splice to the final destination. In fact, the implementation of sendfile in kernel uses splice internally.</p>
<p>NOTE that even if fd_in or fd_out refers to a pipe, the splice operation can still fail with EINVAL if one of the
fd doesn't explicitly support splice peration, e.g. reading from terminal is unsupported from kernel 5.7 to 5.11.
See <a href="https://github.com/axboe/liburing/issues/291">https://github.com/axboe/liburing/issues/291</a></p>
<p>Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd_in: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>off_in: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd_out: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>off_out: <span class="tok-type">u64</span></code></pre></div><div><pre><code>len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.splice">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splice</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd_in: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_in: <span class="tok-type">u64</span>, fd_out: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_out: <span class="tok-type">u64</span>, len: <span class="tok-type">usize</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_splice(fd_in, off_in, fd_out, off_out, len);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.read_fixed" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">read_fixed</span><a href="#src.zig-std.os.linux.IoUring.read_fixed">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read_fixed</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, buffer: *<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>, buffer_index: <span class="tok-type">u16</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a IORING_OP_READ_FIXED.
The <code>buffer</code> provided must be registered with the kernel by calling <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.register_buffers">register_buffers</a></code> first.
The <code>buffer_index</code> must be the same as its index in the array provided to <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.register_buffers">register_buffers</a></code>.</p>
<p>Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buffer: *<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>buffer_index: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.read_fixed">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read_fixed</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: *<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>,
    offset: <span class="tok-type">u64</span>,
    buffer_index: <span class="tok-type">u16</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_read_fixed(fd, buffer, offset, buffer_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.writev" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writev</span><a href="#src.zig-std.os.linux.IoUring.writev">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>pwritev()</code>.
Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.
For example, if you want to do a <code>pwritev2()</code> then set <code>rw_flags</code> on the returned SQE.
See <a href="https://linux.die.net/man/2/pwritev">https://linux.die.net/man/2/pwritev</a>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.writev">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>,
    offset: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_writev(fd, iovecs, offset);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.write_fixed" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">write_fixed</span><a href="#src.zig-std.os.linux.IoUring.write_fixed">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write_fixed</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, buffer: *<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>, buffer_index: <span class="tok-type">u16</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a IORING_OP_WRITE_FIXED.
The <code>buffer</code> provided must be registered with the kernel by calling <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.register_buffers">register_buffers</a></code> first.
The <code>buffer_index</code> must be the same as its index in the array provided to <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.register_buffers">register_buffers</a></code>.</p>
<p>Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buffer: *<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>buffer_index: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.write_fixed">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write_fixed</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: *<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>,
    offset: <span class="tok-type">u64</span>,
    buffer_index: <span class="tok-type">u16</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_write_fixed(fd, buffer, offset, buffer_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.accept" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accept</span><a href="#src.zig-std.os.linux.IoUring.accept">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform an <code>accept4(2)</code> on a socket.
Returns a pointer to the SQE.
Available since 5.5</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.accept">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_accept(fd, addr, addrlen, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.accept_multishot" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accept_multishot</span><a href="#src.zig-std.os.linux.IoUring.accept_multishot">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_multishot</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues an multishot accept on a socket.</p>
<p>Multishot variant allows an application to issue a single accept request,
which will repeatedly trigger a CQE when a connection request comes in.
While IORING_CQE_F_MORE flag is set in CQE flags accept will generate
further CQEs.</p>
<p>Available since 5.19</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.accept_multishot">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_multishot</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_multishot_accept(fd, addr, addrlen, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.accept_direct" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accept_direct</span><a href="#src.zig-std.os.linux.IoUring.accept_direct">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_direct</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues an accept using direct (registered) file descriptors.</p>
<p>To use an accept direct variant, the application must first have registered
a file table (with register_files). An unused table index will be
dynamically chosen and returned in the CQE res field.</p>
<p>After creation, they can be used by setting IOSQE_FIXED_FILE in the SQE
flags member, and setting the SQE fd field to the direct descriptor value
rather than the regular file descriptor.</p>
<p>Available since 5.19</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.accept_direct">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_direct</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_accept_direct(fd, addr, addrlen, flags, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_FILE_INDEX_ALLOC">IORING_FILE_INDEX_ALLOC</a>);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.accept_multishot_direct" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">accept_multishot_direct</span><a href="#src.zig-std.os.linux.IoUring.accept_multishot_direct">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_multishot_direct</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues an multishot accept using direct (registered) file descriptors.
Available since 5.19</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.accept_multishot_direct">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_multishot_direct</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_multishot_accept_direct(fd, addr, addrlen, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.connect" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">connect</span><a href="#src.zig-std.os.linux.IoUring.connect">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, addr: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>, addrlen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queue (but does not submit) an SQE to perform a <code>connect(2)</code> on a socket.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>addr: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a></code></pre></div><div><pre><code>addrlen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.connect">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_connect(fd, addr, addrlen);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.epoll_ctl" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">epoll_ctl</span><a href="#src.zig-std.os.linux.IoUring.epoll_ctl">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_ctl</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, epfd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, op: <span class="tok-type">u32</span>, ev: ?*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.epoll_event.html">epoll_event</a>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>epoll_ctl(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>epfd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>op: <span class="tok-type">u32</span></code></pre></div><div><pre><code>ev: ?*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.epoll_event.html">epoll_event</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.epoll_ctl">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_ctl</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    epfd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    op: <span class="tok-type">u32</span>,
    ev: ?*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.epoll_event.html">epoll_event</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_epoll_ctl(epfd, fd, op, ev);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.recv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">recv</span><a href="#src.zig-std.os.linux.IoUring.recv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recv</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, buffer: <a href="std.os.linux.IoUring.RecvBuffer.html">RecvBuffer</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>recv(2)</code>.
Returns a pointer to the SQE.
Available since 5.6</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buffer: <a href="std.os.linux.IoUring.RecvBuffer.html">RecvBuffer</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.recv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recv</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: <a href="std.os.linux.IoUring.RecvBuffer.html">RecvBuffer</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    <span class="tok-kw">switch</span> (buffer) {
        .buffer =&gt; |slice| sqe.prep_recv(fd, slice, flags),
        .buffer_selection =&gt; |selection| {
            sqe.prep_rw(.RECV, fd, <span class="tok-number">0</span>, selection.len, <span class="tok-number">0</span>);
            sqe.rw_flags = flags;
            sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>;
            sqe.buf_index = selection.group_id;
        },
    }
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.send" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">send</span><a href="#src.zig-std.os.linux.IoUring.send">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>send(2)</code>.
Returns a pointer to the SQE.
Available since 5.6</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.send">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_send(fd, buffer, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.send_zc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">send_zc</span><a href="#src.zig-std.os.linux.IoUring.send_zc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send_zc</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, send_flags: <span class="tok-type">u32</span>, zc_flags: <span class="tok-type">u16</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform an async zerocopy <code>send(2)</code>.</p>
<p>This operation will most likely produce two CQEs. The flags field of the
first cqe may likely contain IORING_CQE_F_MORE, which means that there will
be a second cqe with the user_data field set to the same value. The user
must not modify the data buffer until the notification is posted. The first
cqe follows the usual rules and so its res field will contain the number of
bytes sent or a negative error code. The notification's res field will be
set to zero and the flags field will contain IORING_CQE_F_NOTIF. The two
step model is needed because the kernel may hold on to buffers for a long
time, e.g. waiting for a TCP ACK. Notifications responsible for controlling
the lifetime of the buffers. Even errored requests may generate a
notification.</p>
<p>Available since 6.0</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>send_flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>zc_flags: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.send_zc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send_zc</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    send_flags: <span class="tok-type">u32</span>,
    zc_flags: <span class="tok-type">u16</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_send_zc(fd, buffer, send_flags, zc_flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.send_zc_fixed" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">send_zc_fixed</span><a href="#src.zig-std.os.linux.IoUring.send_zc_fixed">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send_zc_fixed</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, send_flags: <span class="tok-type">u32</span>, zc_flags: <span class="tok-type">u16</span>, buf_index: <span class="tok-type">u16</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform an async zerocopy <code>send(2)</code>.
Returns a pointer to the SQE.
Available since 6.0</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>send_flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>zc_flags: <span class="tok-type">u16</span></code></pre></div><div><pre><code>buf_index: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.send_zc_fixed">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send_zc_fixed</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    send_flags: <span class="tok-type">u32</span>,
    zc_flags: <span class="tok-type">u16</span>,
    buf_index: <span class="tok-type">u16</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_send_zc_fixed(fd, buffer, send_flags, zc_flags, buf_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.recvmsg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">recvmsg</span><a href="#src.zig-std.os.linux.IoUring.recvmsg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recvmsg</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, msg: *<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr">msghdr</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>recvmsg(2)</code>.
Returns a pointer to the SQE.
Available since 5.3</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>msg: *<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr">msghdr</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.recvmsg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recvmsg</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    msg: *<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr">msghdr</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_recvmsg(fd, msg, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.sendmsg" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sendmsg</span><a href="#src.zig-std.os.linux.IoUring.sendmsg">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, msg: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>sendmsg(2)</code>.
Returns a pointer to the SQE.
Available since 5.3</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>msg: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.sendmsg">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    msg: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_sendmsg(fd, msg, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.sendmsg_zc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sendmsg_zc</span><a href="#src.zig-std.os.linux.IoUring.sendmsg_zc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg_zc</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, msg: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform an async zerocopy <code>sendmsg(2)</code>.
Returns a pointer to the SQE.
Available since 6.1</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>msg: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.sendmsg_zc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg_zc</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    msg: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_sendmsg_zc(fd, msg, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.openat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openat</span><a href="#src.zig-std.os.linux.IoUring.openat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a>, mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform an <code>openat(2)</code>.
Returns a pointer to the SQE.
Available since 5.6.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a></code></pre></div><div><pre><code>mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.openat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a>,
    mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_openat(fd, path, flags, mode);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.openat_direct" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">openat_direct</span><a href="#src.zig-std.os.linux.IoUring.openat_direct">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat_direct</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a>, mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>, file_index: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues an openat using direct (registered) file descriptors.</p>
<p>To use an accept direct variant, the application must first have registered
a file table (with register_files). An unused table index will be
dynamically chosen and returned in the CQE res field.</p>
<p>After creation, they can be used by setting IOSQE_FIXED_FILE in the SQE
flags member, and setting the SQE fd field to the direct descriptor value
rather than the regular file descriptor.</p>
<p>Available since 5.15</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a></code></pre></div><div><pre><code>mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div><div><pre><code>file_index: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.openat_direct">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat_direct</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a>,
    mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>,
    file_index: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_openat_direct(fd, path, flags, mode, file_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.close" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">close</span><a href="#src.zig-std.os.linux.IoUring.close">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>close(2)</code>.
Returns a pointer to the SQE.
Available since 5.6.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.close">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_close(fd);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.close_direct" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">close_direct</span><a href="#src.zig-std.os.linux.IoUring.close_direct">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close_direct</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, file_index: <span class="tok-type">u32</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues close of registered file descriptor.
Available since 5.15</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>file_index: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.close_direct">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close_direct</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, file_index: <span class="tok-type">u32</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_close_direct(file_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.timeout" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">timeout</span><a href="#src.zig-std.os.linux.IoUring.timeout">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timeout</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, ts: *<span class="tok-kw">const</span> <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a>, count: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to register a timeout operation.
Returns a pointer to the SQE.</p>
<p>The timeout will complete when either the timeout expires, or after the specified number of
events complete (if <code>count</code> is greater than <code>0</code>).</p>
<p><code>flags</code> may be <code>0</code> for a relative timeout, or <code>IORING_TIMEOUT_ABS</code> for an absolute timeout.</p>
<p>The completion event result will be <code>-ETIME</code> if the timeout completed through expiration,
<code>0</code> if the timeout completed after the specified number of events, or <code>-ECANCELED</code> if the
timeout was removed before it expired.</p>
<p>io_uring timeouts use the <code>CLOCK.MONOTONIC</code> clock source.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>ts: *<span class="tok-kw">const</span> <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a></code></pre></div><div><pre><code>count: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.timeout">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timeout</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    ts: *<span class="tok-kw">const</span> <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a>,
    count: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_timeout(ts, count, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.timeout_remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">timeout_remove</span><a href="#src.zig-std.os.linux.IoUring.timeout_remove">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timeout_remove</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, timeout_user_data: <span class="tok-type">u64</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to remove an existing timeout operation.
Returns a pointer to the SQE.</p>
<p>The timeout is identified by its <code>user_data</code>.</p>
<p>The completion event result will be <code>0</code> if the timeout was found and cancelled successfully,
<code>-EBUSY</code> if the timeout was found but expiration was already in progress, or
<code>-ENOENT</code> if the timeout was not found.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>timeout_user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.timeout_remove">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timeout_remove</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    timeout_user_data: <span class="tok-type">u64</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_timeout_remove(timeout_user_data, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.link_timeout" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">link_timeout</span><a href="#src.zig-std.os.linux.IoUring.link_timeout">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">link_timeout</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, ts: *<span class="tok-kw">const</span> <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to add a link timeout operation.
Returns a pointer to the SQE.</p>
<p>You need to set linux.IOSQE_IO_LINK to flags of the target operation
and then call this method right after the target operation.
See <a href="https://lwn.net/Articles/803932/">https://lwn.net/Articles/803932/</a> for detail.</p>
<p>If the dependent request finishes before the linked timeout, the timeout
is canceled. If the timeout finishes before the dependent request, the
dependent request will be canceled.</p>
<p>The completion event result of the link_timeout will be
<code>-ETIME</code> if the timeout finishes before the dependent request
(in this case, the completion event result of the dependent request will
be <code>-ECANCELED</code>), or
<code>-EALREADY</code> if the dependent request finishes before the linked timeout.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>ts: *<span class="tok-kw">const</span> <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.link_timeout">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">link_timeout</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    ts: *<span class="tok-kw">const</span> <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_link_timeout(ts, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.poll_add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">poll_add</span><a href="#src.zig-std.os.linux.IoUring.poll_add">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_add</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, poll_mask: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>poll(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>poll_mask: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.poll_add">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_add</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    poll_mask: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_poll_add(fd, poll_mask);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.poll_remove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">poll_remove</span><a href="#src.zig-std.os.linux.IoUring.poll_remove">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_remove</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, target_user_data: <span class="tok-type">u64</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to remove an existing poll operation.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>target_user_data: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.poll_remove">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_remove</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    target_user_data: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_poll_remove(target_user_data);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.poll_update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">poll_update</span><a href="#src.zig-std.os.linux.IoUring.poll_update">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_update</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, old_user_data: <span class="tok-type">u64</span>, new_user_data: <span class="tok-type">u64</span>, poll_mask: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to update the user data of an existing poll
operation. Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>old_user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>new_user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>poll_mask: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.poll_update">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_update</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    old_user_data: <span class="tok-type">u64</span>,
    new_user_data: <span class="tok-type">u64</span>,
    poll_mask: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_poll_update(old_user_data, new_user_data, poll_mask, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.fallocate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fallocate</span><a href="#src.zig-std.os.linux.IoUring.fallocate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fallocate</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, mode: <span class="tok-type">i32</span>, offset: <span class="tok-type">u64</span>, len: <span class="tok-type">u64</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform an <code>fallocate(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>mode: <span class="tok-type">i32</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>len: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.fallocate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fallocate</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    mode: <span class="tok-type">i32</span>,
    offset: <span class="tok-type">u64</span>,
    len: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_fallocate(fd, mode, offset, len);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.statx" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">statx</span><a href="#src.zig-std.os.linux.IoUring.statx">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statx</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>, mask: <span class="tok-type">u32</span>, buf: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform an <code>statx(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>path: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>mask: <span class="tok-type">u32</span></code></pre></div><div><pre><code>buf: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.statx">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statx</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
    mask: <span class="tok-type">u32</span>,
    buf: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_statx(fd, path, flags, mask, buf);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.cancel" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cancel</span><a href="#src.zig-std.os.linux.IoUring.cancel">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cancel</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, cancel_user_data: <span class="tok-type">u64</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to remove an existing operation.
Returns a pointer to the SQE.</p>
<p>The operation is identified by its <code>user_data</code>.</p>
<p>The completion event result will be <code>0</code> if the operation was found and cancelled successfully,
<code>-EALREADY</code> if the operation was found but was already in progress, or
<code>-ENOENT</code> if the operation was not found.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>cancel_user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.cancel">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cancel</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    cancel_user_data: <span class="tok-type">u64</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_cancel(cancel_user_data, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.shutdown" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shutdown</span><a href="#src.zig-std.os.linux.IoUring.shutdown">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shutdown</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, sockfd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a>, how: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>shutdown(2)</code>.
Returns a pointer to the SQE.</p>
<p>The operation is identified by its <code>user_data</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>sockfd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a></code></pre></div><div><pre><code>how: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.shutdown">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shutdown</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    sockfd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    how: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_shutdown(sockfd, how);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.renameat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">renameat</span><a href="#src.zig-std.os.linux.IoUring.renameat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameat</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, old_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>renameat2(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>old_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.renameat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    old_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_renameat(old_dir_fd, old_path, new_dir_fd, new_path, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.unlinkat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlinkat</span><a href="#src.zig-std.os.linux.IoUring.unlinkat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkat</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>unlinkat(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.unlinkat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_unlinkat(dir_fd, path, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.mkdirat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mkdirat</span><a href="#src.zig-std.os.linux.IoUring.mkdirat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirat</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>mkdirat(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.mkdirat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_mkdirat(dir_fd, path, mode);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.symlinkat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">symlinkat</span><a href="#src.zig-std.os.linux.IoUring.symlinkat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkat</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, target: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>symlinkat(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>target: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.symlinkat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    target: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_symlinkat(target, new_dir_fd, link_path);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.linkat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">linkat</span><a href="#src.zig-std.os.linux.IoUring.linkat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkat</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, old_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>linkat(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>old_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.linkat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    old_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_linkat(old_dir_fd, old_path, new_dir_fd, new_path, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.provide_buffers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">provide_buffers</span><a href="#src.zig-std.os.linux.IoUring.provide_buffers">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">provide_buffers</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, buffers: [*]<span class="tok-type">u8</span>, buffer_size: <span class="tok-type">usize</span>, buffers_count: <span class="tok-type">usize</span>, group_id: <span class="tok-type">usize</span>, buffer_id: <span class="tok-type">usize</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to provide a group of buffers used for commands that read/receive data.
Returns a pointer to the SQE.</p>
<p>Provided buffers can be used in <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.read">read</a></code>, <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.recv">recv</a></code> or <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.recvmsg">recvmsg</a></code> commands via .buffer_selection.</p>
<p>The kernel expects a contiguous block of memory of size (buffers_count * buffer_size).</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>buffers: [*]<span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer_size: <span class="tok-type">usize</span></code></pre></div><div><pre><code>buffers_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>group_id: <span class="tok-type">usize</span></code></pre></div><div><pre><code>buffer_id: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.provide_buffers">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">provide_buffers</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    buffers: [*]<span class="tok-type">u8</span>,
    buffer_size: <span class="tok-type">usize</span>,
    buffers_count: <span class="tok-type">usize</span>,
    group_id: <span class="tok-type">usize</span>,
    buffer_id: <span class="tok-type">usize</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_provide_buffers(buffers, buffer_size, buffers_count, group_id, buffer_id);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.remove_buffers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">remove_buffers</span><a href="#src.zig-std.os.linux.IoUring.remove_buffers">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove_buffers</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, buffers_count: <span class="tok-type">usize</span>, group_id: <span class="tok-type">usize</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to remove a group of provided buffers.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>buffers_count: <span class="tok-type">usize</span></code></pre></div><div><pre><code>group_id: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.remove_buffers">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove_buffers</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    buffers_count: <span class="tok-type">usize</span>,
    group_id: <span class="tok-type">usize</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_remove_buffers(buffers_count, group_id);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.waitid" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">waitid</span><a href="#src.zig-std.os.linux.IoUring.waitid">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitid</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, id_type: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.P.html">P</a>, id: <span class="tok-type">i32</span>, infop: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.siginfo_t">siginfo_t</a>, options: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Queues (but does not submit) an SQE to perform a <code>waitid(2)</code>.
Returns a pointer to the SQE.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>id_type: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.P.html">P</a></code></pre></div><div><pre><code>id: <span class="tok-type">i32</span></code></pre></div><div><pre><code>infop: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.siginfo_t">siginfo_t</a></code></pre></div><div><pre><code>options: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.waitid">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitid</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    id_type: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.P.html">P</a>,
    id: <span class="tok-type">i32</span>,
    infop: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.siginfo_t">siginfo_t</a>,
    options: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_waitid(id_type, id, infop, options, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.register_files" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">register_files</span><a href="#src.zig-std.os.linux.IoUring.register_files">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fds: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Registers an array of file descriptors.
Every time a file descriptor is put in an SQE and submitted to the kernel, the kernel must
retrieve a reference to the file, and once I/O has completed the file reference must be
dropped. The atomic nature of this file reference can be a slowdown for high IOPS workloads.
This slowdown can be avoided by pre-registering file descriptors.
To refer to a registered file descriptor, IOSQE_FIXED_FILE must be set in the SQE's flags,
and the SQE's fd must be set to the index of the file descriptor in the registered array.
Registering file descriptors will wait for the ring to idle.
Files are automatically unregistered by the kernel when the ring is torn down.
An application need unregister only if it wants to register a new array of file descriptors.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>fds: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.register_files">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fds: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_FILES,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(fds.ptr)),
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(fds.len)),
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.register_files_update" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">register_files_update</span><a href="#src.zig-std.os.linux.IoUring.register_files_update">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files_update</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, offset: <span class="tok-type">u32</span>, fds: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Updates registered file descriptors.</p>
<p>Updates are applied starting at the provided offset in the original file descriptors slice.
There are three kind of updates:</p>
<ul>
<li>turning a sparse entry (where the fd is -1) into a real one</li>
<li>removing an existing entry (set the fd to -1)</li>
<li>replacing an existing entry with a new fd
Adding new file descriptors must be done with <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.register_files">register_files</a></code>.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u32</span></code></pre></div><div><pre><code>fds: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.register_files_update">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files_update</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, offset: <span class="tok-type">u32</span>, fds: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> FilesUpdate = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        offset: <span class="tok-type">u32</span>,
        resv: <span class="tok-type">u32</span>,
        fds: <span class="tok-type">u64</span> <span class="tok-kw">align</span>(<span class="tok-number">8</span>),
    };
    <span class="tok-kw">var</span> update = FilesUpdate{
        .offset = offset,
        .resv = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>),
        .fds = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromPtr</span>(fds.ptr)),
    };

    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_FILES_UPDATE,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;update)),
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(fds.len)),
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.register_files_sparse" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">register_files_sparse</span><a href="#src.zig-std.os.linux.IoUring.register_files_sparse">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files_sparse</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, nr_files: <span class="tok-type">u32</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Registers an empty (-1) file table of <code>nr_files</code> number of file descriptors.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>nr_files: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.register_files_sparse">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files_sparse</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, nr_files: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> reg = &amp;<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_rsrc_register.html">io_uring_rsrc_register</a>{
        .nr = nr_files,
        .flags = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_RSRC_REGISTER_SPARSE">IORING_RSRC_REGISTER_SPARSE</a>,
        .resv2 = <span class="tok-number">0</span>,
        .data = <span class="tok-number">0</span>,
        .tags = <span class="tok-number">0</span>,
    };

    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_FILES2,
        <span class="tok-builtin">@ptrCast</span>(reg),
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_rsrc_register.html">io_uring_rsrc_register</a>)),
    );

    <span class="tok-kw">return</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.register_eventfd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">register_eventfd</span><a href="#src.zig-std.os.linux.IoUring.register_eventfd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_eventfd</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Registers the file descriptor for an eventfd that will be notified of completion events on
an io_uring instance.
Only a single a eventfd can be registered at any given point in time.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.register_eventfd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_eventfd</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_EVENTFD,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;fd)),
        <span class="tok-number">1</span>,
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.register_eventfd_async" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">register_eventfd_async</span><a href="#src.zig-std.os.linux.IoUring.register_eventfd_async">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_eventfd_async</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Registers the file descriptor for an eventfd that will be notified of completion events on
an io_uring instance. Notifications are only posted for events that complete in an async manner.
This means that events that complete inline while being submitted do not trigger a notification event.
Only a single eventfd can be registered at any given point in time.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.register_eventfd_async">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_eventfd_async</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_EVENTFD_ASYNC,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;fd)),
        <span class="tok-number">1</span>,
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.unregister_eventfd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unregister_eventfd</span><a href="#src.zig-std.os.linux.IoUring.unregister_eventfd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_eventfd</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unregister the registered eventfd file descriptor.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.unregister_eventfd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_eventfd</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .UNREGISTER_EVENTFD,
        <span class="tok-null">null</span>,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.register_buffers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">register_buffers</span><a href="#src.zig-std.os.linux.IoUring.register_buffers">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_buffers</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, buffers: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Registers an array of buffers for use with <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.read_fixed">read_fixed</a></code> and <code><a href="std.os.linux.IoUring.html#std.os.linux.IoUring.write_fixed">write_fixed</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>buffers: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.register_buffers">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_buffers</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, buffers: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_BUFFERS,
        buffers.ptr,
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(buffers.len)),
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.unregister_buffers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unregister_buffers</span><a href="#src.zig-std.os.linux.IoUring.unregister_buffers">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_buffers</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unregister the registered buffers.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.unregister_buffers">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_buffers</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(self.fd, .UNREGISTER_BUFFERS, <span class="tok-null">null</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BuffersNotRegistered,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.unregister_files" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unregister_files</span><a href="#src.zig-std.os.linux.IoUring.unregister_files">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_files</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Unregisters all registered file descriptors previously associated with the ring.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.unregister_files">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_files</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(self.fd, .UNREGISTER_FILES, <span class="tok-null">null</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FilesNotRegistered,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.socket" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">socket</span><a href="#src.zig-std.os.linux.IoUring.socket">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, domain: <span class="tok-type">u32</span>, socket_type: <span class="tok-type">u32</span>, protocol: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Prepares a socket creation request.
New socket fd will be returned in completion result.
Available since 5.19</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>domain: <span class="tok-type">u32</span></code></pre></div><div><pre><code>socket_type: <span class="tok-type">u32</span></code></pre></div><div><pre><code>protocol: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.socket">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    domain: <span class="tok-type">u32</span>,
    socket_type: <span class="tok-type">u32</span>,
    protocol: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_socket(domain, socket_type, protocol, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.socket_direct" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">socket_direct</span><a href="#src.zig-std.os.linux.IoUring.socket_direct">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket_direct</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, domain: <span class="tok-type">u32</span>, socket_type: <span class="tok-type">u32</span>, protocol: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>, file_index: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Prepares a socket creation request for registered file at index <code>file_index</code>.
Available since 5.19</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>domain: <span class="tok-type">u32</span></code></pre></div><div><pre><code>socket_type: <span class="tok-type">u32</span></code></pre></div><div><pre><code>protocol: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div><div><pre><code>file_index: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.socket_direct">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket_direct</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    domain: <span class="tok-type">u32</span>,
    socket_type: <span class="tok-type">u32</span>,
    protocol: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
    file_index: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_socket_direct(domain, socket_type, protocol, flags, file_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.socket_direct_alloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">socket_direct_alloc</span><a href="#src.zig-std.os.linux.IoUring.socket_direct_alloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket_direct_alloc</span>( self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, domain: <span class="tok-type">u32</span>, socket_type: <span class="tok-type">u32</span>, protocol: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>, ) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a></code></pre></div><div class="tldDocs"><p>Prepares a socket creation request for registered file, index chosen by kernel (file index alloc).
File index will be returned in CQE res field.
Available since 5.19</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.os.linux.IoUring.html">IoUring</a></code></pre></div><div><pre><code>user_data: <span class="tok-type">u64</span></code></pre></div><div><pre><code>domain: <span class="tok-type">u32</span></code></pre></div><div><pre><code>socket_type: <span class="tok-type">u32</span></code></pre></div><div><pre><code>protocol: <span class="tok-type">u32</span></code></pre></div><div><pre><code>flags: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.socket_direct_alloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket_direct_alloc</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    domain: <span class="tok-type">u32</span>,
    socket_type: <span class="tok-type">u32</span>,
    protocol: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_socket_direct_alloc(domain, socket_type, protocol, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.setup_buf_ring" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setup_buf_ring</span><a href="#src.zig-std.os.linux.IoUring.setup_buf_ring">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setup_buf_ring</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, entries: <span class="tok-type">u16</span>, group_id: <span class="tok-type">u16</span>) !*<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a></code></pre></div><div class="tldDocs"><p>Registers a shared buffer ring to be used with provided buffers.
<code>entries</code> number of <code>io_uring_buf</code> structures is mem mapped and shared by kernel.
<code>fd</code> is IO_Uring.fd for which the provided buffer ring is being registered.
<code>entries</code> is the number of entries requested in the buffer ring, must be power of 2.
<code>group_id</code> is the chosen buffer group ID, unique in IO_Uring.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>entries: <span class="tok-type">u16</span></code></pre></div><div><pre><code>group_id: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.setup_buf_ring">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setup_buf_ring</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, entries: <span class="tok-type">u16</span>, group_id: <span class="tok-type">u16</span>) !*<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a> {
    <span class="tok-kw">if</span> (entries == <span class="tok-number">0</span> <span class="tok-kw">or</span> entries &gt; <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">15</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EntriesNotInRange;
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(entries)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EntriesNotPowerOfTwo;

    <span class="tok-kw">const</span> mmap_size = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, entries) * <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf.html">io_uring_buf</a>);
    <span class="tok-kw">const</span> mmap = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mmap">mmap</a>(
        <span class="tok-null">null</span>,
        mmap_size,
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">READ</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">WRITE</a>,
        .{ .TYPE = .PRIVATE, .ANONYMOUS = <span class="tok-null">true</span> },
        -<span class="tok-number">1</span>,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(mmap);
    <a href="std.debug.html#std.debug.assert">assert</a>(mmap.len == mmap_size);

    <span class="tok-kw">const</span> br: *<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a> = <span class="tok-builtin">@ptrCast</span>(mmap.ptr);
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.register_buf_ring">register_buf_ring</a>(fd, <span class="tok-builtin">@intFromPtr</span>(br), entries, group_id);
    <span class="tok-kw">return</span> br;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.free_buf_ring" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">free_buf_ring</span><a href="#src.zig-std.os.linux.IoUring.free_buf_ring">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free_buf_ring</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, br: *<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>, entries: <span class="tok-type">u32</span>, group_id: <span class="tok-type">u16</span>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a></code></pre></div><div><pre><code>br: *<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a></code></pre></div><div><pre><code>entries: <span class="tok-type">u32</span></code></pre></div><div><pre><code>group_id: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.free_buf_ring">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free_buf_ring</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, br: *<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>, entries: <span class="tok-type">u32</span>, group_id: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
    <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.unregister_buf_ring">unregister_buf_ring</a>(fd, group_id) <span class="tok-kw">catch</span> {};
    <span class="tok-kw">var</span> mmap: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    mmap.ptr = <span class="tok-builtin">@ptrCast</span>(br);
    mmap.len = entries * <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf.html">io_uring_buf</a>);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(mmap);
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.buf_ring_init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">buf_ring_init</span><a href="#src.zig-std.os.linux.IoUring.buf_ring_init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_init</span>(br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Initialises <code>br</code> so that it is ready to be used.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.buf_ring_init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_init</span>(br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>) <span class="tok-type">void</span> {
    br.tail = <span class="tok-number">0</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.buf_ring_mask" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">buf_ring_mask</span><a href="#src.zig-std.os.linux.IoUring.buf_ring_mask">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_mask</span>(entries: <span class="tok-type">u16</span>) <span class="tok-type">u16</span></code></pre></div><div class="tldDocs"><p>Calculates the appropriate size mask for a buffer ring.
<code>entries</code> is the ring entries as specified in io_uring_register_buf_ring.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>entries: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.buf_ring_mask">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_mask</span>(entries: <span class="tok-type">u16</span>) <span class="tok-type">u16</span> {
    <span class="tok-kw">return</span> entries - <span class="tok-number">1</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.buf_ring_add" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">buf_ring_add</span><a href="#src.zig-std.os.linux.IoUring.buf_ring_add">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_add</span>( br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>, buffer: []<span class="tok-type">u8</span>, buffer_id: <span class="tok-type">u16</span>, mask: <span class="tok-type">u16</span>, buffer_offset: <span class="tok-type">u16</span>, ) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Assigns <code>buffer</code> with the <code>br</code> buffer ring.
<code>buffer_id</code> is identifier which will be returned in the CQE.
<code>buffer_offset</code> is the offset to insert at from the current tail.
If just one buffer is provided before the ring tail is committed with advance then offset should be 0.
If buffers are provided in a loop before being committed, the offset must be incremented by one for each buffer added.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>buffer_id: <span class="tok-type">u16</span></code></pre></div><div><pre><code>mask: <span class="tok-type">u16</span></code></pre></div><div><pre><code>buffer_offset: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.buf_ring_add">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_add</span>(
    br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>,
    buffer: []<span class="tok-type">u8</span>,
    buffer_id: <span class="tok-type">u16</span>,
    mask: <span class="tok-type">u16</span>,
    buffer_offset: <span class="tok-type">u16</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bufs: [*]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf.html">io_uring_buf</a> = <span class="tok-builtin">@ptrCast</span>(br);
    <span class="tok-kw">const</span> buf: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf.html">io_uring_buf</a> = &amp;bufs[(br.tail +% buffer_offset) &amp; mask];

    buf.addr = <span class="tok-builtin">@intFromPtr</span>(buffer.ptr);
    buf.len = <span class="tok-builtin">@intCast</span>(buffer.len);
    buf.bid = buffer_id;
}</code></pre></details></div></div><div class="decl"><h2 id="std.os.linux.IoUring.buf_ring_advance" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">buf_ring_advance</span><a href="#src.zig-std.os.linux.IoUring.buf_ring_advance">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_advance</span>(br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>, count: <span class="tok-type">u16</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Make <code>count</code> new buffers visible to the kernel. Called after
<code>io_uring_buf_ring_add</code> has been called <code>count</code> times to fill in new buffers.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a></code></pre></div><div><pre><code>count: <span class="tok-type">u16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.os.linux.IoUring.buf_ring_advance">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_advance</span>(br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>, count: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tail: <span class="tok-type">u16</span> = br.tail +% count;
    <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u16</span>, &amp;br.tail, tail, .release);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.os.linux.IoUring">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> IoUring = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> net = <a href="std.html">std</a>.<a href="std.net.html">net</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> linux = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> is_linux = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .linux;
<span class="tok-kw">const</span> page_size_min = <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>;

fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a> = -<span class="tok-number">1</span>,
sq: <a href="std.os.linux.IoUring.SubmissionQueue.html">SubmissionQueue</a>,
cq: <a href="std.os.linux.IoUring.CompletionQueue.html">CompletionQueue</a>,
flags: <span class="tok-type">u32</span>,
features: <span class="tok-type">u32</span>,

<span class="tok-comment">/// A friendly way to setup an io_uring, with default linux.io_uring_params.</span>
<span class="tok-comment">/// `entries` must be a power of two between 1 and 32768, although the kernel will make the final</span>
<span class="tok-comment">/// call on how many entries the submission and completion queues will ultimately have,</span>
<span class="tok-comment">/// see https://github.com/torvalds/linux/blob/v5.8/fs/io_uring.c#L8027-L8050.</span>
<span class="tok-comment">/// Matches the interface of io_uring_queue_init() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(entries: <span class="tok-type">u16</span>, flags: <span class="tok-type">u32</span>) !<a href="std.os.linux.IoUring.html">IoUring</a> {
    <span class="tok-kw">var</span> params = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a>, .{
        .flags = flags,
        .sq_thread_idle = <span class="tok-number">1000</span>,
    });
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init_params">init_params</a>(entries, &amp;params);
}

<span class="tok-comment">/// A powerful way to setup an io_uring, if you want to tweak linux.io_uring_params such as submission</span>
<span class="tok-comment">/// queue thread cpu affinity or thread idle timeout (the kernel and our default is 1 second).</span>
<span class="tok-comment">/// `params` is passed by reference because the kernel needs to modify the parameters.</span>
<span class="tok-comment">/// Matches the interface of io_uring_queue_init_params() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init_params</span>(entries: <span class="tok-type">u16</span>, p: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a>) !<a href="std.os.linux.IoUring.html">IoUring</a> {
    <span class="tok-kw">if</span> (entries == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EntriesZero;
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(entries)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EntriesNotPowerOfTwo;

    <a href="std.debug.html#std.debug.assert">assert</a>(p.sq_entries == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.cq_entries == <span class="tok-number">0</span> <span class="tok-kw">or</span> p.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SETUP_CQSIZE">IORING_SETUP_CQSIZE</a> != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.features == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.wq_fd == <span class="tok-number">0</span> <span class="tok-kw">or</span> p.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SETUP_ATTACH_WQ">IORING_SETUP_ATTACH_WQ</a> != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.resv[<span class="tok-number">0</span>] == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.resv[<span class="tok-number">1</span>] == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.resv[<span class="tok-number">2</span>] == <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_setup">io_uring_setup</a>(entries, p);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},
        .FAULT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ParamsOutsideAccessibleAddressSpace,<span class="tok-comment">
        // The resv array contains non-zero data, p.flags contains an unsupported flag,
        // entries out of bounds, IORING_SETUP_SQ_AFF was specified without IORING_SETUP_SQPOLL,
        // or IORING_SETUP_CQSIZE was specified but linux.io_uring_params.cq_entries was invalid:
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ArgumentsInvalid,
        .MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ProcessFdQuotaExceeded,
        .NFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemFdQuotaExceeded,
        .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,<span class="tok-comment">
        // IORING_SETUP_SQPOLL was specified but effective user ID lacks sufficient privileges,
        // or a container seccomp policy prohibits io_uring syscalls:
        </span>.PERM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied,
        .NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemOutdated,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
    <span class="tok-kw">const</span> fd = <span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, <span class="tok-builtin">@intCast</span>(res));
    <a href="std.debug.html#std.debug.assert">assert</a>(fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);<span class="tok-comment">

    // Kernel versions 5.4 and up use only one mmap() for the submission and completion queues.
    // This is not an optional feature for us... if the kernel does it, we have to do it.
    // The thinking on this by the kernel developers was that both the submission and the
    // completion queue rings have sizes just over a power of two, but the submission queue ring
    // is significantly smaller with u32 slots. By bundling both in a single mmap, the kernel
    // gets the submission queue ring for free.
    // See https://patchwork.kernel.org/patch/11115257 for the kernel patch.
    // We do not support the double mmap() done before 5.4, because we want to keep the
    // init/deinit mmap paths simple and because io_uring has had many bug fixes even since 5.4.
    </span><span class="tok-kw">if</span> ((p.features &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_FEAT_SINGLE_MMAP">IORING_FEAT_SINGLE_MMAP</a>) == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemOutdated;
    }<span class="tok-comment">

    // Check that the kernel has actually set params and that &quot;impossible is nothing&quot;.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(p.sq_entries != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.cq_entries != <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(p.cq_entries &gt;= p.sq_entries);<span class="tok-comment">

    // From here on, we only need to read from params, so pass `p` by value as immutable.
    // The completion queue shares the mmap with the submission queue, so pass `sq` there too.
    </span><span class="tok-kw">var</span> sq = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.SubmissionQueue.html">SubmissionQueue</a>.<a href="std.os.linux.IoUring.SubmissionQueue.html#std.os.linux.IoUring.SubmissionQueue.init">init</a>(fd, p.*);
    <span class="tok-kw">errdefer</span> sq.deinit();
    <span class="tok-kw">var</span> cq = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.CompletionQueue.html">CompletionQueue</a>.<a href="std.os.linux.IoUring.CompletionQueue.html#std.os.linux.IoUring.CompletionQueue.init">init</a>(fd, p.*, sq);
    <span class="tok-kw">errdefer</span> cq.deinit();<span class="tok-comment">

    // Check that our starting state is as we expect.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(sq.head.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.tail.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.mask == p.sq_entries - <span class="tok-number">1</span>);<span class="tok-comment">
    // Allow flags.* to be non-zero, since the kernel may set IORING_SQ_NEED_WAKEUP at any time.
    </span><a href="std.debug.html#std.debug.assert">assert</a>(sq.dropped.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.array.len == p.sq_entries);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.sqes.len == p.sq_entries);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.sqe_head == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(sq.sqe_tail == <span class="tok-number">0</span>);

    <a href="std.debug.html#std.debug.assert">assert</a>(cq.head.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(cq.tail.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(cq.mask == p.cq_entries - <span class="tok-number">1</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(cq.overflow.* == <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(cq.cqes.len == p.cq_entries);

    <span class="tok-kw">return</span> <a href="std.os.linux.IoUring.html">IoUring</a>{
        .fd = fd,
        .sq = sq,
        .cq = cq,
        .flags = p.flags,
        .features = p.features,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);<span class="tok-comment">
    // The mmaps depend on the fd, so the order of these calls is important:
    </span>self.cq.deinit();
    self.sq.deinit();
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.fd);
    self.fd = -<span class="tok-number">1</span>;
}

<span class="tok-comment">/// Returns a pointer to a vacant SQE, or an error if the submission queue is full.</span>
<span class="tok-comment">/// We follow the implementation (and atomics) of liburing's `io_uring_get_sqe()` exactly.</span>
<span class="tok-comment">/// However, instead of a null we return an error to force safe handling.</span>
<span class="tok-comment">/// Any situation where the submission queue is full tends more towards a control flow error,</span>
<span class="tok-comment">/// and the null return in liburing is more a C idiom than anything else, for lack of a better</span>
<span class="tok-comment">/// alternative. In Zig, we have first-class error handling... so let's use it.</span>
<span class="tok-comment">/// Matches the implementation of io_uring_get_sqe() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get_sqe</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> head = <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.sq.head, .acquire);<span class="tok-comment">
    // Remember that these head and tail offsets wrap around every four billion operations.
    // We must therefore use wrapping addition and subtraction to avoid a runtime crash.
    </span><span class="tok-kw">const</span> next = self.sq.sqe_tail +% <span class="tok-number">1</span>;
    <span class="tok-kw">if</span> (next -% head &gt; self.sq.sqes.len) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SubmissionQueueFull;
    <span class="tok-kw">const</span> sqe = &amp;self.sq.sqes[self.sq.sqe_tail &amp; self.sq.mask];
    self.sq.sqe_tail = next;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Submits the SQEs acquired via get_sqe() to the kernel. You can call this once after you have</span>
<span class="tok-comment">/// called get_sqe() multiple times to setup multiple I/O requests.</span>
<span class="tok-comment">/// Returns the number of SQEs submitted, if not used alongside IORING_SETUP_SQPOLL.</span>
<span class="tok-comment">/// If the io_uring instance is uses IORING_SETUP_SQPOLL, the value returned on success is not</span>
<span class="tok-comment">/// guaranteed to match the amount of actually submitted sqes during this call. A value higher</span>
<span class="tok-comment">/// or lower, including 0, may be returned.</span>
<span class="tok-comment">/// Matches the implementation of io_uring_submit() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">submit</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> self.submit_and_wait(<span class="tok-number">0</span>);
}

<span class="tok-comment">/// Like submit(), but allows waiting for events as well.</span>
<span class="tok-comment">/// Returns the number of SQEs submitted.</span>
<span class="tok-comment">/// Matches the implementation of io_uring_submit_and_wait() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">submit_and_wait</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, wait_nr: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> submitted = self.flush_sq();
    <span class="tok-kw">var</span> flags: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (self.sq_ring_needs_enter(&amp;flags) <span class="tok-kw">or</span> wait_nr &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (wait_nr &gt; <span class="tok-number">0</span> <span class="tok-kw">or</span> (self.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SETUP_IOPOLL">IORING_SETUP_IOPOLL</a>) != <span class="tok-number">0</span>) {
            flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_ENTER_GETEVENTS">IORING_ENTER_GETEVENTS</a>;
        }
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.enter(submitted, wait_nr, flags);
    }
    <span class="tok-kw">return</span> submitted;
}

<span class="tok-comment">/// Tell the kernel we have submitted SQEs and/or want to wait for CQEs.</span>
<span class="tok-comment">/// Returns the number of SQEs submitted.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">enter</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, to_submit: <span class="tok-type">u32</span>, min_complete: <span class="tok-type">u32</span>, flags: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_enter">io_uring_enter</a>(self.fd, to_submit, min_complete, flags, <span class="tok-null">null</span>);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // The kernel was unable to allocate memory or ran out of resources for the request.
        // The application should wait for some completions and try again:
        </span>.AGAIN =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,<span class="tok-comment">
        // The SQE `fd` is invalid, or IOSQE_FIXED_FILE was set but no files were registered:
        </span>.BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorInvalid,<span class="tok-comment">
        // The file descriptor is valid, but the ring is not in the right state.
        // See io_uring_register(2) for how to enable the ring.
        </span>.BADFD =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorInBadState,<span class="tok-comment">
        // The application attempted to overcommit the number of requests it can have pending.
        // The application should wait for some completions and try again:
        </span>.BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.CompletionQueueOvercommitted,<span class="tok-comment">
        // The SQE is invalid, or valid but the ring was setup with IORING_SETUP_IOPOLL:
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SubmissionQueueEntryInvalid,<span class="tok-comment">
        // The buffer is outside the process' accessible address space, or IORING_OP_READ_FIXED
        // or IORING_OP_WRITE_FIXED was specified but no buffers were registered, or the range
        // described by `addr` and `len` is not within the buffer registered at `buf_index`:
        </span>.FAULT =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BufferInvalid,
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RingShuttingDown,<span class="tok-comment">
        // The kernel believes our `self.fd` does not refer to an io_uring instance,
        // or the opcode is valid but not supported by this kernel (more likely):
        </span>.OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OpcodeNotSupported,<span class="tok-comment">
        // The operation was interrupted by a delivery of a signal before it could complete.
        // This can happen while waiting for events with IORING_ENTER_GETEVENTS:
        </span>.INTR =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SignalInterrupt,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(res));
}

<span class="tok-comment">/// Sync internal state with kernel ring state on the SQ side.</span>
<span class="tok-comment">/// Returns the number of all pending events in the SQ ring, for the shared ring.</span>
<span class="tok-comment">/// This return value includes previously flushed SQEs, as per liburing.</span>
<span class="tok-comment">/// The rationale is to suggest that an io_uring_enter() call is needed rather than not.</span>
<span class="tok-comment">/// Matches the implementation of __io_uring_flush_sq() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">flush_sq</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (self.sq.sqe_head != self.sq.sqe_tail) {<span class="tok-comment">
        // Fill in SQEs that we have queued up, adding them to the kernel ring.
        </span><span class="tok-kw">const</span> to_submit = self.sq.sqe_tail -% self.sq.sqe_head;
        <span class="tok-kw">var</span> tail = self.sq.tail.*;
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; to_submit) : (i += <span class="tok-number">1</span>) {
            self.sq.array[tail &amp; self.sq.mask] = self.sq.sqe_head &amp; self.sq.mask;
            tail +%= <span class="tok-number">1</span>;
            self.sq.sqe_head +%= <span class="tok-number">1</span>;
        }<span class="tok-comment">
        // Ensure that the kernel can actually see the SQE updates when it sees the tail update.
        </span><span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, self.sq.tail, tail, .release);
    }
    <span class="tok-kw">return</span> self.sq_ready();
}

<span class="tok-comment">/// Returns true if we are not using an SQ thread (thus nobody submits but us),</span>
<span class="tok-comment">/// or if IORING_SQ_NEED_WAKEUP is set and the SQ thread must be explicitly awakened.</span>
<span class="tok-comment">/// For the latter case, we set the SQ thread wakeup flag.</span>
<span class="tok-comment">/// Matches the implementation of sq_ring_needs_enter() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq_ring_needs_enter</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, flags: *<span class="tok-type">u32</span>) <span class="tok-type">bool</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(flags.* == <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> ((self.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SETUP_SQPOLL">IORING_SETUP_SQPOLL</a>) == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    <span class="tok-kw">if</span> ((<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.sq.flags, .unordered) &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SQ_NEED_WAKEUP">IORING_SQ_NEED_WAKEUP</a>) != <span class="tok-number">0</span>) {
        flags.* |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_ENTER_SQ_WAKEUP">IORING_ENTER_SQ_WAKEUP</a>;
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-comment">/// Returns the number of flushed and unflushed SQEs pending in the submission queue.</span>
<span class="tok-comment">/// In other words, this is the number of SQEs in the submission queue, i.e. its length.</span>
<span class="tok-comment">/// These are SQEs that the kernel is yet to consume.</span>
<span class="tok-comment">/// Matches the implementation of io_uring_sq_ready in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sq_ready</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span> {<span class="tok-comment">
    // Always use the shared ring state (i.e. head and not sqe_head) to avoid going out of sync,
    // see https://github.com/axboe/liburing/issues/92.
    </span><span class="tok-kw">return</span> self.sq.sqe_tail -% <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.sq.head, .acquire);
}

<span class="tok-comment">/// Returns the number of CQEs in the completion queue, i.e. its length.</span>
<span class="tok-comment">/// These are CQEs that the application is yet to consume.</span>
<span class="tok-comment">/// Matches the implementation of io_uring_cq_ready in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_ready</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.cq.tail, .acquire) -% self.cq.head.*;
}

<span class="tok-comment">/// Copies as many CQEs as are ready, and that can fit into the destination `cqes` slice.</span>
<span class="tok-comment">/// If none are available, enters into the kernel to wait for at most `wait_nr` CQEs.</span>
<span class="tok-comment">/// Returns the number of CQEs copied, advancing the CQ ring.</span>
<span class="tok-comment">/// Provides all the wait/peek methods found in liburing, but with batching and a single method.</span>
<span class="tok-comment">/// The rationale for copying CQEs rather than copying pointers is that pointers are 8 bytes</span>
<span class="tok-comment">/// whereas CQEs are not much more at only 16 bytes, and this provides a safer faster interface.</span>
<span class="tok-comment">/// Safer, because you no longer need to call cqe_seen(), avoiding idempotency bugs.</span>
<span class="tok-comment">/// Faster, because we can now amortize the atomic store release to `cq.head` across the batch.</span>
<span class="tok-comment">/// See https://github.com/axboe/liburing/issues/103#issuecomment-686665007.</span>
<span class="tok-comment">/// Matches the implementation of io_uring_peek_batch_cqe() in liburing, but supports waiting.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_cqes</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, cqes: []<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>, wait_nr: <span class="tok-type">u32</span>) !<span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> count = self.copy_cqes_ready(cqes);
    <span class="tok-kw">if</span> (count &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> count;
    <span class="tok-kw">if</span> (self.cq_ring_needs_flush() <span class="tok-kw">or</span> wait_nr &gt; <span class="tok-number">0</span>) {
        _ = <span class="tok-kw">try</span> self.enter(<span class="tok-number">0</span>, wait_nr, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_ENTER_GETEVENTS">IORING_ENTER_GETEVENTS</a>);
        <span class="tok-kw">return</span> self.copy_cqes_ready(cqes);
    }
    <span class="tok-kw">return</span> <span class="tok-number">0</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">copy_cqes_ready</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, cqes: []<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> ready = self.cq_ready();
    <span class="tok-kw">const</span> count = <span class="tok-builtin">@min</span>(cqes.len, ready);
    <span class="tok-kw">const</span> head = self.cq.head.* &amp; self.cq.mask;<span class="tok-comment">

    // before wrapping
    </span><span class="tok-kw">const</span> n = <span class="tok-builtin">@min</span>(self.cq.cqes.len - head, count);
    <span class="tok-builtin">@memcpy</span>(cqes[<span class="tok-number">0</span>..n], self.cq.cqes[head..][<span class="tok-number">0</span>..n]);

    <span class="tok-kw">if</span> (count &gt; n) {<span class="tok-comment">
        // wrap self.cq.cqes
        </span><span class="tok-kw">const</span> w = count - n;
        <span class="tok-builtin">@memcpy</span>(cqes[n..][<span class="tok-number">0</span>..w], self.cq.cqes[<span class="tok-number">0</span>..w]);
    }

    self.cq_advance(count);
    <span class="tok-kw">return</span> count;
}

<span class="tok-comment">/// Returns a copy of an I/O completion, waiting for it if necessary, and advancing the CQ ring.</span>
<span class="tok-comment">/// A convenience method for `copy_cqes()` for when you don't need to batch or peek.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copy_cqe</span>(ring: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> {
    <span class="tok-kw">var</span> cqes: [<span class="tok-number">1</span>]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> count = <span class="tok-kw">try</span> ring.copy_cqes(&amp;cqes, <span class="tok-number">1</span>);
        <span class="tok-kw">if</span> (count &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> cqes[<span class="tok-number">0</span>];
    }
}

<span class="tok-comment">/// Matches the implementation of cq_ring_needs_flush() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_ring_needs_flush</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> (<span class="tok-builtin">@atomicLoad</span>(<span class="tok-type">u32</span>, self.sq.flags, .unordered) &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_SQ_CQ_OVERFLOW">IORING_SQ_CQ_OVERFLOW</a>) != <span class="tok-number">0</span>;
}

<span class="tok-comment">/// For advanced use cases only that implement custom completion queue methods.</span>
<span class="tok-comment">/// If you use copy_cqes() or copy_cqe() you must not call cqe_seen() or cq_advance().</span>
<span class="tok-comment">/// Must be called exactly once after a zero-copy CQE has been processed by your application.</span>
<span class="tok-comment">/// Not idempotent, calling more than once will result in other CQEs being lost.</span>
<span class="tok-comment">/// Matches the implementation of cqe_seen() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cqe_seen</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, cqe: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>) <span class="tok-type">void</span> {
    _ = cqe;
    self.cq_advance(<span class="tok-number">1</span>);
}

<span class="tok-comment">/// For advanced use cases only that implement custom completion queue methods.</span>
<span class="tok-comment">/// Matches the implementation of cq_advance() in liburing.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cq_advance</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, count: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (count &gt; <span class="tok-number">0</span>) {<span class="tok-comment">
        // Ensure the kernel only sees the new head value after the CQEs have been read.
        </span><span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u32</span>, self.cq.head, self.cq.head.* +% count, .release);
    }
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform an `fsync(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</span>
<span class="tok-comment">/// For example, for `fdatasync()` you can set `IORING_FSYNC_DATASYNC` in the SQE's `rw_flags`.</span>
<span class="tok-comment">/// N.B. While SQEs are initiated in the order in which they appear in the submission queue,</span>
<span class="tok-comment">/// operations execute in parallel and completions are unordered. Therefore, an application that</span>
<span class="tok-comment">/// submits a write followed by an fsync in the submission queue cannot expect the fsync to</span>
<span class="tok-comment">/// apply to the write, since the fsync may complete before the write is issued to the disk.</span>
<span class="tok-comment">/// You should preferably use `link_with_next_sqe()` on a write's SQE to link it with an fsync,</span>
<span class="tok-comment">/// or else insert a full write barrier using `drain_previous_sqes()` when queueing an fsync.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fsync</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, flags: <span class="tok-type">u32</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_fsync(fd, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a no-op.</span>
<span class="tok-comment">/// Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</span>
<span class="tok-comment">/// A no-op is more useful than may appear at first glance.</span>
<span class="tok-comment">/// For example, you could call `drain_previous_sqes()` on the returned SQE, to use the no-op to</span>
<span class="tok-comment">/// know when the ring is idle before acting on a kill signal.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nop</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_nop();
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Used to select how the read should be handled.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadBuffer = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    <span class="tok-comment">/// io_uring will read directly into this buffer</span>
    buffer: []<span class="tok-type">u8</span>,

    <span class="tok-comment">/// io_uring will read directly into these buffers using readv.</span>
    iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>,

    <span class="tok-comment">/// io_uring will select a buffer that has previously been provided with `provide_buffers`.</span>
    <span class="tok-comment">/// The buffer group reference by `group_id` must contain at least one buffer for the read to work.</span>
    <span class="tok-comment">/// `len` controls the number of bytes to read into the selected buffer.</span>
    buffer_selection: <span class="tok-kw">struct</span> {
        group_id: <span class="tok-type">u16</span>,
        len: <span class="tok-type">usize</span>,
    },
};

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `read(2)` or `preadv(2)` depending on the buffer type.</span>
<span class="tok-comment">/// * Reading into a `ReadBuffer.buffer` uses `read(2)`</span>
<span class="tok-comment">/// * Reading into a `ReadBuffer.iovecs` uses `preadv(2)`</span>
<span class="tok-comment">///   If you want to do a `preadv2(2)` then set `rw_flags` on the returned SQE. See https://man7.org/linux/man-pages/man2/preadv2.2.html</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: <a href="std.os.linux.IoUring.ReadBuffer.html">ReadBuffer</a>,
    offset: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    <span class="tok-kw">switch</span> (buffer) {
        .buffer =&gt; |slice| sqe.prep_read(fd, slice, offset),
        .iovecs =&gt; |vecs| sqe.prep_readv(fd, vecs, offset),
        .buffer_selection =&gt; |selection| {
            sqe.prep_rw(.READ, fd, <span class="tok-number">0</span>, selection.len, offset);
            sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>;
            sqe.buf_index = selection.group_id;
        },
    }
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `write(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    offset: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_write(fd, buffer, offset);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `splice(2)`</span>
<span class="tok-comment">/// Either `fd_in` or `fd_out` must be a pipe.</span>
<span class="tok-comment">/// If `fd_in` refers to a pipe, `off_in` is ignored and must be set to std.math.maxInt(u64).</span>
<span class="tok-comment">/// If `fd_in` does not refer to a pipe and `off_in` is maxInt(u64), then `len` are read</span>
<span class="tok-comment">/// from `fd_in` starting from the file offset, which is incremented by the number of bytes read.</span>
<span class="tok-comment">/// If `fd_in` does not refer to a pipe and `off_in` is not maxInt(u64), then the starting offset of `fd_in` will be `off_in`.</span>
<span class="tok-comment">/// This splice operation can be used to implement sendfile by splicing to an intermediate pipe first,</span>
<span class="tok-comment">/// then splice to the final destination. In fact, the implementation of sendfile in kernel uses splice internally.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// NOTE that even if fd_in or fd_out refers to a pipe, the splice operation can still fail with EINVAL if one of the</span>
<span class="tok-comment">/// fd doesn't explicitly support splice peration, e.g. reading from terminal is unsupported from kernel 5.7 to 5.11.</span>
<span class="tok-comment">/// See https://github.com/axboe/liburing/issues/291</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splice</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd_in: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_in: <span class="tok-type">u64</span>, fd_out: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, off_out: <span class="tok-type">u64</span>, len: <span class="tok-type">usize</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_splice(fd_in, off_in, fd_out, off_out, len);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a IORING_OP_READ_FIXED.</span>
<span class="tok-comment">/// The `buffer` provided must be registered with the kernel by calling `register_buffers` first.</span>
<span class="tok-comment">/// The `buffer_index` must be the same as its index in the array provided to `register_buffers`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read_fixed</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: *<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>,
    offset: <span class="tok-type">u64</span>,
    buffer_index: <span class="tok-type">u16</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_read_fixed(fd, buffer, offset, buffer_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `pwritev()`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</span>
<span class="tok-comment">/// For example, if you want to do a `pwritev2()` then set `rw_flags` on the returned SQE.</span>
<span class="tok-comment">/// See https://linux.die.net/man/2/pwritev.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>,
    offset: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_writev(fd, iovecs, offset);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a IORING_OP_WRITE_FIXED.</span>
<span class="tok-comment">/// The `buffer` provided must be registered with the kernel by calling `register_buffers` first.</span>
<span class="tok-comment">/// The `buffer_index` must be the same as its index in the array provided to `register_buffers`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Returns a pointer to the SQE so that you can further modify the SQE for advanced use cases.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write_fixed</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: *<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>,
    offset: <span class="tok-type">u64</span>,
    buffer_index: <span class="tok-type">u16</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_write_fixed(fd, buffer, offset, buffer_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform an `accept4(2)` on a socket.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 5.5</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_accept(fd, addr, addrlen, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues an multishot accept on a socket.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Multishot variant allows an application to issue a single accept request,</span>
<span class="tok-comment">/// which will repeatedly trigger a CQE when a connection request comes in.</span>
<span class="tok-comment">/// While IORING_CQE_F_MORE flag is set in CQE flags accept will generate</span>
<span class="tok-comment">/// further CQEs.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Available since 5.19</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_multishot</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_multishot_accept(fd, addr, addrlen, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues an accept using direct (registered) file descriptors.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// To use an accept direct variant, the application must first have registered</span>
<span class="tok-comment">/// a file table (with register_files). An unused table index will be</span>
<span class="tok-comment">/// dynamically chosen and returned in the CQE res field.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// After creation, they can be used by setting IOSQE_FIXED_FILE in the SQE</span>
<span class="tok-comment">/// flags member, and setting the SQE fd field to the direct descriptor value</span>
<span class="tok-comment">/// rather than the regular file descriptor.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Available since 5.19</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_direct</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_accept_direct(fd, addr, addrlen, flags, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_FILE_INDEX_ALLOC">IORING_FILE_INDEX_ALLOC</a>);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues an multishot accept using direct (registered) file descriptors.</span>
<span class="tok-comment">/// Available since 5.19</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accept_multishot_direct</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: ?*<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_multishot_accept_direct(fd, addr, addrlen, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queue (but does not submit) an SQE to perform a `connect(2)` on a socket.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">connect</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    addr: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a>,
    addrlen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_connect(fd, addr, addrlen);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `epoll_ctl(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">epoll_ctl</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    epfd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    op: <span class="tok-type">u32</span>,
    ev: ?*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.epoll_event.html">epoll_event</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_epoll_ctl(epfd, fd, op, ev);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Used to select how the recv call should be handled.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> RecvBuffer = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    <span class="tok-comment">/// io_uring will recv directly into this buffer</span>
    buffer: []<span class="tok-type">u8</span>,

    <span class="tok-comment">/// io_uring will select a buffer that has previously been provided with `provide_buffers`.</span>
    <span class="tok-comment">/// The buffer group referenced by `group_id` must contain at least one buffer for the recv call to work.</span>
    <span class="tok-comment">/// `len` controls the number of bytes to read into the selected buffer.</span>
    buffer_selection: <span class="tok-kw">struct</span> {
        group_id: <span class="tok-type">u16</span>,
        len: <span class="tok-type">usize</span>,
    },
};

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `recv(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 5.6</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recv</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: <a href="std.os.linux.IoUring.RecvBuffer.html">RecvBuffer</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    <span class="tok-kw">switch</span> (buffer) {
        .buffer =&gt; |slice| sqe.prep_recv(fd, slice, flags),
        .buffer_selection =&gt; |selection| {
            sqe.prep_rw(.RECV, fd, <span class="tok-number">0</span>, selection.len, <span class="tok-number">0</span>);
            sqe.rw_flags = flags;
            sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>;
            sqe.buf_index = selection.group_id;
        },
    }
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `send(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 5.6</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_send(fd, buffer, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform an async zerocopy `send(2)`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This operation will most likely produce two CQEs. The flags field of the</span>
<span class="tok-comment">/// first cqe may likely contain IORING_CQE_F_MORE, which means that there will</span>
<span class="tok-comment">/// be a second cqe with the user_data field set to the same value. The user</span>
<span class="tok-comment">/// must not modify the data buffer until the notification is posted. The first</span>
<span class="tok-comment">/// cqe follows the usual rules and so its res field will contain the number of</span>
<span class="tok-comment">/// bytes sent or a negative error code. The notification's res field will be</span>
<span class="tok-comment">/// set to zero and the flags field will contain IORING_CQE_F_NOTIF. The two</span>
<span class="tok-comment">/// step model is needed because the kernel may hold on to buffers for a long</span>
<span class="tok-comment">/// time, e.g. waiting for a TCP ACK. Notifications responsible for controlling</span>
<span class="tok-comment">/// the lifetime of the buffers. Even errored requests may generate a</span>
<span class="tok-comment">/// notification.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Available since 6.0</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send_zc</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    send_flags: <span class="tok-type">u32</span>,
    zc_flags: <span class="tok-type">u16</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_send_zc(fd, buffer, send_flags, zc_flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform an async zerocopy `send(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 6.0</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">send_zc_fixed</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    buffer: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    send_flags: <span class="tok-type">u32</span>,
    zc_flags: <span class="tok-type">u16</span>,
    buf_index: <span class="tok-type">u16</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_send_zc_fixed(fd, buffer, send_flags, zc_flags, buf_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `recvmsg(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 5.3</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recvmsg</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    msg: *<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr">msghdr</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_recvmsg(fd, msg, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `sendmsg(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 5.3</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    msg: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_sendmsg(fd, msg, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform an async zerocopy `sendmsg(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 6.1</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sendmsg_zc</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    msg: *<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_sendmsg_zc(fd, msg, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform an `openat(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 5.6.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a>,
    mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_openat(fd, path, flags, mode);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues an openat using direct (registered) file descriptors.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// To use an accept direct variant, the application must first have registered</span>
<span class="tok-comment">/// a file table (with register_files). An unused table index will be</span>
<span class="tok-comment">/// dynamically chosen and returned in the CQE res field.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// After creation, they can be used by setting IOSQE_FIXED_FILE in the SQE</span>
<span class="tok-comment">/// flags member, and setting the SQE fd field to the direct descriptor value</span>
<span class="tok-comment">/// rather than the regular file descriptor.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Available since 5.15</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">openat_direct</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a>,
    mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>,
    file_index: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_openat_direct(fd, path, flags, mode, file_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `close(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">/// Available since 5.6.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_close(fd);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues close of registered file descriptor.</span>
<span class="tok-comment">/// Available since 5.15</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close_direct</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, user_data: <span class="tok-type">u64</span>, file_index: <span class="tok-type">u32</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_close_direct(file_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to register a timeout operation.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The timeout will complete when either the timeout expires, or after the specified number of</span>
<span class="tok-comment">/// events complete (if `count` is greater than `0`).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// `flags` may be `0` for a relative timeout, or `IORING_TIMEOUT_ABS` for an absolute timeout.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The completion event result will be `-ETIME` if the timeout completed through expiration,</span>
<span class="tok-comment">/// `0` if the timeout completed after the specified number of events, or `-ECANCELED` if the</span>
<span class="tok-comment">/// timeout was removed before it expired.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// io_uring timeouts use the `CLOCK.MONOTONIC` clock source.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timeout</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    ts: *<span class="tok-kw">const</span> <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a>,
    count: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_timeout(ts, count, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to remove an existing timeout operation.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The timeout is identified by its `user_data`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The completion event result will be `0` if the timeout was found and cancelled successfully,</span>
<span class="tok-comment">/// `-EBUSY` if the timeout was found but expiration was already in progress, or</span>
<span class="tok-comment">/// `-ENOENT` if the timeout was not found.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">timeout_remove</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    timeout_user_data: <span class="tok-type">u64</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_timeout_remove(timeout_user_data, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to add a link timeout operation.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// You need to set linux.IOSQE_IO_LINK to flags of the target operation</span>
<span class="tok-comment">/// and then call this method right after the target operation.</span>
<span class="tok-comment">/// See https://lwn.net/Articles/803932/ for detail.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// If the dependent request finishes before the linked timeout, the timeout</span>
<span class="tok-comment">/// is canceled. If the timeout finishes before the dependent request, the</span>
<span class="tok-comment">/// dependent request will be canceled.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The completion event result of the link_timeout will be</span>
<span class="tok-comment">/// `-ETIME` if the timeout finishes before the dependent request</span>
<span class="tok-comment">/// (in this case, the completion event result of the dependent request will</span>
<span class="tok-comment">/// be `-ECANCELED`), or</span>
<span class="tok-comment">/// `-EALREADY` if the dependent request finishes before the linked timeout.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">link_timeout</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    ts: *<span class="tok-kw">const</span> <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_link_timeout(ts, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `poll(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_add</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    poll_mask: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_poll_add(fd, poll_mask);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to remove an existing poll operation.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_remove</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    target_user_data: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_poll_remove(target_user_data);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to update the user data of an existing poll</span>
<span class="tok-comment">/// operation. Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poll_update</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    old_user_data: <span class="tok-type">u64</span>,
    new_user_data: <span class="tok-type">u64</span>,
    poll_mask: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_poll_update(old_user_data, new_user_data, poll_mask, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform an `fallocate(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fallocate</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    mode: <span class="tok-type">i32</span>,
    offset: <span class="tok-type">u64</span>,
    len: <span class="tok-type">u64</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_fallocate(fd, mode, offset, len);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform an `statx(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">statx</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
    mask: <span class="tok-type">u32</span>,
    buf: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_statx(fd, path, flags, mask, buf);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to remove an existing operation.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The operation is identified by its `user_data`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The completion event result will be `0` if the operation was found and cancelled successfully,</span>
<span class="tok-comment">/// `-EALREADY` if the operation was found but was already in progress, or</span>
<span class="tok-comment">/// `-ENOENT` if the operation was not found.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cancel</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    cancel_user_data: <span class="tok-type">u64</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_cancel(cancel_user_data, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `shutdown(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The operation is identified by its `user_data`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shutdown</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    sockfd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    how: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_shutdown(sockfd, how);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `renameat2(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">renameat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    old_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_renameat(old_dir_fd, old_path, new_dir_fd, new_path, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `unlinkat(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlinkat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_unlinkat(dir_fd, path, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `mkdirat(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mkdirat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_mkdirat(dir_fd, path, mode);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `symlinkat(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">symlinkat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    target: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    link_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_symlinkat(target, new_dir_fd, link_path);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `linkat(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">linkat</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    old_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    old_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    new_dir_fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    new_path: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_linkat(old_dir_fd, old_path, new_dir_fd, new_path, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to provide a group of buffers used for commands that read/receive data.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Provided buffers can be used in `read`, `recv` or `recvmsg` commands via .buffer_selection.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The kernel expects a contiguous block of memory of size (buffers_count * buffer_size).</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">provide_buffers</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    buffers: [*]<span class="tok-type">u8</span>,
    buffer_size: <span class="tok-type">usize</span>,
    buffers_count: <span class="tok-type">usize</span>,
    group_id: <span class="tok-type">usize</span>,
    buffer_id: <span class="tok-type">usize</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_provide_buffers(buffers, buffer_size, buffers_count, group_id, buffer_id);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to remove a group of provided buffers.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">remove_buffers</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    buffers_count: <span class="tok-type">usize</span>,
    group_id: <span class="tok-type">usize</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_remove_buffers(buffers_count, group_id);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Queues (but does not submit) an SQE to perform a `waitid(2)`.</span>
<span class="tok-comment">/// Returns a pointer to the SQE.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">waitid</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    id_type: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.P.html">P</a>,
    id: <span class="tok-type">i32</span>,
    infop: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.siginfo_t">siginfo_t</a>,
    options: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_waitid(id_type, id, infop, options, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Registers an array of file descriptors.</span>
<span class="tok-comment">/// Every time a file descriptor is put in an SQE and submitted to the kernel, the kernel must</span>
<span class="tok-comment">/// retrieve a reference to the file, and once I/O has completed the file reference must be</span>
<span class="tok-comment">/// dropped. The atomic nature of this file reference can be a slowdown for high IOPS workloads.</span>
<span class="tok-comment">/// This slowdown can be avoided by pre-registering file descriptors.</span>
<span class="tok-comment">/// To refer to a registered file descriptor, IOSQE_FIXED_FILE must be set in the SQE's flags,</span>
<span class="tok-comment">/// and the SQE's fd must be set to the index of the file descriptor in the registered array.</span>
<span class="tok-comment">/// Registering file descriptors will wait for the ring to idle.</span>
<span class="tok-comment">/// Files are automatically unregistered by the kernel when the ring is torn down.</span>
<span class="tok-comment">/// An application need unregister only if it wants to register a new array of file descriptors.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fds: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_FILES,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(fds.ptr)),
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(fds.len)),
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}

<span class="tok-comment">/// Updates registered file descriptors.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Updates are applied starting at the provided offset in the original file descriptors slice.</span>
<span class="tok-comment">/// There are three kind of updates:</span>
<span class="tok-comment">/// * turning a sparse entry (where the fd is -1) into a real one</span>
<span class="tok-comment">/// * removing an existing entry (set the fd to -1)</span>
<span class="tok-comment">/// * replacing an existing entry with a new fd</span>
<span class="tok-comment">/// Adding new file descriptors must be done with `register_files`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files_update</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, offset: <span class="tok-type">u32</span>, fds: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> FilesUpdate = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        offset: <span class="tok-type">u32</span>,
        resv: <span class="tok-type">u32</span>,
        fds: <span class="tok-type">u64</span> <span class="tok-kw">align</span>(<span class="tok-number">8</span>),
    };
    <span class="tok-kw">var</span> update = FilesUpdate{
        .offset = offset,
        .resv = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>),
        .fds = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@intFromPtr</span>(fds.ptr)),
    };

    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_FILES_UPDATE,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;update)),
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(fds.len)),
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}

<span class="tok-comment">/// Registers an empty (-1) file table of `nr_files` number of file descriptors.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_files_sparse</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, nr_files: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> reg = &amp;<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_rsrc_register.html">io_uring_rsrc_register</a>{
        .nr = nr_files,
        .flags = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_RSRC_REGISTER_SPARSE">IORING_RSRC_REGISTER_SPARSE</a>,
        .resv2 = <span class="tok-number">0</span>,
        .data = <span class="tok-number">0</span>,
        .tags = <span class="tok-number">0</span>,
    };

    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_FILES2,
        <span class="tok-builtin">@ptrCast</span>(reg),
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_rsrc_register.html">io_uring_rsrc_register</a>)),
    );

    <span class="tok-kw">return</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}

<span class="tok-comment">/// Registers the file descriptor for an eventfd that will be notified of completion events on</span>
<span class="tok-comment">///  an io_uring instance.</span>
<span class="tok-comment">/// Only a single a eventfd can be registered at any given point in time.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_eventfd</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_EVENTFD,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;fd)),
        <span class="tok-number">1</span>,
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}

<span class="tok-comment">/// Registers the file descriptor for an eventfd that will be notified of completion events on</span>
<span class="tok-comment">/// an io_uring instance. Notifications are only posted for events that complete in an async manner.</span>
<span class="tok-comment">/// This means that events that complete inline while being submitted do not trigger a notification event.</span>
<span class="tok-comment">/// Only a single eventfd can be registered at any given point in time.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_eventfd_async</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_EVENTFD_ASYNC,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;fd)),
        <span class="tok-number">1</span>,
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}

<span class="tok-comment">/// Unregister the registered eventfd file descriptor.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_eventfd</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .UNREGISTER_EVENTFD,
        <span class="tok-null">null</span>,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}

<span class="tok-comment">/// Registers an array of buffers for use with `read_fixed` and `write_fixed`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">register_buffers</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>, buffers: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        self.fd,
        .REGISTER_BUFFERS,
        buffers.ptr,
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(buffers.len)),
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_registration_result">handle_registration_result</a>(res);
}

<span class="tok-comment">/// Unregister the registered buffers.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_buffers</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(self.fd, .UNREGISTER_BUFFERS, <span class="tok-null">null</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.BuffersNotRegistered,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">handle_registration_result</span>(res: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // One or more fds in the array are invalid, or the kernel does not support sparse sets:
        </span>.BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileDescriptorInvalid,
        .BUSY =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FilesAlreadyRegistered,
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FilesEmpty,<span class="tok-comment">
        // Adding `nr_args` file references would exceed the maximum allowed number of files the
        // user is allowed to have according to the per-user RLIMIT_NOFILE resource limit and
        // the CAP_SYS_RESOURCE capability is not set, or `nr_args` exceeds the maximum allowed
        // for a fixed file set (older kernels have a limit of 1024 files vs 64K files):
        </span>.MFILE =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UserFdQuotaExceeded,<span class="tok-comment">
        // Insufficient kernel resources, or the caller had a non-zero RLIMIT_MEMLOCK soft
        // resource limit but tried to lock more memory than the limit permitted (not enforced
        // when the process is privileged with CAP_IPC_LOCK):
        </span>.NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,<span class="tok-comment">
        // Attempt to register files on a ring already registering files or being torn down:
        </span>.NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.RingShuttingDownOrAlreadyRegisteringFiles,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
}

<span class="tok-comment">/// Unregisters all registered file descriptors previously associated with the ring.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unregister_files</span>(self: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.fd &gt;= <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(self.fd, .UNREGISTER_FILES, <span class="tok-null">null</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},
        .NXIO =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FilesNotRegistered,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
}

<span class="tok-comment">/// Prepares a socket creation request.</span>
<span class="tok-comment">/// New socket fd will be returned in completion result.</span>
<span class="tok-comment">/// Available since 5.19</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    domain: <span class="tok-type">u32</span>,
    socket_type: <span class="tok-type">u32</span>,
    protocol: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_socket(domain, socket_type, protocol, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Prepares a socket creation request for registered file at index `file_index`.</span>
<span class="tok-comment">/// Available since 5.19</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket_direct</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    domain: <span class="tok-type">u32</span>,
    socket_type: <span class="tok-type">u32</span>,
    protocol: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
    file_index: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_socket_direct(domain, socket_type, protocol, flags, file_index);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-comment">/// Prepares a socket creation request for registered file, index chosen by kernel (file index alloc).</span>
<span class="tok-comment">/// File index will be returned in CQE res field.</span>
<span class="tok-comment">/// Available since 5.19</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">socket_direct_alloc</span>(
    self: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    user_data: <span class="tok-type">u64</span>,
    domain: <span class="tok-type">u32</span>,
    socket_type: <span class="tok-type">u32</span>,
    protocol: <span class="tok-type">u32</span>,
    flags: <span class="tok-type">u32</span>,
) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> self.get_sqe();
    sqe.prep_socket_direct_alloc(domain, socket_type, protocol, flags);
    sqe.user_data = user_data;
    <span class="tok-kw">return</span> sqe;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SubmissionQueue = <span class="tok-kw">struct</span> {
    head: *<span class="tok-type">u32</span>,
    tail: *<span class="tok-type">u32</span>,
    mask: <span class="tok-type">u32</span>,
    flags: *<span class="tok-type">u32</span>,
    dropped: *<span class="tok-type">u32</span>,
    array: []<span class="tok-type">u32</span>,
    sqes: []<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a>,
    mmap: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>,
    mmap_sqes: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span>,<span class="tok-comment">

    // We use `sqe_head` and `sqe_tail` in the same way as liburing:
    // We increment `sqe_tail` (but not `tail`) for each call to `get_sqe()`.
    // We then set `tail` to `sqe_tail` once, only when these events are actually submitted.
    // This allows us to amortize the cost of the @atomicStore to `tail` across multiple SQEs.
    </span>sqe_head: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
    sqe_tail: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, p: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a>) !<a href="std.os.linux.IoUring.SubmissionQueue.html">SubmissionQueue</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(fd &gt;= <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>((p.features &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_FEAT_SINGLE_MMAP">IORING_FEAT_SINGLE_MMAP</a>) != <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> size = <span class="tok-builtin">@max</span>(
            p.sq_off.array + p.sq_entries * <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u32</span>),
            p.cq_off.cqes + p.cq_entries * <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>),
        );
        <span class="tok-kw">const</span> mmap = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mmap">mmap</a>(
            <span class="tok-null">null</span>,
            size,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">READ</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">WRITE</a>,
            .{ .TYPE = .SHARED, .POPULATE = <span class="tok-null">true</span> },
            fd,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_OFF_SQ_RING">IORING_OFF_SQ_RING</a>,
        );
        <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(mmap);
        <a href="std.debug.html#std.debug.assert">assert</a>(mmap.len == size);<span class="tok-comment">

        // The motivation for the `sqes` and `array` indirection is to make it possible for the
        // application to preallocate static linux.io_uring_sqe entries and then replay them when needed.
        </span><span class="tok-kw">const</span> size_sqes = p.sq_entries * <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a>);
        <span class="tok-kw">const</span> mmap_sqes = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mmap">mmap</a>(
            <span class="tok-null">null</span>,
            size_sqes,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">READ</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">WRITE</a>,
            .{ .TYPE = .SHARED, .POPULATE = <span class="tok-null">true</span> },
            fd,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_OFF_SQES">IORING_OFF_SQES</a>,
        );
        <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(mmap_sqes);
        <a href="std.debug.html#std.debug.assert">assert</a>(mmap_sqes.len == size_sqes);

        <span class="tok-kw">const</span> array: [*]<span class="tok-type">u32</span> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.sq_off.array]));
        <span class="tok-kw">const</span> sqes: [*]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap_sqes[<span class="tok-number">0</span>]));<span class="tok-comment">
        // We expect the kernel copies p.sq_entries to the u32 pointed to by p.sq_off.ring_entries,
        // see https://github.com/torvalds/linux/blob/v5.8/fs/io_uring.c#L7843-L7844.
        </span><a href="std.debug.html#std.debug.assert">assert</a>(p.sq_entries == <span class="tok-builtin">@as</span>(*<span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.sq_off.ring_entries]))).*);
        <span class="tok-kw">return</span> <a href="std.os.linux.IoUring.SubmissionQueue.html">SubmissionQueue</a>{
            .head = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.sq_off.head])),
            .tail = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.sq_off.tail])),
            .mask = <span class="tok-builtin">@as</span>(*<span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.sq_off.ring_mask]))).*,
            .flags = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.sq_off.flags])),
            .dropped = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.sq_off.dropped])),
            .array = array[<span class="tok-number">0</span>..p.sq_entries],
            .sqes = sqes[<span class="tok-number">0</span>..p.sq_entries],
            .mmap = mmap,
            .mmap_sqes = mmap_sqes,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.os.linux.IoUring.SubmissionQueue.html">SubmissionQueue</a>) <span class="tok-type">void</span> {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(self.mmap_sqes);
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(self.mmap);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompletionQueue = <span class="tok-kw">struct</span> {
    head: *<span class="tok-type">u32</span>,
    tail: *<span class="tok-type">u32</span>,
    mask: <span class="tok-type">u32</span>,
    overflow: *<span class="tok-type">u32</span>,
    cqes: []<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, p: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a>, sq: <a href="std.os.linux.IoUring.SubmissionQueue.html">SubmissionQueue</a>) !<a href="std.os.linux.IoUring.CompletionQueue.html">CompletionQueue</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(fd &gt;= <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>((p.features &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_FEAT_SINGLE_MMAP">IORING_FEAT_SINGLE_MMAP</a>) != <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> mmap = sq.mmap;
        <span class="tok-kw">const</span> cqes: [*]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.cq_off.cqes]));
        <a href="std.debug.html#std.debug.assert">assert</a>(p.cq_entries == <span class="tok-builtin">@as</span>(*<span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.cq_off.ring_entries]))).*);
        <span class="tok-kw">return</span> <a href="std.os.linux.IoUring.CompletionQueue.html">CompletionQueue</a>{
            .head = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.cq_off.head])),
            .tail = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.cq_off.tail])),
            .mask = <span class="tok-builtin">@as</span>(*<span class="tok-type">u32</span>, <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.cq_off.ring_mask]))).*,
            .overflow = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(&amp;mmap[p.cq_off.overflow])),
            .cqes = cqes[<span class="tok-number">0</span>..p.cq_entries],
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.os.linux.IoUring.CompletionQueue.html">CompletionQueue</a>) <span class="tok-type">void</span> {
        _ = self;<span class="tok-comment">
        // A no-op since we now share the mmap with the submission queue.
        // Here for symmetry with the submission queue, and for any future feature support.
    </span>}
};

<span class="tok-comment">/// Group of application provided buffers. Uses newer type, called ring mapped</span>
<span class="tok-comment">/// buffers, supported since kernel 5.19. Buffers are identified by a buffer</span>
<span class="tok-comment">/// group ID, and within that group, a buffer ID. IO_Uring can have multiple</span>
<span class="tok-comment">/// buffer groups, each with unique group ID.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// In `init` application provides contiguous block of memory `buffers` for</span>
<span class="tok-comment">/// `buffers_count` buffers of size `buffers_size`. Application can then submit</span>
<span class="tok-comment">/// `recv` operation without providing buffer upfront. Once the operation is</span>
<span class="tok-comment">/// ready to receive data, a buffer is picked automatically and the resulting</span>
<span class="tok-comment">/// CQE will contain the buffer ID in `cqe.buffer_id()`. Use `get` method to get</span>
<span class="tok-comment">/// buffer for buffer ID identified by CQE. Once the application has processed</span>
<span class="tok-comment">/// the buffer, it may hand ownership back to the kernel, by calling `put`</span>
<span class="tok-comment">/// allowing the cycle to repeat.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Depending on the rate of arrival of data, it is possible that a given buffer</span>
<span class="tok-comment">/// group will run out of buffers before those in CQEs can be put back to the</span>
<span class="tok-comment">/// kernel. If this happens, a `cqe.err()` will have ENOBUFS as the error value.</span>
<span class="tok-comment">///</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BufferGroup = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Parent ring for which this group is registered.</span>
    ring: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    <span class="tok-comment">/// Pointer to the memory shared by the kernel.</span>
    <span class="tok-comment">/// `buffers_count` of `io_uring_buf` structures are shared by the kernel.</span>
    <span class="tok-comment">/// First `io_uring_buf` is overlaid by `io_uring_buf_ring` struct.</span>
    br: *<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>,
    <span class="tok-comment">/// Contiguous block of memory of size (buffers_count * buffer_size).</span>
    buffers: []<span class="tok-type">u8</span>,
    <span class="tok-comment">/// Size of each buffer in buffers.</span>
    buffer_size: <span class="tok-type">u32</span>,<span class="tok-comment">
    // Number of buffers in `buffers`, number of `io_uring_buf structures` in br.
    </span>buffers_count: <span class="tok-type">u16</span>,
    <span class="tok-comment">/// ID of this group, must be unique in ring.</span>
    group_id: <span class="tok-type">u16</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(
        ring: *<a href="std.os.linux.IoUring.html">IoUring</a>,
        group_id: <span class="tok-type">u16</span>,
        buffers: []<span class="tok-type">u8</span>,
        buffer_size: <span class="tok-type">u32</span>,
        buffers_count: <span class="tok-type">u16</span>,
    ) !<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(buffers.len == buffers_count * buffer_size);

        <span class="tok-kw">const</span> br = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.setup_buf_ring">setup_buf_ring</a>(ring.fd, buffers_count, group_id);
        <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.buf_ring_init">buf_ring_init</a>(br);

        <span class="tok-kw">const</span> mask = <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.buf_ring_mask">buf_ring_mask</a>(buffers_count);
        <span class="tok-kw">var</span> i: <span class="tok-type">u16</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; buffers_count) : (i += <span class="tok-number">1</span>) {
            <span class="tok-kw">const</span> start = buffer_size * i;
            <span class="tok-kw">const</span> buf = buffers[start .. start + buffer_size];
            <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.buf_ring_add">buf_ring_add</a>(br, buf, i, mask, i);
        }
        <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.buf_ring_advance">buf_ring_advance</a>(br, buffers_count);

        <span class="tok-kw">return</span> <a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>{
            .ring = ring,
            .group_id = group_id,
            .br = br,
            .buffers = buffers,
            .buffer_size = buffer_size,
            .buffers_count = buffers_count,
        };
    }<span class="tok-comment">

    // Prepare recv operation which will select buffer from this group.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recv</span>(self: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, flags: <span class="tok-type">u32</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
        <span class="tok-kw">var</span> sqe = <span class="tok-kw">try</span> self.ring.get_sqe();
        sqe.prep_rw(.RECV, fd, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
        sqe.rw_flags = flags;
        sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>;
        sqe.buf_index = self.group_id;
        sqe.user_data = user_data;
        <span class="tok-kw">return</span> sqe;
    }<span class="tok-comment">

    // Prepare multishot recv operation which will select buffer from this group.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">recv_multishot</span>(self: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>, user_data: <span class="tok-type">u64</span>, fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, flags: <span class="tok-type">u32</span>) !*<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a> {
        <span class="tok-kw">var</span> sqe = <span class="tok-kw">try</span> self.recv(user_data, fd, flags);
        sqe.ioprio |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_RECV_MULTISHOT">IORING_RECV_MULTISHOT</a>;
        <span class="tok-kw">return</span> sqe;
    }<span class="tok-comment">

    // Get buffer by id.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>, buffer_id: <span class="tok-type">u16</span>) []<span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> head = self.buffer_size * buffer_id;
        <span class="tok-kw">return</span> self.buffers[head .. head + self.buffer_size];
    }<span class="tok-comment">

    // Get buffer by CQE.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get_cqe</span>(self: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>, cqe: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>) ![]<span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> buffer_id = <span class="tok-kw">try</span> cqe.buffer_id();
        <span class="tok-kw">const</span> used_len = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res));
        <span class="tok-kw">return</span> self.get(buffer_id)[<span class="tok-number">0</span>..used_len];
    }<span class="tok-comment">

    // Release buffer to the kernel.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>, buffer_id: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> mask = <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.buf_ring_mask">buf_ring_mask</a>(self.buffers_count);
        <span class="tok-kw">const</span> buffer = self.get(buffer_id);
        <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.buf_ring_add">buf_ring_add</a>(self.br, buffer, buffer_id, mask, <span class="tok-number">0</span>);
        <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.buf_ring_advance">buf_ring_advance</a>(self.br, <span class="tok-number">1</span>);
    }<span class="tok-comment">

    // Release buffer from CQE to the kernel.
    </span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put_cqe</span>(self: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>, cqe: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>) !<span class="tok-type">void</span> {
        self.put(<span class="tok-kw">try</span> cqe.buffer_id());
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>) <span class="tok-type">void</span> {
        <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.free_buf_ring">free_buf_ring</a>(self.ring.fd, self.br, self.buffers_count, self.group_id);
    }
};

<span class="tok-comment">/// Registers a shared buffer ring to be used with provided buffers.</span>
<span class="tok-comment">/// `entries` number of `io_uring_buf` structures is mem mapped and shared by kernel.</span>
<span class="tok-comment">/// `fd` is IO_Uring.fd for which the provided buffer ring is being registered.</span>
<span class="tok-comment">/// `entries` is the number of entries requested in the buffer ring, must be power of 2.</span>
<span class="tok-comment">/// `group_id` is the chosen buffer group ID, unique in IO_Uring.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setup_buf_ring</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, entries: <span class="tok-type">u16</span>, group_id: <span class="tok-type">u16</span>) !*<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a> {
    <span class="tok-kw">if</span> (entries == <span class="tok-number">0</span> <span class="tok-kw">or</span> entries &gt; <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">15</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EntriesNotInRange;
    <span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(entries)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.EntriesNotPowerOfTwo;

    <span class="tok-kw">const</span> mmap_size = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, entries) * <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf.html">io_uring_buf</a>);
    <span class="tok-kw">const</span> mmap = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mmap">mmap</a>(
        <span class="tok-null">null</span>,
        mmap_size,
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">READ</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PROT">PROT</a>.<a href="#">WRITE</a>,
        .{ .TYPE = .PRIVATE, .ANONYMOUS = <span class="tok-null">true</span> },
        -<span class="tok-number">1</span>,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(mmap);
    <a href="std.debug.html#std.debug.assert">assert</a>(mmap.len == mmap_size);

    <span class="tok-kw">const</span> br: *<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a> = <span class="tok-builtin">@ptrCast</span>(mmap.ptr);
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.register_buf_ring">register_buf_ring</a>(fd, <span class="tok-builtin">@intFromPtr</span>(br), entries, group_id);
    <span class="tok-kw">return</span> br;
}

<span class="tok-kw">fn</span> <span class="tok-fn">register_buf_ring</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, addr: <span class="tok-type">u64</span>, entries: <span class="tok-type">u32</span>, group_id: <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> reg = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_reg.html">io_uring_buf_reg</a>, .{
        .ring_addr = addr,
        .ring_entries = entries,
        .bgid = group_id,
    });
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        fd,
        .REGISTER_PBUF_RING,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;reg)),
        <span class="tok-number">1</span>,
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_register_buf_ring_result">handle_register_buf_ring_result</a>(res);
}

<span class="tok-kw">fn</span> <span class="tok-fn">unregister_buf_ring</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, group_id: <span class="tok-type">u16</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> reg = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroInit">zeroInit</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_reg.html">io_uring_buf_reg</a>, .{
        .bgid = group_id,
    });
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.io_uring_register">io_uring_register</a>(
        fd,
        .UNREGISTER_PBUF_RING,
        <span class="tok-builtin">@as</span>(*<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-builtin">@ptrCast</span>(&amp;reg)),
        <span class="tok-number">1</span>,
    );
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.handle_register_buf_ring_result">handle_register_buf_ring_result</a>(res);
}

<span class="tok-kw">fn</span> <span class="tok-fn">handle_register_buf_ring_result</span>(res: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},
        .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ArgumentsInvalid,
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }
}<span class="tok-comment">

// Unregisters a previously registered shared buffer ring, returned from io_uring_setup_buf_ring.
</span><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">free_buf_ring</span>(fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, br: *<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>, entries: <span class="tok-type">u32</span>, group_id: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
    <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.unregister_buf_ring">unregister_buf_ring</a>(fd, group_id) <span class="tok-kw">catch</span> {};
    <span class="tok-kw">var</span> mmap: []<span class="tok-kw">align</span>(<a href="std.heap.html#std.heap.page_size_min">page_size_min</a>) <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    mmap.ptr = <span class="tok-builtin">@ptrCast</span>(br);
    mmap.len = entries * <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf.html">io_uring_buf</a>);
    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.munmap">munmap</a>(mmap);
}

<span class="tok-comment">/// Initialises `br` so that it is ready to be used.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_init</span>(br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>) <span class="tok-type">void</span> {
    br.tail = <span class="tok-number">0</span>;
}

<span class="tok-comment">/// Calculates the appropriate size mask for a buffer ring.</span>
<span class="tok-comment">/// `entries` is the ring entries as specified in io_uring_register_buf_ring.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_mask</span>(entries: <span class="tok-type">u16</span>) <span class="tok-type">u16</span> {
    <span class="tok-kw">return</span> entries - <span class="tok-number">1</span>;
}

<span class="tok-comment">/// Assigns `buffer` with the `br` buffer ring.</span>
<span class="tok-comment">/// `buffer_id` is identifier which will be returned in the CQE.</span>
<span class="tok-comment">/// `buffer_offset` is the offset to insert at from the current tail.</span>
<span class="tok-comment">/// If just one buffer is provided before the ring tail is committed with advance then offset should be 0.</span>
<span class="tok-comment">/// If buffers are provided in a loop before being committed, the offset must be incremented by one for each buffer added.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_add</span>(
    br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>,
    buffer: []<span class="tok-type">u8</span>,
    buffer_id: <span class="tok-type">u16</span>,
    mask: <span class="tok-type">u16</span>,
    buffer_offset: <span class="tok-type">u16</span>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bufs: [*]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf.html">io_uring_buf</a> = <span class="tok-builtin">@ptrCast</span>(br);
    <span class="tok-kw">const</span> buf: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf.html">io_uring_buf</a> = &amp;bufs[(br.tail +% buffer_offset) &amp; mask];

    buf.addr = <span class="tok-builtin">@intFromPtr</span>(buffer.ptr);
    buf.len = <span class="tok-builtin">@intCast</span>(buffer.len);
    buf.bid = buffer_id;
}

<span class="tok-comment">/// Make `count` new buffers visible to the kernel. Called after</span>
<span class="tok-comment">/// `io_uring_buf_ring_add` has been called `count` times to fill in new buffers.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buf_ring_advance</span>(br: *<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_buf_ring.html">io_uring_buf_ring</a>, count: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> tail: <span class="tok-type">u16</span> = br.tail +% count;
    <span class="tok-builtin">@atomicStore</span>(<span class="tok-type">u16</span>, &amp;br.tail, tail, .release);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;structs/offsets/entries&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">120</span>), <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_params.html">io_uring_params</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">64</span>), <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">16</span>), <span class="tok-builtin">@sizeOf</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>));

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_OFF_SQ_RING">IORING_OFF_SQ_RING</a>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0x8000000</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_OFF_CQ_RING">IORING_OFF_CQ_RING</a>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0x10000000</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_OFF_SQES">IORING_OFF_SQES</a>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.EntriesZero, <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">0</span>, <span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.EntriesNotPowerOfTwo, <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">3</span>, <span class="tok-number">0</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;nop&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> {
        ring.deinit();
        <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>, -<span class="tok-number">1</span>), ring.fd) <span class="tok-kw">catch</span> <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;test failed&quot;</span>);
    }

    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.nop(<span class="tok-number">0xaaaaaaaa</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a>{
        .opcode = .NOP,
        .flags = <span class="tok-number">0</span>,
        .ioprio = <span class="tok-number">0</span>,
        .fd = <span class="tok-number">0</span>,
        .off = <span class="tok-number">0</span>,
        .addr = <span class="tok-number">0</span>,
        .len = <span class="tok-number">0</span>,
        .rw_flags = <span class="tok-number">0</span>,
        .user_data = <span class="tok-number">0xaaaaaaaa</span>,
        .buf_index = <span class="tok-number">0</span>,
        .personality = <span class="tok-number">0</span>,
        .splice_fd_in = <span class="tok-number">0</span>,
        .addr3 = <span class="tok-number">0</span>,
        .resv = <span class="tok-number">0</span>,
    }, sqe.*);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.sq.sqe_head);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), ring.sq.sqe_tail);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.sq.tail.*);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.cq.head.*);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), ring.sq_ready());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.cq_ready());

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), ring.sq.sqe_head);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), ring.sq.sqe_tail);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), ring.sq.tail.*);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.cq.head.*);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.sq_ready());

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xaaaaaaaa</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, <span class="tok-kw">try</span> ring.copy_cqe());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), ring.cq.head.*);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.cq_ready());

    <span class="tok-kw">const</span> sqe_barrier = <span class="tok-kw">try</span> ring.nop(<span class="tok-number">0xbbbbbbbb</span>);
    sqe_barrier.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_DRAIN">IOSQE_IO_DRAIN</a>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xbbbbbbbb</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, <span class="tok-kw">try</span> ring.copy_cqe());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), ring.sq.sqe_head);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), ring.sq.sqe_tail);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), ring.sq.tail.*);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), ring.cq.head.*);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;readv&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openZ">openZ</a>(<span class="tok-str">&quot;/dev/zero&quot;</span>, .{ .ACCMODE = .RDONLY, .CLOEXEC = <span class="tok-null">true</span> }, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);<span class="tok-comment">

    // Linux Kernel 5.4 supports IORING_REGISTER_FILES but not sparse fd sets (i.e. an fd of -1).
    // Linux Kernel 5.5 adds support for sparse fd sets.
    // Compare:
    // https://github.com/torvalds/linux/blob/v5.4/fs/io_uring.c#L3119-L3124 vs
    // https://github.com/torvalds/linux/blob/v5.8/fs/io_uring.c#L6687-L6691
    // We therefore avoid stressing sparse fd sets here:
    </span><span class="tok-kw">var</span> registered_fds = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>{<span class="tok-number">0</span>} ** <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> fd_index = <span class="tok-number">0</span>;
    registered_fds[fd_index] = fd;
    <span class="tok-kw">try</span> ring.register_files(registered_fds[<span class="tok-number">0</span>..]);

    <span class="tok-kw">var</span> buffer = [_]<span class="tok-type">u8</span>{<span class="tok-number">42</span>} ** <span class="tok-number">128</span>;
    <span class="tok-kw">var</span> iovecs = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{ .base = &amp;buffer, .len = buffer.len }};
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xcccccccc</span>, fd_index, .{ .iovecs = iovecs[<span class="tok-number">0</span>..] }, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READV</a>, sqe.opcode);
    sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_FIXED_FILE">IOSQE_FIXED_FILE</a>;

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.SubmissionQueueFull, ring.nop(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xcccccccc</span>,
        .res = buffer.len,
        .flags = <span class="tok-number">0</span>,
    }, <span class="tok-kw">try</span> ring.copy_cqe());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** buffer.len), buffer[<span class="tok-number">0</span>..]);

    <span class="tok-kw">try</span> ring.unregister_files();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;writev/fsync/readv&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">4</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_writev_fsync_readv&quot;</span>;
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> tmp.dir.createFile(path, .{ .read = <span class="tok-null">true</span>, .truncate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">const</span> fd = file.handle;

    <span class="tok-kw">const</span> buffer_write = [_]<span class="tok-type">u8</span>{<span class="tok-number">42</span>} ** <span class="tok-number">128</span>;
    <span class="tok-kw">const</span> iovecs_write = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{
        <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{ .base = &amp;buffer_write, .len = buffer_write.len },
    };
    <span class="tok-kw">var</span> buffer_read = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">128</span>;
    <span class="tok-kw">var</span> iovecs_read = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{
        <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{ .base = &amp;buffer_read, .len = buffer_read.len },
    };

    <span class="tok-kw">const</span> sqe_writev = <span class="tok-kw">try</span> ring.writev(<span class="tok-number">0xdddddddd</span>, fd, iovecs_write[<span class="tok-number">0</span>..], <span class="tok-number">17</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">WRITEV</a>, sqe_writev.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">17</span>), sqe_writev.off);
    sqe_writev.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;

    <span class="tok-kw">const</span> sqe_fsync = <span class="tok-kw">try</span> ring.fsync(<span class="tok-number">0xeeeeeeee</span>, fd, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">FSYNC</a>, sqe_fsync.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(fd, sqe_fsync.fd);
    sqe_fsync.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;

    <span class="tok-kw">const</span> sqe_readv = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xffffffff</span>, fd, .{ .iovecs = iovecs_read[<span class="tok-number">0</span>..] }, <span class="tok-number">17</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READV</a>, sqe_readv.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">17</span>), sqe_readv.off);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">3</span>), ring.sq_ready());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">3</span>), <span class="tok-kw">try</span> ring.submit_and_wait(<span class="tok-number">3</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.sq_ready());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">3</span>), ring.cq_ready());

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xdddddddd</span>,
        .res = buffer_write.len,
        .flags = <span class="tok-number">0</span>,
    }, <span class="tok-kw">try</span> ring.copy_cqe());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), ring.cq_ready());

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xeeeeeeee</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, <span class="tok-kw">try</span> ring.copy_cqe());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), ring.cq_ready());

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xffffffff</span>,
        .res = buffer_read.len,
        .flags = <span class="tok-number">0</span>,
    }, <span class="tok-kw">try</span> ring.copy_cqe());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.cq_ready());

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, buffer_write[<span class="tok-number">0</span>..], buffer_read[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;write/read&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">2</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();
    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_write_read&quot;</span>;
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> tmp.dir.createFile(path, .{ .read = <span class="tok-null">true</span>, .truncate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">const</span> fd = file.handle;

    <span class="tok-kw">const</span> buffer_write = [_]<span class="tok-type">u8</span>{<span class="tok-number">97</span>} ** <span class="tok-number">20</span>;
    <span class="tok-kw">var</span> buffer_read = [_]<span class="tok-type">u8</span>{<span class="tok-number">98</span>} ** <span class="tok-number">20</span>;
    <span class="tok-kw">const</span> sqe_write = <span class="tok-kw">try</span> ring.write(<span class="tok-number">0x11111111</span>, fd, buffer_write[<span class="tok-number">0</span>..], <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">WRITE</a>, sqe_write.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">10</span>), sqe_write.off);
    sqe_write.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;
    <span class="tok-kw">const</span> sqe_read = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0x22222222</span>, fd, .{ .buffer = buffer_read[<span class="tok-number">0</span>..] }, <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ</a>, sqe_read.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">10</span>), sqe_read.off);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe_write = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">const</span> cqe_read = <span class="tok-kw">try</span> ring.copy_cqe();<span class="tok-comment">
    // Prior to Linux Kernel 5.6 this is the only way to test for read/write support:
    // https://lwn.net/Articles/809820/
    </span><span class="tok-kw">if</span> (cqe_write.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">if</span> (cqe_read.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x11111111</span>,
        .res = buffer_write.len,
        .flags = <span class="tok-number">0</span>,
    }, cqe_write);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x22222222</span>,
        .res = buffer_read.len,
        .flags = <span class="tok-number">0</span>,
    }, cqe_read);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, buffer_write[<span class="tok-number">0</span>..], buffer_read[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;splice/read&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">4</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">const</span> path_src = <span class="tok-str">&quot;test_io_uring_splice_src&quot;</span>;
    <span class="tok-kw">const</span> file_src = <span class="tok-kw">try</span> tmp.dir.createFile(path_src, .{ .read = <span class="tok-null">true</span>, .truncate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> file_src.close();
    <span class="tok-kw">const</span> fd_src = file_src.handle;

    <span class="tok-kw">const</span> path_dst = <span class="tok-str">&quot;test_io_uring_splice_dst&quot;</span>;
    <span class="tok-kw">const</span> file_dst = <span class="tok-kw">try</span> tmp.dir.createFile(path_dst, .{ .read = <span class="tok-null">true</span>, .truncate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> file_dst.close();
    <span class="tok-kw">const</span> fd_dst = file_dst.handle;

    <span class="tok-kw">const</span> buffer_write = [_]<span class="tok-type">u8</span>{<span class="tok-number">97</span>} ** <span class="tok-number">20</span>;
    <span class="tok-kw">var</span> buffer_read = [_]<span class="tok-type">u8</span>{<span class="tok-number">98</span>} ** <span class="tok-number">20</span>;
    _ = <span class="tok-kw">try</span> file_src.write(&amp;buffer_write);

    <span class="tok-kw">const</span> fds = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pipe">pipe</a>();
    <span class="tok-kw">const</span> pipe_offset: <span class="tok-type">u64</span> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u64</span>);

    <span class="tok-kw">const</span> sqe_splice_to_pipe = <span class="tok-kw">try</span> ring.splice(<span class="tok-number">0x11111111</span>, fd_src, <span class="tok-number">0</span>, fds[<span class="tok-number">1</span>], pipe_offset, buffer_write.len);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">SPLICE</a>, sqe_splice_to_pipe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe_splice_to_pipe.addr);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(pipe_offset, sqe_splice_to_pipe.off);
    sqe_splice_to_pipe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;

    <span class="tok-kw">const</span> sqe_splice_from_pipe = <span class="tok-kw">try</span> ring.splice(<span class="tok-number">0x22222222</span>, fds[<span class="tok-number">0</span>], pipe_offset, fd_dst, <span class="tok-number">10</span>, buffer_write.len);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">SPLICE</a>, sqe_splice_from_pipe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(pipe_offset, sqe_splice_from_pipe.addr);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">10</span>), sqe_splice_from_pipe.off);
    sqe_splice_from_pipe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;

    <span class="tok-kw">const</span> sqe_read = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0x33333333</span>, fd_dst, .{ .buffer = buffer_read[<span class="tok-number">0</span>..] }, <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ</a>, sqe_read.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">10</span>), sqe_read.off);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">3</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe_splice_to_pipe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">const</span> cqe_splice_from_pipe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">const</span> cqe_read = <span class="tok-kw">try</span> ring.copy_cqe();<span class="tok-comment">
    // Prior to Linux Kernel 5.6 this is the only way to test for splice/read support:
    // https://lwn.net/Articles/809820/
    </span><span class="tok-kw">if</span> (cqe_splice_to_pipe.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">if</span> (cqe_splice_from_pipe.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">if</span> (cqe_read.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x11111111</span>,
        .res = buffer_write.len,
        .flags = <span class="tok-number">0</span>,
    }, cqe_splice_to_pipe);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x22222222</span>,
        .res = buffer_write.len,
        .flags = <span class="tok-number">0</span>,
    }, cqe_splice_from_pipe);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x33333333</span>,
        .res = buffer_read.len,
        .flags = <span class="tok-number">0</span>,
    }, cqe_read);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, buffer_write[<span class="tok-number">0</span>..], buffer_read[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;write_fixed/read_fixed&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">2</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_write_read_fixed&quot;</span>;
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> tmp.dir.createFile(path, .{ .read = <span class="tok-null">true</span>, .truncate = <span class="tok-null">true</span> });
    <span class="tok-kw">defer</span> file.close();
    <span class="tok-kw">const</span> fd = file.handle;

    <span class="tok-kw">var</span> raw_buffers: [<span class="tok-number">2</span>][<span class="tok-number">11</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">
    // First buffer will be written to the file.
    </span><span class="tok-builtin">@memset</span>(&amp;raw_buffers[<span class="tok-number">0</span>], <span class="tok-str">'z'</span>);
    raw_buffers[<span class="tok-number">0</span>][<span class="tok-number">0</span>..<span class="tok-str">&quot;foobar&quot;</span>.len].* = <span class="tok-str">&quot;foobar&quot;</span>.*;

    <span class="tok-kw">var</span> buffers = [<span class="tok-number">2</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{
        .{ .base = &amp;raw_buffers[<span class="tok-number">0</span>], .len = raw_buffers[<span class="tok-number">0</span>].len },
        .{ .base = &amp;raw_buffers[<span class="tok-number">1</span>], .len = raw_buffers[<span class="tok-number">1</span>].len },
    };
    ring.register_buffers(&amp;buffers) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemResources =&gt; {<span class="tok-comment">
            // See https://github.com/ziglang/zig/issues/15362
            </span><span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
        },
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };

    <span class="tok-kw">const</span> sqe_write = <span class="tok-kw">try</span> ring.write_fixed(<span class="tok-number">0x45454545</span>, fd, &amp;buffers[<span class="tok-number">0</span>], <span class="tok-number">3</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">WRITE_FIXED</a>, sqe_write.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">3</span>), sqe_write.off);
    sqe_write.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;

    <span class="tok-kw">const</span> sqe_read = <span class="tok-kw">try</span> ring.read_fixed(<span class="tok-number">0x12121212</span>, fd, &amp;buffers[<span class="tok-number">1</span>], <span class="tok-number">0</span>, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ_FIXED</a>, sqe_read.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe_read.off);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe_write = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">const</span> cqe_read = <span class="tok-kw">try</span> ring.copy_cqe();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x45454545</span>,
        .res = <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intCast</span>(buffers[<span class="tok-number">0</span>].len)),
        .flags = <span class="tok-number">0</span>,
    }, cqe_write);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x12121212</span>,
        .res = <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intCast</span>(buffers[<span class="tok-number">1</span>].len)),
        .flags = <span class="tok-number">0</span>,
    }, cqe_read);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;\x00\x00\x00&quot;</span>, buffers[<span class="tok-number">1</span>].base[<span class="tok-number">0</span>..<span class="tok-number">3</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foobar&quot;</span>, buffers[<span class="tok-number">1</span>].base[<span class="tok-number">3</span>..<span class="tok-number">9</span>]);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, <span class="tok-str">&quot;zz&quot;</span>, buffers[<span class="tok-number">1</span>].base[<span class="tok-number">9</span>..<span class="tok-number">11</span>]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;openat&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_openat&quot;</span>;<span class="tok-comment">

    // Workaround for LLVM bug: https://github.com/ziglang/zig/issues/12014
    </span><span class="tok-kw">const</span> path_addr = <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.zig_backend">zig_backend</a> == .stage2_llvm) p: {
        <span class="tok-kw">var</span> workaround = path;
        _ = &amp;workaround;
        <span class="tok-kw">break</span> :p <span class="tok-builtin">@intFromPtr</span>(workaround);
    } <span class="tok-kw">else</span> <span class="tok-builtin">@intFromPtr</span>(path);

    <span class="tok-kw">const</span> flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a> = .{ .CLOEXEC = <span class="tok-null">true</span>, .ACCMODE = .RDWR, .CREAT = <span class="tok-null">true</span> };
    <span class="tok-kw">const</span> mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a> = <span class="tok-number">0o666</span>;
    <span class="tok-kw">const</span> sqe_openat = <span class="tok-kw">try</span> ring.openat(<span class="tok-number">0x33333333</span>, tmp.dir.fd, path, flags, mode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_sqe.io_uring_sqe.html">io_uring_sqe</a>{
        .opcode = .OPENAT,
        .flags = <span class="tok-number">0</span>,
        .ioprio = <span class="tok-number">0</span>,
        .fd = tmp.dir.fd,
        .off = <span class="tok-number">0</span>,
        .addr = path_addr,
        .len = mode,
        .rw_flags = <span class="tok-builtin">@bitCast</span>(flags),
        .user_data = <span class="tok-number">0x33333333</span>,
        .buf_index = <span class="tok-number">0</span>,
        .personality = <span class="tok-number">0</span>,
        .splice_fd_in = <span class="tok-number">0</span>,
        .addr3 = <span class="tok-number">0</span>,
        .resv = <span class="tok-number">0</span>,
    }, sqe_openat.*);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe_openat = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0x33333333</span>), cqe_openat.user_data);
    <span class="tok-kw">if</span> (cqe_openat.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">if</span> (cqe_openat.err() == .BADF) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">if</span> (cqe_openat.res &lt;= <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;\ncqe_openat.res={}\n&quot;</span>, .{cqe_openat.res});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_openat.res &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), cqe_openat.flags);

    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(cqe_openat.res);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;close&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_close&quot;</span>;
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> tmp.dir.createFile(path, .{});
    <span class="tok-kw">errdefer</span> file.close();

    <span class="tok-kw">const</span> sqe_close = <span class="tok-kw">try</span> ring.close(<span class="tok-number">0x44444444</span>, file.handle);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">CLOSE</a>, sqe_close.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(file.handle, sqe_close.fd);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe_close = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_close.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x44444444</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe_close);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;accept/connect/send/recv&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> socket_test_harness = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createSocketTestHarness">createSocketTestHarness</a>(&amp;ring);
    <span class="tok-kw">defer</span> socket_test_harness.close();

    <span class="tok-kw">const</span> buffer_send = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> buffer_recv = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };

    <span class="tok-kw">const</span> sqe_send = <span class="tok-kw">try</span> ring.send(<span class="tok-number">0xeeeeeeee</span>, socket_test_harness.client, buffer_send[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);
    sqe_send.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;
    _ = <span class="tok-kw">try</span> ring.recv(<span class="tok-number">0xffffffff</span>, socket_test_harness.server, .{ .buffer = buffer_recv[<span class="tok-number">0</span>..] }, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe_send = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_send.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xeeeeeeee</span>,
        .res = buffer_send.len,
        .flags = <span class="tok-number">0</span>,
    }, cqe_send);

    <span class="tok-kw">const</span> cqe_recv = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_recv.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xffffffff</span>,
        .res = buffer_recv.len,<span class="tok-comment">
        // ignore IORING_CQE_F_SOCK_NONEMPTY since it is only set on some systems
        </span>.flags = cqe_recv.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_SOCK_NONEMPTY">IORING_CQE_F_SOCK_NONEMPTY</a>,
    }, cqe_recv);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, buffer_send[<span class="tok-number">0</span>..buffer_recv.len], buffer_recv[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sendmsg/recvmsg&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">2</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> address_server = <span class="tok-kw">try</span> <a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(<span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> server = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address_server.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">DGRAM</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(server);
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setsockopt">setsockopt</a>(server, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">SOCKET</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SO">SO</a>.<a href="#">REUSEPORT</a>, &amp;<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)));
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setsockopt">setsockopt</a>(server, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">SOCKET</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SO">SO</a>.<a href="#">REUSEADDR</a>, &amp;<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)));
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.bind">bind</a>(server, &amp;address_server.any, address_server.getOsSockLen());<span class="tok-comment">

    // set address_server to the OS-chosen IP/port.
    </span><span class="tok-kw">var</span> slen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = address_server.getOsSockLen();
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getsockname">getsockname</a>(server, &amp;address_server.any, &amp;slen);

    <span class="tok-kw">const</span> client = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address_server.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">DGRAM</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(client);

    <span class="tok-kw">const</span> buffer_send = [_]<span class="tok-type">u8</span>{<span class="tok-number">42</span>} ** <span class="tok-number">128</span>;
    <span class="tok-kw">const</span> iovecs_send = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{
        <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{ .base = &amp;buffer_send, .len = buffer_send.len },
    };
    <span class="tok-kw">const</span> msg_send: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr_const">msghdr_const</a> = .{
        .name = &amp;address_server.any,
        .namelen = address_server.getOsSockLen(),
        .iov = &amp;iovecs_send,
        .iovlen = <span class="tok-number">1</span>,
        .control = <span class="tok-null">null</span>,
        .controllen = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">const</span> sqe_sendmsg = <span class="tok-kw">try</span> ring.sendmsg(<span class="tok-number">0x11111111</span>, client, &amp;msg_send, <span class="tok-number">0</span>);
    sqe_sendmsg.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">SENDMSG</a>, sqe_sendmsg.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(client, sqe_sendmsg.fd);

    <span class="tok-kw">var</span> buffer_recv = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">128</span>;
    <span class="tok-kw">var</span> iovecs_recv = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{
        <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>{ .base = &amp;buffer_recv, .len = buffer_recv.len },
    };
    <span class="tok-kw">const</span> addr = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">4</span>;
    <span class="tok-kw">var</span> address_recv = <a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.initIp4">initIp4</a>(addr, <span class="tok-number">0</span>);
    <span class="tok-kw">var</span> msg_recv: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.msghdr">msghdr</a> = .{
        .name = &amp;address_recv.any,
        .namelen = address_recv.getOsSockLen(),
        .iov = &amp;iovecs_recv,
        .iovlen = <span class="tok-number">1</span>,
        .control = <span class="tok-null">null</span>,
        .controllen = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">const</span> sqe_recvmsg = <span class="tok-kw">try</span> ring.recvmsg(<span class="tok-number">0x22222222</span>, server, &amp;msg_recv, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">RECVMSG</a>, sqe_recvmsg.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(server, sqe_recvmsg.fd);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), ring.sq_ready());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit_and_wait(<span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), ring.sq_ready());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), ring.cq_ready());

    <span class="tok-kw">const</span> cqe_sendmsg = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_sendmsg.res == -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">INVAL</a>))) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x11111111</span>,
        .res = buffer_send.len,
        .flags = <span class="tok-number">0</span>,
    }, cqe_sendmsg);

    <span class="tok-kw">const</span> cqe_recvmsg = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_recvmsg.res == -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">INVAL</a>))) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x22222222</span>,
        .res = buffer_recv.len,<span class="tok-comment">
        // ignore IORING_CQE_F_SOCK_NONEMPTY since it is set non-deterministically
        </span>.flags = cqe_recvmsg.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_SOCK_NONEMPTY">IORING_CQE_F_SOCK_NONEMPTY</a>,
    }, cqe_recvmsg);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, buffer_send[<span class="tok-number">0</span>..buffer_recv.len], buffer_recv[<span class="tok-number">0</span>..]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;timeout (after a relative time)&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> ms = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> margin = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> ts: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a> = .{ .sec = <span class="tok-number">0</span>, .nsec = ms * <span class="tok-number">1000000</span> };

    <span class="tok-kw">const</span> started = <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.milliTimestamp">milliTimestamp</a>();
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.timeout(<span class="tok-number">0x55555555</span>, &amp;ts, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">TIMEOUT</a>, sqe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">const</span> stopped = <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.milliTimestamp">milliTimestamp</a>();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x55555555</span>,
        .res = -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">TIME</a>)),
        .flags = <span class="tok-number">0</span>,
    }, cqe);<span class="tok-comment">

    // Tests should not depend on timings: skip test if outside margin.
    </span><span class="tok-kw">if</span> (!<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.approxEqAbs">approxEqAbs</a>(<span class="tok-type">f64</span>, ms, <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-builtin">@floatFromInt</span>(stopped - started)), margin)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;timeout (after a number of completions)&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">2</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> ts: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a> = .{ .sec = <span class="tok-number">3</span>, .nsec = <span class="tok-number">0</span> };
    <span class="tok-kw">const</span> count_completions: <span class="tok-type">u64</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> sqe_timeout = <span class="tok-kw">try</span> ring.timeout(<span class="tok-number">0x66666666</span>, &amp;ts, count_completions, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">TIMEOUT</a>, sqe_timeout.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(count_completions, sqe_timeout.off);
    _ = <span class="tok-kw">try</span> ring.nop(<span class="tok-number">0x77777777</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe_nop = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x77777777</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe_nop);

    <span class="tok-kw">const</span> cqe_timeout = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x66666666</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe_timeout);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;timeout_remove&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">2</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> ts: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a> = .{ .sec = <span class="tok-number">3</span>, .nsec = <span class="tok-number">0</span> };
    <span class="tok-kw">const</span> sqe_timeout = <span class="tok-kw">try</span> ring.timeout(<span class="tok-number">0x88888888</span>, &amp;ts, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">TIMEOUT</a>, sqe_timeout.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0x88888888</span>), sqe_timeout.user_data);

    <span class="tok-kw">const</span> sqe_timeout_remove = <span class="tok-kw">try</span> ring.timeout_remove(<span class="tok-number">0x99999999</span>, <span class="tok-number">0x88888888</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">TIMEOUT_REMOVE</a>, sqe_timeout_remove.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0x88888888</span>), sqe_timeout_remove.addr);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0x99999999</span>), sqe_timeout_remove.user_data);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment">

    // The order in which the CQE arrive is not clearly documented and it changed with kernel 5.18:
    // * kernel 5.10 gives user data 0x88888888 first, 0x99999999 second
    // * kernel 5.18 gives user data 0x99999999 first, 0x88888888 second

    </span><span class="tok-kw">var</span> cqes: [<span class="tok-number">2</span>]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> = <span class="tok-null">undefined</span>;
    cqes[<span class="tok-number">0</span>] = <span class="tok-kw">try</span> ring.copy_cqe();
    cqes[<span class="tok-number">1</span>] = <span class="tok-kw">try</span> ring.copy_cqe();

    <span class="tok-kw">for</span> (cqes) |cqe| {<span class="tok-comment">
        // IORING_OP_TIMEOUT_REMOVE is not supported by this kernel version:
        // Timeout remove operations set the fd to -1, which results in EBADF before EINVAL.
        // We use IORING_FEAT_RW_CUR_POS as a safety check here to make sure we are at least pre-5.6.
        // We don't want to skip this test for newer kernels.
        </span><span class="tok-kw">if</span> (cqe.user_data == <span class="tok-number">0x99999999</span> <span class="tok-kw">and</span>
            cqe.err() == .BADF <span class="tok-kw">and</span>
            (ring.features &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_FEAT_RW_CUR_POS">IORING_FEAT_RW_CUR_POS</a>) == <span class="tok-number">0</span>)
        {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.user_data == <span class="tok-number">0x88888888</span> <span class="tok-kw">or</span> cqe.user_data == <span class="tok-number">0x99999999</span>);

        <span class="tok-kw">if</span> (cqe.user_data == <span class="tok-number">0x88888888</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
                .user_data = <span class="tok-number">0x88888888</span>,
                .res = -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">CANCELED</a>)),
                .flags = <span class="tok-number">0</span>,
            }, cqe);
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cqe.user_data == <span class="tok-number">0x99999999</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
                .user_data = <span class="tok-number">0x99999999</span>,
                .res = <span class="tok-number">0</span>,
                .flags = <span class="tok-number">0</span>,
            }, cqe);
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;accept/connect/recv/link_timeout&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> socket_test_harness = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createSocketTestHarness">createSocketTestHarness</a>(&amp;ring);
    <span class="tok-kw">defer</span> socket_test_harness.close();

    <span class="tok-kw">var</span> buffer_recv = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };

    <span class="tok-kw">const</span> sqe_recv = <span class="tok-kw">try</span> ring.recv(<span class="tok-number">0xffffffff</span>, socket_test_harness.server, .{ .buffer = buffer_recv[<span class="tok-number">0</span>..] }, <span class="tok-number">0</span>);
    sqe_recv.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;

    <span class="tok-kw">const</span> ts = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.kernel_timespec.html">kernel_timespec</a>{ .sec = <span class="tok-number">0</span>, .nsec = <span class="tok-number">1000000</span> };
    _ = <span class="tok-kw">try</span> ring.link_timeout(<span class="tok-number">0x22222222</span>, &amp;ts, <span class="tok-number">0</span>);

    <span class="tok-kw">const</span> nr_wait = <span class="tok-kw">try</span> ring.submit();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), nr_wait);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; nr_wait) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.user_data) {
            <span class="tok-number">0xffffffff</span> =&gt; {
                <span class="tok-kw">if</span> (cqe.res != -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">INTR</a>)) <span class="tok-kw">and</span>
                    cqe.res != -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">CANCELED</a>)))
                {
                    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;Req 0x{x} got {d}\n&quot;</span>, .{ cqe.user_data, cqe.res });
                    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-null">false</span>);
                }
            },
            <span class="tok-number">0x22222222</span> =&gt; {
                <span class="tok-kw">if</span> (cqe.res != -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">ALREADY</a>)) <span class="tok-kw">and</span>
                    cqe.res != -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">TIME</a>)))
                {
                    <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;Req 0x{x} got {d}\n&quot;</span>, .{ cqe.user_data, cqe.res });
                    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-null">false</span>);
                }
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;should not happen&quot;</span>),
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fallocate&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_fallocate&quot;</span>;
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> tmp.dir.createFile(path, .{ .truncate = <span class="tok-null">true</span>, .mode = <span class="tok-number">0o666</span> });
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), (<span class="tok-kw">try</span> file.stat()).size);

    <span class="tok-kw">const</span> len: <span class="tok-type">u64</span> = <span class="tok-number">65536</span>;
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.fallocate(<span class="tok-number">0xaaaaaaaa</span>, file.handle, <span class="tok-number">0</span>, <span class="tok-number">0</span>, len);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">FALLOCATE</a>, sqe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(file.handle, sqe.fd);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">switch</span> (cqe.err()) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // This kernel's io_uring does not yet implement fallocate():
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,<span class="tok-comment">
        // This kernel does not implement fallocate():
        </span>.NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,<span class="tok-comment">
        // The filesystem containing the file referred to by fd does not support this operation;
        // or the mode is not supported by the filesystem containing the file referred to by fd:
        </span>.OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xaaaaaaaa</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(len, (<span class="tok-kw">try</span> file.stat()).size);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;statx&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();
    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_statx&quot;</span>;
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> tmp.dir.createFile(path, .{ .truncate = <span class="tok-null">true</span>, .mode = <span class="tok-number">0o666</span> });
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), (<span class="tok-kw">try</span> file.stat()).size);

    <span class="tok-kw">try</span> file.writeAll(<span class="tok-str">&quot;foobar&quot;</span>);

    <span class="tok-kw">var</span> buf: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.statx(
        <span class="tok-number">0xaaaaaaaa</span>,
        tmp.dir.fd,
        path,
        <span class="tok-number">0</span>,
        <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_SIZE">STATX_SIZE</a>,
        &amp;buf,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">STATX</a>, sqe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, tmp.dir.fd), sqe.fd);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">switch</span> (cqe.err()) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // This kernel's io_uring does not yet implement statx():
        </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,<span class="tok-comment">
        // This kernel does not implement statx():
        </span>.NOSYS =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,<span class="tok-comment">
        // The filesystem containing the file referred to by fd does not support this operation;
        // or the mode is not supported by the filesystem containing the file referred to by fd:
        </span>.OPNOTSUPP =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,<span class="tok-comment">
        // not supported on older kernels (5.4)
        </span>.BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xaaaaaaaa</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(buf.mask &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_SIZE">STATX_SIZE</a> == <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_SIZE">STATX_SIZE</a>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">6</span>), buf.size);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;accept/connect/recv/cancel&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> socket_test_harness = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createSocketTestHarness">createSocketTestHarness</a>(&amp;ring);
    <span class="tok-kw">defer</span> socket_test_harness.close();

    <span class="tok-kw">var</span> buffer_recv = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };

    _ = <span class="tok-kw">try</span> ring.recv(<span class="tok-number">0xffffffff</span>, socket_test_harness.server, .{ .buffer = buffer_recv[<span class="tok-number">0</span>..] }, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> sqe_cancel = <span class="tok-kw">try</span> ring.cancel(<span class="tok-number">0x99999999</span>, <span class="tok-number">0xffffffff</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">ASYNC_CANCEL</a>, sqe_cancel.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xffffffff</span>), sqe_cancel.addr);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0x99999999</span>), sqe_cancel.user_data);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">var</span> cqe_recv = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_recv.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">var</span> cqe_cancel = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_cancel.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment">

    // The recv/cancel CQEs may arrive in any order, the recv CQE will sometimes come first:
    </span><span class="tok-kw">if</span> (cqe_recv.user_data == <span class="tok-number">0x99999999</span> <span class="tok-kw">and</span> cqe_cancel.user_data == <span class="tok-number">0xffffffff</span>) {
        <span class="tok-kw">const</span> a = cqe_recv;
        <span class="tok-kw">const</span> b = cqe_cancel;
        cqe_recv = b;
        cqe_cancel = a;
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xffffffff</span>,
        .res = -<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intFromEnum</span>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">CANCELED</a>)),
        .flags = <span class="tok-number">0</span>,
    }, cqe_recv);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x99999999</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe_cancel);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;register_files_update&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openZ">openZ</a>(<span class="tok-str">&quot;/dev/zero&quot;</span>, .{ .ACCMODE = .RDONLY, .CLOEXEC = <span class="tok-null">true</span> }, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">var</span> registered_fds = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>{<span class="tok-number">0</span>} ** <span class="tok-number">2</span>;
    <span class="tok-kw">const</span> fd_index = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> fd_index2 = <span class="tok-number">1</span>;
    registered_fds[fd_index] = fd;
    registered_fds[fd_index2] = -<span class="tok-number">1</span>;

    ring.register_files(registered_fds[<span class="tok-number">0</span>..]) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
        // Happens when the kernel doesn't support sparse entry (-1) in the file descriptors array.
        </span><span class="tok-kw">error</span>.FileDescriptorInvalid =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
    };<span class="tok-comment">

    // Test IORING_REGISTER_FILES_UPDATE
    // Only available since Linux 5.5

    </span><span class="tok-kw">const</span> fd2 = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openZ">openZ</a>(<span class="tok-str">&quot;/dev/zero&quot;</span>, .{ .ACCMODE = .RDONLY, .CLOEXEC = <span class="tok-null">true</span> }, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd2);

    registered_fds[fd_index] = fd2;
    registered_fds[fd_index2] = -<span class="tok-number">1</span>;
    <span class="tok-kw">try</span> ring.register_files_update(<span class="tok-number">0</span>, registered_fds[<span class="tok-number">0</span>..]);

    <span class="tok-kw">var</span> buffer = [_]<span class="tok-type">u8</span>{<span class="tok-number">42</span>} ** <span class="tok-number">128</span>;
    {
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xcccccccc</span>, fd_index, .{ .buffer = &amp;buffer }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ</a>, sqe.opcode);
        sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_FIXED_FILE">IOSQE_FIXED_FILE</a>;

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
            .user_data = <span class="tok-number">0xcccccccc</span>,
            .res = buffer.len,
            .flags = <span class="tok-number">0</span>,
        }, <span class="tok-kw">try</span> ring.copy_cqe());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** buffer.len), buffer[<span class="tok-number">0</span>..]);
    }<span class="tok-comment">

    // Test with a non-zero offset

    </span>registered_fds[fd_index] = -<span class="tok-number">1</span>;
    registered_fds[fd_index2] = -<span class="tok-number">1</span>;
    <span class="tok-kw">try</span> ring.register_files_update(<span class="tok-number">1</span>, registered_fds[<span class="tok-number">1</span>..]);

    {<span class="tok-comment">
        // Next read should still work since fd_index in the registered file descriptors hasn't been updated yet.
        </span><span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xcccccccc</span>, fd_index, .{ .buffer = &amp;buffer }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ</a>, sqe.opcode);
        sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_FIXED_FILE">IOSQE_FIXED_FILE</a>;

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
            .user_data = <span class="tok-number">0xcccccccc</span>,
            .res = buffer.len,
            .flags = <span class="tok-number">0</span>,
        }, <span class="tok-kw">try</span> ring.copy_cqe());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** buffer.len), buffer[<span class="tok-number">0</span>..]);
    }

    <span class="tok-kw">try</span> ring.register_files_update(<span class="tok-number">0</span>, registered_fds[<span class="tok-number">0</span>..]);

    {<span class="tok-comment">
        // Now this should fail since both fds are sparse (-1)
        </span><span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xcccccccc</span>, fd_index, .{ .buffer = &amp;buffer }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ</a>, sqe.opcode);
        sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_FIXED_FILE">IOSQE_FIXED_FILE</a>;

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">BADF</a>, cqe.err());
    }

    <span class="tok-kw">try</span> ring.unregister_files();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;shutdown&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> address = <span class="tok-kw">try</span> <a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(<span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">0</span>);<span class="tok-comment">

    // Socket bound, expect shutdown to work
    </span>{
        <span class="tok-kw">const</span> server = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(server);
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setsockopt">setsockopt</a>(server, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">SOCKET</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SO">SO</a>.<a href="#">REUSEADDR</a>, &amp;<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)));
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.bind">bind</a>(server, &amp;address.any, address.getOsSockLen());
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.listen">listen</a>(server, <span class="tok-number">1</span>);<span class="tok-comment">

        // set address to the OS-chosen IP/port.
        </span><span class="tok-kw">var</span> slen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = address.getOsSockLen();
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getsockname">getsockname</a>(server, &amp;address.any, &amp;slen);

        <span class="tok-kw">const</span> shutdown_sqe = <span class="tok-kw">try</span> ring.shutdown(<span class="tok-number">0x445445445</span>, server, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.SHUT.html">SHUT</a>.<a href="std.os.linux.SHUT.html#std.os.linux.SHUT.RD">RD</a>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">SHUTDOWN</a>, shutdown_sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, server), shutdown_sqe.fd);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},<span class="tok-comment">
            // This kernel's io_uring does not yet implement shutdown (kernel version &lt; 5.11)
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
            .user_data = <span class="tok-number">0x445445445</span>,
            .res = <span class="tok-number">0</span>,
            .flags = <span class="tok-number">0</span>,
        }, cqe);
    }<span class="tok-comment">

    // Socket not bound, expect to fail with ENOTCONN
    </span>{
        <span class="tok-kw">const</span> server = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(server);

        <span class="tok-kw">const</span> shutdown_sqe = ring.shutdown(<span class="tok-number">0x445445445</span>, server, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.SHUT.html">SHUT</a>.<a href="std.os.linux.SHUT.html#std.os.linux.SHUT.RD">RD</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        };
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">SHUTDOWN</a>, shutdown_sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, server), shutdown_sqe.fd);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0x445445445</span>), cqe.user_data);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="#">NOTCONN</a>, cqe.err());
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;renameat&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> old_path = <span class="tok-str">&quot;test_io_uring_renameat_old&quot;</span>;
    <span class="tok-kw">const</span> new_path = <span class="tok-str">&quot;test_io_uring_renameat_new&quot;</span>;

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();<span class="tok-comment">

    // Write old file with data

    </span><span class="tok-kw">const</span> old_file = <span class="tok-kw">try</span> tmp.dir.createFile(old_path, .{ .truncate = <span class="tok-null">true</span>, .mode = <span class="tok-number">0o666</span> });
    <span class="tok-kw">defer</span> old_file.close();
    <span class="tok-kw">try</span> old_file.writeAll(<span class="tok-str">&quot;hello&quot;</span>);<span class="tok-comment">

    // Submit renameat

    </span><span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.renameat(
        <span class="tok-number">0x12121212</span>,
        tmp.dir.fd,
        old_path,
        tmp.dir.fd,
        new_path,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">RENAMEAT</a>, sqe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, tmp.dir.fd), sqe.fd);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, tmp.dir.fd), <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@bitCast</span>(sqe.len)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">switch</span> (cqe.err()) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // This kernel's io_uring does not yet implement renameat (kernel version &lt; 5.11)
        </span>.BADF, .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x12121212</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe);<span class="tok-comment">

    // Validate that the old file doesn't exist anymore
    </span>{
        _ = tmp.dir.openFile(old_path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.FileNotFound =&gt; {},
            <span class="tok-kw">else</span> =&gt; <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unexpected error: {}&quot;</span>, .{err}),
        };
    }<span class="tok-comment">

    // Validate that the new file exists with the proper content
    </span>{
        <span class="tok-kw">const</span> new_file = <span class="tok-kw">try</span> tmp.dir.openFile(new_path, .{});
        <span class="tok-kw">defer</span> new_file.close();

        <span class="tok-kw">var</span> new_file_data: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> new_file.readAll(&amp;new_file_data);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;hello&quot;</span>, new_file_data[<span class="tok-number">0</span>..bytes_read]);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;unlinkat&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_unlinkat&quot;</span>;

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();<span class="tok-comment">

    // Write old file with data

    </span><span class="tok-kw">const</span> file = <span class="tok-kw">try</span> tmp.dir.createFile(path, .{ .truncate = <span class="tok-null">true</span>, .mode = <span class="tok-number">0o666</span> });
    <span class="tok-kw">defer</span> file.close();<span class="tok-comment">

    // Submit unlinkat

    </span><span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.unlinkat(
        <span class="tok-number">0x12121212</span>,
        tmp.dir.fd,
        path,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">UNLINKAT</a>, sqe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, tmp.dir.fd), sqe.fd);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">switch</span> (cqe.err()) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // This kernel's io_uring does not yet implement unlinkat (kernel version &lt; 5.11)
        </span>.BADF, .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x12121212</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe);<span class="tok-comment">

    // Validate that the file doesn't exist anymore
    </span>_ = tmp.dir.openFile(path, .{}) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound =&gt; {},
        <span class="tok-kw">else</span> =&gt; <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unexpected error: {}&quot;</span>, .{err}),
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;mkdirat&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_mkdirat&quot;</span>;<span class="tok-comment">

    // Submit mkdirat

    </span><span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.mkdirat(
        <span class="tok-number">0x12121212</span>,
        tmp.dir.fd,
        path,
        <span class="tok-number">0o0755</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">MKDIRAT</a>, sqe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, tmp.dir.fd), sqe.fd);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">switch</span> (cqe.err()) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // This kernel's io_uring does not yet implement mkdirat (kernel version &lt; 5.15)
        </span>.BADF, .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x12121212</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe);<span class="tok-comment">

    // Validate that the directory exist
    </span>_ = <span class="tok-kw">try</span> tmp.dir.openDir(path, .{});
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;symlinkat&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_symlinkat&quot;</span>;
    <span class="tok-kw">const</span> link_path = <span class="tok-str">&quot;test_io_uring_symlinkat_link&quot;</span>;

    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> tmp.dir.createFile(path, .{ .truncate = <span class="tok-null">true</span>, .mode = <span class="tok-number">0o666</span> });
    <span class="tok-kw">defer</span> file.close();<span class="tok-comment">

    // Submit symlinkat

    </span><span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.symlinkat(
        <span class="tok-number">0x12121212</span>,
        path,
        tmp.dir.fd,
        link_path,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">SYMLINKAT</a>, sqe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, tmp.dir.fd), sqe.fd);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">switch</span> (cqe.err()) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // This kernel's io_uring does not yet implement symlinkat (kernel version &lt; 5.15)
        </span>.BADF, .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x12121212</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe);<span class="tok-comment">

    // Validate that the symlink exist
    </span>_ = <span class="tok-kw">try</span> tmp.dir.openFile(link_path, .{});
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;linkat&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();

    <span class="tok-kw">const</span> first_path = <span class="tok-str">&quot;test_io_uring_linkat_first&quot;</span>;
    <span class="tok-kw">const</span> second_path = <span class="tok-str">&quot;test_io_uring_linkat_second&quot;</span>;<span class="tok-comment">

    // Write file with data

    </span><span class="tok-kw">const</span> first_file = <span class="tok-kw">try</span> tmp.dir.createFile(first_path, .{ .truncate = <span class="tok-null">true</span>, .mode = <span class="tok-number">0o666</span> });
    <span class="tok-kw">defer</span> first_file.close();
    <span class="tok-kw">try</span> first_file.writeAll(<span class="tok-str">&quot;hello&quot;</span>);<span class="tok-comment">

    // Submit linkat

    </span><span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.linkat(
        <span class="tok-number">0x12121212</span>,
        tmp.dir.fd,
        first_path,
        tmp.dir.fd,
        second_path,
        <span class="tok-number">0</span>,
    );
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">LINKAT</a>, sqe.opcode);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, tmp.dir.fd), sqe.fd);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, tmp.dir.fd), <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@bitCast</span>(sqe.len)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">switch</span> (cqe.err()) {
        .SUCCESS =&gt; {},<span class="tok-comment">
        // This kernel's io_uring does not yet implement linkat (kernel version &lt; 5.15)
        </span>.BADF, .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0x12121212</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe);<span class="tok-comment">

    // Validate the second file
    </span><span class="tok-kw">const</span> second_file = <span class="tok-kw">try</span> tmp.dir.openFile(second_path, .{});
    <span class="tok-kw">defer</span> second_file.close();

    <span class="tok-kw">var</span> second_file_data: [<span class="tok-number">16</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> bytes_read = <span class="tok-kw">try</span> second_file.readAll(&amp;second_file_data);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;hello&quot;</span>, second_file_data[<span class="tok-number">0</span>..bytes_read]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;provide_buffers: read&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openZ">openZ</a>(<span class="tok-str">&quot;/dev/zero&quot;</span>, .{ .ACCMODE = .RDONLY, .CLOEXEC = <span class="tok-null">true</span> }, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">const</span> group_id = <span class="tok-number">1337</span>;
    <span class="tok-kw">const</span> buffer_id = <span class="tok-number">0</span>;

    <span class="tok-kw">const</span> buffer_len = <span class="tok-number">128</span>;

    <span class="tok-kw">var</span> buffers: [<span class="tok-number">4</span>][buffer_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">

    // Provide 4 buffers

    </span>{
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.provide_buffers(<span class="tok-number">0xcccccccc</span>, <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;buffers)), buffer_len, buffers.len, group_id, buffer_id);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">PROVIDE_BUFFERS</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, buffers.len), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, buffers[<span class="tok-number">0</span>].len), sqe.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {<span class="tok-comment">
            // Happens when the kernel is &lt; 5.7
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xcccccccc</span>), cqe.user_data);
    }<span class="tok-comment">

    // Do 4 reads which should consume all buffers

    </span><span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; buffers.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xdededede</span>, fd, .{ .buffer_selection = .{ .group_id = group_id, .len = buffer_len } }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, fd), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe.addr);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, buffer_len), sqe.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a> == <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a>);
        <span class="tok-kw">const</span> used_buffer_id = cqe.flags &gt;&gt; <span class="tok-number">16</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(used_buffer_id &gt;= <span class="tok-number">0</span> <span class="tok-kw">and</span> used_buffer_id &lt;= <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, buffer_len), cqe.res);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xdededede</span>), cqe.user_data);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** buffer_len), buffers[used_buffer_id][<span class="tok-number">0</span>..<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res))]);
    }<span class="tok-comment">

    // This read should fail

    </span>{
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xdfdfdfdf</span>, fd, .{ .buffer_selection = .{ .group_id = group_id, .len = buffer_len } }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, fd), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe.addr);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, buffer_len), sqe.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {<span class="tok-comment">
            // Expected
            </span>.NOBUFS =&gt; {},
            .SUCCESS =&gt; <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unexpected success&quot;</span>, .{}),
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xdfdfdfdf</span>), cqe.user_data);
    }<span class="tok-comment">

    // Provide 1 buffer again

    // Deliberately put something we don't expect in the buffers
    </span><span class="tok-builtin">@memset</span>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(&amp;buffers), <span class="tok-number">42</span>);

    <span class="tok-kw">const</span> reprovided_buffer_id = <span class="tok-number">2</span>;

    {
        _ = <span class="tok-kw">try</span> ring.provide_buffers(<span class="tok-number">0xabababab</span>, <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;buffers[reprovided_buffer_id])), buffer_len, <span class="tok-number">1</span>, group_id, reprovided_buffer_id);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
    }<span class="tok-comment">

    // Final read which should work

    </span>{
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xdfdfdfdf</span>, fd, .{ .buffer_selection = .{ .group_id = group_id, .len = buffer_len } }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">READ</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, fd), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe.addr);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, buffer_len), sqe.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a> == <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a>);
        <span class="tok-kw">const</span> used_buffer_id = cqe.flags &gt;&gt; <span class="tok-number">16</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(used_buffer_id, reprovided_buffer_id);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, buffer_len), cqe.res);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xdfdfdfdf</span>), cqe.user_data);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** buffer_len), buffers[used_buffer_id][<span class="tok-number">0</span>..<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res))]);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;remove_buffers&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.openZ">openZ</a>(<span class="tok-str">&quot;/dev/zero&quot;</span>, .{ .ACCMODE = .RDONLY, .CLOEXEC = <span class="tok-null">true</span> }, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);

    <span class="tok-kw">const</span> group_id = <span class="tok-number">1337</span>;
    <span class="tok-kw">const</span> buffer_id = <span class="tok-number">0</span>;

    <span class="tok-kw">const</span> buffer_len = <span class="tok-number">128</span>;

    <span class="tok-kw">var</span> buffers: [<span class="tok-number">4</span>][buffer_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">

    // Provide 4 buffers

    </span>{
        _ = <span class="tok-kw">try</span> ring.provide_buffers(<span class="tok-number">0xcccccccc</span>, <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;buffers)), buffer_len, buffers.len, group_id, buffer_id);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xcccccccc</span>), cqe.user_data);
    }<span class="tok-comment">

    // Remove 3 buffers

    </span>{
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.remove_buffers(<span class="tok-number">0xbababababa</span>, <span class="tok-number">3</span>, group_id);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">REMOVE_BUFFERS</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">3</span>), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe.addr);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xbababababa</span>), cqe.user_data);
    }<span class="tok-comment">

    // This read should work

    </span>{
        _ = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xdfdfdfdf</span>, fd, .{ .buffer_selection = .{ .group_id = group_id, .len = buffer_len } }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a> == <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a>);
        <span class="tok-kw">const</span> used_buffer_id = cqe.flags &gt;&gt; <span class="tok-number">16</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(used_buffer_id &gt;= <span class="tok-number">0</span> <span class="tok-kw">and</span> used_buffer_id &lt; <span class="tok-number">4</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, buffer_len), cqe.res);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xdfdfdfdf</span>), cqe.user_data);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** buffer_len), buffers[used_buffer_id][<span class="tok-number">0</span>..<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res))]);
    }<span class="tok-comment">

    // Final read should _not_ work

    </span>{
        _ = <span class="tok-kw">try</span> ring.read(<span class="tok-number">0xdfdfdfdf</span>, fd, .{ .buffer_selection = .{ .group_id = group_id, .len = buffer_len } }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {<span class="tok-comment">
            // Expected
            </span>.NOBUFS =&gt; {},
            .SUCCESS =&gt; <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unexpected success&quot;</span>, .{}),
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;provide_buffers: accept/connect/send/recv&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> group_id = <span class="tok-number">1337</span>;
    <span class="tok-kw">const</span> buffer_id = <span class="tok-number">0</span>;

    <span class="tok-kw">const</span> buffer_len = <span class="tok-number">128</span>;
    <span class="tok-kw">var</span> buffers: [<span class="tok-number">4</span>][buffer_len]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;<span class="tok-comment">

    // Provide 4 buffers

    </span>{
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.provide_buffers(<span class="tok-number">0xcccccccc</span>, <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;buffers)), buffer_len, buffers.len, group_id, buffer_id);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">PROVIDE_BUFFERS</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, buffers.len), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, buffer_len), sqe.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {<span class="tok-comment">
            // Happens when the kernel is &lt; 5.7
            </span>.INVAL =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,<span class="tok-comment">
            // Happens on the kernel 5.4
            </span>.BADF =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xcccccccc</span>), cqe.user_data);
    }

    <span class="tok-kw">const</span> socket_test_harness = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createSocketTestHarness">createSocketTestHarness</a>(&amp;ring);
    <span class="tok-kw">defer</span> socket_test_harness.close();<span class="tok-comment">

    // Do 4 send on the socket

    </span>{
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; buffers.len) : (i += <span class="tok-number">1</span>) {
            _ = <span class="tok-kw">try</span> ring.send(<span class="tok-number">0xdeaddead</span>, socket_test_harness.server, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-str">'z'</span>} ** buffer_len), <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
        }

        <span class="tok-kw">var</span> cqes: [<span class="tok-number">4</span>]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">4</span>), <span class="tok-kw">try</span> ring.copy_cqes(&amp;cqes, <span class="tok-number">4</span>));
    }<span class="tok-comment">

    // Do 4 recv which should consume all buffers

    // Deliberately put something we don't expect in the buffers
    </span><span class="tok-builtin">@memset</span>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(&amp;buffers), <span class="tok-number">1</span>);

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; buffers.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.recv(<span class="tok-number">0xdededede</span>, socket_test_harness.client, .{ .buffer_selection = .{ .group_id = group_id, .len = buffer_len } }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">RECV</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, socket_test_harness.client), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe.addr);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, buffer_len), sqe.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), sqe.rw_flags);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>), sqe.flags);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a> == <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a>);
        <span class="tok-kw">const</span> used_buffer_id = cqe.flags &gt;&gt; <span class="tok-number">16</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(used_buffer_id &gt;= <span class="tok-number">0</span> <span class="tok-kw">and</span> used_buffer_id &lt;= <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, buffer_len), cqe.res);

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xdededede</span>), cqe.user_data);
        <span class="tok-kw">const</span> buffer = buffers[used_buffer_id][<span class="tok-number">0</span>..<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res))];
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-str">'z'</span>} ** buffer_len), buffer);
    }<span class="tok-comment">

    // This recv should fail

    </span>{
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.recv(<span class="tok-number">0xdfdfdfdf</span>, socket_test_harness.client, .{ .buffer_selection = .{ .group_id = group_id, .len = buffer_len } }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">RECV</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, socket_test_harness.client), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe.addr);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, buffer_len), sqe.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), sqe.rw_flags);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>), sqe.flags);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {<span class="tok-comment">
            // Expected
            </span>.NOBUFS =&gt; {},
            .SUCCESS =&gt; <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unexpected success&quot;</span>, .{}),
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xdfdfdfdf</span>), cqe.user_data);
    }<span class="tok-comment">

    // Provide 1 buffer again

    </span><span class="tok-kw">const</span> reprovided_buffer_id = <span class="tok-number">2</span>;

    {
        _ = <span class="tok-kw">try</span> ring.provide_buffers(<span class="tok-number">0xabababab</span>, <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(&amp;buffers[reprovided_buffer_id])), buffer_len, <span class="tok-number">1</span>, group_id, reprovided_buffer_id);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }
    }<span class="tok-comment">

    // Redo 1 send on the server socket

    </span>{
        _ = <span class="tok-kw">try</span> ring.send(<span class="tok-number">0xdeaddead</span>, socket_test_harness.server, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-str">'w'</span>} ** buffer_len), <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        _ = <span class="tok-kw">try</span> ring.copy_cqe();
    }<span class="tok-comment">

    // Final recv which should work

    // Deliberately put something we don't expect in the buffers
    </span><span class="tok-builtin">@memset</span>(<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(&amp;buffers), <span class="tok-number">1</span>);

    {
        <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.recv(<span class="tok-number">0xdfdfdfdf</span>, socket_test_harness.client, .{ .buffer_selection = .{ .group_id = group_id, .len = buffer_len } }, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.IORING_OP.html">IORING_OP</a>.<a href="#">RECV</a>, sqe.opcode);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, socket_test_harness.client), sqe.fd);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0</span>), sqe.addr);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, buffer_len), sqe.len);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, group_id), sqe.buf_index);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), sqe.rw_flags);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>), sqe.flags);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">switch</span> (cqe.err()) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; |errno| <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.panic">panic</a>(<span class="tok-str">&quot;unhandled errno: {}&quot;</span>, .{errno}),
        }

        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a> == <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a>);
        <span class="tok-kw">const</span> used_buffer_id = cqe.flags &gt;&gt; <span class="tok-number">16</span>;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(used_buffer_id, reprovided_buffer_id);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, buffer_len), cqe.res);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xdfdfdfdf</span>), cqe.user_data);
        <span class="tok-kw">const</span> buffer = buffers[used_buffer_id][<span class="tok-number">0</span>..<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res))];
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;([_]<span class="tok-type">u8</span>{<span class="tok-str">'w'</span>} ** buffer_len), buffer);
    }
}

<span class="tok-comment">/// Used for testing server/client interactions.</span>
<span class="tok-kw">const</span> SocketTestHarness = <span class="tok-kw">struct</span> {
    listener: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    server: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a>,
    client: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: <a href="std.os.linux.IoUring.SocketTestHarness.html">SocketTestHarness</a>) <span class="tok-type">void</span> {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.client);
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.listener);
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">createSocketTestHarness</span>(ring: *<a href="std.os.linux.IoUring.html">IoUring</a>) !<a href="std.os.linux.IoUring.SocketTestHarness.html">SocketTestHarness</a> {<span class="tok-comment">
    // Create a TCP server socket
    </span><span class="tok-kw">var</span> address = <span class="tok-kw">try</span> <a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(<span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> listener_socket = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createListenerSocket">createListenerSocket</a>(&amp;address);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(listener_socket);<span class="tok-comment">

    // Submit 1 accept
    </span><span class="tok-kw">var</span> accept_addr: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> accept_addr_len: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(accept_addr));
    _ = <span class="tok-kw">try</span> ring.accept(<span class="tok-number">0xaaaaaaaa</span>, listener_socket, &amp;accept_addr, &amp;accept_addr_len, <span class="tok-number">0</span>);<span class="tok-comment">

    // Create a TCP client socket
    </span><span class="tok-kw">const</span> client = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(client);
    _ = <span class="tok-kw">try</span> ring.connect(<span class="tok-number">0xcccccccc</span>, client, &amp;address.any, address.getOsSockLen());

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">var</span> cqe_accept = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_accept.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    <span class="tok-kw">var</span> cqe_connect = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">if</span> (cqe_connect.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment">

    // The accept/connect CQEs may arrive in any order, the connect CQE will sometimes come first:
    </span><span class="tok-kw">if</span> (cqe_accept.user_data == <span class="tok-number">0xcccccccc</span> <span class="tok-kw">and</span> cqe_connect.user_data == <span class="tok-number">0xaaaaaaaa</span>) {
        <span class="tok-kw">const</span> a = cqe_accept;
        <span class="tok-kw">const</span> b = cqe_connect;
        cqe_accept = b;
        cqe_connect = a;
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">0xaaaaaaaa</span>), cqe_accept.user_data);
    <span class="tok-kw">if</span> (cqe_accept.res &lt;= <span class="tok-number">0</span>) <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>(<span class="tok-str">&quot;\ncqe_accept.res={}\n&quot;</span>, .{cqe_accept.res});
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_accept.res &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>), cqe_accept.flags);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xcccccccc</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <span class="tok-number">0</span>,
    }, cqe_connect);<span class="tok-comment">

    // All good

    </span><span class="tok-kw">return</span> <a href="std.os.linux.IoUring.SocketTestHarness.html">SocketTestHarness</a>{
        .listener = listener_socket,
        .server = cqe_accept.res,
        .client = client,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">createListenerSocket</span>(address: *<a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>) !<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket_t">socket_t</a> {
    <span class="tok-kw">const</span> kernel_backlog = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> listener_socket = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(listener_socket);

    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.setsockopt">setsockopt</a>(listener_socket, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOL">SOL</a>.<a href="#">SOCKET</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SO">SO</a>.<a href="#">REUSEADDR</a>, &amp;<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.toBytes">toBytes</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)));
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.bind">bind</a>(listener_socket, &amp;address.any, address.getOsSockLen());
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.listen">listen</a>(listener_socket, kernel_backlog);<span class="tok-comment">

    // set address to the OS-chosen IP/port.
    </span><span class="tok-kw">var</span> slen: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = address.getOsSockLen();
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getsockname">getsockname</a>(listener_socket, &amp;address.any, &amp;slen);

    <span class="tok-kw">return</span> listener_socket;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;accept multishot&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> address = <span class="tok-kw">try</span> <a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(<span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> listener_socket = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createListenerSocket">createListenerSocket</a>(&amp;address);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(listener_socket);<span class="tok-comment">

    // submit multishot accept operation
    </span><span class="tok-kw">var</span> addr: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sockaddr">sockaddr</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> addr_len: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socklen_t">socklen_t</a> = <span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(addr));
    <span class="tok-kw">const</span> userdata: <span class="tok-type">u64</span> = <span class="tok-number">0xaaaaaaaa</span>;
    _ = <span class="tok-kw">try</span> ring.accept_multishot(userdata, listener_socket, &amp;addr, &amp;addr_len, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">var</span> nr: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;<span class="tok-comment"> // number of clients to connect
    </span><span class="tok-kw">while</span> (nr &gt; <span class="tok-number">0</span>) : (nr -= <span class="tok-number">1</span>) {<span class="tok-comment">
        // connect client
        </span><span class="tok-kw">const</span> client = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">errdefer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(client);
        <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(client, &amp;address.any, address.getOsSockLen());<span class="tok-comment">

        // test accept completion
        </span><span class="tok-kw">var</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">if</span> (cqe.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.res &gt; <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.user_data == userdata);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> &gt; <span class="tok-number">0</span>);<span class="tok-comment"> // more flag is set

        </span><a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(client);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;accept/connect/send_zc/recv&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.skipKernelLessThan">skipKernelLessThan</a>(.{ .major = <span class="tok-number">6</span>, .minor = <span class="tok-number">0</span>, .patch = <span class="tok-number">0</span> });

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> socket_test_harness = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createSocketTestHarness">createSocketTestHarness</a>(&amp;ring);
    <span class="tok-kw">defer</span> socket_test_harness.close();

    <span class="tok-kw">const</span> buffer_send = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">0xa</span>, <span class="tok-number">0xb</span>, <span class="tok-number">0xc</span>, <span class="tok-number">0xd</span>, <span class="tok-number">0xe</span> };
    <span class="tok-kw">var</span> buffer_recv = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">10</span>;<span class="tok-comment">

    // zero-copy send
    </span><span class="tok-kw">const</span> sqe_send = <span class="tok-kw">try</span> ring.send_zc(<span class="tok-number">0xeeeeeeee</span>, socket_test_harness.client, buffer_send[<span class="tok-number">0</span>..], <span class="tok-number">0</span>, <span class="tok-number">0</span>);
    sqe_send.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_IO_LINK">IOSQE_IO_LINK</a>;
    _ = <span class="tok-kw">try</span> ring.recv(<span class="tok-number">0xffffffff</span>, socket_test_harness.server, .{ .buffer = buffer_recv[<span class="tok-number">0</span>..] }, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">var</span> cqe_send = <span class="tok-kw">try</span> ring.copy_cqe();<span class="tok-comment">
    // First completion of zero-copy send.
    // IORING_CQE_F_MORE, means that there
    // will be a second completion event / notification for the
    // request, with the user_data field set to the same value.
    // buffer_send must be keep alive until second cqe.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xeeeeeeee</span>,
        .res = buffer_send.len,
        .flags = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a>,
    }, cqe_send);

    cqe_send, <span class="tok-kw">const</span> cqe_recv = brk: {
        <span class="tok-kw">const</span> cqe1 = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">const</span> cqe2 = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">break</span> :brk <span class="tok-kw">if</span> (cqe1.user_data == <span class="tok-number">0xeeeeeeee</span>) .{ cqe1, cqe2 } <span class="tok-kw">else</span> .{ cqe2, cqe1 };
    };

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xffffffff</span>,
        .res = buffer_recv.len,
        .flags = cqe_recv.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_SOCK_NONEMPTY">IORING_CQE_F_SOCK_NONEMPTY</a>,
    }, cqe_recv);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, buffer_send[<span class="tok-number">0</span>..buffer_recv.len], buffer_recv[<span class="tok-number">0</span>..]);<span class="tok-comment">

    // Second completion of zero-copy send.
    // IORING_CQE_F_NOTIF in flags signals that kernel is done with send_buffer
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{
        .user_data = <span class="tok-number">0xeeeeeeee</span>,
        .res = <span class="tok-number">0</span>,
        .flags = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_NOTIF">IORING_CQE_F_NOTIF</a>,
    }, cqe_send);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;accept_direct&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.skipKernelLessThan">skipKernelLessThan</a>(.{ .major = <span class="tok-number">5</span>, .minor = <span class="tok-number">19</span>, .patch = <span class="tok-number">0</span> });

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();
    <span class="tok-kw">var</span> address = <span class="tok-kw">try</span> <a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(<span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">0</span>);<span class="tok-comment">

    // register direct file descriptors
    </span><span class="tok-kw">var</span> registered_fds = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>{-<span class="tok-number">1</span>} ** <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> ring.register_files(registered_fds[<span class="tok-number">0</span>..]);

    <span class="tok-kw">const</span> listener_socket = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createListenerSocket">createListenerSocket</a>(&amp;address);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(listener_socket);

    <span class="tok-kw">const</span> accept_userdata: <span class="tok-type">u64</span> = <span class="tok-number">0xaaaaaaaa</span>;
    <span class="tok-kw">const</span> read_userdata: <span class="tok-type">u64</span> = <span class="tok-number">0xbbbbbbbb</span>;
    <span class="tok-kw">const</span> data = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">0xa</span>, <span class="tok-number">0xb</span>, <span class="tok-number">0xc</span>, <span class="tok-number">0xd</span>, <span class="tok-number">0xe</span> };

    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">2</span>) |_| {
        <span class="tok-kw">for</span> (registered_fds, <span class="tok-number">0</span>..) |_, i| {
            <span class="tok-kw">var</span> buffer_recv = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-number">16</span>;
            <span class="tok-kw">const</span> buffer_send: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = data[<span class="tok-number">0</span> .. data.len - i];<span class="tok-comment"> // make it different at each loop

            // submit accept, will chose registered fd and return index in cqe
            </span>_ = <span class="tok-kw">try</span> ring.accept_direct(accept_userdata, listener_socket, <span class="tok-null">null</span>, <span class="tok-null">null</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment">

            // connect
            </span><span class="tok-kw">const</span> client = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(client, &amp;address.any, address.getOsSockLen());
            <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(client);<span class="tok-comment">

            // accept completion
            </span><span class="tok-kw">const</span> cqe_accept = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe_accept.err());
            <span class="tok-kw">const</span> fd_index = cqe_accept.res;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fd_index &lt; registered_fds.len);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_accept.user_data == accept_userdata);<span class="tok-comment">

            // send data
            </span>_ = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.send">send</a>(client, buffer_send, <span class="tok-number">0</span>);<span class="tok-comment">

            // Example of how to use registered fd:
            // Submit receive to fixed file returned by accept (fd_index).
            // Fd field is set to registered file index, returned by accept.
            // Flag linux.IOSQE_FIXED_FILE must be set.
            </span><span class="tok-kw">const</span> recv_sqe = <span class="tok-kw">try</span> ring.recv(read_userdata, fd_index, .{ .buffer = &amp;buffer_recv }, <span class="tok-number">0</span>);
            recv_sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_FIXED_FILE">IOSQE_FIXED_FILE</a>;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment">

            // accept receive
            </span><span class="tok-kw">const</span> recv_cqe = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(recv_cqe.user_data == read_userdata);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(recv_cqe.res == buffer_send.len);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, buffer_send, buffer_recv[<span class="tok-number">0</span>..buffer_send.len]);
        }<span class="tok-comment">
        // no more available fds, accept will get NFILE error
        </span>{<span class="tok-comment">
            // submit accept
            </span>_ = <span class="tok-kw">try</span> ring.accept_direct(accept_userdata, listener_socket, <span class="tok-null">null</span>, <span class="tok-null">null</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment">
            // connect
            </span><span class="tok-kw">const</span> client = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(client, &amp;address.any, address.getOsSockLen());
            <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(client);<span class="tok-comment">
            // completion with error
            </span><span class="tok-kw">const</span> cqe_accept = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_accept.user_data == accept_userdata);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">NFILE</a>, cqe_accept.err());
        }<span class="tok-comment">
        // return file descriptors to kernel
        </span><span class="tok-kw">try</span> ring.register_files_update(<span class="tok-number">0</span>, registered_fds[<span class="tok-number">0</span>..]);
    }
    <span class="tok-kw">try</span> ring.unregister_files();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;accept_multishot_direct&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.skipKernelLessThan">skipKernelLessThan</a>(.{ .major = <span class="tok-number">5</span>, .minor = <span class="tok-number">19</span>, .patch = <span class="tok-number">0</span> });

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> address = <span class="tok-kw">try</span> <a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(<span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">0</span>);

    <span class="tok-kw">var</span> registered_fds = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>{-<span class="tok-number">1</span>} ** <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> ring.register_files(registered_fds[<span class="tok-number">0</span>..]);

    <span class="tok-kw">const</span> listener_socket = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createListenerSocket">createListenerSocket</a>(&amp;address);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(listener_socket);

    <span class="tok-kw">const</span> accept_userdata: <span class="tok-type">u64</span> = <span class="tok-number">0xaaaaaaaa</span>;

    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">2</span>) |_| {<span class="tok-comment">
        // submit multishot accept
        // Will chose registered fd and return index of the selected registered file in cqe.
        </span>_ = <span class="tok-kw">try</span> ring.accept_multishot_direct(accept_userdata, listener_socket, <span class="tok-null">null</span>, <span class="tok-null">null</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());

        <span class="tok-kw">for</span> (registered_fds) |_| {<span class="tok-comment">
            // connect
            </span><span class="tok-kw">const</span> client = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(client, &amp;address.any, address.getOsSockLen());
            <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(client);<span class="tok-comment">

            // accept completion
            </span><span class="tok-kw">const</span> cqe_accept = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">const</span> fd_index = cqe_accept.res;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fd_index &lt; registered_fds.len);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_accept.user_data == accept_userdata);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_accept.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> &gt; <span class="tok-number">0</span>);<span class="tok-comment"> // has more is set
        </span>}<span class="tok-comment">
        // No more available fds, accept will get NFILE error.
        // Multishot is terminated (more flag is not set).
        </span>{<span class="tok-comment">
            // connect
            </span><span class="tok-kw">const</span> client = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.socket">socket</a>(address.any.family, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">CLOEXEC</a>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.connect">connect</a>(client, &amp;address.any, address.getOsSockLen());
            <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(client);<span class="tok-comment">
            // completion with error
            </span><span class="tok-kw">const</span> cqe_accept = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_accept.user_data == accept_userdata);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">NFILE</a>, cqe_accept.err());
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_accept.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> == <span class="tok-number">0</span>);<span class="tok-comment"> // has more is not set
        </span>}<span class="tok-comment">
        // return file descriptors to kernel
        </span><span class="tok-kw">try</span> ring.register_files_update(<span class="tok-number">0</span>, registered_fds[<span class="tok-number">0</span>..]);
    }
    <span class="tok-kw">try</span> ring.unregister_files();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;socket&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.skipKernelLessThan">skipKernelLessThan</a>(.{ .major = <span class="tok-number">5</span>, .minor = <span class="tok-number">19</span>, .patch = <span class="tok-number">0</span> });

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">1</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();<span class="tok-comment">

    // prepare, submit socket operation
    </span>_ = <span class="tok-kw">try</span> ring.socket(<span class="tok-number">0</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AF.html">AF</a>.<a href="std.os.linux.PF.html#std.os.linux.PF.INET">INET</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment">

    // test completion
    </span><span class="tok-kw">var</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe.err());
    <span class="tok-kw">const</span> fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a> = <span class="tok-builtin">@intCast</span>(cqe.res);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(fd &gt; <span class="tok-number">2</span>);

    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(fd);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;socket_direct/socket_direct_alloc/close_direct&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.skipKernelLessThan">skipKernelLessThan</a>(.{ .major = <span class="tok-number">5</span>, .minor = <span class="tok-number">19</span>, .patch = <span class="tok-number">0</span> });

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">2</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> registered_fds = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>{-<span class="tok-number">1</span>} ** <span class="tok-number">3</span>;
    <span class="tok-kw">try</span> ring.register_files(registered_fds[<span class="tok-number">0</span>..]);<span class="tok-comment">

    // create socket in registered file descriptor at index 0 (last param)
    </span>_ = <span class="tok-kw">try</span> ring.socket_direct(<span class="tok-number">0</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AF.html">AF</a>.<a href="std.os.linux.PF.html#std.os.linux.PF.INET">INET</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    <span class="tok-kw">var</span> cqe_socket = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe_socket.err());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_socket.res == <span class="tok-number">0</span>);<span class="tok-comment">

    // create socket in registered file descriptor at index 1 (last param)
    </span>_ = <span class="tok-kw">try</span> ring.socket_direct(<span class="tok-number">0</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AF.html">AF</a>.<a href="std.os.linux.PF.html#std.os.linux.PF.INET">INET</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    cqe_socket = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe_socket.err());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_socket.res == <span class="tok-number">0</span>);<span class="tok-comment"> // res is 0 when index is specified

    // create socket in kernel chosen file descriptor index (_alloc version)
    // completion res has index from registered files
    </span>_ = <span class="tok-kw">try</span> ring.socket_direct_alloc(<span class="tok-number">0</span>, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AF.html">AF</a>.<a href="std.os.linux.PF.html#std.os.linux.PF.INET">INET</a>, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SOCK">SOCK</a>.<a href="#">STREAM</a>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    cqe_socket = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe_socket.err());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_socket.res == <span class="tok-number">2</span>);<span class="tok-comment"> // returns registered file index

    // use sockets from registered_fds in connect operation
    </span><span class="tok-kw">var</span> address = <span class="tok-kw">try</span> <a href="std.net.html">net</a>.<a href="std.net.Address.html">Address</a>.<a href="std.net.Address.html#std.net.Address.parseIp4">parseIp4</a>(<span class="tok-str">&quot;127.0.0.1&quot;</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> listener_socket = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createListenerSocket">createListenerSocket</a>(&amp;address);
    <span class="tok-kw">defer</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(listener_socket);
    <span class="tok-kw">const</span> accept_userdata: <span class="tok-type">u64</span> = <span class="tok-number">0xaaaaaaaa</span>;
    <span class="tok-kw">const</span> connect_userdata: <span class="tok-type">u64</span> = <span class="tok-number">0xbbbbbbbb</span>;
    <span class="tok-kw">const</span> close_userdata: <span class="tok-type">u64</span> = <span class="tok-number">0xcccccccc</span>;
    <span class="tok-kw">for</span> (registered_fds, <span class="tok-number">0</span>..) |_, fd_index| {<span class="tok-comment">
        // prepare accept
        </span>_ = <span class="tok-kw">try</span> ring.accept(accept_userdata, listener_socket, <span class="tok-null">null</span>, <span class="tok-null">null</span>, <span class="tok-number">0</span>);<span class="tok-comment">
        // prepare connect with fixed socket
        </span><span class="tok-kw">const</span> connect_sqe = <span class="tok-kw">try</span> ring.connect(connect_userdata, <span class="tok-builtin">@intCast</span>(fd_index), &amp;address.any, address.getOsSockLen());
        connect_sqe.flags |= <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_FIXED_FILE">IOSQE_FIXED_FILE</a>;<span class="tok-comment"> // fd is fixed file index
        // submit both
        </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">2</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment">
        // get completions
        </span><span class="tok-kw">var</span> cqe_connect = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">var</span> cqe_accept = <span class="tok-kw">try</span> ring.copy_cqe();<span class="tok-comment">
        // ignore order
        </span><span class="tok-kw">if</span> (cqe_connect.user_data == accept_userdata <span class="tok-kw">and</span> cqe_accept.user_data == connect_userdata) {
            <span class="tok-kw">const</span> a = cqe_accept;
            <span class="tok-kw">const</span> b = cqe_connect;
            cqe_accept = b;
            cqe_connect = a;
        }<span class="tok-comment">
        // test connect completion
        </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_connect.user_data == connect_userdata);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe_connect.err());<span class="tok-comment">
        // test accept completion
        </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_accept.user_data == accept_userdata);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe_accept.err());<span class="tok-comment">

        //  submit and test close_direct
        </span>_ = <span class="tok-kw">try</span> ring.close_direct(close_userdata, <span class="tok-builtin">@intCast</span>(fd_index));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
        <span class="tok-kw">var</span> cqe_close = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_close.user_data == close_userdata);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe_close.err());
    }

    <span class="tok-kw">try</span> ring.unregister_files();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;openat_direct/close_direct&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.skipKernelLessThan">skipKernelLessThan</a>(.{ .major = <span class="tok-number">5</span>, .minor = <span class="tok-number">19</span>, .patch = <span class="tok-number">0</span> });

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">2</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">var</span> registered_fds = [_]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>{-<span class="tok-number">1</span>} ** <span class="tok-number">3</span>;
    <span class="tok-kw">try</span> ring.register_files(registered_fds[<span class="tok-number">0</span>..]);

    <span class="tok-kw">var</span> tmp = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.tmpDir">tmpDir</a>(.{});
    <span class="tok-kw">defer</span> tmp.cleanup();
    <span class="tok-kw">const</span> path = <span class="tok-str">&quot;test_io_uring_close_direct&quot;</span>;
    <span class="tok-kw">const</span> flags: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.O">O</a> = .{ .ACCMODE = .RDWR, .CREAT = <span class="tok-null">true</span> };
    <span class="tok-kw">const</span> mode: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a> = <span class="tok-number">0o666</span>;
    <span class="tok-kw">const</span> user_data: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;<span class="tok-comment">

    // use registered file at index 0 (last param)
    </span>_ = <span class="tok-kw">try</span> ring.openat_direct(user_data, tmp.dir.fd, path, flags, mode, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    <span class="tok-kw">var</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe.err());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.res == <span class="tok-number">0</span>);<span class="tok-comment">

    // use registered file at index 1
    </span>_ = <span class="tok-kw">try</span> ring.openat_direct(user_data, tmp.dir.fd, path, flags, mode, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe.err());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.res == <span class="tok-number">0</span>);<span class="tok-comment"> // res is 0 when we specify index

    // let kernel choose registered file index
    </span>_ = <span class="tok-kw">try</span> ring.openat_direct(user_data, tmp.dir.fd, path, flags, mode, <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_FILE_INDEX_ALLOC">IORING_FILE_INDEX_ALLOC</a>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
    cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe.err());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.res == <span class="tok-number">2</span>);<span class="tok-comment"> // chosen index is in res

    // close all open file descriptors
    </span><span class="tok-kw">for</span> (registered_fds, <span class="tok-number">0</span>..) |_, fd_index| {
        _ = <span class="tok-kw">try</span> ring.close_direct(user_data, <span class="tok-builtin">@intCast</span>(fd_index));
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
        <span class="tok-kw">var</span> cqe_close = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe_close.err());
    }
    <span class="tok-kw">try</span> ring.unregister_files();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;waitid&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.skipKernelLessThan">skipKernelLessThan</a>(.{ .major = <span class="tok-number">6</span>, .minor = <span class="tok-number">7</span>, .patch = <span class="tok-number">0</span> });

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">const</span> pid = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fork">fork</a>();
    <span class="tok-kw">if</span> (pid == <span class="tok-number">0</span>) {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.exit">exit</a>(<span class="tok-number">7</span>);
    }

    <span class="tok-kw">var</span> siginfo: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.siginfo_t">siginfo_t</a> = <span class="tok-null">undefined</span>;
    _ = <span class="tok-kw">try</span> ring.waitid(<span class="tok-number">0</span>, .PID, pid, &amp;siginfo, <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.W">W</a>.<a href="#">EXITED</a>, <span class="tok-number">0</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, <span class="tok-kw">try</span> ring.submit());

    <span class="tok-kw">const</span> cqe_waitid = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">0</span>, cqe_waitid.res);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(pid, siginfo.fields.common.first.piduid.pid);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">7</span>, siginfo.fields.common.second.sigchld.status);
}

<span class="tok-comment">/// For use in tests. Returns SkipZigTest if kernel version is less than required.</span>
<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">skipKernelLessThan</span>(required: <a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> uts: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.utsname.html">utsname</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> res = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.uname">uname</a>(&amp;uts);
    <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(res)) {
        .SUCCESS =&gt; {},
        <span class="tok-kw">else</span> =&gt; |errno| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(errno),
    }

    <span class="tok-kw">const</span> release = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceTo">sliceTo</a>(&amp;uts.release, <span class="tok-number">0</span>);<span class="tok-comment">
    // Strips potential extra, as kernel version might not be semver compliant, example &quot;6.8.9-300.fc40.x86_64&quot;
    </span><span class="tok-kw">const</span> extra_index = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfAny">indexOfAny</a>(<span class="tok-type">u8</span>, release, <span class="tok-str">&quot;-+&quot;</span>);
    <span class="tok-kw">const</span> stripped = release[<span class="tok-number">0</span>..(extra_index <span class="tok-kw">orelse</span> release.len)];<span class="tok-comment">
    // Make sure the input don't rely on the extra we just stripped
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(required.pre == <span class="tok-null">null</span> <span class="tok-kw">and</span> required.build == <span class="tok-null">null</span>);

    <span class="tok-kw">var</span> current = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>.<a href="std.SemanticVersion.html#std.SemanticVersion.parse">parse</a>(stripped);
    current.pre = <span class="tok-null">null</span>;<span class="tok-comment"> // don't check pre field
    </span><span class="tok-kw">if</span> (required.order(current) == .gt) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
}

<span class="tok-kw">test</span> BufferGroup {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment">

    // Init IoUring
    </span><span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();<span class="tok-comment">

    // Init buffer group for ring
    </span><span class="tok-kw">const</span> group_id: <span class="tok-type">u16</span> = <span class="tok-number">1</span>;<span class="tok-comment"> // buffers group id
    </span><span class="tok-kw">const</span> buffers_count: <span class="tok-type">u16</span> = <span class="tok-number">1</span>;<span class="tok-comment"> // number of buffers in buffer group
    </span><span class="tok-kw">const</span> buffer_size: <span class="tok-type">usize</span> = <span class="tok-number">128</span>;<span class="tok-comment"> // size of each buffer in group
    </span><span class="tok-kw">const</span> buffers = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alloc</a>(<span class="tok-type">u8</span>, buffers_count * buffer_size);
    <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(buffers);
    <span class="tok-kw">var</span> buf_grp = <a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>.<a href="std.os.linux.IoUring.BufferGroup.html#std.os.linux.IoUring.BufferGroup.init">init</a>(
        &amp;ring,
        group_id,
        buffers,
        buffer_size,
        buffers_count,
    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
        // kernel older than 5.19
        </span><span class="tok-kw">error</span>.ArgumentsInvalid =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> buf_grp.deinit();<span class="tok-comment">

    // Create client/server fds
    </span><span class="tok-kw">const</span> fds = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createSocketTestHarness">createSocketTestHarness</a>(&amp;ring);
    <span class="tok-kw">defer</span> fds.close();
    <span class="tok-kw">const</span> data = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">0xa</span>, <span class="tok-number">0xb</span>, <span class="tok-number">0xc</span>, <span class="tok-number">0xd</span>, <span class="tok-number">0xe</span> };<span class="tok-comment">

    // Client sends data
    </span>{
        _ = <span class="tok-kw">try</span> ring.send(<span class="tok-number">1</span>, fds.client, data[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> submitted = <span class="tok-kw">try</span> ring.submit();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, submitted);
        <span class="tok-kw">const</span> cqe_send = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">if</span> (cqe_send.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{ .user_data = <span class="tok-number">1</span>, .res = data.len, .flags = <span class="tok-number">0</span> }, cqe_send);
    }<span class="tok-comment">

    // Server uses buffer group receive
    </span>{<span class="tok-comment">
        // Submit recv operation, buffer will be chosen from buffer group
        </span>_ = <span class="tok-kw">try</span> buf_grp.recv(<span class="tok-number">2</span>, fds.server, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> submitted = <span class="tok-kw">try</span> ring.submit();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">1</span>, submitted);<span class="tok-comment">

        // ... when we have completion for recv operation
        </span><span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, cqe.user_data);<span class="tok-comment"> // matches submitted user_data
        </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.res &gt;= <span class="tok-number">0</span>);<span class="tok-comment"> // success
        </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe.err());
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(data.len, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res)));<span class="tok-comment"> // cqe.res holds received data len

        // Read buffer_id and used buffer len from cqe
        </span><span class="tok-kw">const</span> buffer_id = <span class="tok-kw">try</span> cqe.buffer_id();
        <span class="tok-kw">const</span> len: <span class="tok-type">usize</span> = <span class="tok-builtin">@intCast</span>(cqe.res);<span class="tok-comment">
        // Get buffer from pool
        </span><span class="tok-kw">const</span> buf = buf_grp.get(buffer_id)[<span class="tok-number">0</span>..len];
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, &amp;data, buf);<span class="tok-comment">
        // Release buffer to the kernel when application is done with it
        </span>buf_grp.put(buffer_id);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ring mapped buffers recv&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();<span class="tok-comment">

    // init buffer group
    </span><span class="tok-kw">const</span> group_id: <span class="tok-type">u16</span> = <span class="tok-number">1</span>;<span class="tok-comment"> // buffers group id
    </span><span class="tok-kw">const</span> buffers_count: <span class="tok-type">u16</span> = <span class="tok-number">2</span>;<span class="tok-comment"> // number of buffers in buffer group
    </span><span class="tok-kw">const</span> buffer_size: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;<span class="tok-comment"> // size of each buffer in group
    </span><span class="tok-kw">const</span> buffers = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alloc</a>(<span class="tok-type">u8</span>, buffers_count * buffer_size);
    <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(buffers);
    <span class="tok-kw">var</span> buf_grp = <a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>.<a href="std.os.linux.IoUring.BufferGroup.html#std.os.linux.IoUring.BufferGroup.init">init</a>(
        &amp;ring,
        group_id,
        buffers,
        buffer_size,
        buffers_count,
    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
        // kernel older than 5.19
        </span><span class="tok-kw">error</span>.ArgumentsInvalid =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> buf_grp.deinit();<span class="tok-comment">

    // create client/server fds
    </span><span class="tok-kw">const</span> fds = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createSocketTestHarness">createSocketTestHarness</a>(&amp;ring);
    <span class="tok-kw">defer</span> fds.close();<span class="tok-comment">

    // for random user_data in sqe/cqe
    </span><span class="tok-kw">var</span> Rnd = <a href="std.html">std</a>.<a href="std.Random.html">Random</a>.<a href="std.Random.Xoshiro256.html">DefaultPrng</a>.<a href="std.Random.Xoshiro256.html#std.Random.Xoshiro256.init">init</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.random_seed">random_seed</a>);
    <span class="tok-kw">var</span> rnd = Rnd.random();

    <span class="tok-kw">var</span> round: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;<span class="tok-comment"> // repeat send/recv cycle round times
    </span><span class="tok-kw">while</span> (round &gt; <span class="tok-number">0</span>) : (round -= <span class="tok-number">1</span>) {<span class="tok-comment">
        // client sends data
        </span><span class="tok-kw">const</span> data = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">0xa</span>, <span class="tok-number">0xb</span>, <span class="tok-number">0xc</span>, <span class="tok-number">0xd</span>, <span class="tok-number">0xe</span> };
        {
            <span class="tok-kw">const</span> user_data = rnd.int(<span class="tok-type">u64</span>);
            _ = <span class="tok-kw">try</span> ring.send(user_data, fds.client, data[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
            <span class="tok-kw">const</span> cqe_send = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">if</span> (cqe_send.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{ .user_data = user_data, .res = data.len, .flags = <span class="tok-number">0</span> }, cqe_send);
        }<span class="tok-comment">

        // server reads data into provided buffers
        // there are 2 buffers of size 4, so each read gets only chunk of data
        // we read four chunks of 4, 4, 4, 3 bytes each
        </span><span class="tok-kw">var</span> chunk: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = data[<span class="tok-number">0</span>..buffer_size];<span class="tok-comment"> // first chunk
        </span><span class="tok-kw">const</span> id1 = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_recv">expect_buf_grp_recv</a>(&amp;ring, &amp;buf_grp, fds.server, rnd.int(<span class="tok-type">u64</span>), chunk);
        chunk = data[buffer_size .. buffer_size * <span class="tok-number">2</span>];<span class="tok-comment"> // second chunk
        </span><span class="tok-kw">const</span> id2 = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_recv">expect_buf_grp_recv</a>(&amp;ring, &amp;buf_grp, fds.server, rnd.int(<span class="tok-type">u64</span>), chunk);<span class="tok-comment">

        // both buffers provided to the kernel are used so we get error
        // 'no more buffers', until we put buffers to the kernel
        </span>{
            <span class="tok-kw">const</span> user_data = rnd.int(<span class="tok-type">u64</span>);
            _ = <span class="tok-kw">try</span> buf_grp.recv(user_data, fds.server, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
            <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(user_data, cqe.user_data);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.res &lt; <span class="tok-number">0</span>);<span class="tok-comment"> // fail
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">NOBUFS</a>, cqe.err());
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a> == <span class="tok-number">0</span>);<span class="tok-comment"> // IORING_CQE_F_BUFFER flags is set on success only
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.NoBufferSelected, cqe.buffer_id());
        }<span class="tok-comment">

        // put buffers back to the kernel
        </span>buf_grp.put(id1);
        buf_grp.put(id2);

        chunk = data[buffer_size * <span class="tok-number">2</span> .. buffer_size * <span class="tok-number">3</span>];<span class="tok-comment"> // third chunk
        </span><span class="tok-kw">const</span> id3 = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_recv">expect_buf_grp_recv</a>(&amp;ring, &amp;buf_grp, fds.server, rnd.int(<span class="tok-type">u64</span>), chunk);
        buf_grp.put(id3);

        chunk = data[buffer_size * <span class="tok-number">3</span> ..];<span class="tok-comment"> // last chunk
        </span><span class="tok-kw">const</span> id4 = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_recv">expect_buf_grp_recv</a>(&amp;ring, &amp;buf_grp, fds.server, rnd.int(<span class="tok-type">u64</span>), chunk);
        buf_grp.put(id4);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ring mapped buffers multishot recv&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">16</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();<span class="tok-comment">

    // init buffer group
    </span><span class="tok-kw">const</span> group_id: <span class="tok-type">u16</span> = <span class="tok-number">1</span>;<span class="tok-comment"> // buffers group id
    </span><span class="tok-kw">const</span> buffers_count: <span class="tok-type">u16</span> = <span class="tok-number">2</span>;<span class="tok-comment"> // number of buffers in buffer group
    </span><span class="tok-kw">const</span> buffer_size: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;<span class="tok-comment"> // size of each buffer in group
    </span><span class="tok-kw">const</span> buffers = <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">alloc</a>(<span class="tok-type">u8</span>, buffers_count * buffer_size);
    <span class="tok-kw">defer</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>.<a href="#">free</a>(buffers);
    <span class="tok-kw">var</span> buf_grp = <a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>.<a href="std.os.linux.IoUring.BufferGroup.html#std.os.linux.IoUring.BufferGroup.init">init</a>(
        &amp;ring,
        group_id,
        buffers,
        buffer_size,
        buffers_count,
    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {<span class="tok-comment">
        // kernel older than 5.19
        </span><span class="tok-kw">error</span>.ArgumentsInvalid =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> buf_grp.deinit();<span class="tok-comment">

    // create client/server fds
    </span><span class="tok-kw">const</span> fds = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.createSocketTestHarness">createSocketTestHarness</a>(&amp;ring);
    <span class="tok-kw">defer</span> fds.close();<span class="tok-comment">

    // for random user_data in sqe/cqe
    </span><span class="tok-kw">var</span> Rnd = <a href="std.html">std</a>.<a href="std.Random.html">Random</a>.<a href="std.Random.Xoshiro256.html">DefaultPrng</a>.<a href="std.Random.Xoshiro256.html#std.Random.Xoshiro256.init">init</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.random_seed">random_seed</a>);
    <span class="tok-kw">var</span> rnd = Rnd.random();

    <span class="tok-kw">var</span> round: <span class="tok-type">usize</span> = <span class="tok-number">4</span>;<span class="tok-comment"> // repeat send/recv cycle round times
    </span><span class="tok-kw">while</span> (round &gt; <span class="tok-number">0</span>) : (round -= <span class="tok-number">1</span>) {<span class="tok-comment">
        // client sends data
        </span><span class="tok-kw">const</span> data = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0</span>, <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">0xa</span>, <span class="tok-number">0xb</span>, <span class="tok-number">0xc</span>, <span class="tok-number">0xd</span>, <span class="tok-number">0xe</span> };
        {
            <span class="tok-kw">const</span> user_data = rnd.int(<span class="tok-type">u64</span>);
            _ = <span class="tok-kw">try</span> ring.send(user_data, fds.client, data[<span class="tok-number">0</span>..], <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());
            <span class="tok-kw">const</span> cqe_send = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">if</span> (cqe_send.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a>{ .user_data = user_data, .res = data.len, .flags = <span class="tok-number">0</span> }, cqe_send);
        }<span class="tok-comment">

        // start multishot recv
        </span><span class="tok-kw">var</span> recv_user_data = rnd.int(<span class="tok-type">u64</span>);
        _ = <span class="tok-kw">try</span> buf_grp.recv_multishot(recv_user_data, fds.server, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment"> // submit

        // server reads data into provided buffers
        // there are 2 buffers of size 4, so each read gets only chunk of data
        // we read four chunks of 4, 4, 4, 3 bytes each
        </span><span class="tok-kw">var</span> chunk: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = data[<span class="tok-number">0</span>..buffer_size];<span class="tok-comment"> // first chunk
        </span><span class="tok-kw">const</span> cqe1 = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_cqe">expect_buf_grp_cqe</a>(&amp;ring, &amp;buf_grp, recv_user_data, chunk);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe1.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> &gt; <span class="tok-number">0</span>);

        chunk = data[buffer_size .. buffer_size * <span class="tok-number">2</span>];<span class="tok-comment"> // second chunk
        </span><span class="tok-kw">const</span> cqe2 = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_cqe">expect_buf_grp_cqe</a>(&amp;ring, &amp;buf_grp, recv_user_data, chunk);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe2.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> &gt; <span class="tok-number">0</span>);<span class="tok-comment">

        // both buffers provided to the kernel are used so we get error
        // 'no more buffers', until we put buffers to the kernel
        </span>{
            <span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(recv_user_data, cqe.user_data);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.res &lt; <span class="tok-number">0</span>);<span class="tok-comment"> // fail
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">NOBUFS</a>, cqe.err());
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a> == <span class="tok-number">0</span>);<span class="tok-comment"> // IORING_CQE_F_BUFFER flags is set on success only
            // has more is not set
            // indicates that multishot is finished
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> == <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectError">expectError</a>(<span class="tok-kw">error</span>.NoBufferSelected, cqe.buffer_id());
        }<span class="tok-comment">

        // put buffers back to the kernel
        </span>buf_grp.put(<span class="tok-kw">try</span> cqe1.buffer_id());
        buf_grp.put(<span class="tok-kw">try</span> cqe2.buffer_id());<span class="tok-comment">

        // restart multishot
        </span>recv_user_data = rnd.int(<span class="tok-type">u64</span>);
        _ = <span class="tok-kw">try</span> buf_grp.recv_multishot(recv_user_data, fds.server, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment"> // submit

        </span>chunk = data[buffer_size * <span class="tok-number">2</span> .. buffer_size * <span class="tok-number">3</span>];<span class="tok-comment"> // third chunk
        </span><span class="tok-kw">const</span> cqe3 = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_cqe">expect_buf_grp_cqe</a>(&amp;ring, &amp;buf_grp, recv_user_data, chunk);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe3.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> &gt; <span class="tok-number">0</span>);
        buf_grp.put(<span class="tok-kw">try</span> cqe3.buffer_id());

        chunk = data[buffer_size * <span class="tok-number">3</span> ..];<span class="tok-comment"> // last chunk
        </span><span class="tok-kw">const</span> cqe4 = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_cqe">expect_buf_grp_cqe</a>(&amp;ring, &amp;buf_grp, recv_user_data, chunk);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe4.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> &gt; <span class="tok-number">0</span>);
        buf_grp.put(<span class="tok-kw">try</span> cqe4.buffer_id());<span class="tok-comment">

        // cancel pending multishot recv operation
        </span>{
            <span class="tok-kw">const</span> cancel_user_data = rnd.int(<span class="tok-type">u64</span>);
            _ = <span class="tok-kw">try</span> ring.cancel(cancel_user_data, recv_user_data, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment">

            // expect completion of cancel operation and completion of recv operation
            </span><span class="tok-kw">var</span> cqe_cancel = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">if</span> (cqe_cancel.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
            <span class="tok-kw">var</span> cqe_recv = <span class="tok-kw">try</span> ring.copy_cqe();
            <span class="tok-kw">if</span> (cqe_recv.err() == .INVAL) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;<span class="tok-comment">

            // don't depend on order of completions
            </span><span class="tok-kw">if</span> (cqe_cancel.user_data == recv_user_data <span class="tok-kw">and</span> cqe_recv.user_data == cancel_user_data) {
                <span class="tok-kw">const</span> a = cqe_cancel;
                <span class="tok-kw">const</span> b = cqe_recv;
                cqe_cancel = b;
                cqe_recv = a;
            }<span class="tok-comment">

            // Note on different kernel results:
            // on older kernel (tested with v6.0.16, v6.1.57, v6.2.12, v6.4.16)
            //   cqe_cancel.err() == .NOENT
            //   cqe_recv.err() == .NOBUFS
            // on kernel (tested with v6.5.0, v6.5.7)
            //   cqe_cancel.err() == .SUCCESS
            //   cqe_recv.err() == .CANCELED
            // Upstream reference: https://github.com/axboe/liburing/issues/984

            // cancel operation is success (or NOENT on older kernels)
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(cancel_user_data, cqe_cancel.user_data);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_cancel.err() == .NOENT <span class="tok-kw">or</span> cqe_cancel.err() == .SUCCESS);<span class="tok-comment">

            // recv operation is failed with err CANCELED (or NOBUFS on older kernels)
            </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(recv_user_data, cqe_recv.user_data);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_recv.res &lt; <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_recv.err() == .NOBUFS <span class="tok-kw">or</span> cqe_recv.err() == .CANCELED);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe_recv.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_MORE">IORING_CQE_F_MORE</a> == <span class="tok-number">0</span>);
        }
    }
}<span class="tok-comment">

// Prepare and submit recv using buffer group.
// Test that buffer from group, pointed by cqe, matches expected.
</span><span class="tok-kw">fn</span> <span class="tok-fn">expect_buf_grp_recv</span>(
    ring: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    buf_grp: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>,
    fd: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>,
    user_data: <span class="tok-type">u64</span>,
    expected: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !<span class="tok-type">u16</span> {<span class="tok-comment">
    // prepare and submit read
    </span><span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> buf_grp.recv(user_data, fd, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(sqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a> == <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IOSQE_BUFFER_SELECT">IOSQE_BUFFER_SELECT</a>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(sqe.buf_index == buf_grp.group_id);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1</span>), <span class="tok-kw">try</span> ring.submit());<span class="tok-comment"> // submit

    </span><span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> <a href="std.os.linux.IoUring.html#std.os.linux.IoUring.expect_buf_grp_cqe">expect_buf_grp_cqe</a>(ring, buf_grp, user_data, expected);
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> cqe.buffer_id();
}

<span class="tok-kw">fn</span> <span class="tok-fn">expect_buf_grp_cqe</span>(
    ring: *<a href="std.os.linux.IoUring.html">IoUring</a>,
    buf_grp: *<a href="std.os.linux.IoUring.BufferGroup.html">BufferGroup</a>,
    user_data: <span class="tok-type">u64</span>,
    expected: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
) !<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> {<span class="tok-comment">
    // get cqe
    </span><span class="tok-kw">const</span> cqe = <span class="tok-kw">try</span> ring.copy_cqe();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(user_data, cqe.user_data);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.res &gt;= <span class="tok-number">0</span>);<span class="tok-comment"> // success
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(cqe.flags &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a> == <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.IORING_CQE_F_BUFFER">IORING_CQE_F_BUFFER</a>);<span class="tok-comment"> // IORING_CQE_F_BUFFER flag is set
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(expected.len, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res)));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.E">E</a>.<a href="#">SUCCESS</a>, cqe.err());<span class="tok-comment">

    // get buffer from pool
    </span><span class="tok-kw">const</span> buffer_id = <span class="tok-kw">try</span> cqe.buffer_id();
    <span class="tok-kw">const</span> len = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cqe.res));
    <span class="tok-kw">const</span> buf = buf_grp.get(buffer_id)[<span class="tok-number">0</span>..len];
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualSlices">expectEqualSlices</a>(<span class="tok-type">u8</span>, expected, buf);

    <span class="tok-kw">return</span> cqe;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;copy_cqes with wrapping sq.cqes buffer&quot;</span> {
    <span class="tok-kw">if</span> (!<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.is_linux">is_linux</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> ring = <a href="std.os.linux.IoUring.html">IoUring</a>.<a href="std.os.linux.IoUring.html#std.os.linux.IoUring.init">init</a>(<span class="tok-number">2</span>, <span class="tok-number">0</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.SystemOutdated =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">error</span>.PermissionDenied =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> err,
    };
    <span class="tok-kw">defer</span> ring.deinit();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, ring.sq.sqes.len);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">4</span>, ring.cq.cqes.len);<span class="tok-comment">

    // submit 2 entries, receive 2 completions
    </span><span class="tok-kw">var</span> cqes: [<span class="tok-number">8</span>]<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.io_uring_cqe.html">io_uring_cqe</a> = <span class="tok-null">undefined</span>;
    {
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">2</span>) |_| {
            <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.get_sqe();
            sqe.prep_timeout(&amp;.{ .sec = <span class="tok-number">0</span>, .nsec = <span class="tok-number">10000</span> }, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">try</span> ring.submit() == <span class="tok-number">1</span>);
        }
        <span class="tok-kw">var</span> cqe_count: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (cqe_count &lt; <span class="tok-number">2</span>) {
            cqe_count += <span class="tok-kw">try</span> ring.copy_cqes(&amp;cqes, <span class="tok-number">2</span> - cqe_count);
        }
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, ring.cq.head.*);<span class="tok-comment">

    // sq.sqes len is 4, starting at position 2
    // every 4 entries submit wraps completion buffer
    // we are reading ring.cq.cqes at indexes 2,3,0,1
    </span><span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">1024</span>) |i| {
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">4</span>) |_| {
            <span class="tok-kw">const</span> sqe = <span class="tok-kw">try</span> ring.get_sqe();
            sqe.prep_timeout(&amp;.{ .sec = <span class="tok-number">0</span>, .nsec = <span class="tok-number">10000</span> }, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-kw">try</span> ring.submit() == <span class="tok-number">1</span>);
        }
        <span class="tok-kw">var</span> cqe_count: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (cqe_count &lt; <span class="tok-number">4</span>) {
            cqe_count += <span class="tok-kw">try</span> ring.copy_cqes(&amp;cqes, <span class="tok-number">4</span> - cqe_count);
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">4</span>, cqe_count);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span> + <span class="tok-number">4</span> * i, ring.cq.head.*);
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
