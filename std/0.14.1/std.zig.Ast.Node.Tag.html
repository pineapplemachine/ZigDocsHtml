<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.Ast.html" class="">Ast</a></li><li><a href="std.zig.Ast.Node.html" class="">Node</a></li><li><a href="std.zig.Ast.Node.Tag.html" class="active">Tag</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.Ast.Node.Tag" class="declHeader"><span class="declHeaderCategory">enum</span><span class="declHeaderIdentifier">std.zig.Ast.Node.Tag</span><a href="#src.zig-std.zig.Ast.Node.Tag">[src]</a></h1><div class="tldDocs"><p>Note: The FooComma/FooSemicolon variants exist to ease the implementation of
Ast.lastToken()</p>
</div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>root</code></pre><div class="fieldDocs"><p>sub_list[lhs...rhs]</p>
</div></div><div><pre><code>@&quot;usingnamespace&quot;</code></pre><div class="fieldDocs"><p><code>usingnamespace lhs;</code>. rhs unused. main_token is <code>usingnamespace</code>.</p>
</div></div><div><pre><code>test_decl</code></pre><div class="fieldDocs"><p>lhs is test name token (must be string literal or identifier), if any.
rhs is the body node.</p>
</div></div><div><pre><code>global_var_decl</code></pre><div class="fieldDocs"><p>lhs is the index into extra_data.
rhs is the initialization expression, if any.
main_token is <code>var</code> or <code>const</code>.</p>
</div></div><div><pre><code>local_var_decl</code></pre><div class="fieldDocs"><p><code>var a: x align(y) = rhs</code>
lhs is the index into extra_data.
main_token is <code>var</code> or <code>const</code>.</p>
</div></div><div><pre><code>simple_var_decl</code></pre><div class="fieldDocs"><p><code>var a: lhs = rhs</code>. lhs and rhs may be unused.
Can be local or global.
main_token is <code>var</code> or <code>const</code>.</p>
</div></div><div><pre><code>aligned_var_decl</code></pre><div class="fieldDocs"><p><code>var a align(lhs) = rhs</code>. lhs and rhs may be unused.
Can be local or global.
main_token is <code>var</code> or <code>const</code>.</p>
</div></div><div><pre><code>@&quot;errdefer&quot;</code></pre><div class="fieldDocs"><p>lhs is the identifier token payload if any,
rhs is the deferred expression.</p>
</div></div><div><pre><code>@&quot;defer&quot;</code></pre><div class="fieldDocs"><p>lhs is unused.
rhs is the deferred expression.</p>
</div></div><div><pre><code>@&quot;catch&quot;</code></pre><div class="fieldDocs"><p>lhs catch rhs
lhs catch |err| rhs
main_token is the <code>catch</code> keyword.
payload is determined by looking at the next token after the <code>catch</code> keyword.</p>
</div></div><div><pre><code>field_access</code></pre><div class="fieldDocs"><p><code>lhs.a</code>. main_token is the dot. rhs is the identifier token index.</p>
</div></div><div><pre><code>unwrap_optional</code></pre><div class="fieldDocs"><p><code>lhs.?</code>. main_token is the dot. rhs is the <code>?</code> token index.</p>
</div></div><div><pre><code>equal_equal</code></pre><div class="fieldDocs"><p><code>lhs == rhs</code>. main_token is op.</p>
</div></div><div><pre><code>bang_equal</code></pre><div class="fieldDocs"><p><code>lhs != rhs</code>. main_token is op.</p>
</div></div><div><pre><code>less_than</code></pre><div class="fieldDocs"><p><code>lhs &lt; rhs</code>. main_token is op.</p>
</div></div><div><pre><code>greater_than</code></pre><div class="fieldDocs"><p><code>lhs &gt; rhs</code>. main_token is op.</p>
</div></div><div><pre><code>less_or_equal</code></pre><div class="fieldDocs"><p><code>lhs &lt;= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>greater_or_equal</code></pre><div class="fieldDocs"><p><code>lhs &gt;= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_mul</code></pre><div class="fieldDocs"><p><code>lhs *= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_div</code></pre><div class="fieldDocs"><p><code>lhs /= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_mod</code></pre><div class="fieldDocs"><p><code>lhs %= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_add</code></pre><div class="fieldDocs"><p><code>lhs += rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_sub</code></pre><div class="fieldDocs"><p><code>lhs -= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_shl</code></pre><div class="fieldDocs"><p><code>lhs &lt;&lt;= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_shl_sat</code></pre><div class="fieldDocs"><p><code>lhs &lt;&lt;|= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_shr</code></pre><div class="fieldDocs"><p><code>lhs &gt;&gt;= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_bit_and</code></pre><div class="fieldDocs"><p><code>lhs &amp;= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_bit_xor</code></pre><div class="fieldDocs"><p><code>lhs ^= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_bit_or</code></pre><div class="fieldDocs"><p><code>lhs |= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_mul_wrap</code></pre><div class="fieldDocs"><p><code>lhs *%= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_add_wrap</code></pre><div class="fieldDocs"><p><code>lhs +%= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_sub_wrap</code></pre><div class="fieldDocs"><p><code>lhs -%= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_mul_sat</code></pre><div class="fieldDocs"><p><code>lhs *|= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_add_sat</code></pre><div class="fieldDocs"><p><code>lhs +|= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_sub_sat</code></pre><div class="fieldDocs"><p><code>lhs -|= rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign</code></pre><div class="fieldDocs"><p><code>lhs = rhs</code>. main_token is op.</p>
</div></div><div><pre><code>assign_destructure</code></pre><div class="fieldDocs"><p><code>a, b, ... = rhs</code>. main_token is op. lhs is index into <code>extra_data</code>
of an lhs elem count followed by an array of that many <code><a href="std.zig.Ast.Node.html#std.zig.Ast.Node.Index">Node.Index</a></code>,
with each node having one of the following types:</p>
<ul>
<li><code>global_var_decl</code></li>
<li><code>local_var_decl</code></li>
<li><code>simple_var_decl</code></li>
<li><code>aligned_var_decl</code></li>
<li>Any expression node
The first 3 types correspond to a <code>var</code> or <code>const</code> lhs node (note
that their <code>rhs</code> is always 0). An expression node corresponds to a
standard assignment LHS (which must be evaluated as an lvalue).
There may be a preceding <code>comptime</code> token, which does not create a
corresponding <code>comptime</code> node so must be manually detected.</li>
</ul>
</div></div><div><pre><code>merge_error_sets</code></pre><div class="fieldDocs"><p><code>lhs || rhs</code>. main_token is the <code>||</code>.</p>
</div></div><div><pre><code>mul</code></pre><div class="fieldDocs"><p><code>lhs * rhs</code>. main_token is the <code>*</code>.</p>
</div></div><div><pre><code>div</code></pre><div class="fieldDocs"><p><code>lhs / rhs</code>. main_token is the <code>/</code>.</p>
</div></div><div><pre><code>mod</code></pre><div class="fieldDocs"><p><code>lhs % rhs</code>. main_token is the <code>%</code>.</p>
</div></div><div><pre><code>array_mult</code></pre><div class="fieldDocs"><p><code>lhs ** rhs</code>. main_token is the <code>**</code>.</p>
</div></div><div><pre><code>mul_wrap</code></pre><div class="fieldDocs"><p><code>lhs *% rhs</code>. main_token is the <code>*%</code>.</p>
</div></div><div><pre><code>mul_sat</code></pre><div class="fieldDocs"><p><code>lhs *| rhs</code>. main_token is the <code>*|</code>.</p>
</div></div><div><pre><code>add</code></pre><div class="fieldDocs"><p><code>lhs + rhs</code>. main_token is the <code>+</code>.</p>
</div></div><div><pre><code>sub</code></pre><div class="fieldDocs"><p><code>lhs - rhs</code>. main_token is the <code>-</code>.</p>
</div></div><div><pre><code>array_cat</code></pre><div class="fieldDocs"><p><code>lhs ++ rhs</code>. main_token is the <code>++</code>.</p>
</div></div><div><pre><code>add_wrap</code></pre><div class="fieldDocs"><p><code>lhs +% rhs</code>. main_token is the <code>+%</code>.</p>
</div></div><div><pre><code>sub_wrap</code></pre><div class="fieldDocs"><p><code>lhs -% rhs</code>. main_token is the <code>-%</code>.</p>
</div></div><div><pre><code>add_sat</code></pre><div class="fieldDocs"><p><code>lhs +| rhs</code>. main_token is the <code>+|</code>.</p>
</div></div><div><pre><code>sub_sat</code></pre><div class="fieldDocs"><p><code>lhs -| rhs</code>. main_token is the <code>-|</code>.</p>
</div></div><div><pre><code>shl</code></pre><div class="fieldDocs"><p><code>lhs &lt;&lt; rhs</code>. main_token is the <code>&lt;&lt;</code>.</p>
</div></div><div><pre><code>shl_sat</code></pre><div class="fieldDocs"><p><code>lhs &lt;&lt;| rhs</code>. main_token is the <code>&lt;&lt;|</code>.</p>
</div></div><div><pre><code>shr</code></pre><div class="fieldDocs"><p><code>lhs &gt;&gt; rhs</code>. main_token is the <code>&gt;&gt;</code>.</p>
</div></div><div><pre><code>bit_and</code></pre><div class="fieldDocs"><p><code>lhs &amp; rhs</code>. main_token is the <code>&amp;</code>.</p>
</div></div><div><pre><code>bit_xor</code></pre><div class="fieldDocs"><p><code>lhs ^ rhs</code>. main_token is the <code>^</code>.</p>
</div></div><div><pre><code>bit_or</code></pre><div class="fieldDocs"><p><code>lhs | rhs</code>. main_token is the <code>|</code>.</p>
</div></div><div><pre><code>@&quot;orelse&quot;</code></pre><div class="fieldDocs"><p><code>lhs orelse rhs</code>. main_token is the <code>orelse</code>.</p>
</div></div><div><pre><code>bool_and</code></pre><div class="fieldDocs"><p><code>lhs and rhs</code>. main_token is the <code>and</code>.</p>
</div></div><div><pre><code>bool_or</code></pre><div class="fieldDocs"><p><code>lhs or rhs</code>. main_token is the <code>or</code>.</p>
</div></div><div><pre><code>bool_not</code></pre><div class="fieldDocs"><p><code>op lhs</code>. rhs unused. main_token is op.</p>
</div></div><div><pre><code>negation</code></pre><div class="fieldDocs"><p><code>op lhs</code>. rhs unused. main_token is op.</p>
</div></div><div><pre><code>bit_not</code></pre><div class="fieldDocs"><p><code>op lhs</code>. rhs unused. main_token is op.</p>
</div></div><div><pre><code>negation_wrap</code></pre><div class="fieldDocs"><p><code>op lhs</code>. rhs unused. main_token is op.</p>
</div></div><div><pre><code>address_of</code></pre><div class="fieldDocs"><p><code>op lhs</code>. rhs unused. main_token is op.</p>
</div></div><div><pre><code>@&quot;try&quot;</code></pre><div class="fieldDocs"><p><code>op lhs</code>. rhs unused. main_token is op.</p>
</div></div><div><pre><code>@&quot;await&quot;</code></pre><div class="fieldDocs"><p><code>op lhs</code>. rhs unused. main_token is op.</p>
</div></div><div><pre><code>optional_type</code></pre><div class="fieldDocs"><p><code>?lhs</code>. rhs unused. main_token is the <code>?</code>.</p>
</div></div><div><pre><code>array_type</code></pre><div class="fieldDocs"><p><code>[lhs]rhs</code>.</p>
</div></div><div><pre><code>array_type_sentinel</code></pre><div class="fieldDocs"><p><code>[lhs:a]b</code>. <code>ArrayTypeSentinel[rhs]</code>.</p>
</div></div><div><pre><code>ptr_type_aligned</code></pre><div class="fieldDocs"><p><code>[*]align(lhs) rhs</code>. lhs can be omitted.
<code>*align(lhs) rhs</code>. lhs can be omitted.
<code>[]rhs</code>.
main_token is the asterisk if a single item pointer or the lbracket
if a slice, many-item pointer, or C-pointer
main_token might be a ** token, which is shared with a parent/child
pointer type and may require special handling.</p>
</div></div><div><pre><code>ptr_type_sentinel</code></pre><div class="fieldDocs"><p><code>[*:lhs]rhs</code>. lhs can be omitted.
<code>*rhs</code>.
<code>[:lhs]rhs</code>.
main_token is the asterisk if a single item pointer or the lbracket
if a slice, many-item pointer, or C-pointer
main_token might be a ** token, which is shared with a parent/child
pointer type and may require special handling.</p>
</div></div><div><pre><code>ptr_type</code></pre><div class="fieldDocs"><p>lhs is index into ptr_type. rhs is the element type expression.
main_token is the asterisk if a single item pointer or the lbracket
if a slice, many-item pointer, or C-pointer
main_token might be a ** token, which is shared with a parent/child
pointer type and may require special handling.</p>
</div></div><div><pre><code>ptr_type_bit_range</code></pre><div class="fieldDocs"><p>lhs is index into ptr_type_bit_range. rhs is the element type expression.
main_token is the asterisk if a single item pointer or the lbracket
if a slice, many-item pointer, or C-pointer
main_token might be a ** token, which is shared with a parent/child
pointer type and may require special handling.</p>
</div></div><div><pre><code>slice_open</code></pre><div class="fieldDocs"><p><code>lhs[rhs..]</code>
main_token is the lbracket.</p>
</div></div><div><pre><code><a href="std.zig.Ast.html#std.zig.Ast.slice">slice</a></code></pre><div class="fieldDocs"><p><code>lhs[b..c]</code>. rhs is index into Slice
main_token is the lbracket.</p>
</div></div><div><pre><code>slice_sentinel</code></pre><div class="fieldDocs"><p><code>lhs[b..c :d]</code>. rhs is index into SliceSentinel. Slice end &quot;c&quot; can be omitted.
main_token is the lbracket.</p>
</div></div><div><pre><code>deref</code></pre><div class="fieldDocs"><p><code>lhs.*</code>. rhs is unused.</p>
</div></div><div><pre><code>array_access</code></pre><div class="fieldDocs"><p><code>lhs[rhs]</code>.</p>
</div></div><div><pre><code>array_init_one</code></pre><div class="fieldDocs"><p><code>lhs{rhs}</code>. rhs can be omitted.</p>
</div></div><div><pre><code>array_init_one_comma</code></pre><div class="fieldDocs"><p><code>lhs{rhs,}</code>. rhs can <em>not</em> be omitted</p>
</div></div><div><pre><code>array_init_dot_two</code></pre><div class="fieldDocs"><p><code>.{lhs, rhs}</code>. lhs and rhs can be omitted.</p>
</div></div><div><pre><code>array_init_dot_two_comma</code></pre><div class="fieldDocs"><p>Same as <code>array_init_dot_two</code> except there is known to be a trailing comma
before the final rbrace.</p>
</div></div><div><pre><code>array_init_dot</code></pre><div class="fieldDocs"><p><code>.{a, b}</code>. <code>sub_list[lhs..rhs]</code>.</p>
</div></div><div><pre><code>array_init_dot_comma</code></pre><div class="fieldDocs"><p>Same as <code>array_init_dot</code> except there is known to be a trailing comma
before the final rbrace.</p>
</div></div><div><pre><code>array_init</code></pre><div class="fieldDocs"><p><code>lhs{a, b}</code>. <code>sub_range_list[rhs]</code>. lhs can be omitted which means <code>.{a, b}</code>.</p>
</div></div><div><pre><code>array_init_comma</code></pre><div class="fieldDocs"><p>Same as <code>array_init</code> except there is known to be a trailing comma
before the final rbrace.</p>
</div></div><div><pre><code>struct_init_one</code></pre><div class="fieldDocs"><p><code>lhs{.a = rhs}</code>. rhs can be omitted making it empty.
main_token is the lbrace.</p>
</div></div><div><pre><code>struct_init_one_comma</code></pre><div class="fieldDocs"><p><code>lhs{.a = rhs,}</code>. rhs can <em>not</em> be omitted.
main_token is the lbrace.</p>
</div></div><div><pre><code>struct_init_dot_two</code></pre><div class="fieldDocs"><p><code>.{.a = lhs, .b = rhs}</code>. lhs and rhs can be omitted.
main_token is the lbrace.
No trailing comma before the rbrace.</p>
</div></div><div><pre><code>struct_init_dot_two_comma</code></pre><div class="fieldDocs"><p>Same as <code>struct_init_dot_two</code> except there is known to be a trailing comma
before the final rbrace.</p>
</div></div><div><pre><code>struct_init_dot</code></pre><div class="fieldDocs"><p><code>.{.a = b, .c = d}</code>. <code>sub_list[lhs..rhs]</code>.
main_token is the lbrace.</p>
</div></div><div><pre><code>struct_init_dot_comma</code></pre><div class="fieldDocs"><p>Same as <code>struct_init_dot</code> except there is known to be a trailing comma
before the final rbrace.</p>
</div></div><div><pre><code>struct_init</code></pre><div class="fieldDocs"><p><code>lhs{.a = b, .c = d}</code>. <code>sub_range_list[rhs]</code>.
lhs can be omitted which means <code>.{.a = b, .c = d}</code>.
main_token is the lbrace.</p>
</div></div><div><pre><code>struct_init_comma</code></pre><div class="fieldDocs"><p>Same as <code>struct_init</code> except there is known to be a trailing comma
before the final rbrace.</p>
</div></div><div><pre><code>call_one</code></pre><div class="fieldDocs"><p><code>lhs(rhs)</code>. rhs can be omitted.
main_token is the lparen.</p>
</div></div><div><pre><code>call_one_comma</code></pre><div class="fieldDocs"><p><code>lhs(rhs,)</code>. rhs can be omitted.
main_token is the lparen.</p>
</div></div><div><pre><code>async_call_one</code></pre><div class="fieldDocs"><p><code>async lhs(rhs)</code>. rhs can be omitted.</p>
</div></div><div><pre><code>async_call_one_comma</code></pre><div class="fieldDocs"><p><code>async lhs(rhs,)</code>.</p>
</div></div><div><pre><code>call</code></pre><div class="fieldDocs"><p><code>lhs(a, b, c)</code>. <code>SubRange[rhs]</code>.
main_token is the <code>(</code>.</p>
</div></div><div><pre><code>call_comma</code></pre><div class="fieldDocs"><p><code>lhs(a, b, c,)</code>. <code>SubRange[rhs]</code>.
main_token is the <code>(</code>.</p>
</div></div><div><pre><code>async_call</code></pre><div class="fieldDocs"><p><code>async lhs(a, b, c)</code>. <code>SubRange[rhs]</code>.
main_token is the <code>(</code>.</p>
</div></div><div><pre><code>async_call_comma</code></pre><div class="fieldDocs"><p><code>async lhs(a, b, c,)</code>. <code>SubRange[rhs]</code>.
main_token is the <code>(</code>.</p>
</div></div><div><pre><code>@&quot;switch&quot;</code></pre><div class="fieldDocs"><p><code>switch(lhs) {}</code>. <code>SubRange[rhs]</code>.
<code>main_token</code> is the identifier of a preceding label, if any; otherwise <code>switch</code>.</p>
</div></div><div><pre><code>switch_comma</code></pre><div class="fieldDocs"><p>Same as switch except there is known to be a trailing comma
before the final rbrace</p>
</div></div><div><pre><code>switch_case_one</code></pre><div class="fieldDocs"><p><code>lhs =&gt; rhs</code>. If lhs is omitted it means <code>else</code>.
main_token is the <code>=&gt;</code></p>
</div></div><div><pre><code>switch_case_inline_one</code></pre><div class="fieldDocs"><p>Same ast <code>switch_case_one</code> but the case is inline</p>
</div></div><div><pre><code>switch_case</code></pre><div class="fieldDocs"><p><code>a, b, c =&gt; rhs</code>. <code>SubRange[lhs]</code>.
main_token is the <code>=&gt;</code></p>
</div></div><div><pre><code>switch_case_inline</code></pre><div class="fieldDocs"><p>Same ast <code>switch_case</code> but the case is inline</p>
</div></div><div><pre><code>switch_range</code></pre><div class="fieldDocs"><p><code>lhs...rhs</code>.</p>
</div></div><div><pre><code>while_simple</code></pre><div class="fieldDocs"><p><code>while (lhs) rhs</code>.
<code>while (lhs) |x| rhs</code>.</p>
</div></div><div><pre><code>while_cont</code></pre><div class="fieldDocs"><p><code>while (lhs) : (a) b</code>. <code>WhileCont[rhs]</code>.
<code>while (lhs) : (a) b</code>. <code>WhileCont[rhs]</code>.</p>
</div></div><div><pre><code>@&quot;while&quot;</code></pre><div class="fieldDocs"><p><code>while (lhs) : (a) b else c</code>. <code>While[rhs]</code>.
<code>while (lhs) |x| : (a) b else c</code>. <code>While[rhs]</code>.
<code>while (lhs) |x| : (a) b else |y| c</code>. <code>While[rhs]</code>.
The cont expression part <code>: (a)</code> may be omitted.</p>
</div></div><div><pre><code>for_simple</code></pre><div class="fieldDocs"><p><code>for (lhs) rhs</code>.</p>
</div></div><div><pre><code>@&quot;for&quot;</code></pre><div class="fieldDocs"><p><code>for (lhs[0..inputs]) lhs[inputs + 1] else lhs[inputs + 2]</code>. <code>For[rhs]</code>.</p>
</div></div><div><pre><code>for_range</code></pre><div class="fieldDocs"><p><code>lhs..rhs</code>. rhs can be omitted.</p>
</div></div><div><pre><code>if_simple</code></pre><div class="fieldDocs"><p><code>if (lhs) rhs</code>.
<code>if (lhs) |a| rhs</code>.</p>
</div></div><div><pre><code>@&quot;if&quot;</code></pre><div class="fieldDocs"><p><code>if (lhs) a else b</code>. <code>If[rhs]</code>.
<code>if (lhs) |x| a else b</code>. <code>If[rhs]</code>.
<code>if (lhs) |x| a else |y| b</code>. <code>If[rhs]</code>.</p>
</div></div><div><pre><code>@&quot;suspend&quot;</code></pre><div class="fieldDocs"><p><code>suspend lhs</code>. lhs can be omitted. rhs is unused.</p>
</div></div><div><pre><code>@&quot;resume&quot;</code></pre><div class="fieldDocs"><p><code>resume lhs</code>. rhs is unused.</p>
</div></div><div><pre><code>@&quot;continue&quot;</code></pre><div class="fieldDocs"><p><code>continue :lhs rhs</code>
both lhs and rhs may be omitted.</p>
</div></div><div><pre><code>@&quot;break&quot;</code></pre><div class="fieldDocs"><p><code>break :lhs rhs</code>
both lhs and rhs may be omitted.</p>
</div></div><div><pre><code>@&quot;return&quot;</code></pre><div class="fieldDocs"><p><code>return lhs</code>. lhs can be omitted. rhs is unused.</p>
</div></div><div><pre><code>fn_proto_simple</code></pre><div class="fieldDocs"><p><code>fn (a: lhs) rhs</code>. lhs can be omitted.
anytype and ... parameters are omitted from the AST tree.
main_token is the <code>fn</code> keyword.
extern function declarations use this tag.</p>
</div></div><div><pre><code>fn_proto_multi</code></pre><div class="fieldDocs"><p><code>fn (a: b, c: d) rhs</code>. <code>sub_range_list[lhs]</code>.
anytype and ... parameters are omitted from the AST tree.
main_token is the <code>fn</code> keyword.
extern function declarations use this tag.</p>
</div></div><div><pre><code>fn_proto_one</code></pre><div class="fieldDocs"><p><code>fn (a: b) addrspace(e) linksection(f) callconv(g) rhs</code>. <code>FnProtoOne[lhs]</code>.
zero or one parameters.
anytype and ... parameters are omitted from the AST tree.
main_token is the <code>fn</code> keyword.
extern function declarations use this tag.</p>
</div></div><div><pre><code>fn_proto</code></pre><div class="fieldDocs"><p><code>fn (a: b, c: d) addrspace(e) linksection(f) callconv(g) rhs</code>. <code>FnProto[lhs]</code>.
anytype and ... parameters are omitted from the AST tree.
main_token is the <code>fn</code> keyword.
extern function declarations use this tag.</p>
</div></div><div><pre><code>fn_decl</code></pre><div class="fieldDocs"><p>lhs is the fn_proto.
rhs is the function body block.
Note that extern function declarations use the fn_proto tags rather
than this one.</p>
</div></div><div><pre><code>anyframe_type</code></pre><div class="fieldDocs"><p><code>anyframe-&gt;rhs</code>. main_token is <code>anyframe</code>. <code>lhs</code> is arrow token index.</p>
</div></div><div><pre><code>anyframe_literal</code></pre><div class="fieldDocs"><p>Both lhs and rhs unused.</p>
</div></div><div><pre><code>char_literal</code></pre><div class="fieldDocs"><p>Both lhs and rhs unused.</p>
</div></div><div><pre><code>number_literal</code></pre><div class="fieldDocs"><p>Both lhs and rhs unused.</p>
</div></div><div><pre><code>unreachable_literal</code></pre><div class="fieldDocs"><p>Both lhs and rhs unused.</p>
</div></div><div><pre><code>identifier</code></pre><div class="fieldDocs"><p>Both lhs and rhs unused.
Most identifiers will not have explicit AST nodes, however for expressions
which could be one of many different kinds of AST nodes, there will be an
identifier AST node for it.</p>
</div></div><div><pre><code>enum_literal</code></pre><div class="fieldDocs"><p>lhs is the dot token index, rhs unused, main_token is the identifier.</p>
</div></div><div><pre><code>string_literal</code></pre><div class="fieldDocs"><p>main_token is the string literal token
Both lhs and rhs unused.</p>
</div></div><div><pre><code>multiline_string_literal</code></pre><div class="fieldDocs"><p>main_token is the first token index (redundant with lhs)
lhs is the first token index; rhs is the last token index.
Could be a series of multiline_string_literal_line tokens, or a single
string_literal token.</p>
</div></div><div><pre><code>grouped_expression</code></pre><div class="fieldDocs"><p><code>(lhs)</code>. main_token is the <code>(</code>; rhs is the token index of the <code>)</code>.</p>
</div></div><div><pre><code>builtin_call_two</code></pre><div class="fieldDocs"><p><code>@a(lhs, rhs)</code>. lhs and rhs may be omitted.
main_token is the builtin token.</p>
</div></div><div><pre><code>builtin_call_two_comma</code></pre><div class="fieldDocs"><p>Same as builtin_call_two but there is known to be a trailing comma before the rparen.</p>
</div></div><div><pre><code>builtin_call</code></pre><div class="fieldDocs"><p><code>@a(b, c)</code>. <code>sub_list[lhs..rhs]</code>.
main_token is the builtin token.</p>
</div></div><div><pre><code>builtin_call_comma</code></pre><div class="fieldDocs"><p>Same as builtin_call but there is known to be a trailing comma before the rparen.</p>
</div></div><div><pre><code>error_set_decl</code></pre><div class="fieldDocs"><p><code>error{a, b}</code>.
rhs is the rbrace, lhs is unused.</p>
</div></div><div><pre><code>container_decl</code></pre><div class="fieldDocs"><p><code>struct {}</code>, <code>union {}</code>, <code>opaque {}</code>, <code>enum {}</code>. <code>extra_data[lhs..rhs]</code>.
main_token is <code>struct</code>, <code>union</code>, <code>opaque</code>, <code>enum</code> keyword.</p>
</div></div><div><pre><code>container_decl_trailing</code></pre><div class="fieldDocs"><p>Same as ContainerDecl but there is known to be a trailing comma
or semicolon before the rbrace.</p>
</div></div><div><pre><code>container_decl_two</code></pre><div class="fieldDocs"><p><code>struct {lhs, rhs}</code>, <code>union {lhs, rhs}</code>, <code>opaque {lhs, rhs}</code>, <code>enum {lhs, rhs}</code>.
lhs or rhs can be omitted.
main_token is <code>struct</code>, <code>union</code>, <code>opaque</code>, <code>enum</code> keyword.</p>
</div></div><div><pre><code>container_decl_two_trailing</code></pre><div class="fieldDocs"><p>Same as ContainerDeclTwo except there is known to be a trailing comma
or semicolon before the rbrace.</p>
</div></div><div><pre><code>container_decl_arg</code></pre><div class="fieldDocs"><p><code>struct(lhs)</code> / <code>union(lhs)</code> / <code>enum(lhs)</code>. <code>SubRange[rhs]</code>.</p>
</div></div><div><pre><code>container_decl_arg_trailing</code></pre><div class="fieldDocs"><p>Same as container_decl_arg but there is known to be a trailing
comma or semicolon before the rbrace.</p>
</div></div><div><pre><code>tagged_union</code></pre><div class="fieldDocs"><p><code>union(enum) {}</code>. <code>sub_list[lhs..rhs]</code>.
Note that tagged unions with explicitly provided enums are represented
by <code>container_decl_arg</code>.</p>
</div></div><div><pre><code>tagged_union_trailing</code></pre><div class="fieldDocs"><p>Same as tagged_union but there is known to be a trailing comma
or semicolon before the rbrace.</p>
</div></div><div><pre><code>tagged_union_two</code></pre><div class="fieldDocs"><p><code>union(enum) {lhs, rhs}</code>. lhs or rhs may be omitted.
Note that tagged unions with explicitly provided enums are represented
by <code>container_decl_arg</code>.</p>
</div></div><div><pre><code>tagged_union_two_trailing</code></pre><div class="fieldDocs"><p>Same as tagged_union_two but there is known to be a trailing comma
or semicolon before the rbrace.</p>
</div></div><div><pre><code>tagged_union_enum_tag</code></pre><div class="fieldDocs"><p><code>union(enum(lhs)) {}</code>. <code>SubRange[rhs]</code>.</p>
</div></div><div><pre><code>tagged_union_enum_tag_trailing</code></pre><div class="fieldDocs"><p>Same as tagged_union_enum_tag but there is known to be a trailing comma
or semicolon before the rbrace.</p>
</div></div><div><pre><code>container_field_init</code></pre><div class="fieldDocs"><p><code>a: lhs = rhs,</code>. lhs and rhs can be omitted.
main_token is the field name identifier.
lastToken() does not include the possible trailing comma.</p>
</div></div><div><pre><code>container_field_align</code></pre><div class="fieldDocs"><p><code>a: lhs align(rhs),</code>. rhs can be omitted.
main_token is the field name identifier.
lastToken() does not include the possible trailing comma.</p>
</div></div><div><pre><code>container_field</code></pre><div class="fieldDocs"><p><code>a: lhs align(c) = d,</code>. <code>container_field_list[rhs]</code>.
main_token is the field name identifier.
lastToken() does not include the possible trailing comma.</p>
</div></div><div><pre><code>@&quot;comptime&quot;</code></pre><div class="fieldDocs"><p><code>comptime lhs</code>. rhs unused.</p>
</div></div><div><pre><code>@&quot;nosuspend&quot;</code></pre><div class="fieldDocs"><p><code>nosuspend lhs</code>. rhs unused.</p>
</div></div><div><pre><code>block_two</code></pre><div class="fieldDocs"><p><code>{lhs rhs}</code>. rhs or lhs can be omitted.
main_token points at the lbrace.</p>
</div></div><div><pre><code>block_two_semicolon</code></pre><div class="fieldDocs"><p>Same as block_two but there is known to be a semicolon before the rbrace.</p>
</div></div><div><pre><code>block</code></pre><div class="fieldDocs"><p><code>{}</code>. <code>sub_list[lhs..rhs]</code>.
main_token points at the lbrace.</p>
</div></div><div><pre><code>block_semicolon</code></pre><div class="fieldDocs"><p>Same as block but there is known to be a semicolon before the rbrace.</p>
</div></div><div><pre><code>asm_simple</code></pre><div class="fieldDocs"><p><code>asm(lhs)</code>. rhs is the token index of the rparen.</p>
</div></div><div><pre><code>@&quot;asm&quot;</code></pre><div class="fieldDocs"><p><code>asm(lhs, a)</code>. <code>Asm[rhs]</code>.</p>
</div></div><div><pre><code>asm_output</code></pre><div class="fieldDocs"><p><code>[a] &quot;b&quot; (c)</code>. lhs is 0, rhs is token index of the rparen.
<code>[a] &quot;b&quot; (-&gt; lhs)</code>. rhs is token index of the rparen.
main_token is <code>a</code>.</p>
</div></div><div><pre><code>asm_input</code></pre><div class="fieldDocs"><p><code>[a] &quot;b&quot; (lhs)</code>. rhs is token index of the rparen.
main_token is <code>a</code>.</p>
</div></div><div><pre><code>error_value</code></pre><div class="fieldDocs"><p><code>error.a</code>. lhs is token index of <code>.</code>. rhs is token index of <code>a</code>.</p>
</div></div><div><pre><code>error_union</code></pre><div class="fieldDocs"><p><code>lhs!rhs</code>. main_token is the <code>!</code>.</p>
</div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.zig.Ast.Node.Tag.isContainerField" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isContainerField</span><a href="#src.zig-std.zig.Ast.Node.Tag.isContainerField">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isContainerField</span>(tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.Ast.Node.Tag.isContainerField">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isContainerField</span>(tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {
        .container_field_init,
        .container_field_align,
        .container_field,
        =&gt; <span class="tok-null">true</span>,

        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.Ast.Node.Tag">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// sub_list[lhs...rhs]</span>
    root,
    <span class="tok-comment">/// `usingnamespace lhs;`. rhs unused. main_token is `usingnamespace`.</span>
    @&quot;usingnamespace&quot;,
    <span class="tok-comment">/// lhs is test name token (must be string literal or identifier), if any.</span>
    <span class="tok-comment">/// rhs is the body node.</span>
    test_decl,
    <span class="tok-comment">/// lhs is the index into extra_data.</span>
    <span class="tok-comment">/// rhs is the initialization expression, if any.</span>
    <span class="tok-comment">/// main_token is `var` or `const`.</span>
    global_var_decl,
    <span class="tok-comment">/// `var a: x align(y) = rhs`</span>
    <span class="tok-comment">/// lhs is the index into extra_data.</span>
    <span class="tok-comment">/// main_token is `var` or `const`.</span>
    local_var_decl,
    <span class="tok-comment">/// `var a: lhs = rhs`. lhs and rhs may be unused.</span>
    <span class="tok-comment">/// Can be local or global.</span>
    <span class="tok-comment">/// main_token is `var` or `const`.</span>
    simple_var_decl,
    <span class="tok-comment">/// `var a align(lhs) = rhs`. lhs and rhs may be unused.</span>
    <span class="tok-comment">/// Can be local or global.</span>
    <span class="tok-comment">/// main_token is `var` or `const`.</span>
    aligned_var_decl,
    <span class="tok-comment">/// lhs is the identifier token payload if any,</span>
    <span class="tok-comment">/// rhs is the deferred expression.</span>
    @&quot;errdefer&quot;,
    <span class="tok-comment">/// lhs is unused.</span>
    <span class="tok-comment">/// rhs is the deferred expression.</span>
    @&quot;defer&quot;,
    <span class="tok-comment">/// lhs catch rhs</span>
    <span class="tok-comment">/// lhs catch |err| rhs</span>
    <span class="tok-comment">/// main_token is the `catch` keyword.</span>
    <span class="tok-comment">/// payload is determined by looking at the next token after the `catch` keyword.</span>
    @&quot;catch&quot;,
    <span class="tok-comment">/// `lhs.a`. main_token is the dot. rhs is the identifier token index.</span>
    field_access,
    <span class="tok-comment">/// `lhs.?`. main_token is the dot. rhs is the `?` token index.</span>
    unwrap_optional,
    <span class="tok-comment">/// `lhs == rhs`. main_token is op.</span>
    equal_equal,
    <span class="tok-comment">/// `lhs != rhs`. main_token is op.</span>
    bang_equal,
    <span class="tok-comment">/// `lhs &lt; rhs`. main_token is op.</span>
    less_than,
    <span class="tok-comment">/// `lhs &gt; rhs`. main_token is op.</span>
    greater_than,
    <span class="tok-comment">/// `lhs &lt;= rhs`. main_token is op.</span>
    less_or_equal,
    <span class="tok-comment">/// `lhs &gt;= rhs`. main_token is op.</span>
    greater_or_equal,
    <span class="tok-comment">/// `lhs *= rhs`. main_token is op.</span>
    assign_mul,
    <span class="tok-comment">/// `lhs /= rhs`. main_token is op.</span>
    assign_div,
    <span class="tok-comment">/// `lhs %= rhs`. main_token is op.</span>
    assign_mod,
    <span class="tok-comment">/// `lhs += rhs`. main_token is op.</span>
    assign_add,
    <span class="tok-comment">/// `lhs -= rhs`. main_token is op.</span>
    assign_sub,
    <span class="tok-comment">/// `lhs &lt;&lt;= rhs`. main_token is op.</span>
    assign_shl,
    <span class="tok-comment">/// `lhs &lt;&lt;|= rhs`. main_token is op.</span>
    assign_shl_sat,
    <span class="tok-comment">/// `lhs &gt;&gt;= rhs`. main_token is op.</span>
    assign_shr,
    <span class="tok-comment">/// `lhs &amp;= rhs`. main_token is op.</span>
    assign_bit_and,
    <span class="tok-comment">/// `lhs ^= rhs`. main_token is op.</span>
    assign_bit_xor,
    <span class="tok-comment">/// `lhs |= rhs`. main_token is op.</span>
    assign_bit_or,
    <span class="tok-comment">/// `lhs *%= rhs`. main_token is op.</span>
    assign_mul_wrap,
    <span class="tok-comment">/// `lhs +%= rhs`. main_token is op.</span>
    assign_add_wrap,
    <span class="tok-comment">/// `lhs -%= rhs`. main_token is op.</span>
    assign_sub_wrap,
    <span class="tok-comment">/// `lhs *|= rhs`. main_token is op.</span>
    assign_mul_sat,
    <span class="tok-comment">/// `lhs +|= rhs`. main_token is op.</span>
    assign_add_sat,
    <span class="tok-comment">/// `lhs -|= rhs`. main_token is op.</span>
    assign_sub_sat,
    <span class="tok-comment">/// `lhs = rhs`. main_token is op.</span>
    assign,
    <span class="tok-comment">/// `a, b, ... = rhs`. main_token is op. lhs is index into `extra_data`</span>
    <span class="tok-comment">/// of an lhs elem count followed by an array of that many `Node.Index`,</span>
    <span class="tok-comment">/// with each node having one of the following types:</span>
    <span class="tok-comment">/// * `global_var_decl`</span>
    <span class="tok-comment">/// * `local_var_decl`</span>
    <span class="tok-comment">/// * `simple_var_decl`</span>
    <span class="tok-comment">/// * `aligned_var_decl`</span>
    <span class="tok-comment">/// * Any expression node</span>
    <span class="tok-comment">/// The first 3 types correspond to a `var` or `const` lhs node (note</span>
    <span class="tok-comment">/// that their `rhs` is always 0). An expression node corresponds to a</span>
    <span class="tok-comment">/// standard assignment LHS (which must be evaluated as an lvalue).</span>
    <span class="tok-comment">/// There may be a preceding `comptime` token, which does not create a</span>
    <span class="tok-comment">/// corresponding `comptime` node so must be manually detected.</span>
    assign_destructure,
    <span class="tok-comment">/// `lhs || rhs`. main_token is the `||`.</span>
    merge_error_sets,
    <span class="tok-comment">/// `lhs * rhs`. main_token is the `*`.</span>
    mul,
    <span class="tok-comment">/// `lhs / rhs`. main_token is the `/`.</span>
    div,
    <span class="tok-comment">/// `lhs % rhs`. main_token is the `%`.</span>
    mod,
    <span class="tok-comment">/// `lhs ** rhs`. main_token is the `**`.</span>
    array_mult,
    <span class="tok-comment">/// `lhs *% rhs`. main_token is the `*%`.</span>
    mul_wrap,
    <span class="tok-comment">/// `lhs *| rhs`. main_token is the `*|`.</span>
    mul_sat,
    <span class="tok-comment">/// `lhs + rhs`. main_token is the `+`.</span>
    add,
    <span class="tok-comment">/// `lhs - rhs`. main_token is the `-`.</span>
    sub,
    <span class="tok-comment">/// `lhs ++ rhs`. main_token is the `++`.</span>
    array_cat,
    <span class="tok-comment">/// `lhs +% rhs`. main_token is the `+%`.</span>
    add_wrap,
    <span class="tok-comment">/// `lhs -% rhs`. main_token is the `-%`.</span>
    sub_wrap,
    <span class="tok-comment">/// `lhs +| rhs`. main_token is the `+|`.</span>
    add_sat,
    <span class="tok-comment">/// `lhs -| rhs`. main_token is the `-|`.</span>
    sub_sat,
    <span class="tok-comment">/// `lhs &lt;&lt; rhs`. main_token is the `&lt;&lt;`.</span>
    shl,
    <span class="tok-comment">/// `lhs &lt;&lt;| rhs`. main_token is the `&lt;&lt;|`.</span>
    shl_sat,
    <span class="tok-comment">/// `lhs &gt;&gt; rhs`. main_token is the `&gt;&gt;`.</span>
    shr,
    <span class="tok-comment">/// `lhs &amp; rhs`. main_token is the `&amp;`.</span>
    bit_and,
    <span class="tok-comment">/// `lhs ^ rhs`. main_token is the `^`.</span>
    bit_xor,
    <span class="tok-comment">/// `lhs | rhs`. main_token is the `|`.</span>
    bit_or,
    <span class="tok-comment">/// `lhs orelse rhs`. main_token is the `orelse`.</span>
    @&quot;orelse&quot;,
    <span class="tok-comment">/// `lhs and rhs`. main_token is the `and`.</span>
    bool_and,
    <span class="tok-comment">/// `lhs or rhs`. main_token is the `or`.</span>
    bool_or,
    <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
    bool_not,
    <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
    negation,
    <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
    bit_not,
    <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
    negation_wrap,
    <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
    address_of,
    <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
    @&quot;try&quot;,
    <span class="tok-comment">/// `op lhs`. rhs unused. main_token is op.</span>
    @&quot;await&quot;,
    <span class="tok-comment">/// `?lhs`. rhs unused. main_token is the `?`.</span>
    optional_type,
    <span class="tok-comment">/// `[lhs]rhs`.</span>
    array_type,
    <span class="tok-comment">/// `[lhs:a]b`. `ArrayTypeSentinel[rhs]`.</span>
    array_type_sentinel,
    <span class="tok-comment">/// `[*]align(lhs) rhs`. lhs can be omitted.</span>
    <span class="tok-comment">/// `*align(lhs) rhs`. lhs can be omitted.</span>
    <span class="tok-comment">/// `[]rhs`.</span>
    <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
    <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
    <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
    <span class="tok-comment">/// pointer type and may require special handling.</span>
    ptr_type_aligned,
    <span class="tok-comment">/// `[*:lhs]rhs`. lhs can be omitted.</span>
    <span class="tok-comment">/// `*rhs`.</span>
    <span class="tok-comment">/// `[:lhs]rhs`.</span>
    <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
    <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
    <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
    <span class="tok-comment">/// pointer type and may require special handling.</span>
    ptr_type_sentinel,
    <span class="tok-comment">/// lhs is index into ptr_type. rhs is the element type expression.</span>
    <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
    <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
    <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
    <span class="tok-comment">/// pointer type and may require special handling.</span>
    ptr_type,
    <span class="tok-comment">/// lhs is index into ptr_type_bit_range. rhs is the element type expression.</span>
    <span class="tok-comment">/// main_token is the asterisk if a single item pointer or the lbracket</span>
    <span class="tok-comment">/// if a slice, many-item pointer, or C-pointer</span>
    <span class="tok-comment">/// main_token might be a ** token, which is shared with a parent/child</span>
    <span class="tok-comment">/// pointer type and may require special handling.</span>
    ptr_type_bit_range,
    <span class="tok-comment">/// `lhs[rhs..]`</span>
    <span class="tok-comment">/// main_token is the lbracket.</span>
    slice_open,
    <span class="tok-comment">/// `lhs[b..c]`. rhs is index into Slice</span>
    <span class="tok-comment">/// main_token is the lbracket.</span>
    <a href="std.zig.Ast.html#std.zig.Ast.slice">slice</a>,
    <span class="tok-comment">/// `lhs[b..c :d]`. rhs is index into SliceSentinel. Slice end &quot;c&quot; can be omitted.</span>
    <span class="tok-comment">/// main_token is the lbracket.</span>
    slice_sentinel,
    <span class="tok-comment">/// `lhs.*`. rhs is unused.</span>
    deref,
    <span class="tok-comment">/// `lhs[rhs]`.</span>
    array_access,
    <span class="tok-comment">/// `lhs{rhs}`. rhs can be omitted.</span>
    array_init_one,
    <span class="tok-comment">/// `lhs{rhs,}`. rhs can *not* be omitted</span>
    array_init_one_comma,
    <span class="tok-comment">/// `.{lhs, rhs}`. lhs and rhs can be omitted.</span>
    array_init_dot_two,
    <span class="tok-comment">/// Same as `array_init_dot_two` except there is known to be a trailing comma</span>
    <span class="tok-comment">/// before the final rbrace.</span>
    array_init_dot_two_comma,
    <span class="tok-comment">/// `.{a, b}`. `sub_list[lhs..rhs]`.</span>
    array_init_dot,
    <span class="tok-comment">/// Same as `array_init_dot` except there is known to be a trailing comma</span>
    <span class="tok-comment">/// before the final rbrace.</span>
    array_init_dot_comma,
    <span class="tok-comment">/// `lhs{a, b}`. `sub_range_list[rhs]`. lhs can be omitted which means `.{a, b}`.</span>
    array_init,
    <span class="tok-comment">/// Same as `array_init` except there is known to be a trailing comma</span>
    <span class="tok-comment">/// before the final rbrace.</span>
    array_init_comma,
    <span class="tok-comment">/// `lhs{.a = rhs}`. rhs can be omitted making it empty.</span>
    <span class="tok-comment">/// main_token is the lbrace.</span>
    struct_init_one,
    <span class="tok-comment">/// `lhs{.a = rhs,}`. rhs can *not* be omitted.</span>
    <span class="tok-comment">/// main_token is the lbrace.</span>
    struct_init_one_comma,
    <span class="tok-comment">/// `.{.a = lhs, .b = rhs}`. lhs and rhs can be omitted.</span>
    <span class="tok-comment">/// main_token is the lbrace.</span>
    <span class="tok-comment">/// No trailing comma before the rbrace.</span>
    struct_init_dot_two,
    <span class="tok-comment">/// Same as `struct_init_dot_two` except there is known to be a trailing comma</span>
    <span class="tok-comment">/// before the final rbrace.</span>
    struct_init_dot_two_comma,
    <span class="tok-comment">/// `.{.a = b, .c = d}`. `sub_list[lhs..rhs]`.</span>
    <span class="tok-comment">/// main_token is the lbrace.</span>
    struct_init_dot,
    <span class="tok-comment">/// Same as `struct_init_dot` except there is known to be a trailing comma</span>
    <span class="tok-comment">/// before the final rbrace.</span>
    struct_init_dot_comma,
    <span class="tok-comment">/// `lhs{.a = b, .c = d}`. `sub_range_list[rhs]`.</span>
    <span class="tok-comment">/// lhs can be omitted which means `.{.a = b, .c = d}`.</span>
    <span class="tok-comment">/// main_token is the lbrace.</span>
    struct_init,
    <span class="tok-comment">/// Same as `struct_init` except there is known to be a trailing comma</span>
    <span class="tok-comment">/// before the final rbrace.</span>
    struct_init_comma,
    <span class="tok-comment">/// `lhs(rhs)`. rhs can be omitted.</span>
    <span class="tok-comment">/// main_token is the lparen.</span>
    call_one,
    <span class="tok-comment">/// `lhs(rhs,)`. rhs can be omitted.</span>
    <span class="tok-comment">/// main_token is the lparen.</span>
    call_one_comma,
    <span class="tok-comment">/// `async lhs(rhs)`. rhs can be omitted.</span>
    async_call_one,
    <span class="tok-comment">/// `async lhs(rhs,)`.</span>
    async_call_one_comma,
    <span class="tok-comment">/// `lhs(a, b, c)`. `SubRange[rhs]`.</span>
    <span class="tok-comment">/// main_token is the `(`.</span>
    call,
    <span class="tok-comment">/// `lhs(a, b, c,)`. `SubRange[rhs]`.</span>
    <span class="tok-comment">/// main_token is the `(`.</span>
    call_comma,
    <span class="tok-comment">/// `async lhs(a, b, c)`. `SubRange[rhs]`.</span>
    <span class="tok-comment">/// main_token is the `(`.</span>
    async_call,
    <span class="tok-comment">/// `async lhs(a, b, c,)`. `SubRange[rhs]`.</span>
    <span class="tok-comment">/// main_token is the `(`.</span>
    async_call_comma,
    <span class="tok-comment">/// `switch(lhs) {}`. `SubRange[rhs]`.</span>
    <span class="tok-comment">/// `main_token` is the identifier of a preceding label, if any; otherwise `switch`.</span>
    @&quot;switch&quot;,
    <span class="tok-comment">/// Same as switch except there is known to be a trailing comma</span>
    <span class="tok-comment">/// before the final rbrace</span>
    switch_comma,
    <span class="tok-comment">/// `lhs =&gt; rhs`. If lhs is omitted it means `else`.</span>
    <span class="tok-comment">/// main_token is the `=&gt;`</span>
    switch_case_one,
    <span class="tok-comment">/// Same ast `switch_case_one` but the case is inline</span>
    switch_case_inline_one,
    <span class="tok-comment">/// `a, b, c =&gt; rhs`. `SubRange[lhs]`.</span>
    <span class="tok-comment">/// main_token is the `=&gt;`</span>
    switch_case,
    <span class="tok-comment">/// Same ast `switch_case` but the case is inline</span>
    switch_case_inline,
    <span class="tok-comment">/// `lhs...rhs`.</span>
    switch_range,
    <span class="tok-comment">/// `while (lhs) rhs`.</span>
    <span class="tok-comment">/// `while (lhs) |x| rhs`.</span>
    while_simple,
    <span class="tok-comment">/// `while (lhs) : (a) b`. `WhileCont[rhs]`.</span>
    <span class="tok-comment">/// `while (lhs) : (a) b`. `WhileCont[rhs]`.</span>
    while_cont,
    <span class="tok-comment">/// `while (lhs) : (a) b else c`. `While[rhs]`.</span>
    <span class="tok-comment">/// `while (lhs) |x| : (a) b else c`. `While[rhs]`.</span>
    <span class="tok-comment">/// `while (lhs) |x| : (a) b else |y| c`. `While[rhs]`.</span>
    <span class="tok-comment">/// The cont expression part `: (a)` may be omitted.</span>
    @&quot;while&quot;,
    <span class="tok-comment">/// `for (lhs) rhs`.</span>
    for_simple,
    <span class="tok-comment">/// `for (lhs[0..inputs]) lhs[inputs + 1] else lhs[inputs + 2]`. `For[rhs]`.</span>
    @&quot;for&quot;,
    <span class="tok-comment">/// `lhs..rhs`. rhs can be omitted.</span>
    for_range,
    <span class="tok-comment">/// `if (lhs) rhs`.</span>
    <span class="tok-comment">/// `if (lhs) |a| rhs`.</span>
    if_simple,
    <span class="tok-comment">/// `if (lhs) a else b`. `If[rhs]`.</span>
    <span class="tok-comment">/// `if (lhs) |x| a else b`. `If[rhs]`.</span>
    <span class="tok-comment">/// `if (lhs) |x| a else |y| b`. `If[rhs]`.</span>
    @&quot;if&quot;,
    <span class="tok-comment">/// `suspend lhs`. lhs can be omitted. rhs is unused.</span>
    @&quot;suspend&quot;,
    <span class="tok-comment">/// `resume lhs`. rhs is unused.</span>
    @&quot;resume&quot;,
    <span class="tok-comment">/// `continue :lhs rhs`</span>
    <span class="tok-comment">/// both lhs and rhs may be omitted.</span>
    @&quot;continue&quot;,
    <span class="tok-comment">/// `break :lhs rhs`</span>
    <span class="tok-comment">/// both lhs and rhs may be omitted.</span>
    @&quot;break&quot;,
    <span class="tok-comment">/// `return lhs`. lhs can be omitted. rhs is unused.</span>
    @&quot;return&quot;,
    <span class="tok-comment">/// `fn (a: lhs) rhs`. lhs can be omitted.</span>
    <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
    <span class="tok-comment">/// main_token is the `fn` keyword.</span>
    <span class="tok-comment">/// extern function declarations use this tag.</span>
    fn_proto_simple,
    <span class="tok-comment">/// `fn (a: b, c: d) rhs`. `sub_range_list[lhs]`.</span>
    <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
    <span class="tok-comment">/// main_token is the `fn` keyword.</span>
    <span class="tok-comment">/// extern function declarations use this tag.</span>
    fn_proto_multi,
    <span class="tok-comment">/// `fn (a: b) addrspace(e) linksection(f) callconv(g) rhs`. `FnProtoOne[lhs]`.</span>
    <span class="tok-comment">/// zero or one parameters.</span>
    <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
    <span class="tok-comment">/// main_token is the `fn` keyword.</span>
    <span class="tok-comment">/// extern function declarations use this tag.</span>
    fn_proto_one,
    <span class="tok-comment">/// `fn (a: b, c: d) addrspace(e) linksection(f) callconv(g) rhs`. `FnProto[lhs]`.</span>
    <span class="tok-comment">/// anytype and ... parameters are omitted from the AST tree.</span>
    <span class="tok-comment">/// main_token is the `fn` keyword.</span>
    <span class="tok-comment">/// extern function declarations use this tag.</span>
    fn_proto,
    <span class="tok-comment">/// lhs is the fn_proto.</span>
    <span class="tok-comment">/// rhs is the function body block.</span>
    <span class="tok-comment">/// Note that extern function declarations use the fn_proto tags rather</span>
    <span class="tok-comment">/// than this one.</span>
    fn_decl,
    <span class="tok-comment">/// `anyframe-&gt;rhs`. main_token is `anyframe`. `lhs` is arrow token index.</span>
    anyframe_type,
    <span class="tok-comment">/// Both lhs and rhs unused.</span>
    anyframe_literal,
    <span class="tok-comment">/// Both lhs and rhs unused.</span>
    char_literal,
    <span class="tok-comment">/// Both lhs and rhs unused.</span>
    number_literal,
    <span class="tok-comment">/// Both lhs and rhs unused.</span>
    unreachable_literal,
    <span class="tok-comment">/// Both lhs and rhs unused.</span>
    <span class="tok-comment">/// Most identifiers will not have explicit AST nodes, however for expressions</span>
    <span class="tok-comment">/// which could be one of many different kinds of AST nodes, there will be an</span>
    <span class="tok-comment">/// identifier AST node for it.</span>
    identifier,
    <span class="tok-comment">/// lhs is the dot token index, rhs unused, main_token is the identifier.</span>
    enum_literal,
    <span class="tok-comment">/// main_token is the string literal token</span>
    <span class="tok-comment">/// Both lhs and rhs unused.</span>
    string_literal,
    <span class="tok-comment">/// main_token is the first token index (redundant with lhs)</span>
    <span class="tok-comment">/// lhs is the first token index; rhs is the last token index.</span>
    <span class="tok-comment">/// Could be a series of multiline_string_literal_line tokens, or a single</span>
    <span class="tok-comment">/// string_literal token.</span>
    multiline_string_literal,
    <span class="tok-comment">/// `(lhs)`. main_token is the `(`; rhs is the token index of the `)`.</span>
    grouped_expression,
    <span class="tok-comment">/// `@a(lhs, rhs)`. lhs and rhs may be omitted.</span>
    <span class="tok-comment">/// main_token is the builtin token.</span>
    builtin_call_two,
    <span class="tok-comment">/// Same as builtin_call_two but there is known to be a trailing comma before the rparen.</span>
    builtin_call_two_comma,
    <span class="tok-comment">/// `@a(b, c)`. `sub_list[lhs..rhs]`.</span>
    <span class="tok-comment">/// main_token is the builtin token.</span>
    builtin_call,
    <span class="tok-comment">/// Same as builtin_call but there is known to be a trailing comma before the rparen.</span>
    builtin_call_comma,
    <span class="tok-comment">/// `error{a, b}`.</span>
    <span class="tok-comment">/// rhs is the rbrace, lhs is unused.</span>
    error_set_decl,
    <span class="tok-comment">/// `struct {}`, `union {}`, `opaque {}`, `enum {}`. `extra_data[lhs..rhs]`.</span>
    <span class="tok-comment">/// main_token is `struct`, `union`, `opaque`, `enum` keyword.</span>
    container_decl,
    <span class="tok-comment">/// Same as ContainerDecl but there is known to be a trailing comma</span>
    <span class="tok-comment">/// or semicolon before the rbrace.</span>
    container_decl_trailing,
    <span class="tok-comment">/// `struct {lhs, rhs}`, `union {lhs, rhs}`, `opaque {lhs, rhs}`, `enum {lhs, rhs}`.</span>
    <span class="tok-comment">/// lhs or rhs can be omitted.</span>
    <span class="tok-comment">/// main_token is `struct`, `union`, `opaque`, `enum` keyword.</span>
    container_decl_two,
    <span class="tok-comment">/// Same as ContainerDeclTwo except there is known to be a trailing comma</span>
    <span class="tok-comment">/// or semicolon before the rbrace.</span>
    container_decl_two_trailing,
    <span class="tok-comment">/// `struct(lhs)` / `union(lhs)` / `enum(lhs)`. `SubRange[rhs]`.</span>
    container_decl_arg,
    <span class="tok-comment">/// Same as container_decl_arg but there is known to be a trailing</span>
    <span class="tok-comment">/// comma or semicolon before the rbrace.</span>
    container_decl_arg_trailing,
    <span class="tok-comment">/// `union(enum) {}`. `sub_list[lhs..rhs]`.</span>
    <span class="tok-comment">/// Note that tagged unions with explicitly provided enums are represented</span>
    <span class="tok-comment">/// by `container_decl_arg`.</span>
    tagged_union,
    <span class="tok-comment">/// Same as tagged_union but there is known to be a trailing comma</span>
    <span class="tok-comment">/// or semicolon before the rbrace.</span>
    tagged_union_trailing,
    <span class="tok-comment">/// `union(enum) {lhs, rhs}`. lhs or rhs may be omitted.</span>
    <span class="tok-comment">/// Note that tagged unions with explicitly provided enums are represented</span>
    <span class="tok-comment">/// by `container_decl_arg`.</span>
    tagged_union_two,
    <span class="tok-comment">/// Same as tagged_union_two but there is known to be a trailing comma</span>
    <span class="tok-comment">/// or semicolon before the rbrace.</span>
    tagged_union_two_trailing,
    <span class="tok-comment">/// `union(enum(lhs)) {}`. `SubRange[rhs]`.</span>
    tagged_union_enum_tag,
    <span class="tok-comment">/// Same as tagged_union_enum_tag but there is known to be a trailing comma</span>
    <span class="tok-comment">/// or semicolon before the rbrace.</span>
    tagged_union_enum_tag_trailing,
    <span class="tok-comment">/// `a: lhs = rhs,`. lhs and rhs can be omitted.</span>
    <span class="tok-comment">/// main_token is the field name identifier.</span>
    <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
    container_field_init,
    <span class="tok-comment">/// `a: lhs align(rhs),`. rhs can be omitted.</span>
    <span class="tok-comment">/// main_token is the field name identifier.</span>
    <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
    container_field_align,
    <span class="tok-comment">/// `a: lhs align(c) = d,`. `container_field_list[rhs]`.</span>
    <span class="tok-comment">/// main_token is the field name identifier.</span>
    <span class="tok-comment">/// lastToken() does not include the possible trailing comma.</span>
    container_field,
    <span class="tok-comment">/// `comptime lhs`. rhs unused.</span>
    @&quot;comptime&quot;,
    <span class="tok-comment">/// `nosuspend lhs`. rhs unused.</span>
    @&quot;nosuspend&quot;,
    <span class="tok-comment">/// `{lhs rhs}`. rhs or lhs can be omitted.</span>
    <span class="tok-comment">/// main_token points at the lbrace.</span>
    block_two,
    <span class="tok-comment">/// Same as block_two but there is known to be a semicolon before the rbrace.</span>
    block_two_semicolon,
    <span class="tok-comment">/// `{}`. `sub_list[lhs..rhs]`.</span>
    <span class="tok-comment">/// main_token points at the lbrace.</span>
    block,
    <span class="tok-comment">/// Same as block but there is known to be a semicolon before the rbrace.</span>
    block_semicolon,
    <span class="tok-comment">/// `asm(lhs)`. rhs is the token index of the rparen.</span>
    asm_simple,
    <span class="tok-comment">/// `asm(lhs, a)`. `Asm[rhs]`.</span>
    @&quot;asm&quot;,
    <span class="tok-comment">/// `[a] &quot;b&quot; (c)`. lhs is 0, rhs is token index of the rparen.</span>
    <span class="tok-comment">/// `[a] &quot;b&quot; (-&gt; lhs)`. rhs is token index of the rparen.</span>
    <span class="tok-comment">/// main_token is `a`.</span>
    asm_output,
    <span class="tok-comment">/// `[a] &quot;b&quot; (lhs)`. rhs is token index of the rparen.</span>
    <span class="tok-comment">/// main_token is `a`.</span>
    asm_input,
    <span class="tok-comment">/// `error.a`. lhs is token index of `.`. rhs is token index of `a`.</span>
    error_value,
    <span class="tok-comment">/// `lhs!rhs`. main_token is the `!`.</span>
    error_union,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isContainerField</span>(tag: <a href="std.zig.Ast.Node.Tag.html">Tag</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {
            .container_field_init,
            .container_field_align,
            .container_field,
            =&gt; <span class="tok-null">true</span>,

            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        };
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
