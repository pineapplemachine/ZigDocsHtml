<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">fs</a></li><li><a href="std.fs.File.html" class="active">File</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.fs.File" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.fs.File</span><a href="#src.zig-std.fs.File">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.fs.File.Kind.html">std.fs.File.Kind</a></li><li><a href="std.fs.File.OpenMode.html">std.fs.File.OpenMode</a></li><li><a href="std.fs.File.Lock.html">std.fs.File.Lock</a></li><li><a href="std.fs.File.OpenFlags.html">std.fs.File.OpenFlags</a></li><li><a href="std.fs.File.CreateFlags.html">std.fs.File.CreateFlags</a></li><li><a href="std.fs.File.Stat.html">std.fs.File.Stat</a></li><li><a href="std.fs.File.Permissions.html">std.fs.File.Permissions</a></li><li><a href="std.fs.File.PermissionsWindows.html">std.fs.File.PermissionsWindows</a></li><li><a href="std.fs.File.PermissionsUnix.html">std.fs.File.PermissionsUnix</a></li><li><a href="std.fs.File.Metadata.html">std.fs.File.Metadata</a></li><li><a href="std.fs.File.MetadataUnix.html">std.fs.File.MetadataUnix</a></li><li><a href="std.fs.File.MetadataLinux.html">std.fs.File.MetadataLinux</a></li><li><a href="std.fs.File.MetadataWasi.html">std.fs.File.MetadataWasi</a></li><li><a href="std.fs.File.MetadataWindows.html">std.fs.File.MetadataWindows</a></li><li><a href="std.fs.File.WriteFileOptions.html">std.fs.File.WriteFileOptions</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.fs.File.Reader" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Reader</span><a href="#src.zig-std.fs.File.Reader">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.Reader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(<a href="std.fs.File.html">File</a>, <a href="std.posix.html#std.posix.ReadError">ReadError</a>, <a href="std.fs.File.html#std.fs.File.read">read</a>)</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.Writer" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Writer</span><a href="#src.zig-std.fs.File.Writer">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.Writer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(<a href="std.fs.File.html">File</a>, <a href="std.posix.html#std.posix.WriteError">WriteError</a>, <a href="std.fs.File.html#std.fs.File.write">write</a>)</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.SeekableStream" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">SeekableStream</span><a href="#src.zig-std.fs.File.SeekableStream">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.SeekableStream">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SeekableStream = <a href="std.io.html">io</a>.<a href="std.io.seekable_stream.html#std.io.seekable_stream.SeekableStream">SeekableStream</a>(
    <a href="std.fs.File.html">File</a>,
    <a href="std.posix.html#std.posix.SeekError">SeekError</a>,
    <a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a>,
    <a href="std.fs.File.html#std.fs.File.seekTo">seekTo</a>,
    <a href="std.fs.File.html#std.fs.File.seekBy">seekBy</a>,
    <a href="std.fs.File.html#std.fs.File.getPos">getPos</a>,
    <a href="std.fs.File.html#std.fs.File.getEndPos">getEndPos</a>,
)</code></pre></details></div></div></div></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>handle: <a href="std.posix.html#std.posix.fd_t">Handle</a></code></pre><div class="fieldDocs"><p>The OS-specific file descriptor or file handle.</p>
</div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.posix.fd_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">fd_t</span><a href="#src.zig-std.posix.fd_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.fd_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> fd_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.fd_t">fd_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.mode_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">mode_t</span><a href="#src.zig-std.posix.mode_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.mode_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> mode_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">mode_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ino_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">ino_t</span><a href="#src.zig-std.posix.ino_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ino_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ino_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="#">ino_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.uid_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">uid_t</span><a href="#src.zig-std.posix.uid_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.uid_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> uid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.uid_t">uid_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.gid_t" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">gid_t</span><a href="#src.zig-std.posix.gid_t">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.gid_t">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> gid_t = <a href="std.posix.html#std.posix.system">system</a>.<a href="std.posix.html#std.posix.system.gid_t">gid_t</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.default_mode" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">default_mode</span><a href="#src.zig-std.fs.File.default_mode">[src]</a></h2><div class="tldDocs"><p>This is the default mode given to POSIX operating systems for creating
files. <code>0o666</code> is &quot;-rw-rw-rw-&quot; which is counter-intuitive at first,
since most people would expect &quot;-rw-r--r--&quot;, for example, when using
the <code>touch</code> command, which would correspond to <code>0o644</code>. However, POSIX
libc implementations use <code>0o666</code> inside <code>fopen</code> and then rely on the
process-scoped &quot;umask&quot; setting to adjust this number for file creation.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.default_mode">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_mode = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
    .windows =&gt; <span class="tok-number">0</span>,
    .wasi =&gt; <span class="tok-number">0</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-number">0o666</span>,
}</code></pre></details></div></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.fs.File.OpenError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">OpenError</span><a href="#src.zig-std.fs.File.OpenError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to open a new resource relative to it.</p>
</dd></div><div><dt>AntivirusInterference</dt><dd><p>On Windows, antivirus software is enabled by default. It can be
disabled, but Windows Update sometimes ignores the user's preference
and re-enables it. When enabled, antivirus software on Windows
intercepts file system operations and makes them significantly slower
in addition to possibly failing with this error code.</p>
</dd></div><div><dt>BadPathName</dt><dd><p>On Windows, file paths cannot contain these characters:
'/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</p>
</dd></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>FileBusy <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>One of these three things:</p>
<ul>
<li>pathname  refers to an executable image which is currently being
executed and write access was requested.</li>
<li>pathname refers to a file that is currently in  use  as  a  swap
file, and the O_TRUNC flag was specified.</li>
<li>pathname  refers  to  a file that is currently being read by the
kernel (e.g., for module/firmware loading), and write access was
requested.</li>
</ul>
</dd></div><div><dt>FileLocksNotSupported <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The underlying filesystem does not support file locks</p>
</dd></div><div><dt>FileNotFound <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Either:</p>
<ul>
<li>One of the path components does not exist.</li>
<li>Cwd was used, but cwd has been deleted.</li>
<li>The path associated with the open directory handle has been deleted.</li>
<li>On macOS, multiple processes or threads raced to create the same file
with <code>O.EXCL</code> set to <code>false</code>.</li>
</ul>
</dd></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The file is too large to be opened. This error is unreachable
for 64-bit targets, as well as when opening directories.</p>
</dd></div><div><dt>InvalidUtf8</dt><dd><p>WASI-only; file paths must be valid UTF-8.</p>
</dd></div><div><dt>InvalidWtf8</dt><dd><p>Windows-only; file paths provided by the user must be valid WTF-8.
<a href="https://simonsapin.github.io/wtf-8/">https://simonsapin.github.io/wtf-8/</a></p>
</dd></div><div><dt>IsDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path refers to directory but the <code>DIRECTORY</code> flag was not provided.</p>
</dd></div><div><dt>NameTooLong <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path exceeded <code><a href="std.fs.html#std.fs.max_path_bytes">max_path_bytes</a></code> bytes.</p>
</dd></div><div><dt>NetworkNotFound</dt><dd><p>On Windows, <code>\\server</code> or <code>\\server\share</code> was not found.</p>
</dd></div><div><dt>NoDevice</dt></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A new path cannot be created because the device has no room for the new file.
This error is only reachable when the <code>CREAT</code> flag is provided.</p>
</dd></div><div><dt>NotDir <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>A component used as a directory in the path was not, in fact, a directory, or
<code>DIRECTORY</code> was specified and the path was not a directory.</p>
</dd></div><div><dt>PathAlreadyExists <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>The path already exists and the <code>CREAT</code> and <code>EXCL</code> flags were provided.</p>
</dd></div><div><dt>PipeBusy</dt></div><div><dt>ProcessFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SharingViolation</dt></div><div><dt>SymLinkLoop <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemFdQuotaExceeded <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt><dd><p>Insufficient kernel memory was available, or
the named file is a FIFO and per-user hard limit on
memory allocation for pipes has been reached.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.OpenError">OpenError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.OpenError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    SharingViolation,
    PathAlreadyExists,
    FileNotFound,
    AccessDenied,
    PipeBusy,
    NoDevice,
    NameTooLong,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span>
    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span>
    BadPathName,
    Unexpected,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.OpenError">OpenError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FlockError">FlockError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SyncError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SyncError</span><a href="#src.zig-std.posix.SyncError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>DiskQuota</dt></div><div><dt>InputOutput</dt></div><div><dt>NoSpaceLeft</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SyncError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SyncError = <span class="tok-kw">error</span>{
    InputOutput,
    NoSpaceLeft,
    DiskQuota,
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.TruncateError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">TruncateError</span><a href="#src.zig-std.posix.TruncateError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to call <code><a href="std.posix.html#std.posix.ftruncate">ftruncate</a></code> on it.</p>
</dd></div><div><dt>FileBusy</dt></div><div><dt>FileTooBig</dt></div><div><dt>InputOutput</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.TruncateError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TruncateError = <span class="tok-kw">error</span>{
    FileTooBig,
    InputOutput,
    FileBusy,

    <span class="tok-comment">/// In WASI, this error occurs when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to call `ftruncate` on it.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.SeekError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">SeekError</span><a href="#src.zig-std.posix.SeekError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to seek on it.</p>
</dd></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable</dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.SeekError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> SeekError = <span class="tok-kw">error</span>{
    Unseekable,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to seek on it.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.GetSeekPosError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">GetSeekPosError</span><a href="#src.zig-std.fs.File.GetSeekPosError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.SeekError">SeekError</a></dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to seek on it.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.FStatError">FStatError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable <a href="std.posix.html#std.posix.SeekError">SeekError</a></dt></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.GetSeekPosError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetSeekPosError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SeekError">SeekError</a> || <a href="std.posix.html#std.posix.FStatError">StatError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FStatError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FStatError</span><a href="#src.zig-std.posix.FStatError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to get its filestat information.</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FStatError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatError = <span class="tok-kw">error</span>{
    SystemResources,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to get its filestat information.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FStatError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FStatError</span><a href="#src.zig-std.posix.FStatError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to get its filestat information.</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FStatError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatError = <span class="tok-kw">error</span>{
    SystemResources,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to get its filestat information.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FChmodError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChmodError</span><a href="#src.zig-std.posix.FChmodError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChmodError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChmodError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FChownError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChownError</span><a href="#src.zig-std.posix.FChownError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChownError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChownError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FChmodError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FChmodError</span><a href="#src.zig-std.posix.FChmodError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt></div><div><dt>FileNotFound</dt></div><div><dt>InputOutput</dt></div><div><dt>ReadOnlyFileSystem</dt></div><div><dt>SymLinkLoop</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FChmodError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FChmodError = <span class="tok-kw">error</span>{
    AccessDenied,
    InputOutput,
    SymLinkLoop,
    FileNotFound,
    SystemResources,
    ReadOnlyFileSystem,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.FStatError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">FStatError</span><a href="#src.zig-std.posix.FStatError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error may occur when the file descriptor does
not hold the required rights to get its filestat information.</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.FStatError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FStatError = <span class="tok-kw">error</span>{
    SystemResources,

    <span class="tok-comment">/// In WASI, this error may occur when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to get its filestat information.</span>
    AccessDenied,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.UpdateTimesError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">UpdateTimesError</span><a href="#src.zig-std.fs.File.UpdateTimesError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.FutimensError">FutimensError</a></dt><dd><p>times is NULL, or both nsec values are UTIME_NOW, and either:</p>
<ul>
<li>the effective user ID of the caller does not match the  owner
of  the  file,  the  caller does not have write access to the
file, and the caller is not privileged (Linux: does not  have
either  the  CAP_FOWNER  or the CAP_DAC_OVERRIDE capability);
or,</li>
<li>the file is marked immutable (see chattr(1)).</li>
</ul>
</dd></div><div><dt>PermissionDenied <a href="std.posix.html#std.posix.FutimensError">FutimensError</a></dt><dd><p>The caller attempted to change one or both timestamps to a value
other than the current time, or to change one of the  timestamps
to the current time while leaving the other timestamp unchanged,
(i.e., times is not NULL, neither nsec  field  is  UTIME_NOW,
and neither nsec field is UTIME_OMIT) and either:</p>
<ul>
<li>the  caller's  effective  user ID does not match the owner of
file, and the caller is not privileged (Linux: does not  have
the CAP_FOWNER capability); or,</li>
<li>the file is marked append-only or immutable (see chattr(1)).</li>
</ul>
</dd></div><div><dt>ReadOnlyFileSystem <a href="std.posix.html#std.posix.FutimensError">FutimensError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.UpdateTimesError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> UpdateTimesError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FutimensError">FutimensError</a> || <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFileTimeError">SetFileTimeError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.ReadError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ReadError</span><a href="#src.zig-std.posix.ReadError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe</dt></div><div><dt>Canceled</dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer</dt></div><div><dt>ConnectionTimedOut</dt></div><div><dt>InputOutput</dt></div><div><dt>IsDir</dt></div><div><dt>LockViolation</dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NotOpenForReading</dt></div><div><dt>OperationAborted</dt></div><div><dt>ProcessNotFound</dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.ReadError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <span class="tok-kw">error</span>{
    InputOutput,
    SystemResources,
    IsDir,
    OperationAborted,
    BrokenPipe,
    ConnectionResetByPeer,
    ConnectionTimedOut,
    NotOpenForReading,
    SocketNotConnected,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and reading from the file descriptor would block.</span>
    WouldBlock,

    <span class="tok-comment">/// reading a timerfd with CANCEL_ON_SET will lead to this error</span>
    <span class="tok-comment">/// when the clock goes through a discontinuous change</span>
    Canceled,

    <span class="tok-comment">/// In WASI, this error occurs when the file descriptor does</span>
    <span class="tok-comment">/// not hold the required rights to read from it.</span>
    AccessDenied,

    <span class="tok-comment">/// This error occurs in Linux if the process to be read from</span>
    <span class="tok-comment">/// no longer exists.</span>
    ProcessNotFound,

    <span class="tok-comment">/// Unable to read file due to lock.</span>
    LockViolation,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PReadError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PReadError</span><a href="#src.zig-std.posix.PReadError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>IsDir <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable</dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PReadError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PReadError = <a href="std.posix.html#std.posix.ReadError">ReadError</a> || <span class="tok-kw">error</span>{Unseekable}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.WriteError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">WriteError</span><a href="#src.zig-std.posix.WriteError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied</dt><dd><p>File descriptor does not hold the required rights to write to it.</p>
</dd></div><div><dt>BrokenPipe</dt></div><div><dt>ConnectionResetByPeer</dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>DeviceBusy</dt></div><div><dt>DiskQuota</dt></div><div><dt>FileTooBig</dt></div><div><dt>InputOutput</dt></div><div><dt>InvalidArgument</dt></div><div><dt>LockViolation</dt><dd><p>The process cannot access the file because another process has locked
a portion of the file. Windows-only.</p>
</dd></div><div><dt>NoDevice</dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotOpenForWriting</dt></div><div><dt>OperationAborted</dt></div><div><dt>ProcessNotFound</dt><dd><p>This error occurs in Linux if the process being written to
no longer exists.</p>
</dd></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock</dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.WriteError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <span class="tok-kw">error</span>{
    DiskQuota,
    FileTooBig,
    InputOutput,
    NoSpaceLeft,
    DeviceBusy,
    InvalidArgument,

    <span class="tok-comment">/// File descriptor does not hold the required rights to write to it.</span>
    AccessDenied,
    BrokenPipe,
    SystemResources,
    OperationAborted,
    NotOpenForWriting,

    <span class="tok-comment">/// The process cannot access the file because another process has locked</span>
    <span class="tok-comment">/// a portion of the file. Windows-only.</span>
    LockViolation,

    <span class="tok-comment">/// This error occurs when no global event loop is configured,</span>
    <span class="tok-comment">/// and reading from the file descriptor would block.</span>
    WouldBlock,

    <span class="tok-comment">/// Connection reset by peer.</span>
    ConnectionResetByPeer,

    <span class="tok-comment">/// This error occurs in Linux if the process being written to</span>
    <span class="tok-comment">/// no longer exists.</span>
    ProcessNotFound,
    <span class="tok-comment">/// This error occurs when a device gets disconnected before or mid-flush</span>
    <span class="tok-comment">/// while it's being written to - errno(6): No such device or address.</span>
    NoDevice,
} || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.posix.PWriteError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">PWriteError</span><a href="#src.zig-std.posix.PWriteError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>File descriptor does not hold the required rights to write to it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>The process cannot access the file because another process has locked
a portion of the file. Windows-only.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs in Linux if the process being written to
no longer exists.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable</dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.PWriteError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> PWriteError = <a href="std.posix.html#std.posix.WriteError">WriteError</a> || <span class="tok-kw">error</span>{Unseekable}</code></pre></details></div></div><div class="decl"><h2 id="std.posix.CopyFileRangeError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">CopyFileRangeError</span><a href="#src.zig-std.posix.CopyFileRangeError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>CorruptedData</dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>FileTooBig</dt></div><div><dt>FilesOpenedWithWrongFlags</dt><dd><p><code>fd_in</code> is not open for reading; or <code>fd_out</code> is not open  for  writing;
or the  <code>APPEND</code>  flag  is  set  for <code>fd_out</code>.</p>
</dd></div><div><dt>InputOutput</dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>IsDir</dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft</dt></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OutOfMemory</dt></div><div><dt>PermissionDenied</dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SwapFile</dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>Unseekable</dt></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.posix.CopyFileRangeError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyFileRangeError = <span class="tok-kw">error</span>{
    FileTooBig,
    InputOutput,
    <span class="tok-comment">/// `fd_in` is not open for reading; or `fd_out` is not open  for  writing;</span>
    <span class="tok-comment">/// or the  `APPEND`  flag  is  set  for `fd_out`.</span>
    FilesOpenedWithWrongFlags,
    IsDir,
    OutOfMemory,
    NoSpaceLeft,
    Unseekable,
    PermissionDenied,
    SwapFile,
    CorruptedData,
} || <a href="std.posix.html#std.posix.PReadError">PReadError</a> || <a href="std.posix.html#std.posix.PWriteError">PWriteError</a> || <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.WriteFileError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">WriteFileError</span><a href="#src.zig-std.fs.File.WriteFileError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>EndOfStream</dt></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>IsDir <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.WriteFileError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileError = <a href="std.posix.html#std.posix.ReadError">ReadError</a> || <span class="tok-kw">error</span>{EndOfStream} || <a href="std.posix.html#std.posix.WriteError">WriteError</a></code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.LockError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">LockError</span><a href="#src.zig-std.fs.File.LockError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>FileLocksNotSupported</dt></div><div><dt>SystemResources</dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.LockError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> LockError = <span class="tok-kw">error</span>{
    SystemResources,
    FileLocksNotSupported,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.fs.File.close" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">close</span><a href="#src.zig-std.fs.File.close">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Upon success, the stream is in an uninitialized state. To continue using it,
you must use the open() function.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.close">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(self.handle);
    } <span class="tok-kw">else</span> {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.handle);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.sync" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sync</span><a href="#src.zig-std.fs.File.sync">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sync</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Blocks until all pending file contents and metadata modifications
for the file have been synchronized with the underlying filesystem.</p>
<p>Note that this does not ensure that metadata for the
directory containing the file has also reached disk.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.sync">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sync</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fsync">fsync</a>(self.handle);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.isTty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isTty</span><a href="#src.zig-std.fs.File.isTty">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isTty</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Test whether the file refers to a terminal.
See also <code><a href="std.fs.File.html#std.fs.File.getOrEnableAnsiEscapeSupport">getOrEnableAnsiEscapeSupport</a></code> and <code><a href="std.fs.File.html#std.fs.File.supportsAnsiEscapeCodes">supportsAnsiEscapeCodes</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.isTty">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isTty</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.isatty">isatty</a>(self.handle);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.isCygwinPty" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">isCygwinPty</span><a href="#src.zig-std.fs.File.isCygwinPty">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isCygwinPty</span>(file: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.isCygwinPty">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isCygwinPty</span>(file: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .windows) <span class="tok-kw">return</span> <span class="tok-null">false</span>;

    <span class="tok-kw">const</span> handle = file.handle;<span class="tok-comment">

    // If this is a MSYS2/cygwin pty, then it will be a named pipe with a name in one of these formats:
    //   msys-[...]-ptyN-[...]
    //   cygwin-[...]-ptyN-[...]
    //
    // Example: msys-1888ae32e00d56aa-pty0-to-master

    // First, just check that the handle is a named pipe.
    // This allows us to avoid the more costly NtQueryInformationFile call
    // for handles that aren't named pipes.
    </span>{
        <span class="tok-kw">var</span> io_status: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> device_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_FS_DEVICE_INFORMATION.html">FILE_FS_DEVICE_INFORMATION</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryVolumeInformationFile">NtQueryVolumeInformationFile</a>(handle, &amp;io_status, &amp;device_info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_FS_DEVICE_INFORMATION.html">FILE_FS_DEVICE_INFORMATION</a>), .FileFsDeviceInformation);
        <span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
        }
        <span class="tok-kw">if</span> (device_info.DeviceType != <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_DEVICE_NAMED_PIPE">FILE_DEVICE_NAMED_PIPE</a>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">const</span> name_bytes_offset = <span class="tok-builtin">@offsetOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_NAME_INFO.html">FILE_NAME_INFO</a>, <span class="tok-str">&quot;FileName&quot;</span>);<span class="tok-comment">
    // `NAME_MAX` UTF-16 code units (2 bytes each)
    // This buffer may not be long enough to handle *all* possible paths
    // (PATH_MAX_WIDE would be necessary for that), but because we only care
    // about certain paths and we know they must be within a reasonable length,
    // we can use this smaller buffer and just return false on any error from
    // NtQueryInformationFile.
    </span><span class="tok-kw">const</span> num_name_bytes = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.MAX_PATH">MAX_PATH</a> * <span class="tok-number">2</span>;
    <span class="tok-kw">var</span> name_info_bytes <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_NAME_INFO.html">FILE_NAME_INFO</a>)) = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (name_bytes_offset + num_name_bytes);

    <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(handle, &amp;io_status_block, &amp;name_info_bytes, <span class="tok-builtin">@intCast</span>(name_info_bytes.len), .FileNameInformation);
    <span class="tok-kw">switch</span> (rc) {
        .SUCCESS =&gt; {},
        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    }

    <span class="tok-kw">const</span> name_info: *<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_NAME_INFO.html">FILE_NAME_INFO</a> = <span class="tok-builtin">@ptrCast</span>(&amp;name_info_bytes);
    <span class="tok-kw">const</span> name_bytes = name_info_bytes[name_bytes_offset .. name_bytes_offset + name_info.FileNameLength];
    <span class="tok-kw">const</span> name_wide = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u16</span>, name_bytes);<span class="tok-comment">
    // The name we get from NtQueryInformationFile will be prefixed with a '\', e.g. \msys-1888ae32e00d56aa-pty0-to-master
    </span><span class="tok-kw">return</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u16</span>, name_wide, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'\\'</span>, <span class="tok-str">'m'</span>, <span class="tok-str">'s'</span>, <span class="tok-str">'y'</span>, <span class="tok-str">'s'</span>, <span class="tok-str">'-'</span> }) <span class="tok-kw">or</span>
        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u16</span>, name_wide, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'\\'</span>, <span class="tok-str">'c'</span>, <span class="tok-str">'y'</span>, <span class="tok-str">'g'</span>, <span class="tok-str">'w'</span>, <span class="tok-str">'i'</span>, <span class="tok-str">'n'</span>, <span class="tok-str">'-'</span> })) <span class="tok-kw">and</span>
        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u16</span>, name_wide, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'-'</span>, <span class="tok-str">'p'</span>, <span class="tok-str">'t'</span>, <span class="tok-str">'y'</span> }) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.getOrEnableAnsiEscapeSupport" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrEnableAnsiEscapeSupport</span><a href="#src.zig-std.fs.File.getOrEnableAnsiEscapeSupport">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrEnableAnsiEscapeSupport</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Returns whether or not ANSI escape codes will be treated as such,
and attempts to enable support for ANSI escape codes if necessary
(on Windows).</p>
<p>Returns <code>true</code> if ANSI escape codes are supported or support was
successfully enabled. Returns false if ANSI escape codes are not
supported or support was unable to be enabled.</p>
<p>See also <code><a href="std.fs.File.html#std.fs.File.supportsAnsiEscapeCodes">supportsAnsiEscapeCodes</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.getOrEnableAnsiEscapeSupport">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrEnableAnsiEscapeSupport</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">var</span> original_console_mode: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-number">0</span>;<span class="tok-comment">

        // For Windows Terminal, VT Sequences processing is enabled by default.
        </span><span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleMode">GetConsoleMode</a>(self.handle, &amp;original_console_mode) != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (original_console_mode &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING">ENABLE_VIRTUAL_TERMINAL_PROCESSING</a> != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;<span class="tok-comment">

            // For Windows Console, VT Sequences processing support was added in Windows 10 build 14361, but disabled by default.
            // https://devblogs.microsoft.com/commandline/tmux-support-arrives-for-bash-on-ubuntu-on-windows/
            //
            // Note: In Microsoft's example for enabling virtual terminal processing, it
            // shows attempting to enable `DISABLE_NEWLINE_AUTO_RETURN` as well:
            // https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#example-of-enabling-virtual-terminal-processing
            // This is avoided because in the old Windows Console, that flag causes \n (as opposed to \r\n)
            // to behave unexpectedly (the cursor moves down 1 row but remains on the same column).
            // Additionally, the default console mode in Windows Terminal does not have
            // `DISABLE_NEWLINE_AUTO_RETURN` set, so by only enabling `ENABLE_VIRTUAL_TERMINAL_PROCESSING`
            // we end up matching the mode of Windows Terminal.
            </span><span class="tok-kw">const</span> requested_console_modes = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING">ENABLE_VIRTUAL_TERMINAL_PROCESSING</a>;
            <span class="tok-kw">const</span> console_mode = original_console_mode | requested_console_modes;
            <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.SetConsoleMode">SetConsoleMode</a>(self.handle, console_mode) != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">return</span> self.isCygwinPty();
    }
    <span class="tok-kw">return</span> self.supportsAnsiEscapeCodes();
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.supportsAnsiEscapeCodes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">supportsAnsiEscapeCodes</span><a href="#src.zig-std.fs.File.supportsAnsiEscapeCodes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supportsAnsiEscapeCodes</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Test whether ANSI escape codes will be treated as such without
attempting to enable support for ANSI escape codes.</p>
<p>See also <code><a href="std.fs.File.html#std.fs.File.getOrEnableAnsiEscapeSupport">getOrEnableAnsiEscapeSupport</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.supportsAnsiEscapeCodes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supportsAnsiEscapeCodes</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">var</span> console_mode: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleMode">GetConsoleMode</a>(self.handle, &amp;console_mode) != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (console_mode &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING">ENABLE_VIRTUAL_TERMINAL_PROCESSING</a> != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">return</span> self.isCygwinPty();
    }
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi) {<span class="tok-comment">
        // WASI sanitizes stdout when fd is a tty so ANSI escape codes
        // will not be interpreted as actual cursor commands, and
        // stderr is always sanitized.
        </span><span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">if</span> (self.isTty()) {
        <span class="tok-kw">if</span> (self.handle == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDOUT_FILENO">STDOUT_FILENO</a> <span class="tok-kw">or</span> self.handle == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDERR_FILENO">STDERR_FILENO</a>) {
            <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenvZ">getenvZ</a>(<span class="tok-str">&quot;TERM&quot;</span>)) |term| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, term, <span class="tok-str">&quot;dumb&quot;</span>))
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.setEndPos" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setEndPos</span><a href="#src.zig-std.fs.File.setEndPos">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setEndPos</span>(self: <a href="std.fs.File.html">File</a>, length: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.TruncateError">SetEndPosError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks or expands the file.
The file offset after this call is left unchanged.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>length: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.setEndPos">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setEndPos</span>(self: <a href="std.fs.File.html">File</a>, length: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.TruncateError">SetEndPosError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ftruncate">ftruncate</a>(self.handle, length);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.seekBy" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">seekBy</span><a href="#src.zig-std.fs.File.seekBy">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekBy</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Repositions read/write file offset relative to the current offset.
TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>offset: <span class="tok-type">i64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.seekBy">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekBy</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_CUR">lseek_CUR</a>(self.handle, offset);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.seekFromEnd" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">seekFromEnd</span><a href="#src.zig-std.fs.File.seekFromEnd">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekFromEnd</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Repositions read/write file offset relative to the end.
TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>offset: <span class="tok-type">i64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.seekFromEnd">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekFromEnd</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_END">lseek_END</a>(self.handle, offset);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.seekTo" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">seekTo</span><a href="#src.zig-std.fs.File.seekTo">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekTo</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Repositions read/write file offset relative to the beginning.
TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.seekTo">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekTo</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.handle, offset);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.getPos" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPos</span><a href="#src.zig-std.fs.File.getPos">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPos</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a>!<span class="tok-type">u64</span></code></pre></div><div class="tldDocs"><p>TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.getPos">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPos</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_CUR_get">lseek_CUR_get</a>(self.handle);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.getEndPos" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEndPos</span><a href="#src.zig-std.fs.File.getEndPos">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEndPos</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a>!<span class="tok-type">u64</span></code></pre></div><div class="tldDocs"><p>TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.getEndPos">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEndPos</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetFileSizeEx">GetFileSizeEx</a>(self.handle);
    }
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.stat()).size;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.mode" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">mode</span><a href="#src.zig-std.fs.File.mode">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mode</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">ModeError</a>!<a href="std.posix.html#std.posix.mode_t">Mode</a></code></pre></div><div class="tldDocs"><p>TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.mode">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mode</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">ModeError</a>!<a href="std.posix.html#std.posix.mode_t">Mode</a> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    }
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.stat()).mode;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.stat" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stat</span><a href="#src.zig-std.fs.File.stat">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">StatError</a>!<a href="std.fs.File.Stat.html">Stat</a></code></pre></div><div class="tldDocs"><p>Returns <code><a href="std.fs.File.Stat.html">Stat</a></code> containing basic information about the <code><a href="std.fs.File.html">File</a></code>.
Use <code><a href="std.fs.File.html#std.fs.File.metadata">metadata</a></code> to retrieve more detailed information (e.g. creation time, permissions).
TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.stat">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">StatError</a>!<a href="std.fs.File.Stat.html">Stat</a> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ALL_INFORMATION.html">FILE_ALL_INFORMATION</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(self.handle, &amp;io_status_block, &amp;info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ALL_INFORMATION.html">FILE_ALL_INFORMATION</a>), .FileAllInformation);
        <span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; {},<span class="tok-comment">
            // Buffer overflow here indicates that there is more information available than was able to be stored in the buffer
            // size provided. This is treated as success because the type of variable-length information that this would be relevant for
            // (name, volume name, etc) we don't care about.
            </span>.BUFFER_OVERFLOW =&gt; {},
            .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
        }
        <span class="tok-kw">return</span> .{
            .inode = info.InternalInformation.IndexNumber,
            .size = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(info.StandardInformation.EndOfFile)),
            .mode = <span class="tok-number">0</span>,
            .kind = <span class="tok-kw">if</span> (info.BasicInformation.FileAttributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_REPARSE_POINT">FILE_ATTRIBUTE_REPARSE_POINT</a> != <span class="tok-number">0</span>) reparse_point: {
                <span class="tok-kw">var</span> tag_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ATTRIBUTE_TAG_INFO.html">FILE_ATTRIBUTE_TAG_INFO</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> tag_rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(self.handle, &amp;io_status_block, &amp;tag_info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ATTRIBUTE_TAG_INFO.html">FILE_ATTRIBUTE_TAG_INFO</a>), .FileAttributeTagInformation);
                <span class="tok-kw">switch</span> (tag_rc) {
                    .SUCCESS =&gt; {},<span class="tok-comment">
                    // INFO_LENGTH_MISMATCH and ACCESS_DENIED are the only documented possible errors
                    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/d295752f-ce89-4b98-8553-266d37c84f0e
                    </span>.INFO_LENGTH_MISMATCH =&gt; <span class="tok-kw">unreachable</span>,
                    .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
                }
                <span class="tok-kw">if</span> (tag_info.ReparseTag &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.reparse_tag_name_surrogate_bit">reparse_tag_name_surrogate_bit</a> != <span class="tok-number">0</span>) {
                    <span class="tok-kw">break</span> :reparse_point .sym_link;
                }<span class="tok-comment">
                // Unknown reparse point
                </span><span class="tok-kw">break</span> :reparse_point .unknown;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (info.BasicInformation.FileAttributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_DIRECTORY">FILE_ATTRIBUTE_DIRECTORY</a> != <span class="tok-number">0</span>)
                .directory
            <span class="tok-kw">else</span>
                .file,
            .atime = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.LastAccessTime),
            .mtime = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.LastWriteTime),
            .ctime = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.ChangeTime),
        };
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstat_wasi">fstat_wasi</a>(self.handle);
        <span class="tok-kw">return</span> <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromWasi">fromWasi</a>(st);
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .linux) {
        <span class="tok-kw">var</span> stx = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>);

        <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.statx">statx</a>(
            self.handle,
            <span class="tok-str">&quot;&quot;</span>,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AT.html">AT</a>.<a href="std.os.linux.AT.html#std.os.linux.AT.EMPTY_PATH">EMPTY_PATH</a>,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_TYPE">STATX_TYPE</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_MODE">STATX_MODE</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_ATIME">STATX_ATIME</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_MTIME">STATX_MTIME</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_CTIME">STATX_CTIME</a>,
            &amp;stx,
        );

        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
            .SUCCESS =&gt; <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromLinux">fromLinux</a>(stx),
            .ACCES =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .LOOP =&gt; <span class="tok-kw">unreachable</span>,
            .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">unreachable</span>,
            .NOMEM =&gt; <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |err| <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        };
    }

    <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstat">fstat</a>(self.handle);
    <span class="tok-kw">return</span> <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromPosix">fromPosix</a>(st);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.chmod" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chmod</span><a href="#src.zig-std.fs.File.chmod">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: <a href="std.fs.File.html">File</a>, new_mode: <a href="std.posix.html#std.posix.mode_t">Mode</a>) <a href="std.posix.html#std.posix.FChmodError">ChmodError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the mode of the file.
The process must have the correct privileges in order to do this
successfully, or must have the effective user ID matching the owner
of the file.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>new_mode: <a href="std.posix.html#std.posix.mode_t">Mode</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.chmod">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: <a href="std.fs.File.html">File</a>, new_mode: <a href="std.posix.html#std.posix.mode_t">Mode</a>) <a href="std.posix.html#std.posix.FChmodError">ChmodError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fchmod">fchmod</a>(self.handle, new_mode);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.chown" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">chown</span><a href="#src.zig-std.fs.File.chown">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: <a href="std.fs.File.html">File</a>, owner: ?<a href="std.posix.html#std.posix.uid_t">Uid</a>, group: ?<a href="std.posix.html#std.posix.gid_t">Gid</a>) <a href="std.posix.html#std.posix.FChownError">ChownError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Changes the owner and group of the file.
The process must have the correct privileges in order to do this
successfully. The group may be changed by the owner of the file to
any group of which the owner is a member. If the owner or group is
specified as <code>null</code>, the ID is not changed.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>owner: ?<a href="std.posix.html#std.posix.uid_t">Uid</a></code></pre></div><div><pre><code>group: ?<a href="std.posix.html#std.posix.gid_t">Gid</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.chown">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: <a href="std.fs.File.html">File</a>, owner: ?<a href="std.posix.html#std.posix.uid_t">Uid</a>, group: ?<a href="std.posix.html#std.posix.gid_t">Gid</a>) <a href="std.posix.html#std.posix.FChownError">ChownError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fchown">fchown</a>(self.handle, owner, group);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.setPermissions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setPermissions</span><a href="#src.zig-std.fs.File.setPermissions">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: <a href="std.fs.File.html">File</a>, permissions: <a href="std.fs.File.Permissions.html">Permissions</a>) <a href="std.posix.html#std.posix.FChmodError">SetPermissionsError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sets permissions according to the provided <code><a href="std.fs.File.Permissions.html">Permissions</a></code> struct.
This method is <em>NOT</em> available on WASI</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>permissions: <a href="std.fs.File.Permissions.html">Permissions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.setPermissions">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: <a href="std.fs.File.html">File</a>, permissions: <a href="std.fs.File.Permissions.html">Permissions</a>) <a href="std.posix.html#std.posix.FChmodError">SetPermissionsError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .windows =&gt; {
            <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> info = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_BASIC_INFORMATION.html">FILE_BASIC_INFORMATION</a>{
                .CreationTime = <span class="tok-number">0</span>,
                .LastAccessTime = <span class="tok-number">0</span>,
                .LastWriteTime = <span class="tok-number">0</span>,
                .ChangeTime = <span class="tok-number">0</span>,
                .FileAttributes = permissions.inner.attributes,
            };
            <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtSetInformationFile">NtSetInformationFile</a>(
                self.handle,
                &amp;io_status_block,
                &amp;info,
                <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_BASIC_INFORMATION.html">FILE_BASIC_INFORMATION</a>),
                .FileBasicInformation,
            );
            <span class="tok-kw">switch</span> (rc) {
                .SUCCESS =&gt; <span class="tok-kw">return</span>,
                .INVALID_HANDLE =&gt; <span class="tok-kw">unreachable</span>,
                .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
            }
        },
        .wasi =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),<span class="tok-comment"> // Wasi filesystem does not *yet* support chmod
        </span><span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">try</span> self.chmod(permissions.inner.mode);
        },
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.metadata" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadata</span><a href="#src.zig-std.fs.File.metadata">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">MetadataError</a>!<a href="std.fs.File.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.metadata">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">MetadataError</a>!<a href="std.fs.File.Metadata.html">Metadata</a> {
    <span class="tok-kw">return</span> .{
        .inner = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
            .windows =&gt; blk: {
                <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">var</span> info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ALL_INFORMATION.html">FILE_ALL_INFORMATION</a> = <span class="tok-null">undefined</span>;

                <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(self.handle, &amp;io_status_block, &amp;info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ALL_INFORMATION.html">FILE_ALL_INFORMATION</a>), .FileAllInformation);
                <span class="tok-kw">switch</span> (rc) {
                    .SUCCESS =&gt; {},<span class="tok-comment">
                    // Buffer overflow here indicates that there is more information available than was able to be stored in the buffer
                    // size provided. This is treated as success because the type of variable-length information that this would be relevant for
                    // (name, volume name, etc) we don't care about.
                    </span>.BUFFER_OVERFLOW =&gt; {},
                    .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
                    .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
                }

                <span class="tok-kw">const</span> reparse_tag: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = reparse_blk: {
                    <span class="tok-kw">if</span> (info.BasicInformation.FileAttributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_REPARSE_POINT">FILE_ATTRIBUTE_REPARSE_POINT</a> != <span class="tok-number">0</span>) {
                        <span class="tok-kw">var</span> tag_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ATTRIBUTE_TAG_INFO.html">FILE_ATTRIBUTE_TAG_INFO</a> = <span class="tok-null">undefined</span>;
                        <span class="tok-kw">const</span> tag_rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(self.handle, &amp;io_status_block, &amp;tag_info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ATTRIBUTE_TAG_INFO.html">FILE_ATTRIBUTE_TAG_INFO</a>), .FileAttributeTagInformation);
                        <span class="tok-kw">switch</span> (tag_rc) {
                            .SUCCESS =&gt; {},<span class="tok-comment">
                            // INFO_LENGTH_MISMATCH and ACCESS_DENIED are the only documented possible errors
                            // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/d295752f-ce89-4b98-8553-266d37c84f0e
                            </span>.INFO_LENGTH_MISMATCH =&gt; <span class="tok-kw">unreachable</span>,
                            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
                        }
                        <span class="tok-kw">break</span> :reparse_blk tag_info.ReparseTag;
                    }
                    <span class="tok-kw">break</span> :reparse_blk <span class="tok-number">0</span>;
                };

                <span class="tok-kw">break</span> :blk .{
                    .attributes = info.BasicInformation.FileAttributes,
                    .reparse_tag = reparse_tag,
                    ._size = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(info.StandardInformation.EndOfFile)),
                    .access_time = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.LastAccessTime),
                    .modified_time = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.LastWriteTime),
                    .creation_time = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.CreationTime),
                };
            },
            .linux =&gt; blk: {
                <span class="tok-kw">var</span> stx = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>);<span class="tok-comment">

                // We are gathering information for Metadata, which is meant to contain all the
                // native OS information about the file, so use all known flags.
                </span><span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.statx">statx</a>(
                    self.handle,
                    <span class="tok-str">&quot;&quot;</span>,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AT.html">AT</a>.<a href="std.os.linux.AT.html#std.os.linux.AT.EMPTY_PATH">EMPTY_PATH</a>,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_BASIC_STATS">STATX_BASIC_STATS</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_BTIME">STATX_BTIME</a>,
                    &amp;stx,
                );

                <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
                    .SUCCESS =&gt; {},
                    .ACCES =&gt; <span class="tok-kw">unreachable</span>,
                    .BADF =&gt; <span class="tok-kw">unreachable</span>,
                    .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                    .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .LOOP =&gt; <span class="tok-kw">unreachable</span>,
                    .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,
                    .NOENT =&gt; <span class="tok-kw">unreachable</span>,
                    .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }

                <span class="tok-kw">break</span> :blk .{
                    .statx = stx,
                };
            },
            .wasi =&gt; .{ .stat = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstat_wasi">fstat_wasi</a>(self.handle) },
            <span class="tok-kw">else</span> =&gt; .{ .stat = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstat">fstat</a>(self.handle) },
        },
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.updateTimes" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">updateTimes</span><a href="#src.zig-std.fs.File.updateTimes">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateTimes</span>( self: <a href="std.fs.File.html">File</a>, atime: <span class="tok-type">i128</span>, mtime: <span class="tok-type">i128</span>, ) <a href="std.fs.File.html#std.fs.File.UpdateTimesError">UpdateTimesError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>The underlying file system may have a different granularity than nanoseconds,
and therefore this function cannot guarantee any precision will be stored.
Further, the maximum value is limited by the system ABI. When a value is provided
that exceeds this range, the value is clamped to the maximum.
TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>atime: <span class="tok-type">i128</span></code></pre><div class="fieldDocs"><p>access timestamp in nanoseconds</p>
</div></div><div><pre><code>mtime: <span class="tok-type">i128</span></code></pre><div class="fieldDocs"><p>last modification timestamp in nanoseconds</p>
</div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.updateTimes">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateTimes</span>(
    self: <a href="std.fs.File.html">File</a>,
    <span class="tok-comment">/// access timestamp in nanoseconds</span>
    atime: <span class="tok-type">i128</span>,
    <span class="tok-comment">/// last modification timestamp in nanoseconds</span>
    mtime: <span class="tok-type">i128</span>,
) <a href="std.fs.File.html#std.fs.File.UpdateTimesError">UpdateTimesError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">const</span> atime_ft = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.nanoSecondsToFileTime">nanoSecondsToFileTime</a>(atime);
        <span class="tok-kw">const</span> mtime_ft = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.nanoSecondsToFileTime">nanoSecondsToFileTime</a>(mtime);
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFileTime">SetFileTime</a>(self.handle, <span class="tok-null">null</span>, &amp;atime_ft, &amp;mtime_ft);
    }
    <span class="tok-kw">const</span> times = [<span class="tok-number">2</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.timespec">timespec</a>{
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.timespec">timespec</a>{
            .sec = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@divFloor</span>(atime, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>)) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
            .nsec = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@mod</span>(atime, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>)) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
        },
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.timespec">timespec</a>{
            .sec = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@divFloor</span>(mtime, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>)) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
            .nsec = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@mod</span>(mtime, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>)) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
        },
    };
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.futimens">futimens</a>(self.handle, &amp;times);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.readToEndAlloc" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readToEndAlloc</span><a href="#src.zig-std.fs.File.readToEndAlloc">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readToEndAlloc</span>(self: <a href="std.fs.File.html">File</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span></code></pre></div><div class="tldDocs"><p>Reads all the bytes from the current position to the end of the file.
On success, caller owns returned buffer.
If the file is larger than <code>max_bytes</code>, returns <code>error.FileTooBig</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>max_bytes: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.readToEndAlloc">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readToEndAlloc</span>(self: <a href="std.fs.File.html">File</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> self.readToEndAllocOptions(allocator, max_bytes, <span class="tok-null">null</span>, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u8</span>), <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.readToEndAllocOptions" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readToEndAllocOptions</span><a href="#src.zig-std.fs.File.readToEndAllocOptions">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readToEndAllocOptions</span>( self: <a href="std.fs.File.html">File</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, max_bytes: <span class="tok-type">usize</span>, size_hint: ?<span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>, <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>, ) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>)</code></pre></div><div class="tldDocs"><p>Reads all the bytes from the current position to the end of the file.
On success, caller owns returned buffer.
If the file is larger than <code>max_bytes</code>, returns <code>error.FileTooBig</code>.
If <code>size_hint</code> is specified the initial buffer size is calculated using
that value, otherwise an arbitrary value is used instead.
Allows specifying alignment and a sentinel value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>max_bytes: <span class="tok-type">usize</span></code></pre></div><div><pre><code>size_hint: ?<span class="tok-type">usize</span></code></pre></div><div><pre><code>alignment: <span class="tok-type">u29</span></code></pre></div><div><pre><code>optional_sentinel: ?<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.readToEndAllocOptions">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readToEndAllocOptions</span>(
    self: <a href="std.fs.File.html">File</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    max_bytes: <span class="tok-type">usize</span>,
    size_hint: ?<span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>,
) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>) {<span class="tok-comment">
    // If no size hint is provided fall back to the size=0 code path
    </span><span class="tok-kw">const</span> size = size_hint <span class="tok-kw">orelse</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // The file size returned by stat is used as hint to set the buffer
    // size. If the reported size is zero, as it happens on Linux for files
    // in /proc, a small buffer is allocated instead.
    </span><span class="tok-kw">const</span> initial_cap = <span class="tok-builtin">@min</span>((<span class="tok-kw">if</span> (size &gt; <span class="tok-number">0</span>) size <span class="tok-kw">else</span> <span class="tok-number">1024</span>), max_bytes) + <span class="tok-builtin">@intFromBool</span>(optional_sentinel != <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> array_list = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(<span class="tok-type">u8</span>, alignment).initCapacity(allocator, initial_cap);
    <span class="tok-kw">defer</span> array_list.deinit();

    self.reader().readAllArrayListAligned(alignment, &amp;array_list, max_bytes) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.StreamTooLong =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };

    <span class="tok-kw">if</span> (optional_sentinel) |sentinel| {
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> array_list.toOwnedSliceSentinel(sentinel);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> array_list.toOwnedSlice();
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.read" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">read</span><a href="#src.zig-std.fs.File.read">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.read">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, buffer, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.read">read</a>(self.handle, buffer);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.readAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readAll</span><a href="#src.zig-std.fs.File.readAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bytes read. If the number read is smaller than <code>buffer.len</code>, it
means the file reached the end. Reaching the end of a file is not an error condition.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.readAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index != buffer.len) {
        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> self.read(buffer[index..]);
        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        index += amt;
    }
    <span class="tok-kw">return</span> index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.pread" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pread</span><a href="#src.zig-std.fs.File.pread">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pread</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>On Windows, this function currently does alter the file pointer.
<a href="https://github.com/ziglang/zig/issues/12783">https://github.com/ziglang/zig/issues/12783</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.pread">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pread</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, buffer, offset);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pread">pread</a>(self.handle, buffer, offset);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.preadAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">preadAll</span><a href="#src.zig-std.fs.File.preadAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadAll</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bytes read. If the number read is smaller than <code>buffer.len</code>, it
means the file reached the end. Reaching the end of a file is not an error condition.
On Windows, this function currently does alter the file pointer.
<a href="https://github.com/ziglang/zig/issues/12783">https://github.com/ziglang/zig/issues/12783</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>buffer: []<span class="tok-type">u8</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.preadAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadAll</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index != buffer.len) {
        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> self.pread(buffer[index..], offset + index);
        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        index += amt;
    }
    <span class="tok-kw">return</span> index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.readv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readv</span><a href="#src.zig-std.fs.File.readv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>See <a href="https://github.com/ziglang/zig/issues/7699">https://github.com/ziglang/zig/issues/7699</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.readv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // TODO improve this to use ReadFileScatter
        </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, first.base[<span class="tok-number">0</span>..first.len], <span class="tok-null">null</span>);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readv">readv</a>(self.handle, iovecs);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.readvAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">readvAll</span><a href="#src.zig-std.fs.File.readvAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bytes read. If the number read is smaller than the total bytes
from all the buffers, it means the file reached the end. Reaching the end of a file
is not an error condition.</p>
<p>The <code>iovecs</code> parameter is mutable because:</p>
<ul>
<li>This function needs to mutate the fields in order to handle partial
reads from the underlying OS layer.</li>
<li>The OS layer expects pointer addresses to be inside the application's address space
even if the length is zero. Meanwhile, in Zig, slices may have undefined pointer
addresses when the length is zero. So this function modifies the base fields
when the length is zero.</li>
</ul>
<p>Related open issue: <a href="https://github.com/ziglang/zig/issues/7699">https://github.com/ziglang/zig/issues/7699</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.readvAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // We use the address of this local variable for all zero-length
    // vectors so that the OS does not complain that we are giving it
    // addresses outside the application's address space.
    </span><span class="tok-kw">var</span> garbage: [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (iovecs) |*v| {
        <span class="tok-kw">if</span> (v.len == <span class="tok-number">0</span>) v.base = &amp;garbage;
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.readv(iovecs[i..]);
        <span class="tok-kw">var</span> eof = amt == <span class="tok-number">0</span>;
        off += amt;
        <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
            amt -= iovecs[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span> off;
            eof = <span class="tok-null">false</span>;
        }
        <span class="tok-kw">if</span> (eof) <span class="tok-kw">return</span> off;
        iovecs[i].base += amt;
        iovecs[i].len -= amt;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.preadv" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">preadv</span><a href="#src.zig-std.fs.File.preadv">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadv</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>See <a href="https://github.com/ziglang/zig/issues/7699">https://github.com/ziglang/zig/issues/7699</a>
On Windows, this function currently does alter the file pointer.
<a href="https://github.com/ziglang/zig/issues/12783">https://github.com/ziglang/zig/issues/12783</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.preadv">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadv</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // TODO improve this to use ReadFileScatter
        </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, first.base[<span class="tok-number">0</span>..first.len], offset);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.preadv">preadv</a>(self.handle, iovecs, offset);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.preadvAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">preadvAll</span><a href="#src.zig-std.fs.File.preadvAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadvAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of bytes read. If the number read is smaller than the total bytes
from all the buffers, it means the file reached the end. Reaching the end of a file
is not an error condition.
The <code>iovecs</code> parameter is mutable because this function needs to mutate the fields in
order to handle partial reads from the underlying OS layer.
See <a href="https://github.com/ziglang/zig/issues/7699">https://github.com/ziglang/zig/issues/7699</a>
On Windows, this function currently does alter the file pointer.
<a href="https://github.com/ziglang/zig/issues/12783">https://github.com/ziglang/zig/issues/12783</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.preadvAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadvAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.preadv(iovecs[i..], offset + off);
        <span class="tok-kw">var</span> eof = amt == <span class="tok-number">0</span>;
        off += amt;
        <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
            amt -= iovecs[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span> off;
            eof = <span class="tok-null">false</span>;
        }
        <span class="tok-kw">if</span> (eof) <span class="tok-kw">return</span> off;
        iovecs[i].base += amt;
        iovecs[i].len -= amt;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.write" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">write</span><a href="#src.zig-std.fs.File.write">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.write">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, bytes, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.write">write</a>(self.handle, bytes);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.writeAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeAll</span><a href="#src.zig-std.fs.File.writeAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.writeAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> self.write(bytes[index..]);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.pwrite" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pwrite</span><a href="#src.zig-std.fs.File.pwrite">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwrite</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>On Windows, this function currently does alter the file pointer.
<a href="https://github.com/ziglang/zig/issues/12783">https://github.com/ziglang/zig/issues/12783</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.pwrite">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwrite</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, bytes, offset);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pwrite">pwrite</a>(self.handle, bytes, offset);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.pwriteAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pwriteAll</span><a href="#src.zig-std.fs.File.pwriteAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwriteAll</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>On Windows, this function currently does alter the file pointer.
<a href="https://github.com/ziglang/zig/issues/12783">https://github.com/ziglang/zig/issues/12783</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.pwriteAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwriteAll</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> self.pwrite(bytes[index..], offset + index);
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.writev" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writev</span><a href="#src.zig-std.fs.File.writev">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>See <a href="https://github.com/ziglang/zig/issues/7699">https://github.com/ziglang/zig/issues/7699</a>
See equivalent function: <code><a href="std.net.Stream.html#std.net.Stream.writev">std.net.Stream.writev</a></code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.writev">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // TODO improve this to use WriteFileScatter
        </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, first.base[<span class="tok-number">0</span>..first.len], <span class="tok-null">null</span>);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.writev">writev</a>(self.handle, iovecs);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.writevAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writevAll</span><a href="#src.zig-std.fs.File.writevAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writevAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>The <code>iovecs</code> parameter is mutable because:</p>
<ul>
<li>This function needs to mutate the fields in order to handle partial
writes from the underlying OS layer.</li>
<li>The OS layer expects pointer addresses to be inside the application's address space
even if the length is zero. Meanwhile, in Zig, slices may have undefined pointer
addresses when the length is zero. So this function modifies the base fields
when the length is zero.
See <a href="https://github.com/ziglang/zig/issues/7699">https://github.com/ziglang/zig/issues/7699</a>
See equivalent function: <code><a href="std.net.Stream.html#std.net.Stream.writevAll">std.net.Stream.writevAll</a></code>.</li>
</ul>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.writevAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writevAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment">

    // We use the address of this local variable for all zero-length
    // vectors so that the OS does not complain that we are giving it
    // addresses outside the application's address space.
    </span><span class="tok-kw">var</span> garbage: [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (iovecs) |*v| {
        <span class="tok-kw">if</span> (v.len == <span class="tok-number">0</span>) v.base = &amp;garbage;
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.writev(iovecs[i..]);
        <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
            amt -= iovecs[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span>;
        }
        iovecs[i].base += amt;
        iovecs[i].len -= amt;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.pwritev" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pwritev</span><a href="#src.zig-std.fs.File.pwritev">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritev</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>See <a href="https://github.com/ziglang/zig/issues/7699">https://github.com/ziglang/zig/issues/7699</a>
On Windows, this function currently does alter the file pointer.
<a href="https://github.com/ziglang/zig/issues/12783">https://github.com/ziglang/zig/issues/12783</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.pwritev">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritev</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // TODO improve this to use WriteFileScatter
        </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, first.base[<span class="tok-number">0</span>..first.len], offset);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pwritev">pwritev</a>(self.handle, iovecs, offset);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.pwritevAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pwritevAll</span><a href="#src.zig-std.fs.File.pwritevAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritevAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>The <code>iovecs</code> parameter is mutable because this function needs to mutate the fields in
order to handle partial writes from the underlying OS layer.
See <a href="https://github.com/ziglang/zig/issues/7699">https://github.com/ziglang/zig/issues/7699</a>
On Windows, this function currently does alter the file pointer.
<a href="https://github.com/ziglang/zig/issues/12783">https://github.com/ziglang/zig/issues/12783</a></p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a></code></pre></div><div><pre><code>offset: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.pwritevAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritevAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> off: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.pwritev(iovecs[i..], offset + off);
        off += amt;
        <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
            amt -= iovecs[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span>;
        }
        iovecs[i].base += amt;
        iovecs[i].len -= amt;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.copyRange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copyRange</span><a href="#src.zig-std.fs.File.copyRange">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyRange</span>(in: <a href="std.fs.File.html">File</a>, in_offset: <span class="tok-type">u64</span>, out: <a href="std.fs.File.html">File</a>, out_offset: <span class="tok-type">u64</span>, len: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyRangeError</a>!<span class="tok-type">u64</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>in: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>in_offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>out: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>out_offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>len: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.copyRange">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyRange</span>(in: <a href="std.fs.File.html">File</a>, in_offset: <span class="tok-type">u64</span>, out: <a href="std.fs.File.html">File</a>, out_offset: <span class="tok-type">u64</span>, len: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyRangeError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">const</span> adjusted_len = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.copy_file_range">copy_file_range</a>(in.handle, in_offset, out.handle, out_offset, adjusted_len, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.copyRangeAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">copyRangeAll</span><a href="#src.zig-std.fs.File.copyRangeAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyRangeAll</span>(in: <a href="std.fs.File.html">File</a>, in_offset: <span class="tok-type">u64</span>, out: <a href="std.fs.File.html">File</a>, out_offset: <span class="tok-type">u64</span>, len: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyRangeError</a>!<span class="tok-type">u64</span></code></pre></div><div class="tldDocs"><p>Returns the number of bytes copied. If the number read is smaller than <code>buffer.len</code>, it
means the in file reached the end. Reaching the end of a file is not an error condition.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>in: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>in_offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>out: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>out_offset: <span class="tok-type">u64</span></code></pre></div><div><pre><code>len: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.copyRangeAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyRangeAll</span>(in: <a href="std.fs.File.html">File</a>, in_offset: <span class="tok-type">u64</span>, out: <a href="std.fs.File.html">File</a>, out_offset: <span class="tok-type">u64</span>, len: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyRangeError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">var</span> total_bytes_copied: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> in_off = in_offset;
    <span class="tok-kw">var</span> out_off = out_offset;
    <span class="tok-kw">while</span> (total_bytes_copied &lt; len) {
        <span class="tok-kw">const</span> amt_copied = <span class="tok-kw">try</span> <a href="std.fs.File.html#std.fs.File.copyRange">copyRange</a>(in, in_off, out, out_off, len - total_bytes_copied);
        <span class="tok-kw">if</span> (amt_copied == <span class="tok-number">0</span>) <span class="tok-kw">return</span> total_bytes_copied;
        total_bytes_copied += amt_copied;
        in_off += amt_copied;
        out_off += amt_copied;
    }
    <span class="tok-kw">return</span> total_bytes_copied;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.writeFileAll" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeFileAll</span><a href="#src.zig-std.fs.File.writeFileAll">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFileAll</span>(self: <a href="std.fs.File.html">File</a>, in_file: <a href="std.fs.File.html">File</a>, args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.File.html#std.fs.File.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>in_file: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.writeFileAll">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFileAll</span>(self: <a href="std.fs.File.html">File</a>, in_file: <a href="std.fs.File.html">File</a>, args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.File.html#std.fs.File.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.writeFileAllSendfile(in_file, args) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">error</span>.FastOpenAlreadyInProgress,
        <span class="tok-kw">error</span>.MessageTooBig,
        <span class="tok-kw">error</span>.FileDescriptorNotASocket,
        <span class="tok-kw">error</span>.NetworkUnreachable,
        <span class="tok-kw">error</span>.NetworkSubsystemFailed,
        =&gt; <span class="tok-kw">return</span> self.writeFileAllUnseekable(in_file, args),

        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.writeFileAllUnseekable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writeFileAllUnseekable</span><a href="#src.zig-std.fs.File.writeFileAllUnseekable">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFileAllUnseekable</span>(self: <a href="std.fs.File.html">File</a>, in_file: <a href="std.fs.File.html">File</a>, args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.File.html#std.fs.File.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Does not try seeking in either of the File parameters.
See <code><a href="std.fs.File.html#std.fs.File.writeFileAll">writeFileAll</a></code> as an alternative to calling this.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>in_file: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.writeFileAllUnseekable">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFileAllUnseekable</span>(self: <a href="std.fs.File.html">File</a>, in_file: <a href="std.fs.File.html">File</a>, args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.File.html#std.fs.File.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> headers = args.headers_and_trailers[<span class="tok-number">0</span>..args.header_count];
    <span class="tok-kw">const</span> trailers = args.headers_and_trailers[args.header_count..];

    <span class="tok-kw">try</span> self.writevAll(headers);

    <span class="tok-kw">try</span> in_file.reader().skipBytes(args.in_offset, .{ .buf_size = <span class="tok-number">4096</span> });

    <span class="tok-kw">var</span> fifo = <a href="std.html">std</a>.<a href="std.fifo.html">fifo</a>.<a href="std.fifo.html#std.fifo.LinearFifo">LinearFifo</a>(<span class="tok-type">u8</span>, .{ .Static = <span class="tok-number">4096</span> }).init();
    <span class="tok-kw">if</span> (args.in_len) |len| {
        <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.limited_reader.html#std.io.limited_reader.limitedReader">limitedReader</a>(in_file.reader(), len);
        <span class="tok-kw">try</span> fifo.pump(stream.reader(), self.writer());
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> fifo.pump(in_file.reader(), self.writer());
    }

    <span class="tok-kw">try</span> self.writevAll(trailers);
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.reader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reader</span><a href="#src.zig-std.fs.File.reader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.Reader">Reader</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.reader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.Reader">Reader</a> {
    <span class="tok-kw">return</span> .{ .context = file };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.writer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">writer</span><a href="#src.zig-std.fs.File.writer">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.Writer">Writer</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.writer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = file };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.seekableStream" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">seekableStream</span><a href="#src.zig-std.fs.File.seekableStream">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekableStream</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.SeekableStream">SeekableStream</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.seekableStream">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekableStream</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.SeekableStream">SeekableStream</a> {
    <span class="tok-kw">return</span> .{ .context = file };
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.lock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lock</span><a href="#src.zig-std.fs.File.lock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lock</span>(file: <a href="std.fs.File.html">File</a>, l: <a href="std.fs.File.Lock.html">Lock</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Blocks when an incompatible lock is held by another process.
A process may hold only one type of lock (shared or exclusive) on
a file. When a process terminates in any way, the lock is released.</p>
<p>Assumes the file is unlocked.</p>
<p>TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>l: <a href="std.fs.File.Lock.html">Lock</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.lock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lock</span>(file: <a href="std.fs.File.html">File</a>, l: <a href="std.fs.File.Lock.html">Lock</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (l) {
            .none =&gt; <span class="tok-kw">return</span>,
            .shared =&gt; <span class="tok-null">false</span>,
            .exclusive =&gt; <span class="tok-null">true</span>,
        };
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.LockFile">LockFile</a>(
            file.handle,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FALSE">FALSE</a>,<span class="tok-comment"> // non-blocking=false
            </span><span class="tok-builtin">@intFromBool</span>(exclusive),
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // non-blocking=false
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(file.handle, <span class="tok-kw">switch</span> (l) {
            .none =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.UN">UN</a>,
            .shared =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a>,
            .exclusive =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.EX">EX</a>,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // non-blocking=false
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.unlock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlock</span><a href="#src.zig-std.fs.File.unlock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlock</span>(file: <a href="std.fs.File.html">File</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Assumes the file is locked.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.unlock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlock</span>(file: <a href="std.fs.File.html">File</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UnlockFile">UnlockFile</a>(
            file.handle,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.RangeNotLocked =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Function assumes unlocked.
            </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Resource deallocation must succeed.
        </span>};
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(file.handle, <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.UN">UN</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // unlocking can't block
            </span><span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // We are deallocating resources.
            </span><span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // We already got the lock.
            </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Resource deallocation must succeed.
        </span>};
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.tryLock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">tryLock</span><a href="#src.zig-std.fs.File.tryLock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tryLock</span>(file: <a href="std.fs.File.html">File</a>, l: <a href="std.fs.File.Lock.html">Lock</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Attempts to obtain a lock, returning <code>true</code> if the lock is
obtained, and <code>false</code> if there was an existing incompatible lock held.
A process may hold only one type of lock (shared or exclusive) on
a file. When a process terminates in any way, the lock is released.</p>
<p>Assumes the file is unlocked.</p>
<p>TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.File.html">File</a></code></pre></div><div><pre><code>l: <a href="std.fs.File.Lock.html">Lock</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.tryLock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tryLock</span>(file: <a href="std.fs.File.html">File</a>, l: <a href="std.fs.File.Lock.html">Lock</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (l) {
            .none =&gt; <span class="tok-kw">return</span>,
            .shared =&gt; <span class="tok-null">false</span>,
            .exclusive =&gt; <span class="tok-null">true</span>,
        };
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.LockFile">LockFile</a>(
            file.handle,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>,<span class="tok-comment"> // non-blocking=true
            </span><span class="tok-builtin">@intFromBool</span>(exclusive),
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(file.handle, <span class="tok-kw">switch</span> (l) {
            .none =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.UN">UN</a>,
            .shared =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a>,
            .exclusive =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.EX">EX</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a>,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.fs.File.downgradeLock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">downgradeLock</span><a href="#src.zig-std.fs.File.downgradeLock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">downgradeLock</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Assumes the file is already locked in exclusive mode.
Atomically modifies the lock to be in shared mode, without releasing it.</p>
<p>TODO: integrate with async I/O</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>file: <a href="std.fs.File.html">File</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.fs.File.downgradeLock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">downgradeLock</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // On Windows it works like a semaphore + exclusivity flag. To implement this
        // function, we first obtain another lock in shared mode. This changes the
        // exclusivity flag, but increments the semaphore to 2. So we follow up with
        // an NtUnlockFile which decrements the semaphore but does not modify the
        // exclusivity flag.
        </span><span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.LockFile">LockFile</a>(
            file.handle,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>,<span class="tok-comment"> // non-blocking=true
            </span><a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FALSE">FALSE</a>,<span class="tok-comment"> // exclusive=false
        </span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // File was not locked in exclusive mode.
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UnlockFile">UnlockFile</a>(
            file.handle,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.RangeNotLocked =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // File was not locked.
            </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Resource deallocation must succeed.
        </span>};
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(file.handle, <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // File was not locked in exclusive mode.
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.fs.File">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-comment">/// The OS-specific file descriptor or file handle.</span>
handle: <a href="std.posix.html#std.posix.fd_t">Handle</a>,

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Handle = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fd_t">fd_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Mode = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.mode_t">mode_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> INode = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ino_t">ino_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Uid = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.uid_t">uid_t</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Gid = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.gid_t">gid_t</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> {
    block_device,
    character_device,
    directory,
    named_pipe,
    sym_link,
    file,
    unix_domain_socket,
    whiteout,
    door,
    event_port,
    unknown,
};

<span class="tok-comment">/// This is the default mode given to POSIX operating systems for creating</span>
<span class="tok-comment">/// files. `0o666` is &quot;-rw-rw-rw-&quot; which is counter-intuitive at first,</span>
<span class="tok-comment">/// since most people would expect &quot;-rw-r--r--&quot;, for example, when using</span>
<span class="tok-comment">/// the `touch` command, which would correspond to `0o644`. However, POSIX</span>
<span class="tok-comment">/// libc implementations use `0o666` inside `fopen` and then rely on the</span>
<span class="tok-comment">/// process-scoped &quot;umask&quot; setting to adjust this number for file creation.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> default_mode = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
    .windows =&gt; <span class="tok-number">0</span>,
    .wasi =&gt; <span class="tok-number">0</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-number">0o666</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenError = <span class="tok-kw">error</span>{
    SharingViolation,
    PathAlreadyExists,
    FileNotFound,
    AccessDenied,
    PipeBusy,
    NoDevice,
    NameTooLong,
    <span class="tok-comment">/// WASI-only; file paths must be valid UTF-8.</span>
    InvalidUtf8,
    <span class="tok-comment">/// Windows-only; file paths provided by the user must be valid WTF-8.</span>
    <span class="tok-comment">/// https://simonsapin.github.io/wtf-8/</span>
    InvalidWtf8,
    <span class="tok-comment">/// On Windows, file paths cannot contain these characters:</span>
    <span class="tok-comment">/// '/', '*', '?', '&quot;', '&lt;', '&gt;', '|'</span>
    BadPathName,
    Unexpected,
    <span class="tok-comment">/// On Windows, `\\server` or `\\server\share` was not found.</span>
    NetworkNotFound,
    <span class="tok-comment">/// On Windows, antivirus software is enabled by default. It can be</span>
    <span class="tok-comment">/// disabled, but Windows Update sometimes ignores the user's preference</span>
    <span class="tok-comment">/// and re-enables it. When enabled, antivirus software on Windows</span>
    <span class="tok-comment">/// intercepts file system operations and makes them significantly slower</span>
    <span class="tok-comment">/// in addition to possibly failing with this error code.</span>
    AntivirusInterference,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.OpenError">OpenError</a> || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FlockError">FlockError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenMode = <span class="tok-kw">enum</span> {
    read_only,
    write_only,
    read_write,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Lock = <span class="tok-kw">enum</span> {
    none,
    shared,
    exclusive,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> OpenFlags = <span class="tok-kw">struct</span> {
    mode: <a href="std.fs.File.OpenMode.html">OpenMode</a> = .read_only,

    <span class="tok-comment">/// Open the file with an advisory lock to coordinate with other processes</span>
    <span class="tok-comment">/// accessing it at the same time. An exclusive lock will prevent other</span>
    <span class="tok-comment">/// processes from acquiring a lock. A shared lock will prevent other</span>
    <span class="tok-comment">/// processes from acquiring a exclusive lock, but does not prevent</span>
    <span class="tok-comment">/// other process from getting their own shared locks.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The lock is advisory, except on Linux in very specific circumstances[1].</span>
    <span class="tok-comment">/// This means that a process that does not respect the locking API can still get access</span>
    <span class="tok-comment">/// to the file, despite the lock.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// On these operating systems, the lock is acquired atomically with</span>
    <span class="tok-comment">/// opening the file:</span>
    <span class="tok-comment">/// * Darwin</span>
    <span class="tok-comment">/// * DragonFlyBSD</span>
    <span class="tok-comment">/// * FreeBSD</span>
    <span class="tok-comment">/// * Haiku</span>
    <span class="tok-comment">/// * NetBSD</span>
    <span class="tok-comment">/// * OpenBSD</span>
    <span class="tok-comment">/// On these operating systems, the lock is acquired via a separate syscall</span>
    <span class="tok-comment">/// after opening the file:</span>
    <span class="tok-comment">/// * Linux</span>
    <span class="tok-comment">/// * Windows</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// [1]: https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt</span>
    lock: <a href="std.fs.File.Lock.html">Lock</a> = .none,

    <span class="tok-comment">/// Sets whether or not to wait until the file is locked to return. If set to true,</span>
    <span class="tok-comment">/// `error.WouldBlock` will be returned. Otherwise, the file will wait until the file</span>
    <span class="tok-comment">/// is available to proceed.</span>
    lock_nonblocking: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// Set this to allow the opened file to automatically become the</span>
    <span class="tok-comment">/// controlling TTY for the current process.</span>
    allow_ctty: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isRead</span>(self: <a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.mode != .write_only;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isWrite</span>(self: <a href="std.fs.File.OpenFlags.html">OpenFlags</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.mode != .read_only;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CreateFlags = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Whether the file will be created with read access.</span>
    read: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// If the file already exists, and is a regular file, and the access</span>
    <span class="tok-comment">/// mode allows writing, it will be truncated to length 0.</span>
    truncate: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,

    <span class="tok-comment">/// Ensures that this open call creates the file, otherwise causes</span>
    <span class="tok-comment">/// `error.PathAlreadyExists` to be returned.</span>
    exclusive: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// Open the file with an advisory lock to coordinate with other processes</span>
    <span class="tok-comment">/// accessing it at the same time. An exclusive lock will prevent other</span>
    <span class="tok-comment">/// processes from acquiring a lock. A shared lock will prevent other</span>
    <span class="tok-comment">/// processes from acquiring a exclusive lock, but does not prevent</span>
    <span class="tok-comment">/// other process from getting their own shared locks.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The lock is advisory, except on Linux in very specific circumstances[1].</span>
    <span class="tok-comment">/// This means that a process that does not respect the locking API can still get access</span>
    <span class="tok-comment">/// to the file, despite the lock.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// On these operating systems, the lock is acquired atomically with</span>
    <span class="tok-comment">/// opening the file:</span>
    <span class="tok-comment">/// * Darwin</span>
    <span class="tok-comment">/// * DragonFlyBSD</span>
    <span class="tok-comment">/// * FreeBSD</span>
    <span class="tok-comment">/// * Haiku</span>
    <span class="tok-comment">/// * NetBSD</span>
    <span class="tok-comment">/// * OpenBSD</span>
    <span class="tok-comment">/// On these operating systems, the lock is acquired via a separate syscall</span>
    <span class="tok-comment">/// after opening the file:</span>
    <span class="tok-comment">/// * Linux</span>
    <span class="tok-comment">/// * Windows</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// [1]: https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt</span>
    lock: <a href="std.fs.File.Lock.html">Lock</a> = .none,

    <span class="tok-comment">/// Sets whether or not to wait until the file is locked to return. If set to true,</span>
    <span class="tok-comment">/// `error.WouldBlock` will be returned. Otherwise, the file will wait until the file</span>
    <span class="tok-comment">/// is available to proceed.</span>
    lock_nonblocking: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-comment">/// For POSIX systems this is the file system mode the file will</span>
    <span class="tok-comment">/// be created with. On other systems this is always 0.</span>
    mode: <a href="std.posix.html#std.posix.mode_t">Mode</a> = <a href="std.fs.File.html#std.fs.File.default_mode">default_mode</a>,
};

<span class="tok-comment">/// Upon success, the stream is in an uninitialized state. To continue using it,</span>
<span class="tok-comment">/// you must use the open() function.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">close</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.CloseHandle">CloseHandle</a>(self.handle);
    } <span class="tok-kw">else</span> {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.close">close</a>(self.handle);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SyncError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SyncError">SyncError</a>;

<span class="tok-comment">/// Blocks until all pending file contents and metadata modifications</span>
<span class="tok-comment">/// for the file have been synchronized with the underlying filesystem.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Note that this does not ensure that metadata for the</span>
<span class="tok-comment">/// directory containing the file has also reached disk.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sync</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.SyncError">SyncError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fsync">fsync</a>(self.handle);
}

<span class="tok-comment">/// Test whether the file refers to a terminal.</span>
<span class="tok-comment">/// See also `getOrEnableAnsiEscapeSupport` and `supportsAnsiEscapeCodes`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isTty</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.isatty">isatty</a>(self.handle);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isCygwinPty</span>(file: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> != .windows) <span class="tok-kw">return</span> <span class="tok-null">false</span>;

    <span class="tok-kw">const</span> handle = file.handle;<span class="tok-comment">

    // If this is a MSYS2/cygwin pty, then it will be a named pipe with a name in one of these formats:
    //   msys-[...]-ptyN-[...]
    //   cygwin-[...]-ptyN-[...]
    //
    // Example: msys-1888ae32e00d56aa-pty0-to-master

    // First, just check that the handle is a named pipe.
    // This allows us to avoid the more costly NtQueryInformationFile call
    // for handles that aren't named pipes.
    </span>{
        <span class="tok-kw">var</span> io_status: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> device_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_FS_DEVICE_INFORMATION.html">FILE_FS_DEVICE_INFORMATION</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryVolumeInformationFile">NtQueryVolumeInformationFile</a>(handle, &amp;io_status, &amp;device_info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_FS_DEVICE_INFORMATION.html">FILE_FS_DEVICE_INFORMATION</a>), .FileFsDeviceInformation);
        <span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
        }
        <span class="tok-kw">if</span> (device_info.DeviceType != <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_DEVICE_NAMED_PIPE">FILE_DEVICE_NAMED_PIPE</a>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }

    <span class="tok-kw">const</span> name_bytes_offset = <span class="tok-builtin">@offsetOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_NAME_INFO.html">FILE_NAME_INFO</a>, <span class="tok-str">&quot;FileName&quot;</span>);<span class="tok-comment">
    // `NAME_MAX` UTF-16 code units (2 bytes each)
    // This buffer may not be long enough to handle *all* possible paths
    // (PATH_MAX_WIDE would be necessary for that), but because we only care
    // about certain paths and we know they must be within a reasonable length,
    // we can use this smaller buffer and just return false on any error from
    // NtQueryInformationFile.
    </span><span class="tok-kw">const</span> num_name_bytes = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.MAX_PATH">MAX_PATH</a> * <span class="tok-number">2</span>;
    <span class="tok-kw">var</span> name_info_bytes <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_NAME_INFO.html">FILE_NAME_INFO</a>)) = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** (name_bytes_offset + num_name_bytes);

    <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(handle, &amp;io_status_block, &amp;name_info_bytes, <span class="tok-builtin">@intCast</span>(name_info_bytes.len), .FileNameInformation);
    <span class="tok-kw">switch</span> (rc) {
        .SUCCESS =&gt; {},
        .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    }

    <span class="tok-kw">const</span> name_info: *<span class="tok-kw">const</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_NAME_INFO.html">FILE_NAME_INFO</a> = <span class="tok-builtin">@ptrCast</span>(&amp;name_info_bytes);
    <span class="tok-kw">const</span> name_bytes = name_info_bytes[name_bytes_offset .. name_bytes_offset + name_info.FileNameLength];
    <span class="tok-kw">const</span> name_wide = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.bytesAsSlice">bytesAsSlice</a>(<span class="tok-type">u16</span>, name_bytes);<span class="tok-comment">
    // The name we get from NtQueryInformationFile will be prefixed with a '\', e.g. \msys-1888ae32e00d56aa-pty0-to-master
    </span><span class="tok-kw">return</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u16</span>, name_wide, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'\\'</span>, <span class="tok-str">'m'</span>, <span class="tok-str">'s'</span>, <span class="tok-str">'y'</span>, <span class="tok-str">'s'</span>, <span class="tok-str">'-'</span> }) <span class="tok-kw">or</span>
        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.startsWith">startsWith</a>(<span class="tok-type">u16</span>, name_wide, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'\\'</span>, <span class="tok-str">'c'</span>, <span class="tok-str">'y'</span>, <span class="tok-str">'g'</span>, <span class="tok-str">'w'</span>, <span class="tok-str">'i'</span>, <span class="tok-str">'n'</span>, <span class="tok-str">'-'</span> })) <span class="tok-kw">and</span>
        <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOf">indexOf</a>(<span class="tok-type">u16</span>, name_wide, &amp;[_]<span class="tok-type">u16</span>{ <span class="tok-str">'-'</span>, <span class="tok-str">'p'</span>, <span class="tok-str">'t'</span>, <span class="tok-str">'y'</span> }) != <span class="tok-null">null</span>;
}

<span class="tok-comment">/// Returns whether or not ANSI escape codes will be treated as such,</span>
<span class="tok-comment">/// and attempts to enable support for ANSI escape codes if necessary</span>
<span class="tok-comment">/// (on Windows).</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Returns `true` if ANSI escape codes are supported or support was</span>
<span class="tok-comment">/// successfully enabled. Returns false if ANSI escape codes are not</span>
<span class="tok-comment">/// supported or support was unable to be enabled.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also `supportsAnsiEscapeCodes`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrEnableAnsiEscapeSupport</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">var</span> original_console_mode: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-number">0</span>;<span class="tok-comment">

        // For Windows Terminal, VT Sequences processing is enabled by default.
        </span><span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleMode">GetConsoleMode</a>(self.handle, &amp;original_console_mode) != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (original_console_mode &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING">ENABLE_VIRTUAL_TERMINAL_PROCESSING</a> != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;<span class="tok-comment">

            // For Windows Console, VT Sequences processing support was added in Windows 10 build 14361, but disabled by default.
            // https://devblogs.microsoft.com/commandline/tmux-support-arrives-for-bash-on-ubuntu-on-windows/
            //
            // Note: In Microsoft's example for enabling virtual terminal processing, it
            // shows attempting to enable `DISABLE_NEWLINE_AUTO_RETURN` as well:
            // https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#example-of-enabling-virtual-terminal-processing
            // This is avoided because in the old Windows Console, that flag causes \n (as opposed to \r\n)
            // to behave unexpectedly (the cursor moves down 1 row but remains on the same column).
            // Additionally, the default console mode in Windows Terminal does not have
            // `DISABLE_NEWLINE_AUTO_RETURN` set, so by only enabling `ENABLE_VIRTUAL_TERMINAL_PROCESSING`
            // we end up matching the mode of Windows Terminal.
            </span><span class="tok-kw">const</span> requested_console_modes = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING">ENABLE_VIRTUAL_TERMINAL_PROCESSING</a>;
            <span class="tok-kw">const</span> console_mode = original_console_mode | requested_console_modes;
            <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.SetConsoleMode">SetConsoleMode</a>(self.handle, console_mode) != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">return</span> self.isCygwinPty();
    }
    <span class="tok-kw">return</span> self.supportsAnsiEscapeCodes();
}

<span class="tok-comment">/// Test whether ANSI escape codes will be treated as such without</span>
<span class="tok-comment">/// attempting to enable support for ANSI escape codes.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See also `getOrEnableAnsiEscapeSupport`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">supportsAnsiEscapeCodes</span>(self: <a href="std.fs.File.html">File</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">var</span> console_mode: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = <span class="tok-number">0</span>;
        <span class="tok-kw">if</span> (<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.kernel32.html">kernel32</a>.<a href="std.os.windows.kernel32.html#std.os.windows.kernel32.GetConsoleMode">GetConsoleMode</a>(self.handle, &amp;console_mode) != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (console_mode &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING">ENABLE_VIRTUAL_TERMINAL_PROCESSING</a> != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">return</span> self.isCygwinPty();
    }
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi) {<span class="tok-comment">
        // WASI sanitizes stdout when fd is a tty so ANSI escape codes
        // will not be interpreted as actual cursor commands, and
        // stderr is always sanitized.
        </span><span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
    <span class="tok-kw">if</span> (self.isTty()) {
        <span class="tok-kw">if</span> (self.handle == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDOUT_FILENO">STDOUT_FILENO</a> <span class="tok-kw">or</span> self.handle == <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.STDERR_FILENO">STDERR_FILENO</a>) {
            <span class="tok-kw">if</span> (<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.getenvZ">getenvZ</a>(<span class="tok-str">&quot;TERM&quot;</span>)) |term| {
                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, term, <span class="tok-str">&quot;dumb&quot;</span>))
                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
    }
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetEndPosError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.TruncateError">TruncateError</a>;

<span class="tok-comment">/// Shrinks or expands the file.</span>
<span class="tok-comment">/// The file offset after this call is left unchanged.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setEndPos</span>(self: <a href="std.fs.File.html">File</a>, length: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.TruncateError">SetEndPosError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ftruncate">ftruncate</a>(self.handle, length);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SeekError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SeekError">SeekError</a>;

<span class="tok-comment">/// Repositions read/write file offset relative to the current offset.</span>
<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekBy</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_CUR">lseek_CUR</a>(self.handle, offset);
}

<span class="tok-comment">/// Repositions read/write file offset relative to the end.</span>
<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekFromEnd</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">i64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_END">lseek_END</a>(self.handle, offset);
}

<span class="tok-comment">/// Repositions read/write file offset relative to the beginning.</span>
<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekTo</span>(self: <a href="std.fs.File.html">File</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.SeekError">SeekError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_SET">lseek_SET</a>(self.handle, offset);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetSeekPosError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SeekError">SeekError</a> || <a href="std.posix.html#std.posix.FStatError">StatError</a>;

<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPos</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.lseek_CUR_get">lseek_CUR_get</a>(self.handle);
}

<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEndPos</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.GetFileSizeEx">GetFileSizeEx</a>(self.handle);
    }
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.stat()).size;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ModeError = <a href="std.posix.html#std.posix.FStatError">StatError</a>;

<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">mode</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">ModeError</a>!<a href="std.posix.html#std.posix.mode_t">Mode</a> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    }
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.stat()).mode;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Stat = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// A number that the system uses to point to the file metadata. This</span>
    <span class="tok-comment">/// number is not guaranteed to be unique across time, as some file</span>
    <span class="tok-comment">/// systems may reuse an inode after its file has been deleted. Some</span>
    <span class="tok-comment">/// systems may change the inode of a file over time.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// On Linux, the inode is a structure that stores the metadata, and</span>
    <span class="tok-comment">/// the inode _number_ is what you see here: the index number of the</span>
    <span class="tok-comment">/// inode.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The FileIndex on Windows is similar. It is a number for a file that</span>
    <span class="tok-comment">/// is unique to each filesystem.</span>
    inode: <a href="std.posix.html#std.posix.ino_t">INode</a>,
    size: <span class="tok-type">u64</span>,
    <span class="tok-comment">/// This is available on POSIX systems and is always 0 otherwise.</span>
    mode: <a href="std.posix.html#std.posix.mode_t">Mode</a>,
    kind: <a href="std.fs.File.Kind.html">Kind</a>,

    <span class="tok-comment">/// Last access time in nanoseconds, relative to UTC 1970-01-01.</span>
    atime: <span class="tok-type">i128</span>,
    <span class="tok-comment">/// Last modification time in nanoseconds, relative to UTC 1970-01-01.</span>
    mtime: <span class="tok-type">i128</span>,
    <span class="tok-comment">/// Last status/metadata change time in nanoseconds, relative to UTC 1970-01-01.</span>
    ctime: <span class="tok-type">i128</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromPosix</span>(st: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Stat">Stat</a>) <a href="std.fs.File.Stat.html">Stat</a> {
        <span class="tok-kw">const</span> atime = st.atime();
        <span class="tok-kw">const</span> mtime = st.mtime();
        <span class="tok-kw">const</span> ctime = st.ctime();
        <span class="tok-kw">return</span> .{
            .inode = st.ino,
            .size = <span class="tok-builtin">@bitCast</span>(st.size),
            .mode = st.mode,
            .kind = k: {
                <span class="tok-kw">const</span> m = st.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>;
                <span class="tok-kw">switch</span> (m) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFBLK</a> =&gt; <span class="tok-kw">break</span> :k .block_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFCHR</a> =&gt; <span class="tok-kw">break</span> :k .character_device,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a> =&gt; <span class="tok-kw">break</span> :k .directory,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFIFO</a> =&gt; <span class="tok-kw">break</span> :k .named_pipe,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a> =&gt; <span class="tok-kw">break</span> :k .sym_link,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFREG</a> =&gt; <span class="tok-kw">break</span> :k .file,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFSOCK</a> =&gt; <span class="tok-kw">break</span> :k .unix_domain_socket,
                    <span class="tok-kw">else</span> =&gt; {},
                }
                <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>.<a href="#">isSolarish</a>()) <span class="tok-kw">switch</span> (m) {
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDOOR</a> =&gt; <span class="tok-kw">break</span> :k .door,
                    <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFPORT</a> =&gt; <span class="tok-kw">break</span> :k .event_port,
                    <span class="tok-kw">else</span> =&gt; {},
                };

                <span class="tok-kw">break</span> :k .unknown;
            },
            .atime = <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, atime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + atime.nsec,
            .mtime = <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, mtime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + mtime.nsec,
            .ctime = <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, ctime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + ctime.nsec,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromLinux</span>(stx: <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>) <a href="std.fs.File.Stat.html">Stat</a> {
        <span class="tok-kw">const</span> atime = stx.atime;
        <span class="tok-kw">const</span> mtime = stx.mtime;
        <span class="tok-kw">const</span> ctime = stx.ctime;

        <span class="tok-kw">return</span> .{
            .inode = stx.ino,
            .size = stx.size,
            .mode = stx.mode,
            .kind = <span class="tok-kw">switch</span> (stx.mode &amp; <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.S.html">S</a>.<a href="std.os.linux.S.html#std.os.linux.S.IFMT">IFMT</a>) {
                <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.S.html">S</a>.<a href="std.os.linux.S.html#std.os.linux.S.IFDIR">IFDIR</a> =&gt; .directory,
                <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.S.html">S</a>.<a href="std.os.linux.S.html#std.os.linux.S.IFCHR">IFCHR</a> =&gt; .character_device,
                <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.S.html">S</a>.<a href="std.os.linux.S.html#std.os.linux.S.IFBLK">IFBLK</a> =&gt; .block_device,
                <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.S.html">S</a>.<a href="std.os.linux.S.html#std.os.linux.S.IFREG">IFREG</a> =&gt; .file,
                <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.S.html">S</a>.<a href="std.os.linux.S.html#std.os.linux.S.IFIFO">IFIFO</a> =&gt; .named_pipe,
                <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.S.html">S</a>.<a href="std.os.linux.S.html#std.os.linux.S.IFLNK">IFLNK</a> =&gt; .sym_link,
                <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.S.html">S</a>.<a href="std.os.linux.S.html#std.os.linux.S.IFSOCK">IFSOCK</a> =&gt; .unix_domain_socket,
                <span class="tok-kw">else</span> =&gt; .unknown,
            },
            .atime = <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, atime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + atime.nsec,
            .mtime = <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, mtime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + mtime.nsec,
            .ctime = <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, ctime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + ctime.nsec,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromWasi</span>(st: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.filestat_t.html">filestat_t</a>) <a href="std.fs.File.Stat.html">Stat</a> {
        <span class="tok-kw">return</span> .{
            .inode = st.ino,
            .size = <span class="tok-builtin">@bitCast</span>(st.size),
            .mode = <span class="tok-number">0</span>,
            .kind = <span class="tok-kw">switch</span> (st.filetype) {
                .BLOCK_DEVICE =&gt; .block_device,
                .CHARACTER_DEVICE =&gt; .character_device,
                .DIRECTORY =&gt; .directory,
                .SYMBOLIC_LINK =&gt; .sym_link,
                .REGULAR_FILE =&gt; .file,
                .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,
                <span class="tok-kw">else</span> =&gt; .unknown,
            },
            .atime = st.atim,
            .mtime = st.mtim,
            .ctime = st.ctim,
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StatError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FStatError">FStatError</a>;

<span class="tok-comment">/// Returns `Stat` containing basic information about the `File`.</span>
<span class="tok-comment">/// Use `metadata` to retrieve more detailed information (e.g. creation time, permissions).</span>
<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stat</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">StatError</a>!<a href="std.fs.File.Stat.html">Stat</a> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ALL_INFORMATION.html">FILE_ALL_INFORMATION</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(self.handle, &amp;io_status_block, &amp;info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ALL_INFORMATION.html">FILE_ALL_INFORMATION</a>), .FileAllInformation);
        <span class="tok-kw">switch</span> (rc) {
            .SUCCESS =&gt; {},<span class="tok-comment">
            // Buffer overflow here indicates that there is more information available than was able to be stored in the buffer
            // size provided. This is treated as success because the type of variable-length information that this would be relevant for
            // (name, volume name, etc) we don't care about.
            </span>.BUFFER_OVERFLOW =&gt; {},
            .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
        }
        <span class="tok-kw">return</span> .{
            .inode = info.InternalInformation.IndexNumber,
            .size = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(info.StandardInformation.EndOfFile)),
            .mode = <span class="tok-number">0</span>,
            .kind = <span class="tok-kw">if</span> (info.BasicInformation.FileAttributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_REPARSE_POINT">FILE_ATTRIBUTE_REPARSE_POINT</a> != <span class="tok-number">0</span>) reparse_point: {
                <span class="tok-kw">var</span> tag_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ATTRIBUTE_TAG_INFO.html">FILE_ATTRIBUTE_TAG_INFO</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> tag_rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(self.handle, &amp;io_status_block, &amp;tag_info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ATTRIBUTE_TAG_INFO.html">FILE_ATTRIBUTE_TAG_INFO</a>), .FileAttributeTagInformation);
                <span class="tok-kw">switch</span> (tag_rc) {
                    .SUCCESS =&gt; {},<span class="tok-comment">
                    // INFO_LENGTH_MISMATCH and ACCESS_DENIED are the only documented possible errors
                    // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/d295752f-ce89-4b98-8553-266d37c84f0e
                    </span>.INFO_LENGTH_MISMATCH =&gt; <span class="tok-kw">unreachable</span>,
                    .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
                }
                <span class="tok-kw">if</span> (tag_info.ReparseTag &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.reparse_tag_name_surrogate_bit">reparse_tag_name_surrogate_bit</a> != <span class="tok-number">0</span>) {
                    <span class="tok-kw">break</span> :reparse_point .sym_link;
                }<span class="tok-comment">
                // Unknown reparse point
                </span><span class="tok-kw">break</span> :reparse_point .unknown;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (info.BasicInformation.FileAttributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_DIRECTORY">FILE_ATTRIBUTE_DIRECTORY</a> != <span class="tok-number">0</span>)
                .directory
            <span class="tok-kw">else</span>
                .file,
            .atime = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.LastAccessTime),
            .mtime = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.LastWriteTime),
            .ctime = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.ChangeTime),
        };
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) {
        <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstat_wasi">fstat_wasi</a>(self.handle);
        <span class="tok-kw">return</span> <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromWasi">fromWasi</a>(st);
    }

    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .linux) {
        <span class="tok-kw">var</span> stx = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>);

        <span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.statx">statx</a>(
            self.handle,
            <span class="tok-str">&quot;&quot;</span>,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AT.html">AT</a>.<a href="std.os.linux.AT.html#std.os.linux.AT.EMPTY_PATH">EMPTY_PATH</a>,
            <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_TYPE">STATX_TYPE</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_MODE">STATX_MODE</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_ATIME">STATX_ATIME</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_MTIME">STATX_MTIME</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_CTIME">STATX_CTIME</a>,
            &amp;stx,
        );

        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
            .SUCCESS =&gt; <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromLinux">fromLinux</a>(stx),
            .ACCES =&gt; <span class="tok-kw">unreachable</span>,
            .BADF =&gt; <span class="tok-kw">unreachable</span>,
            .FAULT =&gt; <span class="tok-kw">unreachable</span>,
            .INVAL =&gt; <span class="tok-kw">unreachable</span>,
            .LOOP =&gt; <span class="tok-kw">unreachable</span>,
            .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,
            .NOENT =&gt; <span class="tok-kw">unreachable</span>,
            .NOMEM =&gt; <span class="tok-kw">error</span>.SystemResources,
            .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; |err| <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
        };
    }

    <span class="tok-kw">const</span> st = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstat">fstat</a>(self.handle);
    <span class="tok-kw">return</span> <a href="std.fs.File.Stat.html">Stat</a>.<a href="std.fs.File.Stat.html#std.fs.File.Stat.fromPosix">fromPosix</a>(st);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChmodError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FChmodError">FChmodError</a>;

<span class="tok-comment">/// Changes the mode of the file.</span>
<span class="tok-comment">/// The process must have the correct privileges in order to do this</span>
<span class="tok-comment">/// successfully, or must have the effective user ID matching the owner</span>
<span class="tok-comment">/// of the file.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chmod</span>(self: <a href="std.fs.File.html">File</a>, new_mode: <a href="std.posix.html#std.posix.mode_t">Mode</a>) <a href="std.posix.html#std.posix.FChmodError">ChmodError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fchmod">fchmod</a>(self.handle, new_mode);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ChownError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FChownError">FChownError</a>;

<span class="tok-comment">/// Changes the owner and group of the file.</span>
<span class="tok-comment">/// The process must have the correct privileges in order to do this</span>
<span class="tok-comment">/// successfully. The group may be changed by the owner of the file to</span>
<span class="tok-comment">/// any group of which the owner is a member. If the owner or group is</span>
<span class="tok-comment">/// specified as `null`, the ID is not changed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">chown</span>(self: <a href="std.fs.File.html">File</a>, owner: ?<a href="std.posix.html#std.posix.uid_t">Uid</a>, group: ?<a href="std.posix.html#std.posix.gid_t">Gid</a>) <a href="std.posix.html#std.posix.FChownError">ChownError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fchown">fchown</a>(self.handle, owner, group);
}

<span class="tok-comment">/// Cross-platform representation of permissions on a file.</span>
<span class="tok-comment">/// The `readonly` and `setReadonly` are the only methods available across all platforms.</span>
<span class="tok-comment">/// Platform-specific functionality is available through the `inner` field.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Permissions = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// You may use the `inner` field to use platform-specific functionality</span>
    inner: <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .windows =&gt; <a href="std.fs.File.PermissionsWindows.html">PermissionsWindows</a>,
        <span class="tok-kw">else</span> =&gt; <a href="std.fs.File.PermissionsUnix.html">PermissionsUnix</a>,
    },

    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// Returns `true` if permissions represent an unwritable file.</span>
    <span class="tok-comment">/// On Unix, `true` is returned only if no class has write permissions.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOnly</span>(self: <a href="std.fs.File.Permissions.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.inner.readOnly();
    }

    <span class="tok-comment">/// Sets whether write permissions are provided.</span>
    <span class="tok-comment">/// On Unix, this affects *all* classes. If this is undesired, use `unixSet`.</span>
    <span class="tok-comment">/// This method *DOES NOT* set permissions on the filesystem: use `File.setPermissions(permissions)`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setReadOnly</span>(self: *<a href="std.fs.File.Permissions.html">Self</a>, read_only: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        self.inner.setReadOnly(read_only);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PermissionsWindows = <span class="tok-kw">struct</span> {
    attributes: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a>,

    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// Returns `true` if permissions represent an unwritable file.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOnly</span>(self: <a href="std.fs.File.PermissionsWindows.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.attributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_READONLY">FILE_ATTRIBUTE_READONLY</a> != <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Sets whether write permissions are provided.</span>
    <span class="tok-comment">/// This method *DOES NOT* set permissions on the filesystem: use `File.setPermissions(permissions)`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setReadOnly</span>(self: *<a href="std.fs.File.PermissionsWindows.html">Self</a>, read_only: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (read_only) {
            self.attributes |= <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_READONLY">FILE_ATTRIBUTE_READONLY</a>;
        } <span class="tok-kw">else</span> {
            self.attributes &amp;= ~<span class="tok-builtin">@as</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a>, <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_READONLY">FILE_ATTRIBUTE_READONLY</a>);
        }
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PermissionsUnix = <span class="tok-kw">struct</span> {
    mode: <a href="std.posix.html#std.posix.mode_t">Mode</a>,

    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// Returns `true` if permissions represent an unwritable file.</span>
    <span class="tok-comment">/// `true` is returned only if no class has write permissions.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readOnly</span>(self: <a href="std.fs.File.PermissionsUnix.html">Self</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self.mode &amp; <span class="tok-number">0o222</span> == <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Sets whether write permissions are provided.</span>
    <span class="tok-comment">/// This affects *all* classes. If this is undesired, use `unixSet`.</span>
    <span class="tok-comment">/// This method *DOES NOT* set permissions on the filesystem: use `File.setPermissions(permissions)`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setReadOnly</span>(self: *<a href="std.fs.File.PermissionsUnix.html">Self</a>, read_only: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (read_only) {
            self.mode &amp;= ~<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-number">0o222</span>);
        } <span class="tok-kw">else</span> {
            self.mode |= <span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-number">0o222</span>);
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Class = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
        user = <span class="tok-number">2</span>,
        group = <span class="tok-number">1</span>,
        other = <span class="tok-number">0</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Permission = <span class="tok-kw">enum</span>(<span class="tok-type">u3</span>) {
        <a href="std.fs.File.html#std.fs.File.read">read</a> = <span class="tok-number">0o4</span>,
        <a href="std.fs.File.html#std.fs.File.write">write</a> = <span class="tok-number">0o2</span>,
        execute = <span class="tok-number">0o1</span>,
    };

    <span class="tok-comment">/// Returns `true` if the chosen class has the selected permission.</span>
    <span class="tok-comment">/// This method is only available on Unix platforms.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unixHas</span>(self: <a href="std.fs.File.PermissionsUnix.html">Self</a>, class: <a href="std.fs.File.PermissionsUnix.Class.html">Class</a>, permission: <a href="std.fs.File.PermissionsUnix.Permission.html">Permission</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">const</span> mask = <span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-builtin">@intFromEnum</span>(permission)) &lt;&lt; <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intFromEnum</span>(class)) * <span class="tok-number">3</span>;
        <span class="tok-kw">return</span> self.mode &amp; mask != <span class="tok-number">0</span>;
    }

    <span class="tok-comment">/// Sets the permissions for the chosen class. Any permissions set to `null` are left unchanged.</span>
    <span class="tok-comment">/// This method *DOES NOT* set permissions on the filesystem: use `File.setPermissions(permissions)`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unixSet</span>(self: *<a href="std.fs.File.PermissionsUnix.html">Self</a>, class: <a href="std.fs.File.PermissionsUnix.Class.html">Class</a>, permissions: <span class="tok-kw">struct</span> {
        read: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
        write: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
        execute: ?<span class="tok-type">bool</span> = <span class="tok-null">null</span>,
    }) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> shift = <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intFromEnum</span>(class)) * <span class="tok-number">3</span>;
        <span class="tok-kw">if</span> (permissions.read) |r| {
            <span class="tok-kw">if</span> (r) {
                self.mode |= <span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-number">0o4</span>) &lt;&lt; shift;
            } <span class="tok-kw">else</span> {
                self.mode &amp;= ~(<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-number">0o4</span>) &lt;&lt; shift);
            }
        }
        <span class="tok-kw">if</span> (permissions.write) |w| {
            <span class="tok-kw">if</span> (w) {
                self.mode |= <span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-number">0o2</span>) &lt;&lt; shift;
            } <span class="tok-kw">else</span> {
                self.mode &amp;= ~(<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-number">0o2</span>) &lt;&lt; shift);
            }
        }
        <span class="tok-kw">if</span> (permissions.execute) |x| {
            <span class="tok-kw">if</span> (x) {
                self.mode |= <span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-number">0o1</span>) &lt;&lt; shift;
            } <span class="tok-kw">else</span> {
                self.mode &amp;= ~(<span class="tok-builtin">@as</span>(<a href="std.posix.html#std.posix.mode_t">Mode</a>, <span class="tok-number">0o1</span>) &lt;&lt; shift);
            }
        }
    }

    <span class="tok-comment">/// Returns a `Permissions` struct representing the permissions from the passed mode.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unixNew</span>(new_mode: <a href="std.posix.html#std.posix.mode_t">Mode</a>) <a href="std.fs.File.PermissionsUnix.html">Self</a> {
        <span class="tok-kw">return</span> <a href="std.fs.File.PermissionsUnix.html">Self</a>{
            .mode = new_mode,
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SetPermissionsError = <a href="std.posix.html#std.posix.FChmodError">ChmodError</a>;

<span class="tok-comment">/// Sets permissions according to the provided `Permissions` struct.</span>
<span class="tok-comment">/// This method is *NOT* available on WASI</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setPermissions</span>(self: <a href="std.fs.File.html">File</a>, permissions: <a href="std.fs.File.Permissions.html">Permissions</a>) <a href="std.posix.html#std.posix.FChmodError">SetPermissionsError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .windows =&gt; {
            <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">var</span> info = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_BASIC_INFORMATION.html">FILE_BASIC_INFORMATION</a>{
                .CreationTime = <span class="tok-number">0</span>,
                .LastAccessTime = <span class="tok-number">0</span>,
                .LastWriteTime = <span class="tok-number">0</span>,
                .ChangeTime = <span class="tok-number">0</span>,
                .FileAttributes = permissions.inner.attributes,
            };
            <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtSetInformationFile">NtSetInformationFile</a>(
                self.handle,
                &amp;io_status_block,
                &amp;info,
                <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_BASIC_INFORMATION.html">FILE_BASIC_INFORMATION</a>),
                .FileBasicInformation,
            );
            <span class="tok-kw">switch</span> (rc) {
                .SUCCESS =&gt; <span class="tok-kw">return</span>,
                .INVALID_HANDLE =&gt; <span class="tok-kw">unreachable</span>,
                .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
            }
        },
        .wasi =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unsupported OS&quot;</span>),<span class="tok-comment"> // Wasi filesystem does not *yet* support chmod
        </span><span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">try</span> self.chmod(permissions.inner.mode);
        },
    }
}

<span class="tok-comment">/// Cross-platform representation of file metadata.</span>
<span class="tok-comment">/// Platform-specific functionality is available through the `inner` field.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Metadata = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Exposes platform-specific functionality.</span>
    inner: <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
        .windows =&gt; <a href="std.fs.File.MetadataWindows.html">MetadataWindows</a>,
        .linux =&gt; <a href="std.fs.File.MetadataLinux.html">MetadataLinux</a>,
        .wasi =&gt; <a href="std.fs.File.MetadataWasi.html">MetadataWasi</a>,
        <span class="tok-kw">else</span> =&gt; <a href="std.fs.File.MetadataUnix.html">MetadataUnix</a>,
    },

    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// Returns the size of the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">size</span>(self: <a href="std.fs.File.Metadata.html">Self</a>) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> self.inner.size();
    }

    <span class="tok-comment">/// Returns a `Permissions` struct, representing the permissions on the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">permissions</span>(self: <a href="std.fs.File.Metadata.html">Self</a>) <a href="std.fs.File.Permissions.html">Permissions</a> {
        <span class="tok-kw">return</span> self.inner.permissions();
    }

    <span class="tok-comment">/// Returns the `Kind` of file.</span>
    <span class="tok-comment">/// On Windows, can only return: `.file`, `.directory`, `.sym_link` or `.unknown`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kind</span>(self: <a href="std.fs.File.Metadata.html">Self</a>) <a href="std.fs.File.Kind.html">Kind</a> {
        <span class="tok-kw">return</span> self.inner.kind();
    }

    <span class="tok-comment">/// Returns the last time the file was accessed in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessed</span>(self: <a href="std.fs.File.Metadata.html">Self</a>) <span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.inner.accessed();
    }

    <span class="tok-comment">/// Returns the time the file was modified in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">modified</span>(self: <a href="std.fs.File.Metadata.html">Self</a>) <span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.inner.modified();
    }

    <span class="tok-comment">/// Returns the time the file was created in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-comment">/// On Windows, this cannot return null</span>
    <span class="tok-comment">/// On Linux, this returns null if the filesystem does not support creation times</span>
    <span class="tok-comment">/// On Unices, this returns null if the filesystem or OS does not support creation times</span>
    <span class="tok-comment">/// On MacOS, this returns the ctime if the filesystem does not support creation times; this is insanity, and yet another reason to hate on Apple</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">created</span>(self: <a href="std.fs.File.Metadata.html">Self</a>) ?<span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.inner.created();
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataUnix = <span class="tok-kw">struct</span> {
    stat: <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.Stat">Stat</a>,

    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// Returns the size of the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">size</span>(self: <a href="std.fs.File.MetadataUnix.html">Self</a>) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(self.stat.size);
    }

    <span class="tok-comment">/// Returns a `Permissions` struct, representing the permissions on the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">permissions</span>(self: <a href="std.fs.File.MetadataUnix.html">Self</a>) <a href="std.fs.File.Permissions.html">Permissions</a> {
        <span class="tok-kw">return</span> .{ .inner = .{ .mode = self.stat.mode } };
    }

    <span class="tok-comment">/// Returns the `Kind` of the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kind</span>(self: <a href="std.fs.File.MetadataUnix.html">Self</a>) <a href="std.fs.File.Kind.html">Kind</a> {
        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .wasi <span class="tok-kw">and</span> !<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.link_libc">link_libc</a>) <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.stat.filetype) {
            .BLOCK_DEVICE =&gt; .block_device,
            .CHARACTER_DEVICE =&gt; .character_device,
            .DIRECTORY =&gt; .directory,
            .SYMBOLIC_LINK =&gt; .sym_link,
            .REGULAR_FILE =&gt; .file,
            .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,
            <span class="tok-kw">else</span> =&gt; .unknown,
        };

        <span class="tok-kw">const</span> m = self.stat.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>;

        <span class="tok-kw">switch</span> (m) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFBLK</a> =&gt; <span class="tok-kw">return</span> .block_device,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFCHR</a> =&gt; <span class="tok-kw">return</span> .character_device,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a> =&gt; <span class="tok-kw">return</span> .directory,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFIFO</a> =&gt; <span class="tok-kw">return</span> .named_pipe,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a> =&gt; <span class="tok-kw">return</span> .sym_link,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFREG</a> =&gt; <span class="tok-kw">return</span> .file,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFSOCK</a> =&gt; <span class="tok-kw">return</span> .unix_domain_socket,
            <span class="tok-kw">else</span> =&gt; {},
        }

        <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>.<a href="#">isSolarish</a>()) <span class="tok-kw">switch</span> (m) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDOOR</a> =&gt; <span class="tok-kw">return</span> .door,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFPORT</a> =&gt; <span class="tok-kw">return</span> .event_port,
            <span class="tok-kw">else</span> =&gt; {},
        };

        <span class="tok-kw">return</span> .unknown;
    }

    <span class="tok-comment">/// Returns the last time the file was accessed in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessed</span>(self: <a href="std.fs.File.MetadataUnix.html">Self</a>) <span class="tok-type">i128</span> {
        <span class="tok-kw">const</span> atime = self.stat.atime();
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, atime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + atime.nsec;
    }

    <span class="tok-comment">/// Returns the last time the file was modified in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">modified</span>(self: <a href="std.fs.File.MetadataUnix.html">Self</a>) <span class="tok-type">i128</span> {
        <span class="tok-kw">const</span> mtime = self.stat.mtime();
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, mtime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + mtime.nsec;
    }

    <span class="tok-comment">/// Returns the time the file was created in nanoseconds since UTC 1970-01-01.</span>
    <span class="tok-comment">/// Returns null if this is not supported by the OS or filesystem</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">created</span>(self: <a href="std.fs.File.MetadataUnix.html">Self</a>) ?<span class="tok-type">i128</span> {
        <span class="tok-kw">if</span> (!<span class="tok-builtin">@hasDecl</span>(<span class="tok-builtin">@TypeOf</span>(self.stat), <span class="tok-str">&quot;birthtime&quot;</span>)) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> birthtime = self.stat.birthtime();<span class="tok-comment">

        // If the filesystem doesn't support this the value *should* be:
        // On FreeBSD: nsec = 0, sec = -1
        // On NetBSD and OpenBSD: nsec = 0, sec = 0
        // On MacOS, it is set to ctime -- we cannot detect this!!
        </span><span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
            .freebsd =&gt; <span class="tok-kw">if</span> (birthtime.sec == -<span class="tok-number">1</span> <span class="tok-kw">and</span> birthtime.nsec == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>,
            .netbsd, .openbsd =&gt; <span class="tok-kw">if</span> (birthtime.sec == <span class="tok-number">0</span> <span class="tok-kw">and</span> birthtime.nsec == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>,
            .macos =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Creation time detection not implemented for OS&quot;</span>),
        }

        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, birthtime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + birthtime.nsec;
    }
};

<span class="tok-comment">/// `MetadataUnix`, but using Linux's `statx` syscall.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataLinux = <span class="tok-kw">struct</span> {
    statx: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>,

    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// Returns the size of the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">size</span>(self: <a href="std.fs.File.MetadataLinux.html">Self</a>) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> self.statx.size;
    }

    <span class="tok-comment">/// Returns a `Permissions` struct, representing the permissions on the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">permissions</span>(self: <a href="std.fs.File.MetadataLinux.html">Self</a>) <a href="std.fs.File.Permissions.html">Permissions</a> {
        <span class="tok-kw">return</span> <a href="std.fs.File.Permissions.html">Permissions</a>{ .inner = <a href="std.fs.File.PermissionsUnix.html">PermissionsUnix</a>{ .mode = self.statx.mode } };
    }

    <span class="tok-comment">/// Returns the `Kind` of the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kind</span>(self: <a href="std.fs.File.MetadataLinux.html">Self</a>) <a href="std.fs.File.Kind.html">Kind</a> {
        <span class="tok-kw">const</span> m = self.statx.mode &amp; <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFMT</a>;

        <span class="tok-kw">switch</span> (m) {
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFBLK</a> =&gt; <span class="tok-kw">return</span> .block_device,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFCHR</a> =&gt; <span class="tok-kw">return</span> .character_device,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFDIR</a> =&gt; <span class="tok-kw">return</span> .directory,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFIFO</a> =&gt; <span class="tok-kw">return</span> .named_pipe,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFLNK</a> =&gt; <span class="tok-kw">return</span> .sym_link,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFREG</a> =&gt; <span class="tok-kw">return</span> .file,
            <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.S">S</a>.<a href="#">IFSOCK</a> =&gt; <span class="tok-kw">return</span> .unix_domain_socket,
            <span class="tok-kw">else</span> =&gt; {},
        }

        <span class="tok-kw">return</span> .unknown;
    }

    <span class="tok-comment">/// Returns the last time the file was accessed in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessed</span>(self: <a href="std.fs.File.MetadataLinux.html">Self</a>) <span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, self.statx.atime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + self.statx.atime.nsec;
    }

    <span class="tok-comment">/// Returns the last time the file was modified in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">modified</span>(self: <a href="std.fs.File.MetadataLinux.html">Self</a>) <span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, self.statx.mtime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + self.statx.mtime.nsec;
    }

    <span class="tok-comment">/// Returns the time the file was created in nanoseconds since UTC 1970-01-01.</span>
    <span class="tok-comment">/// Returns null if this is not supported by the filesystem, or on kernels before than version 4.11</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">created</span>(self: <a href="std.fs.File.MetadataLinux.html">Self</a>) ?<span class="tok-type">i128</span> {
        <span class="tok-kw">if</span> (self.statx.mask &amp; <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_BTIME">STATX_BTIME</a> == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">i128</span>, self.statx.btime.sec) * <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a> + self.statx.btime.nsec;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataWasi = <span class="tok-kw">struct</span> {
    stat: <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.wasi.html">wasi</a>.<a href="std.os.wasi.filestat_t.html">filestat_t</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">size</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> self.stat.size;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">permissions</span>(self: <span class="tok-builtin">@This</span>()) <a href="std.fs.File.Permissions.html">Permissions</a> {
        <span class="tok-kw">return</span> .{ .inner = .{ .mode = self.stat.mode } };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kind</span>(self: <span class="tok-builtin">@This</span>()) <a href="std.fs.File.Kind.html">Kind</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.stat.filetype) {
            .BLOCK_DEVICE =&gt; .block_device,
            .CHARACTER_DEVICE =&gt; .character_device,
            .DIRECTORY =&gt; .directory,
            .SYMBOLIC_LINK =&gt; .sym_link,
            .REGULAR_FILE =&gt; .file,
            .SOCKET_STREAM, .SOCKET_DGRAM =&gt; .unix_domain_socket,
            <span class="tok-kw">else</span> =&gt; .unknown,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessed</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.stat.atim;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">modified</span>(self: <span class="tok-builtin">@This</span>()) <span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.stat.mtim;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">created</span>(self: <span class="tok-builtin">@This</span>()) ?<span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.stat.ctim;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataWindows = <span class="tok-kw">struct</span> {
    attributes: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a>,
    reparse_tag: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a>,
    _size: <span class="tok-type">u64</span>,
    access_time: <span class="tok-type">i128</span>,
    modified_time: <span class="tok-type">i128</span>,
    creation_time: <span class="tok-type">i128</span>,

    <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

    <span class="tok-comment">/// Returns the size of the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">size</span>(self: <a href="std.fs.File.MetadataWindows.html">Self</a>) <span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> self._size;
    }

    <span class="tok-comment">/// Returns a `Permissions` struct, representing the permissions on the file</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">permissions</span>(self: <a href="std.fs.File.MetadataWindows.html">Self</a>) <a href="std.fs.File.Permissions.html">Permissions</a> {
        <span class="tok-kw">return</span> .{ .inner = .{ .attributes = self.attributes } };
    }

    <span class="tok-comment">/// Returns the `Kind` of the file.</span>
    <span class="tok-comment">/// Can only return: `.file`, `.directory`, `.sym_link` or `.unknown`</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">kind</span>(self: <a href="std.fs.File.MetadataWindows.html">Self</a>) <a href="std.fs.File.Kind.html">Kind</a> {
        <span class="tok-kw">if</span> (self.attributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_REPARSE_POINT">FILE_ATTRIBUTE_REPARSE_POINT</a> != <span class="tok-number">0</span>) {
            <span class="tok-kw">if</span> (self.reparse_tag &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.reparse_tag_name_surrogate_bit">reparse_tag_name_surrogate_bit</a> != <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> .sym_link;
            }
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (self.attributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_DIRECTORY">FILE_ATTRIBUTE_DIRECTORY</a> != <span class="tok-number">0</span>) {
            <span class="tok-kw">return</span> .directory;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> .file;
        }
        <span class="tok-kw">return</span> .unknown;
    }

    <span class="tok-comment">/// Returns the last time the file was accessed in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">accessed</span>(self: <a href="std.fs.File.MetadataWindows.html">Self</a>) <span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.access_time;
    }

    <span class="tok-comment">/// Returns the time the file was modified in nanoseconds since UTC 1970-01-01</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">modified</span>(self: <a href="std.fs.File.MetadataWindows.html">Self</a>) <span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.modified_time;
    }

    <span class="tok-comment">/// Returns the time the file was created in nanoseconds since UTC 1970-01-01.</span>
    <span class="tok-comment">/// This never returns null, only returning an optional for compatibility with other OSes</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">created</span>(self: <a href="std.fs.File.MetadataWindows.html">Self</a>) ?<span class="tok-type">i128</span> {
        <span class="tok-kw">return</span> self.creation_time;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FStatError">FStatError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadata</span>(self: <a href="std.fs.File.html">File</a>) <a href="std.posix.html#std.posix.FStatError">MetadataError</a>!<a href="std.fs.File.Metadata.html">Metadata</a> {
    <span class="tok-kw">return</span> .{
        .inner = <span class="tok-kw">switch</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a>) {
            .windows =&gt; blk: {
                <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">var</span> info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ALL_INFORMATION.html">FILE_ALL_INFORMATION</a> = <span class="tok-null">undefined</span>;

                <span class="tok-kw">const</span> rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(self.handle, &amp;io_status_block, &amp;info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ALL_INFORMATION.html">FILE_ALL_INFORMATION</a>), .FileAllInformation);
                <span class="tok-kw">switch</span> (rc) {
                    .SUCCESS =&gt; {},<span class="tok-comment">
                    // Buffer overflow here indicates that there is more information available than was able to be stored in the buffer
                    // size provided. This is treated as success because the type of variable-length information that this would be relevant for
                    // (name, volume name, etc) we don't care about.
                    </span>.BUFFER_OVERFLOW =&gt; {},
                    .INVALID_PARAMETER =&gt; <span class="tok-kw">unreachable</span>,
                    .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
                }

                <span class="tok-kw">const</span> reparse_tag: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.DWORD">DWORD</a> = reparse_blk: {
                    <span class="tok-kw">if</span> (info.BasicInformation.FileAttributes &amp; <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FILE_ATTRIBUTE_REPARSE_POINT">FILE_ATTRIBUTE_REPARSE_POINT</a> != <span class="tok-number">0</span>) {
                        <span class="tok-kw">var</span> tag_info: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ATTRIBUTE_TAG_INFO.html">FILE_ATTRIBUTE_TAG_INFO</a> = <span class="tok-null">undefined</span>;
                        <span class="tok-kw">const</span> tag_rc = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.ntdll.html">ntdll</a>.<a href="std.os.windows.ntdll.html#std.os.windows.ntdll.NtQueryInformationFile">NtQueryInformationFile</a>(self.handle, &amp;io_status_block, &amp;tag_info, <span class="tok-builtin">@sizeOf</span>(<a href="std.os.windows.html">windows</a>.<a href="std.os.windows.FILE_ATTRIBUTE_TAG_INFO.html">FILE_ATTRIBUTE_TAG_INFO</a>), .FileAttributeTagInformation);
                        <span class="tok-kw">switch</span> (tag_rc) {
                            .SUCCESS =&gt; {},<span class="tok-comment">
                            // INFO_LENGTH_MISMATCH and ACCESS_DENIED are the only documented possible errors
                            // https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/d295752f-ce89-4b98-8553-266d37c84f0e
                            </span>.INFO_LENGTH_MISMATCH =&gt; <span class="tok-kw">unreachable</span>,
                            .ACCESS_DENIED =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.AccessDenied,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.unexpectedStatus">unexpectedStatus</a>(rc),
                        }
                        <span class="tok-kw">break</span> :reparse_blk tag_info.ReparseTag;
                    }
                    <span class="tok-kw">break</span> :reparse_blk <span class="tok-number">0</span>;
                };

                <span class="tok-kw">break</span> :blk .{
                    .attributes = info.BasicInformation.FileAttributes,
                    .reparse_tag = reparse_tag,
                    ._size = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(info.StandardInformation.EndOfFile)),
                    .access_time = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.LastAccessTime),
                    .modified_time = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.LastWriteTime),
                    .creation_time = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.fromSysTime">fromSysTime</a>(info.BasicInformation.CreationTime),
                };
            },
            .linux =&gt; blk: {
                <span class="tok-kw">var</span> stx = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.zeroes">zeroes</a>(<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.Statx.html">Statx</a>);<span class="tok-comment">

                // We are gathering information for Metadata, which is meant to contain all the
                // native OS information about the file, so use all known flags.
                </span><span class="tok-kw">const</span> rc = <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.statx">statx</a>(
                    self.handle,
                    <span class="tok-str">&quot;&quot;</span>,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.AT.html">AT</a>.<a href="std.os.linux.AT.html#std.os.linux.AT.EMPTY_PATH">EMPTY_PATH</a>,
                    <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_BASIC_STATS">STATX_BASIC_STATS</a> | <a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.STATX_BTIME">STATX_BTIME</a>,
                    &amp;stx,
                );

                <span class="tok-kw">switch</span> (<a href="std.os.linux.html">linux</a>.<a href="std.os.linux.html#std.os.linux.E">E</a>.<a href="std.os.linux.html#std.os.linux.errnoFromSyscall">init</a>(rc)) {
                    .SUCCESS =&gt; {},
                    .ACCES =&gt; <span class="tok-kw">unreachable</span>,
                    .BADF =&gt; <span class="tok-kw">unreachable</span>,
                    .FAULT =&gt; <span class="tok-kw">unreachable</span>,
                    .INVAL =&gt; <span class="tok-kw">unreachable</span>,
                    .LOOP =&gt; <span class="tok-kw">unreachable</span>,
                    .NAMETOOLONG =&gt; <span class="tok-kw">unreachable</span>,
                    .NOENT =&gt; <span class="tok-kw">unreachable</span>,
                    .NOMEM =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SystemResources,
                    .NOTDIR =&gt; <span class="tok-kw">unreachable</span>,
                    <span class="tok-kw">else</span> =&gt; |err| <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.unexpectedErrno">unexpectedErrno</a>(err),
                }

                <span class="tok-kw">break</span> :blk .{
                    .statx = stx,
                };
            },
            .wasi =&gt; .{ .stat = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.html#std.os.fstat_wasi">fstat_wasi</a>(self.handle) },
            <span class="tok-kw">else</span> =&gt; .{ .stat = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.fstat">fstat</a>(self.handle) },
        },
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> UpdateTimesError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.FutimensError">FutimensError</a> || <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFileTimeError">SetFileTimeError</a>;

<span class="tok-comment">/// The underlying file system may have a different granularity than nanoseconds,</span>
<span class="tok-comment">/// and therefore this function cannot guarantee any precision will be stored.</span>
<span class="tok-comment">/// Further, the maximum value is limited by the system ABI. When a value is provided</span>
<span class="tok-comment">/// that exceeds this range, the value is clamped to the maximum.</span>
<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">updateTimes</span>(
    self: <a href="std.fs.File.html">File</a>,
    <span class="tok-comment">/// access timestamp in nanoseconds</span>
    atime: <span class="tok-type">i128</span>,
    <span class="tok-comment">/// last modification timestamp in nanoseconds</span>
    mtime: <span class="tok-type">i128</span>,
) <a href="std.fs.File.html#std.fs.File.UpdateTimesError">UpdateTimesError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows) {
        <span class="tok-kw">const</span> atime_ft = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.nanoSecondsToFileTime">nanoSecondsToFileTime</a>(atime);
        <span class="tok-kw">const</span> mtime_ft = <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.nanoSecondsToFileTime">nanoSecondsToFileTime</a>(mtime);
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.SetFileTime">SetFileTime</a>(self.handle, <span class="tok-null">null</span>, &amp;atime_ft, &amp;mtime_ft);
    }
    <span class="tok-kw">const</span> times = [<span class="tok-number">2</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.timespec">timespec</a>{
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.timespec">timespec</a>{
            .sec = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@divFloor</span>(atime, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>)) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
            .nsec = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@mod</span>(atime, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>)) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
        },
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.timespec">timespec</a>{
            .sec = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@divFloor</span>(mtime, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>)) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
            .nsec = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">isize</span>, <span class="tok-builtin">@mod</span>(mtime, <a href="std.html">std</a>.<a href="std.time.html">time</a>.<a href="std.time.html#std.time.ns_per_s">ns_per_s</a>)) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">isize</span>),
        },
    };
    <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.futimens">futimens</a>(self.handle, &amp;times);
}

<span class="tok-comment">/// Reads all the bytes from the current position to the end of the file.</span>
<span class="tok-comment">/// On success, caller owns returned buffer.</span>
<span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readToEndAlloc</span>(self: <a href="std.fs.File.html">File</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, max_bytes: <span class="tok-type">usize</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> self.readToEndAllocOptions(allocator, max_bytes, <span class="tok-null">null</span>, <span class="tok-builtin">@alignOf</span>(<span class="tok-type">u8</span>), <span class="tok-null">null</span>);
}

<span class="tok-comment">/// Reads all the bytes from the current position to the end of the file.</span>
<span class="tok-comment">/// On success, caller owns returned buffer.</span>
<span class="tok-comment">/// If the file is larger than `max_bytes`, returns `error.FileTooBig`.</span>
<span class="tok-comment">/// If `size_hint` is specified the initial buffer size is calculated using</span>
<span class="tok-comment">/// that value, otherwise an arbitrary value is used instead.</span>
<span class="tok-comment">/// Allows specifying alignment and a sentinel value.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readToEndAllocOptions</span>(
    self: <a href="std.fs.File.html">File</a>,
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    max_bytes: <span class="tok-type">usize</span>,
    size_hint: ?<span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>,
    <span class="tok-kw">comptime</span> optional_sentinel: ?<span class="tok-type">u8</span>,
) !(<span class="tok-kw">if</span> (optional_sentinel) |s| [:s]<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span> <span class="tok-kw">else</span> []<span class="tok-kw">align</span>(alignment) <span class="tok-type">u8</span>) {<span class="tok-comment">
    // If no size hint is provided fall back to the size=0 code path
    </span><span class="tok-kw">const</span> size = size_hint <span class="tok-kw">orelse</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // The file size returned by stat is used as hint to set the buffer
    // size. If the reported size is zero, as it happens on Linux for files
    // in /proc, a small buffer is allocated instead.
    </span><span class="tok-kw">const</span> initial_cap = <span class="tok-builtin">@min</span>((<span class="tok-kw">if</span> (size &gt; <span class="tok-number">0</span>) size <span class="tok-kw">else</span> <span class="tok-number">1024</span>), max_bytes) + <span class="tok-builtin">@intFromBool</span>(optional_sentinel != <span class="tok-null">null</span>);
    <span class="tok-kw">var</span> array_list = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListAligned">ArrayListAligned</a>(<span class="tok-type">u8</span>, alignment).initCapacity(allocator, initial_cap);
    <span class="tok-kw">defer</span> array_list.deinit();

    self.reader().readAllArrayListAligned(alignment, &amp;array_list, max_bytes) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.StreamTooLong =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileTooBig,
        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };

    <span class="tok-kw">if</span> (optional_sentinel) |sentinel| {
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> array_list.toOwnedSliceSentinel(sentinel);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> array_list.toOwnedSlice();
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PReadError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PReadError">PReadError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">read</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, buffer, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.read">read</a>(self.handle, buffer);
}

<span class="tok-comment">/// Returns the number of bytes read. If the number read is smaller than `buffer.len`, it</span>
<span class="tok-comment">/// means the file reached the end. Reaching the end of a file is not an error condition.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readAll</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index != buffer.len) {
        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> self.read(buffer[index..]);
        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        index += amt;
    }
    <span class="tok-kw">return</span> index;
}

<span class="tok-comment">/// On Windows, this function currently does alter the file pointer.</span>
<span class="tok-comment">/// https://github.com/ziglang/zig/issues/12783</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pread</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, buffer, offset);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pread">pread</a>(self.handle, buffer, offset);
}

<span class="tok-comment">/// Returns the number of bytes read. If the number read is smaller than `buffer.len`, it</span>
<span class="tok-comment">/// means the file reached the end. Reaching the end of a file is not an error condition.</span>
<span class="tok-comment">/// On Windows, this function currently does alter the file pointer.</span>
<span class="tok-comment">/// https://github.com/ziglang/zig/issues/12783</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadAll</span>(self: <a href="std.fs.File.html">File</a>, buffer: []<span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index != buffer.len) {
        <span class="tok-kw">const</span> amt = <span class="tok-kw">try</span> self.pread(buffer[index..], offset + index);
        <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
        index += amt;
    }
    <span class="tok-kw">return</span> index;
}

<span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readv</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // TODO improve this to use ReadFileScatter
        </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, first.base[<span class="tok-number">0</span>..first.len], <span class="tok-null">null</span>);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.readv">readv</a>(self.handle, iovecs);
}

<span class="tok-comment">/// Returns the number of bytes read. If the number read is smaller than the total bytes</span>
<span class="tok-comment">/// from all the buffers, it means the file reached the end. Reaching the end of a file</span>
<span class="tok-comment">/// is not an error condition.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// The `iovecs` parameter is mutable because:</span>
<span class="tok-comment">/// * This function needs to mutate the fields in order to handle partial</span>
<span class="tok-comment">///   reads from the underlying OS layer.</span>
<span class="tok-comment">/// * The OS layer expects pointer addresses to be inside the application's address space</span>
<span class="tok-comment">///   even if the length is zero. Meanwhile, in Zig, slices may have undefined pointer</span>
<span class="tok-comment">///   addresses when the length is zero. So this function modifies the base fields</span>
<span class="tok-comment">///   when the length is zero.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Related open issue: https://github.com/ziglang/zig/issues/7699</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">readvAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>) <a href="std.posix.html#std.posix.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;<span class="tok-comment">

    // We use the address of this local variable for all zero-length
    // vectors so that the OS does not complain that we are giving it
    // addresses outside the application's address space.
    </span><span class="tok-kw">var</span> garbage: [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (iovecs) |*v| {
        <span class="tok-kw">if</span> (v.len == <span class="tok-number">0</span>) v.base = &amp;garbage;
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.readv(iovecs[i..]);
        <span class="tok-kw">var</span> eof = amt == <span class="tok-number">0</span>;
        off += amt;
        <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
            amt -= iovecs[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span> off;
            eof = <span class="tok-null">false</span>;
        }
        <span class="tok-kw">if</span> (eof) <span class="tok-kw">return</span> off;
        iovecs[i].base += amt;
        iovecs[i].len -= amt;
    }
}

<span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
<span class="tok-comment">/// On Windows, this function currently does alter the file pointer.</span>
<span class="tok-comment">/// https://github.com/ziglang/zig/issues/12783</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadv</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // TODO improve this to use ReadFileScatter
        </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.ReadFile">ReadFile</a>(self.handle, first.base[<span class="tok-number">0</span>..first.len], offset);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.preadv">preadv</a>(self.handle, iovecs, offset);
}

<span class="tok-comment">/// Returns the number of bytes read. If the number read is smaller than the total bytes</span>
<span class="tok-comment">/// from all the buffers, it means the file reached the end. Reaching the end of a file</span>
<span class="tok-comment">/// is not an error condition.</span>
<span class="tok-comment">/// The `iovecs` parameter is mutable because this function needs to mutate the fields in</span>
<span class="tok-comment">/// order to handle partial reads from the underlying OS layer.</span>
<span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
<span class="tok-comment">/// On Windows, this function currently does alter the file pointer.</span>
<span class="tok-comment">/// https://github.com/ziglang/zig/issues/12783</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">preadvAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec.html">iovec</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PReadError">PReadError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-number">0</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> off: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.preadv(iovecs[i..], offset + off);
        <span class="tok-kw">var</span> eof = amt == <span class="tok-number">0</span>;
        off += amt;
        <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
            amt -= iovecs[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span> off;
            eof = <span class="tok-null">false</span>;
        }
        <span class="tok-kw">if</span> (eof) <span class="tok-kw">return</span> off;
        iovecs[i].base += amt;
        iovecs[i].len -= amt;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> PWriteError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.PWriteError">PWriteError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, bytes, <span class="tok-null">null</span>);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.write">write</a>(self.handle, bytes);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeAll</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> self.write(bytes[index..]);
    }
}

<span class="tok-comment">/// On Windows, this function currently does alter the file pointer.</span>
<span class="tok-comment">/// https://github.com/ziglang/zig/issues/12783</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwrite</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, bytes, offset);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pwrite">pwrite</a>(self.handle, bytes, offset);
}

<span class="tok-comment">/// On Windows, this function currently does alter the file pointer.</span>
<span class="tok-comment">/// https://github.com/ziglang/zig/issues/12783</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwriteAll</span>(self: <a href="std.fs.File.html">File</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (index &lt; bytes.len) {
        index += <span class="tok-kw">try</span> self.pwrite(bytes[index..], offset + index);
    }
}

<span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
<span class="tok-comment">/// See equivalent function: `std.net.Stream.writev`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writev</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<span class="tok-kw">const</span> <a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // TODO improve this to use WriteFileScatter
        </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, first.base[<span class="tok-number">0</span>..first.len], <span class="tok-null">null</span>);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.writev">writev</a>(self.handle, iovecs);
}

<span class="tok-comment">/// The `iovecs` parameter is mutable because:</span>
<span class="tok-comment">/// * This function needs to mutate the fields in order to handle partial</span>
<span class="tok-comment">///   writes from the underlying OS layer.</span>
<span class="tok-comment">/// * The OS layer expects pointer addresses to be inside the application's address space</span>
<span class="tok-comment">///   even if the length is zero. Meanwhile, in Zig, slices may have undefined pointer</span>
<span class="tok-comment">///   addresses when the length is zero. So this function modifies the base fields</span>
<span class="tok-comment">///   when the length is zero.</span>
<span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
<span class="tok-comment">/// See equivalent function: `std.net.Stream.writevAll`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writevAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>) <a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;<span class="tok-comment">

    // We use the address of this local variable for all zero-length
    // vectors so that the OS does not complain that we are giving it
    // addresses outside the application's address space.
    </span><span class="tok-kw">var</span> garbage: [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (iovecs) |*v| {
        <span class="tok-kw">if</span> (v.len == <span class="tok-number">0</span>) v.base = &amp;garbage;
    }

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.writev(iovecs[i..]);
        <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
            amt -= iovecs[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span>;
        }
        iovecs[i].base += amt;
        iovecs[i].len -= amt;
    }
}

<span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
<span class="tok-comment">/// On Windows, this function currently does alter the file pointer.</span>
<span class="tok-comment">/// https://github.com/ziglang/zig/issues/12783</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritev</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // TODO improve this to use WriteFileScatter
        </span><span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> first = iovecs[<span class="tok-number">0</span>];
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.WriteFile">WriteFile</a>(self.handle, first.base[<span class="tok-number">0</span>..first.len], offset);
    }

    <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.pwritev">pwritev</a>(self.handle, iovecs, offset);
}

<span class="tok-comment">/// The `iovecs` parameter is mutable because this function needs to mutate the fields in</span>
<span class="tok-comment">/// order to handle partial writes from the underlying OS layer.</span>
<span class="tok-comment">/// See https://github.com/ziglang/zig/issues/7699</span>
<span class="tok-comment">/// On Windows, this function currently does alter the file pointer.</span>
<span class="tok-comment">/// https://github.com/ziglang/zig/issues/12783</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pwritevAll</span>(self: <a href="std.fs.File.html">File</a>, iovecs: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>, offset: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.PWriteError">PWriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (iovecs.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;

    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> off: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">var</span> amt = <span class="tok-kw">try</span> self.pwritev(iovecs[i..], offset + off);
        off += amt;
        <span class="tok-kw">while</span> (amt &gt;= iovecs[i].len) {
            amt -= iovecs[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= iovecs.len) <span class="tok-kw">return</span>;
        }
        iovecs[i].base += amt;
        iovecs[i].len -= amt;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CopyRangeError = <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.CopyFileRangeError">CopyFileRangeError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyRange</span>(in: <a href="std.fs.File.html">File</a>, in_offset: <span class="tok-type">u64</span>, out: <a href="std.fs.File.html">File</a>, out_offset: <span class="tok-type">u64</span>, len: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyRangeError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">const</span> adjusted_len = <a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">usize</span>, len) <span class="tok-kw">orelse</span> <a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">usize</span>);
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.copy_file_range">copy_file_range</a>(in.handle, in_offset, out.handle, out_offset, adjusted_len, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> result;
}

<span class="tok-comment">/// Returns the number of bytes copied. If the number read is smaller than `buffer.len`, it</span>
<span class="tok-comment">/// means the in file reached the end. Reaching the end of a file is not an error condition.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">copyRangeAll</span>(in: <a href="std.fs.File.html">File</a>, in_offset: <span class="tok-type">u64</span>, out: <a href="std.fs.File.html">File</a>, out_offset: <span class="tok-type">u64</span>, len: <span class="tok-type">u64</span>) <a href="std.posix.html#std.posix.CopyFileRangeError">CopyRangeError</a>!<span class="tok-type">u64</span> {
    <span class="tok-kw">var</span> total_bytes_copied: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> in_off = in_offset;
    <span class="tok-kw">var</span> out_off = out_offset;
    <span class="tok-kw">while</span> (total_bytes_copied &lt; len) {
        <span class="tok-kw">const</span> amt_copied = <span class="tok-kw">try</span> <a href="std.fs.File.html#std.fs.File.copyRange">copyRange</a>(in, in_off, out, out_off, len - total_bytes_copied);
        <span class="tok-kw">if</span> (amt_copied == <span class="tok-number">0</span>) <span class="tok-kw">return</span> total_bytes_copied;
        total_bytes_copied += amt_copied;
        in_off += amt_copied;
        out_off += amt_copied;
    }
    <span class="tok-kw">return</span> total_bytes_copied;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileOptions = <span class="tok-kw">struct</span> {
    in_offset: <span class="tok-type">u64</span> = <span class="tok-number">0</span>,

    <span class="tok-comment">/// `null` means the entire file. `0` means no bytes from the file.</span>
    <span class="tok-comment">/// When this is `null`, trailers must be sent in a separate writev() call</span>
    <span class="tok-comment">/// due to a flaw in the BSD sendfile API. Other operating systems, such as</span>
    <span class="tok-comment">/// Linux, already do this anyway due to API limitations.</span>
    <span class="tok-comment">/// If the size of the source file is known, passing the size here will save one syscall.</span>
    in_len: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,

    headers_and_trailers: []<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a> = &amp;[<span class="tok-number">0</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{},

    <span class="tok-comment">/// The trailer count is inferred from `headers_and_trailers.len - header_count`</span>
    header_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WriteFileError = <a href="std.posix.html#std.posix.ReadError">ReadError</a> || <span class="tok-kw">error</span>{EndOfStream} || <a href="std.posix.html#std.posix.WriteError">WriteError</a>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFileAll</span>(self: <a href="std.fs.File.html">File</a>, in_file: <a href="std.fs.File.html">File</a>, args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.File.html#std.fs.File.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.writeFileAllSendfile(in_file, args) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Unseekable,
        <span class="tok-kw">error</span>.FastOpenAlreadyInProgress,
        <span class="tok-kw">error</span>.MessageTooBig,
        <span class="tok-kw">error</span>.FileDescriptorNotASocket,
        <span class="tok-kw">error</span>.NetworkUnreachable,
        <span class="tok-kw">error</span>.NetworkSubsystemFailed,
        =&gt; <span class="tok-kw">return</span> self.writeFileAllUnseekable(in_file, args),

        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
    };
}

<span class="tok-comment">/// Does not try seeking in either of the File parameters.</span>
<span class="tok-comment">/// See `writeFileAll` as an alternative to calling this.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writeFileAllUnseekable</span>(self: <a href="std.fs.File.html">File</a>, in_file: <a href="std.fs.File.html">File</a>, args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.fs.File.html#std.fs.File.WriteFileError">WriteFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> headers = args.headers_and_trailers[<span class="tok-number">0</span>..args.header_count];
    <span class="tok-kw">const</span> trailers = args.headers_and_trailers[args.header_count..];

    <span class="tok-kw">try</span> self.writevAll(headers);

    <span class="tok-kw">try</span> in_file.reader().skipBytes(args.in_offset, .{ .buf_size = <span class="tok-number">4096</span> });

    <span class="tok-kw">var</span> fifo = <a href="std.html">std</a>.<a href="std.fifo.html">fifo</a>.<a href="std.fifo.html#std.fifo.LinearFifo">LinearFifo</a>(<span class="tok-type">u8</span>, .{ .Static = <span class="tok-number">4096</span> }).init();
    <span class="tok-kw">if</span> (args.in_len) |len| {
        <span class="tok-kw">var</span> stream = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.limited_reader.html#std.io.limited_reader.limitedReader">limitedReader</a>(in_file.reader(), len);
        <span class="tok-kw">try</span> fifo.pump(stream.reader(), self.writer());
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> fifo.pump(in_file.reader(), self.writer());
    }

    <span class="tok-kw">try</span> self.writevAll(trailers);
}

<span class="tok-comment">/// Low level function which can fail for OS-specific reasons.</span>
<span class="tok-comment">/// See `writeFileAll` as an alternative to calling this.</span>
<span class="tok-comment">/// TODO integrate with async I/O</span>
<span class="tok-kw">fn</span> <span class="tok-fn">writeFileAllSendfile</span>(self: <a href="std.fs.File.html">File</a>, in_file: <a href="std.fs.File.html">File</a>, args: <a href="std.fs.File.WriteFileOptions.html">WriteFileOptions</a>) <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.SendFileError">SendFileError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> count = blk: {
        <span class="tok-kw">if</span> (args.in_len) |l| {
            <span class="tok-kw">if</span> (l == <span class="tok-number">0</span>) {
                <span class="tok-kw">return</span> self.writevAll(args.headers_and_trailers);
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">break</span> :blk l;
            }
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
        }
    };
    <span class="tok-kw">const</span> headers = args.headers_and_trailers[<span class="tok-number">0</span>..args.header_count];
    <span class="tok-kw">const</span> trailers = args.headers_and_trailers[args.header_count..];
    <span class="tok-kw">const</span> zero_iovec = &amp;[<span class="tok-number">0</span>]<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a>{};<span class="tok-comment">
    // When reading the whole file, we cannot put the trailers in the sendfile() syscall,
    // because we have no way to determine whether a partial write is past the end of the file or not.
    </span><span class="tok-kw">const</span> trls = <span class="tok-kw">if</span> (count == <span class="tok-number">0</span>) zero_iovec <span class="tok-kw">else</span> trailers;
    <span class="tok-kw">const</span> offset = args.in_offset;
    <span class="tok-kw">const</span> out_fd = self.handle;
    <span class="tok-kw">const</span> in_fd = in_file.handle;
    <span class="tok-kw">const</span> flags = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> amt: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    hdrs: {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; headers.len) {
            amt = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sendfile">sendfile</a>(out_fd, in_fd, offset, count, headers[i..], trls, flags);
            <span class="tok-kw">while</span> (amt &gt;= headers[i].len) {
                amt -= headers[i].len;
                i += <span class="tok-number">1</span>;
                <span class="tok-kw">if</span> (i &gt;= headers.len) <span class="tok-kw">break</span> :hdrs;
            }
            headers[i].base += amt;
            headers[i].len -= amt;
        }
    }
    <span class="tok-kw">if</span> (count == <span class="tok-number">0</span>) {
        <span class="tok-kw">var</span> off: <span class="tok-type">u64</span> = amt;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            amt = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sendfile">sendfile</a>(out_fd, in_fd, offset + off, <span class="tok-number">0</span>, zero_iovec, zero_iovec, flags);
            <span class="tok-kw">if</span> (amt == <span class="tok-number">0</span>) <span class="tok-kw">break</span>;
            off += amt;
        }
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">var</span> off: <span class="tok-type">u64</span> = amt;
        <span class="tok-kw">while</span> (off &lt; count) {
            amt = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.sendfile">sendfile</a>(out_fd, in_fd, offset + off, count - off, zero_iovec, trailers, flags);
            off += amt;
        }
        amt = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(off - count));
    }
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; trailers.len) {
        <span class="tok-kw">while</span> (amt &gt;= trailers[i].len) {
            amt -= trailers[i].len;
            i += <span class="tok-number">1</span>;
            <span class="tok-kw">if</span> (i &gt;= trailers.len) <span class="tok-kw">return</span>;
        }
        trailers[i].base += amt;
        trailers[i].len -= amt;
        amt = <span class="tok-kw">try</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.writev">writev</a>(self.handle, trailers[i..]);
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Reader = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericReader">Reader</a>(<a href="std.fs.File.html">File</a>, <a href="std.posix.html#std.posix.ReadError">ReadError</a>, <a href="std.fs.File.html#std.fs.File.read">read</a>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.Reader">Reader</a> {
    <span class="tok-kw">return</span> .{ .context = file };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(<a href="std.fs.File.html">File</a>, <a href="std.posix.html#std.posix.WriteError">WriteError</a>, <a href="std.fs.File.html#std.fs.File.write">write</a>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.Writer">Writer</a> {
    <span class="tok-kw">return</span> .{ .context = file };
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SeekableStream = <a href="std.io.html">io</a>.<a href="std.io.seekable_stream.html#std.io.seekable_stream.SeekableStream">SeekableStream</a>(
    <a href="std.fs.File.html">File</a>,
    <a href="std.posix.html#std.posix.SeekError">SeekError</a>,
    <a href="std.fs.File.html#std.fs.File.GetSeekPosError">GetSeekPosError</a>,
    <a href="std.fs.File.html#std.fs.File.seekTo">seekTo</a>,
    <a href="std.fs.File.html#std.fs.File.seekBy">seekBy</a>,
    <a href="std.fs.File.html#std.fs.File.getPos">getPos</a>,
    <a href="std.fs.File.html#std.fs.File.getEndPos">getEndPos</a>,
);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">seekableStream</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.SeekableStream">SeekableStream</a> {
    <span class="tok-kw">return</span> .{ .context = file };
}

<span class="tok-kw">const</span> range_off: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.LARGE_INTEGER">LARGE_INTEGER</a> = <span class="tok-number">0</span>;
<span class="tok-kw">const</span> range_len: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.LARGE_INTEGER">LARGE_INTEGER</a> = <span class="tok-number">1</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> LockError = <span class="tok-kw">error</span>{
    SystemResources,
    FileLocksNotSupported,
} || <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a>;

<span class="tok-comment">/// Blocks when an incompatible lock is held by another process.</span>
<span class="tok-comment">/// A process may hold only one type of lock (shared or exclusive) on</span>
<span class="tok-comment">/// a file. When a process terminates in any way, the lock is released.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Assumes the file is unlocked.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lock</span>(file: <a href="std.fs.File.html">File</a>, l: <a href="std.fs.File.Lock.html">Lock</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (l) {
            .none =&gt; <span class="tok-kw">return</span>,
            .shared =&gt; <span class="tok-null">false</span>,
            .exclusive =&gt; <span class="tok-null">true</span>,
        };
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.LockFile">LockFile</a>(
            file.handle,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FALSE">FALSE</a>,<span class="tok-comment"> // non-blocking=false
            </span><span class="tok-builtin">@intFromBool</span>(exclusive),
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // non-blocking=false
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(file.handle, <span class="tok-kw">switch</span> (l) {
            .none =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.UN">UN</a>,
            .shared =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a>,
            .exclusive =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.EX">EX</a>,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // non-blocking=false
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }
}

<span class="tok-comment">/// Assumes the file is locked.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlock</span>(file: <a href="std.fs.File.html">File</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UnlockFile">UnlockFile</a>(
            file.handle,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.RangeNotLocked =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Function assumes unlocked.
            </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Resource deallocation must succeed.
        </span>};
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(file.handle, <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.UN">UN</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // unlocking can't block
            </span><span class="tok-kw">error</span>.SystemResources =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // We are deallocating resources.
            </span><span class="tok-kw">error</span>.FileLocksNotSupported =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // We already got the lock.
            </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Resource deallocation must succeed.
        </span>};
    }
}

<span class="tok-comment">/// Attempts to obtain a lock, returning `true` if the lock is</span>
<span class="tok-comment">/// obtained, and `false` if there was an existing incompatible lock held.</span>
<span class="tok-comment">/// A process may hold only one type of lock (shared or exclusive) on</span>
<span class="tok-comment">/// a file. When a process terminates in any way, the lock is released.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Assumes the file is unlocked.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tryLock</span>(file: <a href="std.fs.File.html">File</a>, l: <a href="std.fs.File.Lock.html">Lock</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {
        <span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> exclusive = <span class="tok-kw">switch</span> (l) {
            .none =&gt; <span class="tok-kw">return</span>,
            .shared =&gt; <span class="tok-null">false</span>,
            .exclusive =&gt; <span class="tok-null">true</span>,
        };
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.LockFile">LockFile</a>(
            file.handle,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>,<span class="tok-comment"> // non-blocking=true
            </span><span class="tok-builtin">@intFromBool</span>(exclusive),
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    } <span class="tok-kw">else</span> {
        <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(file.handle, <span class="tok-kw">switch</span> (l) {
            .none =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.UN">UN</a>,
            .shared =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a>,
            .exclusive =&gt; <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.EX">EX</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a>,
        }) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
            <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-comment">/// Assumes the file is already locked in exclusive mode.</span>
<span class="tok-comment">/// Atomically modifies the lock to be in shared mode, without releasing it.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// TODO: integrate with async I/O</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">downgradeLock</span>(file: <a href="std.fs.File.html">File</a>) <a href="std.fs.File.html#std.fs.File.LockError">LockError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<a href="std.fs.File.html#std.fs.File.is_windows">is_windows</a>) {<span class="tok-comment">
        // On Windows it works like a semaphore + exclusivity flag. To implement this
        // function, we first obtain another lock in shared mode. This changes the
        // exclusivity flag, but increments the semaphore to 2. So we follow up with
        // an NtUnlockFile which decrements the semaphore but does not modify the
        // exclusivity flag.
        </span><span class="tok-kw">var</span> io_status_block: <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.IO_STATUS_BLOCK.html">IO_STATUS_BLOCK</a> = <span class="tok-null">undefined</span>;
        <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.LockFile">LockFile</a>(
            file.handle,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            <span class="tok-null">null</span>,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
            <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.TRUE">TRUE</a>,<span class="tok-comment"> // non-blocking=true
            </span><a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.FALSE">FALSE</a>,<span class="tok-comment"> // exclusive=false
        </span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // File was not locked in exclusive mode.
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
        <span class="tok-kw">return</span> <a href="std.os.windows.html">windows</a>.<a href="std.os.windows.html#std.os.windows.UnlockFile">UnlockFile</a>(
            file.handle,
            &amp;io_status_block,
            &amp;<a href="std.fs.File.html#std.fs.File.range_off">range_off</a>,
            &amp;<a href="std.fs.File.html#std.fs.File.range_len">range_len</a>,
            <span class="tok-null">null</span>,
        ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.RangeNotLocked =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // File was not locked.
            </span><span class="tok-kw">error</span>.Unexpected =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // Resource deallocation must succeed.
        </span>};
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> <a href="std.posix.html">posix</a>.<a href="std.posix.html#std.posix.flock">flock</a>(file.handle, <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.SH">SH</a> | <a href="std.posix.html">posix</a>.<a href="std.posix.LOCK.html">LOCK</a>.<a href="std.posix.LOCK.html#std.posix.LOCK.NB">NB</a>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
            <span class="tok-kw">error</span>.WouldBlock =&gt; <span class="tok-kw">unreachable</span>,<span class="tok-comment"> // File was not locked in exclusive mode.
            </span><span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,
        };
    }
}

<span class="tok-kw">const</span> File = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../std.zig&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> posix = <a href="std.html">std</a>.<a href="std.posix.html">posix</a>;
<span class="tok-kw">const</span> io = <a href="std.html">std</a>.<a href="std.io.html">io</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> linux = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.linux.html">linux</a>;
<span class="tok-kw">const</span> windows = <a href="std.html">std</a>.<a href="std.os.html">os</a>.<a href="std.os.windows.html">windows</a>;
<span class="tok-kw">const</span> Os = <a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="#">Os</a>;
<span class="tok-kw">const</span> maxInt = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>;
<span class="tok-kw">const</span> is_windows = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.os">os</a>.<a href="#">tag</a> == .windows;</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd></kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
