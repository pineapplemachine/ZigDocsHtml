<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">http</a></li><li><a href="std.http.Server.html" class="">Server</a></li><li><a href="std.http.Server.Request.html" class="active">Request</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.http.Server.Request" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.http.Server.Request</span><a href="#src.zig-std.http.Server.Request">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.http.Server.Request.Compression.html">std.http.Server.Request.Compression</a></li><li><a href="std.http.Server.Request.Head.html">std.http.Server.Request.Head</a></li><li><a href="std.http.Server.Request.RespondOptions.html">std.http.Server.Request.RespondOptions</a></li><li><a href="std.http.Server.Request.RespondStreamingOptions.html">std.http.Server.Request.RespondStreamingOptions</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>server: *<a href="std.http.Server.html">Server</a></code></pre></div><div><pre><code>head_end: <span class="tok-type">usize</span></code></pre><div class="fieldDocs"><p>Index into Server's read_buffer.</p>
</div></div><div><pre><code>head: <a href="std.http.Server.Request.Head.html">Head</a></code></pre></div><div><pre><code>reader_state: <span class="tok-kw">union</span> {
    remaining_content_length: <span class="tok-type">u64</span>,
    chunk_parser: <a href="std.http.html">http</a>.<a href="std.http.ChunkParser.html">ChunkParser</a>,
}</code></pre></div></div></div><div class="sectErrSets"><h2 class="sectionHeader">Error Sets</h2><div class="listErrSets"><div class="decl"><h2 id="std.http.Server.Request.ReadError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ReadError</span><a href="#src.zig-std.http.Server.Request.ReadError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>In WASI, this error occurs when the file descriptor does
not hold the required rights to read from it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Canceled <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>reading a timerfd with CANCEL_ON_SET will lead to this error
when the clock goes through a discontinuous change</p>
</dd></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ConnectionTimedOut <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>HttpChunkInvalid</dt></div><div><dt>HttpHeadersOversize</dt></div><div><dt>InputOutput <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>IsDir <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>Unable to read file due to lock.</p>
</dd></div><div><dt>NotOpenForReading <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs in Linux if the process to be read from
no longer exists.</p>
</dd></div><div><dt>SocketNotConnected <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>SystemResources <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.ReadError">ReadError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Server.Request.ReadError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <a href="std.net.html">net</a>.<a href="std.net.Stream.html">Stream</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a> || <span class="tok-kw">error</span>{
    HttpChunkInvalid,
    HttpHeadersOversize,
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Server.Request.ReaderError" class="declHeader"><span class="declHeaderCategory">Error Set</span><span class="declHeaderIdentifier">ReaderError</span><a href="#src.zig-std.http.Server.Request.ReaderError">[src]</a></h2><div class="sectFnErrors"><h3 class="sectionHeader">Errors</h3><div class="fnErrorsAnyError"><p><span class="tok-type">anyerror</span> means the error set is known only at runtime.</p></div><div class="tableFnErrors"><dl class="listFnErrors"><div><dt>AccessDenied <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>File descriptor does not hold the required rights to write to it.</p>
</dd></div><div><dt>BrokenPipe <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>ConnectionResetByPeer <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>Connection reset by peer.</p>
</dd></div><div><dt>DeviceBusy <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>DiskQuota <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>FileTooBig <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>HttpExpectationFailed</dt><dd><p>The client sent an expect HTTP header value other than
&quot;100-continue&quot;.</p>
</dd></div><div><dt>InputOutput <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>InvalidArgument <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>LockViolation <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>The process cannot access the file because another process has locked
a portion of the file. Windows-only.</p>
</dd></div><div><dt>NoDevice <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when a device gets disconnected before or mid-flush
while it's being written to - errno(6): No such device or address.</p>
</dd></div><div><dt>NoSpaceLeft <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>NotOpenForWriting <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>OperationAborted <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>ProcessNotFound <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs in Linux if the process being written to
no longer exists.</p>
</dd></div><div><dt>SystemResources <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt></div><div><dt>Unexpected <a href="std.posix.html#std.posix.UnexpectedError">UnexpectedError</a></dt><dd><p>The Operating System returned an undocumented error code.</p>
<p>This error is in theory not possible, but it would be better
to handle this error than to invoke undefined behavior.</p>
<p>When this error code is observed, it usually means the Zig Standard
Library needs a small patch to add the error code to the error set for
the respective function.</p>
</dd></div><div><dt>WouldBlock <a href="std.posix.html#std.posix.WriteError">WriteError</a></dt><dd><p>This error occurs when no global event loop is configured,
and reading from the file descriptor would block.</p>
</dd></div></dl></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Server.Request.ReaderError">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReaderError = <a href="std.http.Server.Response.html">Response</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a> || <span class="tok-kw">error</span>{
    <span class="tok-comment">/// The client sent an expect HTTP header value other than</span>
    <span class="tok-comment">/// &quot;100-continue&quot;.</span>
    HttpExpectationFailed,
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.http.Server.Request.iterateHeaders" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterateHeaders</span><a href="#src.zig-std.http.Server.Request.iterateHeaders">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateHeaders</span>(r: *<a href="std.http.Server.Request.html">Request</a>) <a href="std.http.html">http</a>.<a href="std.http.HeaderIterator.html">HeaderIterator</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>r: *<a href="std.http.Server.Request.html">Request</a></code></pre></div></div></div><div class="sectDocTests"><h3 class="sectionHeader">Example Usage</h3><pre><code class="docTestsCode"><span class="tok-kw">test</span> iterateHeaders {
    <span class="tok-kw">const</span> request_bytes = <span class="tok-str">&quot;GET /hi HTTP/1.0\r\n&quot;</span> ++
        <span class="tok-str">&quot;content-tYpe: text/plain\r\n&quot;</span> ++
        <span class="tok-str">&quot;content-Length:10\r\n&quot;</span> ++
        <span class="tok-str">&quot;expeCt:   100-continue \r\n&quot;</span> ++
        <span class="tok-str">&quot;TRansfer-encoding:\tdeflate, chunked \r\n&quot;</span> ++
        <span class="tok-str">&quot;connectioN:\t keep-alive \r\n\r\n&quot;</span>;

    <span class="tok-kw">var</span> read_buffer: [<span class="tok-number">500</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-builtin">@memcpy</span>(read_buffer[<span class="tok-number">0</span>..request_bytes.len], request_bytes);

    <span class="tok-kw">var</span> server: <a href="std.http.Server.html">Server</a> = .{
        .connection = <span class="tok-null">undefined</span>,
        .state = .ready,
        .read_buffer = &amp;read_buffer,
        .read_buffer_len = request_bytes.len,
        .next_request_start = <span class="tok-number">0</span>,
    };

    <span class="tok-kw">var</span> request: <a href="std.http.Server.Request.html">Request</a> = .{
        .server = &amp;server,
        .head_end = request_bytes.len,
        .head = <span class="tok-null">undefined</span>,
        .reader_state = <span class="tok-null">undefined</span>,
    };

    <span class="tok-kw">var</span> it = request.iterateHeaders();
    {
        <span class="tok-kw">const</span> header = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content-tYpe&quot;</span>, header.name);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;text/plain&quot;</span>, header.value);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
    }
    {
        <span class="tok-kw">const</span> header = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content-Length&quot;</span>, header.name);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;10&quot;</span>, header.value);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
    }
    {
        <span class="tok-kw">const</span> header = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;expeCt&quot;</span>, header.name);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;100-continue&quot;</span>, header.value);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
    }
    {
        <span class="tok-kw">const</span> header = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;TRansfer-encoding&quot;</span>, header.name);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;deflate, chunked&quot;</span>, header.value);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
    }
    {
        <span class="tok-kw">const</span> header = it.next().?;
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;connectioN&quot;</span>, header.name);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;keep-alive&quot;</span>, header.value);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, it.next());
}</code></pre></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Server.Request.iterateHeaders">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateHeaders</span>(r: *<a href="std.http.Server.Request.html">Request</a>) <a href="std.http.html">http</a>.<a href="std.http.HeaderIterator.html">HeaderIterator</a> {
    <span class="tok-kw">return</span> <a href="std.http.html">http</a>.<a href="std.http.HeaderIterator.html">HeaderIterator</a>.<a href="std.http.HeaderIterator.html#std.http.HeaderIterator.init">init</a>(r.server.read_buffer[<span class="tok-number">0</span>..r.head_end]);
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Server.Request.respond" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">respond</span><a href="#src.zig-std.http.Server.Request.respond">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">respond</span>( request: *<a href="std.http.Server.Request.html">Request</a>, content: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, options: <a href="std.http.Server.Request.RespondOptions.html">RespondOptions</a>, ) <a href="std.http.Server.Response.html">Response</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Send an entire HTTP response to the client, including headers and body.</p>
<p>Automatically handles HEAD requests by omitting the body.</p>
<p>Unless <code>transfer_encoding</code> is specified, uses the &quot;content-length&quot;
header.</p>
<p>If the request contains a body and the connection is to be reused,
discards the request body, leaving the Server in the <code>ready</code> state. If
this discarding fails, the connection is marked as not to be reused and
no error is surfaced.</p>
<p>Asserts status is not <code>continue</code>.
Asserts there are at most 25 extra_headers.
Asserts that &quot;\r\n&quot; does not occur in any header name or value.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>request: *<a href="std.http.Server.Request.html">Request</a></code></pre></div><div><pre><code>content: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>options: <a href="std.http.Server.Request.RespondOptions.html">RespondOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Server.Request.respond">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">respond</span>(
    request: *<a href="std.http.Server.Request.html">Request</a>,
    content: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    options: <a href="std.http.Server.Request.RespondOptions.html">RespondOptions</a>,
) <a href="std.http.Server.Response.html">Response</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> max_extra_headers = <span class="tok-number">25</span>;
    <a href="std.debug.html#std.debug.assert">assert</a>(options.status != .@&quot;continue&quot;);
    <a href="std.debug.html#std.debug.assert">assert</a>(options.extra_headers.len &lt;= max_extra_headers);
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) {
        <span class="tok-kw">for</span> (options.extra_headers) |header| {
            <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-str">':'</span>) == <span class="tok-null">null</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
            <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.value, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
        }
    }

    <span class="tok-kw">const</span> transfer_encoding_none = (options.transfer_encoding <span class="tok-kw">orelse</span> .chunked) == .none;
    <span class="tok-kw">const</span> server_keep_alive = !transfer_encoding_none <span class="tok-kw">and</span> options.keep_alive;
    <span class="tok-kw">const</span> keep_alive = request.discardBody(server_keep_alive);

    <span class="tok-kw">const</span> phrase = options.reason <span class="tok-kw">orelse</span> options.status.phrase() <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;

    <span class="tok-kw">var</span> first_buffer: [<span class="tok-number">500</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> h = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).initBuffer(&amp;first_buffer);
    <span class="tok-kw">if</span> (request.head.expect != <span class="tok-null">null</span>) {<span class="tok-comment">
        // reader() and hence discardBody() above sets expect to null if it
        // is handled. So the fact that it is not null here means unhandled.
        </span>h.appendSliceAssumeCapacity(<span class="tok-str">&quot;HTTP/1.1 417 Expectation Failed\r\n&quot;</span>);
        <span class="tok-kw">if</span> (!keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: close\r\n&quot;</span>);
        h.appendSliceAssumeCapacity(<span class="tok-str">&quot;content-length: 0\r\n\r\n&quot;</span>);
        <span class="tok-kw">try</span> request.server.connection.stream.writeAll(h.items);
        <span class="tok-kw">return</span>;
    }
    h.fixedWriter().print(<span class="tok-str">&quot;{s} {d} {s}\r\n&quot;</span>, .{
        <span class="tok-builtin">@tagName</span>(options.version), <span class="tok-builtin">@intFromEnum</span>(options.status), phrase,
    }) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

    <span class="tok-kw">switch</span> (options.version) {
        .@&quot;HTTP/1.0&quot; =&gt; <span class="tok-kw">if</span> (keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: keep-alive\r\n&quot;</span>),
        .@&quot;HTTP/1.1&quot; =&gt; <span class="tok-kw">if</span> (!keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: close\r\n&quot;</span>),
    }

    <span class="tok-kw">if</span> (options.transfer_encoding) |transfer_encoding| <span class="tok-kw">switch</span> (transfer_encoding) {
        .none =&gt; {},
        .chunked =&gt; h.appendSliceAssumeCapacity(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>),
    } <span class="tok-kw">else</span> {
        h.fixedWriter().print(<span class="tok-str">&quot;content-length: {d}\r\n&quot;</span>, .{content.len}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">var</span> chunk_header_buffer: [<span class="tok-number">18</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> iovecs: [max_extra_headers * <span class="tok-number">4</span> + <span class="tok-number">3</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> iovecs_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    iovecs[iovecs_len] = .{
        .base = h.items.ptr,
        .len = h.items.len,
    };
    iovecs_len += <span class="tok-number">1</span>;

    <span class="tok-kw">for</span> (options.extra_headers) |header| {
        iovecs[iovecs_len] = .{
            .base = header.name.ptr,
            .len = header.name.len,
        };
        iovecs_len += <span class="tok-number">1</span>;

        iovecs[iovecs_len] = .{
            .base = <span class="tok-str">&quot;: &quot;</span>,
            .len = <span class="tok-number">2</span>,
        };
        iovecs_len += <span class="tok-number">1</span>;

        <span class="tok-kw">if</span> (header.value.len != <span class="tok-number">0</span>) {
            iovecs[iovecs_len] = .{
                .base = header.value.ptr,
                .len = header.value.len,
            };
            iovecs_len += <span class="tok-number">1</span>;
        }

        iovecs[iovecs_len] = .{
            .base = <span class="tok-str">&quot;\r\n&quot;</span>,
            .len = <span class="tok-number">2</span>,
        };
        iovecs_len += <span class="tok-number">1</span>;
    }

    iovecs[iovecs_len] = .{
        .base = <span class="tok-str">&quot;\r\n&quot;</span>,
        .len = <span class="tok-number">2</span>,
    };
    iovecs_len += <span class="tok-number">1</span>;

    <span class="tok-kw">if</span> (request.head.method != .HEAD) {
        <span class="tok-kw">const</span> is_chunked = (options.transfer_encoding <span class="tok-kw">orelse</span> .none) == .chunked;
        <span class="tok-kw">if</span> (is_chunked) {
            <span class="tok-kw">if</span> (content.len &gt; <span class="tok-number">0</span>) {
                <span class="tok-kw">const</span> chunk_header = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(
                    &amp;chunk_header_buffer,
                    <span class="tok-str">&quot;{x}\r\n&quot;</span>,
                    .{content.len},
                ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

                iovecs[iovecs_len] = .{
                    .base = chunk_header.ptr,
                    .len = chunk_header.len,
                };
                iovecs_len += <span class="tok-number">1</span>;

                iovecs[iovecs_len] = .{
                    .base = content.ptr,
                    .len = content.len,
                };
                iovecs_len += <span class="tok-number">1</span>;

                iovecs[iovecs_len] = .{
                    .base = <span class="tok-str">&quot;\r\n&quot;</span>,
                    .len = <span class="tok-number">2</span>,
                };
                iovecs_len += <span class="tok-number">1</span>;
            }

            iovecs[iovecs_len] = .{
                .base = <span class="tok-str">&quot;0\r\n\r\n&quot;</span>,
                .len = <span class="tok-number">5</span>,
            };
            iovecs_len += <span class="tok-number">1</span>;
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (content.len &gt; <span class="tok-number">0</span>) {
            iovecs[iovecs_len] = .{
                .base = content.ptr,
                .len = content.len,
            };
            iovecs_len += <span class="tok-number">1</span>;
        }
    }

    <span class="tok-kw">try</span> request.server.connection.stream.writevAll(iovecs[<span class="tok-number">0</span>..iovecs_len]);
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Server.Request.respondStreaming" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">respondStreaming</span><a href="#src.zig-std.http.Server.Request.respondStreaming">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">respondStreaming</span>(request: *<a href="std.http.Server.Request.html">Request</a>, options: <a href="std.http.Server.Request.RespondStreamingOptions.html">RespondStreamingOptions</a>) <a href="std.http.Server.Response.html">Response</a></code></pre></div><div class="tldDocs"><p>The header is buffered but not sent until Response.flush is called.</p>
<p>If the request contains a body and the connection is to be reused,
discards the request body, leaving the Server in the <code>ready</code> state. If
this discarding fails, the connection is marked as not to be reused and
no error is surfaced.</p>
<p>HEAD requests are handled transparently by setting a flag on the
returned Response to omit the body. However it may be worth noticing
that flag and skipping any expensive work that would otherwise need to
be done to satisfy the request.</p>
<p>Asserts <code>send_buffer</code> is large enough to store the entire response header.
Asserts status is not <code>continue</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>request: *<a href="std.http.Server.Request.html">Request</a></code></pre></div><div><pre><code>options: <a href="std.http.Server.Request.RespondStreamingOptions.html">RespondStreamingOptions</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Server.Request.respondStreaming">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">respondStreaming</span>(request: *<a href="std.http.Server.Request.html">Request</a>, options: <a href="std.http.Server.Request.RespondStreamingOptions.html">RespondStreamingOptions</a>) <a href="std.http.Server.Response.html">Response</a> {
    <span class="tok-kw">const</span> o = options.respond_options;
    <a href="std.debug.html#std.debug.assert">assert</a>(o.status != .@&quot;continue&quot;);
    <span class="tok-kw">const</span> transfer_encoding_none = (o.transfer_encoding <span class="tok-kw">orelse</span> .chunked) == .none;
    <span class="tok-kw">const</span> server_keep_alive = !transfer_encoding_none <span class="tok-kw">and</span> o.keep_alive;
    <span class="tok-kw">const</span> keep_alive = request.discardBody(server_keep_alive);
    <span class="tok-kw">const</span> phrase = o.reason <span class="tok-kw">orelse</span> o.status.phrase() <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;

    <span class="tok-kw">var</span> h = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).initBuffer(options.send_buffer);

    <span class="tok-kw">const</span> elide_body = <span class="tok-kw">if</span> (request.head.expect != <span class="tok-null">null</span>) eb: {<span class="tok-comment">
        // reader() and hence discardBody() above sets expect to null if it
        // is handled. So the fact that it is not null here means unhandled.
        </span>h.appendSliceAssumeCapacity(<span class="tok-str">&quot;HTTP/1.1 417 Expectation Failed\r\n&quot;</span>);
        <span class="tok-kw">if</span> (!keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: close\r\n&quot;</span>);
        h.appendSliceAssumeCapacity(<span class="tok-str">&quot;content-length: 0\r\n\r\n&quot;</span>);
        <span class="tok-kw">break</span> :eb <span class="tok-null">true</span>;
    } <span class="tok-kw">else</span> eb: {
        h.fixedWriter().print(<span class="tok-str">&quot;{s} {d} {s}\r\n&quot;</span>, .{
            <span class="tok-builtin">@tagName</span>(o.version), <span class="tok-builtin">@intFromEnum</span>(o.status), phrase,
        }) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">switch</span> (o.version) {
            .@&quot;HTTP/1.0&quot; =&gt; <span class="tok-kw">if</span> (keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: keep-alive\r\n&quot;</span>),
            .@&quot;HTTP/1.1&quot; =&gt; <span class="tok-kw">if</span> (!keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: close\r\n&quot;</span>),
        }

        <span class="tok-kw">if</span> (o.transfer_encoding) |transfer_encoding| <span class="tok-kw">switch</span> (transfer_encoding) {
            .chunked =&gt; h.appendSliceAssumeCapacity(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>),
            .none =&gt; {},
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (options.content_length) |len| {
            h.fixedWriter().print(<span class="tok-str">&quot;content-length: {d}\r\n&quot;</span>, .{len}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        } <span class="tok-kw">else</span> {
            h.appendSliceAssumeCapacity(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>);
        }

        <span class="tok-kw">for</span> (o.extra_headers) |header| {
            <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);
            h.appendSliceAssumeCapacity(header.name);
            h.appendSliceAssumeCapacity(<span class="tok-str">&quot;: &quot;</span>);
            h.appendSliceAssumeCapacity(header.value);
            h.appendSliceAssumeCapacity(<span class="tok-str">&quot;\r\n&quot;</span>);
        }

        h.appendSliceAssumeCapacity(<span class="tok-str">&quot;\r\n&quot;</span>);
        <span class="tok-kw">break</span> :eb request.head.method == .HEAD;
    };

    <span class="tok-kw">return</span> .{
        .stream = request.server.connection.stream,
        .send_buffer = options.send_buffer,
        .send_buffer_start = <span class="tok-number">0</span>,
        .send_buffer_end = h.items.len,
        .transfer_encoding = <span class="tok-kw">if</span> (o.transfer_encoding) |te| <span class="tok-kw">switch</span> (te) {
            .chunked =&gt; .chunked,
            .none =&gt; .none,
        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (options.content_length) |len| .{
            .content_length = len,
        } <span class="tok-kw">else</span> .chunked,
        .elide_body = elide_body,
        .chunk_len = <span class="tok-number">0</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.http.Server.Request.reader" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reader</span><a href="#src.zig-std.http.Server.Request.reader">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(request: *<a href="std.http.Server.Request.html">Request</a>) <a href="std.http.Server.Request.html#std.http.Server.Request.ReaderError">ReaderError</a>!<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.Reader.html">AnyReader</a></code></pre></div><div class="tldDocs"><p>In the case that the request contains &quot;expect: 100-continue&quot;, this
function writes the continuation header, which means it can fail with a
write error. After sending the continuation header, it sets the
request's expect field to <code>null</code>.</p>
<p>Asserts that this function is only called once.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>request: *<a href="std.http.Server.Request.html">Request</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.http.Server.Request.reader">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(request: *<a href="std.http.Server.Request.html">Request</a>) <a href="std.http.Server.Request.html#std.http.Server.Request.ReaderError">ReaderError</a>!<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.Reader.html">AnyReader</a> {
    <span class="tok-kw">const</span> s = request.server;
    <a href="std.debug.html#std.debug.assert">assert</a>(s.state == .received_head);
    s.state = .receiving_body;
    s.next_request_start = request.head_end;

    <span class="tok-kw">if</span> (request.head.expect) |expect| {
        <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, expect, <span class="tok-str">&quot;100-continue&quot;</span>)) {
            <span class="tok-kw">try</span> request.server.connection.stream.writeAll(<span class="tok-str">&quot;HTTP/1.1 100 Continue\r\n\r\n&quot;</span>);
            request.head.expect = <span class="tok-null">null</span>;
        } <span class="tok-kw">else</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpExpectationFailed;
        }
    }

    <span class="tok-kw">switch</span> (request.head.transfer_encoding) {
        .chunked =&gt; {
            request.reader_state = .{ .chunk_parser = <a href="std.http.html">http</a>.<a href="std.http.ChunkParser.html">ChunkParser</a>.<a href="std.http.ChunkParser.html#std.http.ChunkParser.init">init</a> };
            <span class="tok-kw">return</span> .{
                .readFn = <a href="std.http.Server.Request.html#std.http.Server.Request.read_chunked">read_chunked</a>,
                .context = request,
            };
        },
        .none =&gt; {
            request.reader_state = .{
                .remaining_content_length = request.head.content_length <span class="tok-kw">orelse</span> <span class="tok-number">0</span>,
            };
            <span class="tok-kw">return</span> .{
                .readFn = <a href="std.http.Server.Request.html#std.http.Server.Request.read_cl">read_cl</a>,
                .context = request,
            };
        },
    }
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.http.Server.Request">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Request = <span class="tok-kw">struct</span> {
    server: *<a href="std.http.Server.html">Server</a>,
    <span class="tok-comment">/// Index into Server's read_buffer.</span>
    head_end: <span class="tok-type">usize</span>,
    head: <a href="std.http.Server.Request.Head.html">Head</a>,
    reader_state: <span class="tok-kw">union</span> {
        remaining_content_length: <span class="tok-type">u64</span>,
        chunk_parser: <a href="std.http.html">http</a>.<a href="std.http.ChunkParser.html">ChunkParser</a>,
    },

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Compression = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DeflateDecompressor = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.zlib.html">zlib</a>.<a href="std.compress.zlib.html#std.compress.zlib.Decompressor">Decompressor</a>(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.Reader.html">AnyReader</a>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GzipDecompressor = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.gzip.html">gzip</a>.<a href="std.compress.gzip.html#std.compress.gzip.Decompressor">Decompressor</a>(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.Reader.html">AnyReader</a>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ZstdDecompressor = <a href="std.html">std</a>.<a href="std.compress.html">compress</a>.<a href="std.compress.zstandard.html">zstd</a>.<a href="std.compress.zstandard.html#std.compress.zstandard.Decompressor">Decompressor</a>(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.Reader.html">AnyReader</a>);

        deflate: <a href="std.http.Server.Request.Compression.html#std.http.Server.Request.Compression.DeflateDecompressor">DeflateDecompressor</a>,
        gzip: <a href="std.http.Server.Request.Compression.html#std.http.Server.Request.Compression.GzipDecompressor">GzipDecompressor</a>,
        zstd: <a href="std.http.Server.Request.Compression.html#std.http.Server.Request.Compression.ZstdDecompressor">ZstdDecompressor</a>,
        none: <span class="tok-type">void</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Head = <span class="tok-kw">struct</span> {
        method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a>,
        target: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a>,
        expect: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        content_type: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        content_length: ?<span class="tok-type">u64</span>,
        transfer_encoding: <a href="std.http.html">http</a>.<a href="std.http.TransferEncoding.html">TransferEncoding</a>,
        transfer_compression: <a href="std.http.html">http</a>.<a href="std.http.ContentEncoding.html">ContentEncoding</a>,
        keep_alive: <span class="tok-type">bool</span>,
        compression: <a href="std.http.Server.Request.Compression.html">Compression</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ParseError = <span class="tok-kw">error</span>{
            UnknownHttpMethod,
            HttpHeadersInvalid,
            HttpHeaderContinuationsUnsupported,
            HttpTransferEncodingUnsupported,
            HttpConnectionHeaderUnsupported,
            InvalidContentLength,
            CompressionUnsupported,
            MissingFinalNewline,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parse</span>(bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.http.Server.Request.Head.html#std.http.Server.Request.Head.ParseError">ParseError</a>!<a href="std.http.Server.Request.Head.html">Head</a> {
            <span class="tok-kw">var</span> it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitSequence">splitSequence</a>(<span class="tok-type">u8</span>, bytes, <span class="tok-str">&quot;\r\n&quot;</span>);

            <span class="tok-kw">const</span> first_line = it.next().?;
            <span class="tok-kw">if</span> (first_line.len &lt; <span class="tok-number">10</span>)
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;

            <span class="tok-kw">const</span> method_end = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, first_line, <span class="tok-str">' '</span>) <span class="tok-kw">orelse</span>
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;
            <span class="tok-kw">if</span> (method_end &gt; <span class="tok-number">24</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;

            <span class="tok-kw">const</span> method_str = first_line[<span class="tok-number">0</span>..method_end];
            <span class="tok-kw">const</span> method: <a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a> = <span class="tok-builtin">@enumFromInt</span>(<a href="std.http.html">http</a>.<a href="std.http.Method.html">Method</a>.<a href="std.http.Method.html#std.http.Method.parse">parse</a>(method_str));

            <span class="tok-kw">const</span> version_start = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lastIndexOfScalar">lastIndexOfScalar</a>(<span class="tok-type">u8</span>, first_line, <span class="tok-str">' '</span>) <span class="tok-kw">orelse</span>
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;
            <span class="tok-kw">if</span> (version_start == method_end) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;

            <span class="tok-kw">const</span> version_str = first_line[version_start + <span class="tok-number">1</span> ..];
            <span class="tok-kw">if</span> (version_str.len != <span class="tok-number">8</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;
            <span class="tok-kw">const</span> version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a> = <span class="tok-kw">switch</span> (<a href="std.http.Server.Request.Head.html#std.http.Server.Request.Head.int64">int64</a>(version_str[<span class="tok-number">0</span>..<span class="tok-number">8</span>])) {
                <a href="std.http.Server.Request.Head.html#std.http.Server.Request.Head.int64">int64</a>(<span class="tok-str">&quot;HTTP/1.0&quot;</span>) =&gt; .@&quot;HTTP/1.0&quot;,
                <a href="std.http.Server.Request.Head.html#std.http.Server.Request.Head.int64">int64</a>(<span class="tok-str">&quot;HTTP/1.1&quot;</span>) =&gt; .@&quot;HTTP/1.1&quot;,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid,
            };

            <span class="tok-kw">const</span> target = first_line[method_end + <span class="tok-number">1</span> .. version_start];

            <span class="tok-kw">var</span> head: <a href="std.http.Server.Request.Head.html">Head</a> = .{
                .method = method,
                .target = target,
                .version = version,
                .expect = <span class="tok-null">null</span>,
                .content_type = <span class="tok-null">null</span>,
                .content_length = <span class="tok-null">null</span>,
                .transfer_encoding = .none,
                .transfer_compression = .identity,
                .keep_alive = <span class="tok-kw">switch</span> (version) {
                    .@&quot;HTTP/1.0&quot; =&gt; <span class="tok-null">false</span>,
                    .@&quot;HTTP/1.1&quot; =&gt; <span class="tok-null">true</span>,
                },
                .compression = .none,
            };

            <span class="tok-kw">while</span> (it.next()) |line| {
                <span class="tok-kw">if</span> (line.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> head;
                <span class="tok-kw">switch</span> (line[<span class="tok-number">0</span>]) {
                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeaderContinuationsUnsupported,
                    <span class="tok-kw">else</span> =&gt; {},
                }

                <span class="tok-kw">var</span> line_it = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitScalar">splitScalar</a>(<span class="tok-type">u8</span>, line, <span class="tok-str">':'</span>);
                <span class="tok-kw">const</span> header_name = line_it.next().?;
                <span class="tok-kw">const</span> header_value = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, line_it.rest(), <span class="tok-str">&quot; \t&quot;</span>);
                <span class="tok-kw">if</span> (header_name.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;

                <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;connection&quot;</span>)) {
                    head.keep_alive = !<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_value, <span class="tok-str">&quot;close&quot;</span>);
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;expect&quot;</span>)) {
                    head.expect = header_value;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;content-type&quot;</span>)) {
                    head.content_type = header_value;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;content-length&quot;</span>)) {
                    <span class="tok-kw">if</span> (head.content_length != <span class="tok-null">null</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;
                    head.content_length = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.parseInt">parseInt</a>(<span class="tok-type">u64</span>, header_value, <span class="tok-number">10</span>) <span class="tok-kw">catch</span>
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidContentLength;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;content-encoding&quot;</span>)) {
                    <span class="tok-kw">if</span> (head.transfer_compression != .identity) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;

                    <span class="tok-kw">const</span> trimmed = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, header_value, <span class="tok-str">&quot; &quot;</span>);

                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(<a href="std.http.html">http</a>.<a href="std.http.ContentEncoding.html">ContentEncoding</a>, trimmed)) |ce| {
                        head.transfer_compression = ce;
                    } <span class="tok-kw">else</span> {
                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpTransferEncodingUnsupported;
                    }
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.ascii.html">ascii</a>.<a href="std.ascii.html#std.ascii.eqlIgnoreCase">eqlIgnoreCase</a>(header_name, <span class="tok-str">&quot;transfer-encoding&quot;</span>)) {<span class="tok-comment">
                    // Transfer-Encoding: second, first
                    // Transfer-Encoding: deflate, chunked
                    </span><span class="tok-kw">var</span> iter = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.splitBackwardsScalar">splitBackwardsScalar</a>(<span class="tok-type">u8</span>, header_value, <span class="tok-str">','</span>);

                    <span class="tok-kw">const</span> first = iter.first();
                    <span class="tok-kw">const</span> trimmed_first = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, first, <span class="tok-str">&quot; &quot;</span>);

                    <span class="tok-kw">var</span> next: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = first;
                    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(<a href="std.http.html">http</a>.<a href="std.http.TransferEncoding.html">TransferEncoding</a>, trimmed_first)) |transfer| {
                        <span class="tok-kw">if</span> (head.transfer_encoding != .none)
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;<span class="tok-comment"> // we already have a transfer encoding
                        </span>head.transfer_encoding = transfer;

                        next = iter.next();
                    }

                    <span class="tok-kw">if</span> (next) |second| {
                        <span class="tok-kw">const</span> trimmed_second = <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.trim">trim</a>(<span class="tok-type">u8</span>, second, <span class="tok-str">&quot; &quot;</span>);

                        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.stringToEnum">stringToEnum</a>(<a href="std.http.html">http</a>.<a href="std.http.ContentEncoding.html">ContentEncoding</a>, trimmed_second)) |transfer| {
                            <span class="tok-kw">if</span> (head.transfer_compression != .identity)
                                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersInvalid;<span class="tok-comment"> // double compression is not supported
                            </span>head.transfer_compression = transfer;
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpTransferEncodingUnsupported;
                        }
                    }

                    <span class="tok-kw">if</span> (iter.next()) |_| <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpTransferEncodingUnsupported;
                }
            }
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MissingFinalNewline;
        }

        <span class="tok-kw">test</span> parse {
            <span class="tok-kw">const</span> request_bytes = <span class="tok-str">&quot;GET /hi HTTP/1.0\r\n&quot;</span> ++
                <span class="tok-str">&quot;content-tYpe: text/plain\r\n&quot;</span> ++
                <span class="tok-str">&quot;content-Length:10\r\n&quot;</span> ++
                <span class="tok-str">&quot;expeCt:   100-continue \r\n&quot;</span> ++
                <span class="tok-str">&quot;TRansfer-encoding:\tdeflate, chunked \r\n&quot;</span> ++
                <span class="tok-str">&quot;connectioN:\t keep-alive \r\n\r\n&quot;</span>;

            <span class="tok-kw">const</span> req = <span class="tok-kw">try</span> <a href="std.http.Server.Request.Head.html#std.http.Server.Request.Head.parse">parse</a>(request_bytes);

            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.GET, req.method);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.@&quot;HTTP/1.0&quot;, req.version);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;/hi&quot;</span>, req.target);

            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;text/plain&quot;</span>, req.content_type.?);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;100-continue&quot;</span>, req.expect.?);

            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">true</span>, req.keep_alive);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">10</span>, req.content_length.?);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.chunked, req.transfer_encoding);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(.deflate, req.transfer_compression);
        }

        <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">int64</span>(array: *<span class="tok-kw">const</span> [<span class="tok-number">8</span>]<span class="tok-type">u8</span>) <span class="tok-type">u64</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(array.*);
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterateHeaders</span>(r: *<a href="std.http.Server.Request.html">Request</a>) <a href="std.http.html">http</a>.<a href="std.http.HeaderIterator.html">HeaderIterator</a> {
        <span class="tok-kw">return</span> <a href="std.http.html">http</a>.<a href="std.http.HeaderIterator.html">HeaderIterator</a>.<a href="std.http.HeaderIterator.html#std.http.HeaderIterator.init">init</a>(r.server.read_buffer[<span class="tok-number">0</span>..r.head_end]);
    }

    <span class="tok-kw">test</span> iterateHeaders {
        <span class="tok-kw">const</span> request_bytes = <span class="tok-str">&quot;GET /hi HTTP/1.0\r\n&quot;</span> ++
            <span class="tok-str">&quot;content-tYpe: text/plain\r\n&quot;</span> ++
            <span class="tok-str">&quot;content-Length:10\r\n&quot;</span> ++
            <span class="tok-str">&quot;expeCt:   100-continue \r\n&quot;</span> ++
            <span class="tok-str">&quot;TRansfer-encoding:\tdeflate, chunked \r\n&quot;</span> ++
            <span class="tok-str">&quot;connectioN:\t keep-alive \r\n\r\n&quot;</span>;

        <span class="tok-kw">var</span> read_buffer: [<span class="tok-number">500</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-builtin">@memcpy</span>(read_buffer[<span class="tok-number">0</span>..request_bytes.len], request_bytes);

        <span class="tok-kw">var</span> server: <a href="std.http.Server.html">Server</a> = .{
            .connection = <span class="tok-null">undefined</span>,
            .state = .ready,
            .read_buffer = &amp;read_buffer,
            .read_buffer_len = request_bytes.len,
            .next_request_start = <span class="tok-number">0</span>,
        };

        <span class="tok-kw">var</span> request: <a href="std.http.Server.Request.html">Request</a> = .{
            .server = &amp;server,
            .head_end = request_bytes.len,
            .head = <span class="tok-null">undefined</span>,
            .reader_state = <span class="tok-null">undefined</span>,
        };

        <span class="tok-kw">var</span> it = request.iterateHeaders();
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content-tYpe&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;text/plain&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;content-Length&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;10&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;expeCt&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;100-continue&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;TRansfer-encoding&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;deflate, chunked&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        {
            <span class="tok-kw">const</span> header = it.next().?;
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;connectioN&quot;</span>, header.name);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqualStrings">expectEqualStrings</a>(<span class="tok-str">&quot;keep-alive&quot;</span>, header.value);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(!it.is_trailer);
        }
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">null</span>, it.next());
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> RespondOptions = <span class="tok-kw">struct</span> {
        version: <a href="std.http.html">http</a>.<a href="std.http.Version.html">Version</a> = .@&quot;HTTP/1.1&quot;,
        status: <a href="std.http.html">http</a>.<a href="std.http.Status.html">Status</a> = .ok,
        reason: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
        keep_alive: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
        extra_headers: []<span class="tok-kw">const</span> <a href="std.http.html">http</a>.<a href="std.http.Header.html">Header</a> = &amp;.{},
        transfer_encoding: ?<a href="std.http.html">http</a>.<a href="std.http.TransferEncoding.html">TransferEncoding</a> = <span class="tok-null">null</span>,
    };

    <span class="tok-comment">/// Send an entire HTTP response to the client, including headers and body.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Automatically handles HEAD requests by omitting the body.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Unless `transfer_encoding` is specified, uses the &quot;content-length&quot;</span>
    <span class="tok-comment">/// header.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If the request contains a body and the connection is to be reused,</span>
    <span class="tok-comment">/// discards the request body, leaving the Server in the `ready` state. If</span>
    <span class="tok-comment">/// this discarding fails, the connection is marked as not to be reused and</span>
    <span class="tok-comment">/// no error is surfaced.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts status is not `continue`.</span>
    <span class="tok-comment">/// Asserts there are at most 25 extra_headers.</span>
    <span class="tok-comment">/// Asserts that &quot;\r\n&quot; does not occur in any header name or value.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">respond</span>(
        request: *<a href="std.http.Server.Request.html">Request</a>,
        content: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        options: <a href="std.http.Server.Request.RespondOptions.html">RespondOptions</a>,
    ) <a href="std.http.Server.Response.html">Response</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> max_extra_headers = <span class="tok-number">25</span>;
        <a href="std.debug.html#std.debug.assert">assert</a>(options.status != .@&quot;continue&quot;);
        <a href="std.debug.html#std.debug.assert">assert</a>(options.extra_headers.len &lt;= max_extra_headers);
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) {
            <span class="tok-kw">for</span> (options.extra_headers) |header| {
                <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-str">':'</span>) == <span class="tok-null">null</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.name, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfPosLinear">indexOfPosLinear</a>(<span class="tok-type">u8</span>, header.value, <span class="tok-number">0</span>, <span class="tok-str">&quot;\r\n&quot;</span>) == <span class="tok-null">null</span>);
            }
        }

        <span class="tok-kw">const</span> transfer_encoding_none = (options.transfer_encoding <span class="tok-kw">orelse</span> .chunked) == .none;
        <span class="tok-kw">const</span> server_keep_alive = !transfer_encoding_none <span class="tok-kw">and</span> options.keep_alive;
        <span class="tok-kw">const</span> keep_alive = request.discardBody(server_keep_alive);

        <span class="tok-kw">const</span> phrase = options.reason <span class="tok-kw">orelse</span> options.status.phrase() <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;

        <span class="tok-kw">var</span> first_buffer: [<span class="tok-number">500</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> h = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).initBuffer(&amp;first_buffer);
        <span class="tok-kw">if</span> (request.head.expect != <span class="tok-null">null</span>) {<span class="tok-comment">
            // reader() and hence discardBody() above sets expect to null if it
            // is handled. So the fact that it is not null here means unhandled.
            </span>h.appendSliceAssumeCapacity(<span class="tok-str">&quot;HTTP/1.1 417 Expectation Failed\r\n&quot;</span>);
            <span class="tok-kw">if</span> (!keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: close\r\n&quot;</span>);
            h.appendSliceAssumeCapacity(<span class="tok-str">&quot;content-length: 0\r\n\r\n&quot;</span>);
            <span class="tok-kw">try</span> request.server.connection.stream.writeAll(h.items);
            <span class="tok-kw">return</span>;
        }
        h.fixedWriter().print(<span class="tok-str">&quot;{s} {d} {s}\r\n&quot;</span>, .{
            <span class="tok-builtin">@tagName</span>(options.version), <span class="tok-builtin">@intFromEnum</span>(options.status), phrase,
        }) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

        <span class="tok-kw">switch</span> (options.version) {
            .@&quot;HTTP/1.0&quot; =&gt; <span class="tok-kw">if</span> (keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: keep-alive\r\n&quot;</span>),
            .@&quot;HTTP/1.1&quot; =&gt; <span class="tok-kw">if</span> (!keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: close\r\n&quot;</span>),
        }

        <span class="tok-kw">if</span> (options.transfer_encoding) |transfer_encoding| <span class="tok-kw">switch</span> (transfer_encoding) {
            .none =&gt; {},
            .chunked =&gt; h.appendSliceAssumeCapacity(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>),
        } <span class="tok-kw">else</span> {
            h.fixedWriter().print(<span class="tok-str">&quot;content-length: {d}\r\n&quot;</span>, .{content.len}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">var</span> chunk_header_buffer: [<span class="tok-number">18</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> iovecs: [max_extra_headers * <span class="tok-number">4</span> + <span class="tok-number">3</span>]<a href="std.html">std</a>.<a href="std.posix.html">posix</a>.<a href="std.posix.iovec_const.html">iovec_const</a> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> iovecs_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

        iovecs[iovecs_len] = .{
            .base = h.items.ptr,
            .len = h.items.len,
        };
        iovecs_len += <span class="tok-number">1</span>;

        <span class="tok-kw">for</span> (options.extra_headers) |header| {
            iovecs[iovecs_len] = .{
                .base = header.name.ptr,
                .len = header.name.len,
            };
            iovecs_len += <span class="tok-number">1</span>;

            iovecs[iovecs_len] = .{
                .base = <span class="tok-str">&quot;: &quot;</span>,
                .len = <span class="tok-number">2</span>,
            };
            iovecs_len += <span class="tok-number">1</span>;

            <span class="tok-kw">if</span> (header.value.len != <span class="tok-number">0</span>) {
                iovecs[iovecs_len] = .{
                    .base = header.value.ptr,
                    .len = header.value.len,
                };
                iovecs_len += <span class="tok-number">1</span>;
            }

            iovecs[iovecs_len] = .{
                .base = <span class="tok-str">&quot;\r\n&quot;</span>,
                .len = <span class="tok-number">2</span>,
            };
            iovecs_len += <span class="tok-number">1</span>;
        }

        iovecs[iovecs_len] = .{
            .base = <span class="tok-str">&quot;\r\n&quot;</span>,
            .len = <span class="tok-number">2</span>,
        };
        iovecs_len += <span class="tok-number">1</span>;

        <span class="tok-kw">if</span> (request.head.method != .HEAD) {
            <span class="tok-kw">const</span> is_chunked = (options.transfer_encoding <span class="tok-kw">orelse</span> .none) == .chunked;
            <span class="tok-kw">if</span> (is_chunked) {
                <span class="tok-kw">if</span> (content.len &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> chunk_header = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.bufPrint">bufPrint</a>(
                        &amp;chunk_header_buffer,
                        <span class="tok-str">&quot;{x}\r\n&quot;</span>,
                        .{content.len},
                    ) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

                    iovecs[iovecs_len] = .{
                        .base = chunk_header.ptr,
                        .len = chunk_header.len,
                    };
                    iovecs_len += <span class="tok-number">1</span>;

                    iovecs[iovecs_len] = .{
                        .base = content.ptr,
                        .len = content.len,
                    };
                    iovecs_len += <span class="tok-number">1</span>;

                    iovecs[iovecs_len] = .{
                        .base = <span class="tok-str">&quot;\r\n&quot;</span>,
                        .len = <span class="tok-number">2</span>,
                    };
                    iovecs_len += <span class="tok-number">1</span>;
                }

                iovecs[iovecs_len] = .{
                    .base = <span class="tok-str">&quot;0\r\n\r\n&quot;</span>,
                    .len = <span class="tok-number">5</span>,
                };
                iovecs_len += <span class="tok-number">1</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (content.len &gt; <span class="tok-number">0</span>) {
                iovecs[iovecs_len] = .{
                    .base = content.ptr,
                    .len = content.len,
                };
                iovecs_len += <span class="tok-number">1</span>;
            }
        }

        <span class="tok-kw">try</span> request.server.connection.stream.writevAll(iovecs[<span class="tok-number">0</span>..iovecs_len]);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> RespondStreamingOptions = <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// An externally managed slice of memory used to batch bytes before</span>
        <span class="tok-comment">/// sending. `respondStreaming` asserts this is large enough to store</span>
        <span class="tok-comment">/// the full HTTP response head.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Must outlive the returned Response.</span>
        send_buffer: []<span class="tok-type">u8</span>,
        <span class="tok-comment">/// If provided, the response will use the content-length header;</span>
        <span class="tok-comment">/// otherwise it will use transfer-encoding: chunked.</span>
        content_length: ?<span class="tok-type">u64</span> = <span class="tok-null">null</span>,
        <span class="tok-comment">/// Options that are shared with the `respond` method.</span>
        respond_options: <a href="std.http.Server.Request.RespondOptions.html">RespondOptions</a> = .{},
    };

    <span class="tok-comment">/// The header is buffered but not sent until Response.flush is called.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// If the request contains a body and the connection is to be reused,</span>
    <span class="tok-comment">/// discards the request body, leaving the Server in the `ready` state. If</span>
    <span class="tok-comment">/// this discarding fails, the connection is marked as not to be reused and</span>
    <span class="tok-comment">/// no error is surfaced.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// HEAD requests are handled transparently by setting a flag on the</span>
    <span class="tok-comment">/// returned Response to omit the body. However it may be worth noticing</span>
    <span class="tok-comment">/// that flag and skipping any expensive work that would otherwise need to</span>
    <span class="tok-comment">/// be done to satisfy the request.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts `send_buffer` is large enough to store the entire response header.</span>
    <span class="tok-comment">/// Asserts status is not `continue`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">respondStreaming</span>(request: *<a href="std.http.Server.Request.html">Request</a>, options: <a href="std.http.Server.Request.RespondStreamingOptions.html">RespondStreamingOptions</a>) <a href="std.http.Server.Response.html">Response</a> {
        <span class="tok-kw">const</span> o = options.respond_options;
        <a href="std.debug.html#std.debug.assert">assert</a>(o.status != .@&quot;continue&quot;);
        <span class="tok-kw">const</span> transfer_encoding_none = (o.transfer_encoding <span class="tok-kw">orelse</span> .chunked) == .none;
        <span class="tok-kw">const</span> server_keep_alive = !transfer_encoding_none <span class="tok-kw">and</span> o.keep_alive;
        <span class="tok-kw">const</span> keep_alive = request.discardBody(server_keep_alive);
        <span class="tok-kw">const</span> phrase = o.reason <span class="tok-kw">orelse</span> o.status.phrase() <span class="tok-kw">orelse</span> <span class="tok-str">&quot;&quot;</span>;

        <span class="tok-kw">var</span> h = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).initBuffer(options.send_buffer);

        <span class="tok-kw">const</span> elide_body = <span class="tok-kw">if</span> (request.head.expect != <span class="tok-null">null</span>) eb: {<span class="tok-comment">
            // reader() and hence discardBody() above sets expect to null if it
            // is handled. So the fact that it is not null here means unhandled.
            </span>h.appendSliceAssumeCapacity(<span class="tok-str">&quot;HTTP/1.1 417 Expectation Failed\r\n&quot;</span>);
            <span class="tok-kw">if</span> (!keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: close\r\n&quot;</span>);
            h.appendSliceAssumeCapacity(<span class="tok-str">&quot;content-length: 0\r\n\r\n&quot;</span>);
            <span class="tok-kw">break</span> :eb <span class="tok-null">true</span>;
        } <span class="tok-kw">else</span> eb: {
            h.fixedWriter().print(<span class="tok-str">&quot;{s} {d} {s}\r\n&quot;</span>, .{
                <span class="tok-builtin">@tagName</span>(o.version), <span class="tok-builtin">@intFromEnum</span>(o.status), phrase,
            }) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;

            <span class="tok-kw">switch</span> (o.version) {
                .@&quot;HTTP/1.0&quot; =&gt; <span class="tok-kw">if</span> (keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: keep-alive\r\n&quot;</span>),
                .@&quot;HTTP/1.1&quot; =&gt; <span class="tok-kw">if</span> (!keep_alive) h.appendSliceAssumeCapacity(<span class="tok-str">&quot;connection: close\r\n&quot;</span>),
            }

            <span class="tok-kw">if</span> (o.transfer_encoding) |transfer_encoding| <span class="tok-kw">switch</span> (transfer_encoding) {
                .chunked =&gt; h.appendSliceAssumeCapacity(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>),
                .none =&gt; {},
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (options.content_length) |len| {
                h.fixedWriter().print(<span class="tok-str">&quot;content-length: {d}\r\n&quot;</span>, .{len}) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            } <span class="tok-kw">else</span> {
                h.appendSliceAssumeCapacity(<span class="tok-str">&quot;transfer-encoding: chunked\r\n&quot;</span>);
            }

            <span class="tok-kw">for</span> (o.extra_headers) |header| {
                <a href="std.debug.html#std.debug.assert">assert</a>(header.name.len != <span class="tok-number">0</span>);
                h.appendSliceAssumeCapacity(header.name);
                h.appendSliceAssumeCapacity(<span class="tok-str">&quot;: &quot;</span>);
                h.appendSliceAssumeCapacity(header.value);
                h.appendSliceAssumeCapacity(<span class="tok-str">&quot;\r\n&quot;</span>);
            }

            h.appendSliceAssumeCapacity(<span class="tok-str">&quot;\r\n&quot;</span>);
            <span class="tok-kw">break</span> :eb request.head.method == .HEAD;
        };

        <span class="tok-kw">return</span> .{
            .stream = request.server.connection.stream,
            .send_buffer = options.send_buffer,
            .send_buffer_start = <span class="tok-number">0</span>,
            .send_buffer_end = h.items.len,
            .transfer_encoding = <span class="tok-kw">if</span> (o.transfer_encoding) |te| <span class="tok-kw">switch</span> (te) {
                .chunked =&gt; .chunked,
                .none =&gt; .none,
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (options.content_length) |len| .{
                .content_length = len,
            } <span class="tok-kw">else</span> .chunked,
            .elide_body = elide_body,
            .chunk_len = <span class="tok-number">0</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReadError = <a href="std.net.html">net</a>.<a href="std.net.Stream.html">Stream</a>.<a href="std.posix.html#std.posix.ReadError">ReadError</a> || <span class="tok-kw">error</span>{
        HttpChunkInvalid,
        HttpHeadersOversize,
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">read_cl</span>(context: *<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, buffer: []<span class="tok-type">u8</span>) <a href="std.http.Server.Request.html#std.http.Server.Request.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> request: *<a href="std.http.Server.Request.html">Request</a> = <span class="tok-builtin">@constCast</span>(<span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(context)));
        <span class="tok-kw">const</span> s = request.server;

        <span class="tok-kw">const</span> remaining_content_length = &amp;request.reader_state.remaining_content_length;
        <span class="tok-kw">if</span> (remaining_content_length.* == <span class="tok-number">0</span>) {
            s.state = .ready;
            <span class="tok-kw">return</span> <span class="tok-number">0</span>;
        }
        <a href="std.debug.html#std.debug.assert">assert</a>(s.state == .receiving_body);
        <span class="tok-kw">const</span> available = <span class="tok-kw">try</span> <a href="std.http.Server.Request.html#std.http.Server.Request.fill">fill</a>(s, request.head_end);
        <span class="tok-kw">const</span> len = <span class="tok-builtin">@min</span>(remaining_content_length.*, available.len, buffer.len);
        <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..len], available[<span class="tok-number">0</span>..len]);
        remaining_content_length.* -= len;
        s.next_request_start += len;
        <span class="tok-kw">if</span> (remaining_content_length.* == <span class="tok-number">0</span>)
            s.state = .ready;
        <span class="tok-kw">return</span> len;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fill</span>(s: *<a href="std.http.Server.html">Server</a>, head_end: <span class="tok-type">usize</span>) <a href="std.http.Server.Request.html#std.http.Server.Request.ReadError">ReadError</a>![]<span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> available = s.read_buffer[s.next_request_start..s.read_buffer_len];
        <span class="tok-kw">if</span> (available.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">return</span> available;
        s.next_request_start = head_end;
        s.read_buffer_len = head_end + <span class="tok-kw">try</span> s.connection.stream.read(s.read_buffer[head_end..]);
        <span class="tok-kw">return</span> s.read_buffer[head_end..s.read_buffer_len];
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">read_chunked</span>(context: *<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, buffer: []<span class="tok-type">u8</span>) <a href="std.http.Server.Request.html#std.http.Server.Request.ReadError">ReadError</a>!<span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> request: *<a href="std.http.Server.Request.html">Request</a> = <span class="tok-builtin">@constCast</span>(<span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(context)));
        <span class="tok-kw">const</span> s = request.server;

        <span class="tok-kw">const</span> cp = &amp;request.reader_state.chunk_parser;
        <span class="tok-kw">const</span> head_end = request.head_end;<span class="tok-comment">

        // Protect against returning 0 before the end of stream.
        </span><span class="tok-kw">var</span> out_end: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (out_end == <span class="tok-number">0</span>) {
            <span class="tok-kw">switch</span> (cp.state) {
                .invalid =&gt; <span class="tok-kw">return</span> <span class="tok-number">0</span>,
                .data =&gt; {
                    <a href="std.debug.html#std.debug.assert">assert</a>(s.state == .receiving_body);
                    <span class="tok-kw">const</span> available = <span class="tok-kw">try</span> <a href="std.http.Server.Request.html#std.http.Server.Request.fill">fill</a>(s, head_end);
                    <span class="tok-kw">const</span> len = <span class="tok-builtin">@min</span>(cp.chunk_len, available.len, buffer.len);
                    <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..len], available[<span class="tok-number">0</span>..len]);
                    cp.chunk_len -= len;
                    <span class="tok-kw">if</span> (cp.chunk_len == <span class="tok-number">0</span>)
                        cp.state = .data_suffix;
                    out_end += len;
                    s.next_request_start += len;
                    <span class="tok-kw">continue</span>;
                },
                <span class="tok-kw">else</span> =&gt; {
                    <a href="std.debug.html#std.debug.assert">assert</a>(s.state == .receiving_body);
                    <span class="tok-kw">const</span> available = <span class="tok-kw">try</span> <a href="std.http.Server.Request.html#std.http.Server.Request.fill">fill</a>(s, head_end);
                    <span class="tok-kw">const</span> n = cp.feed(available);
                    <span class="tok-kw">switch</span> (cp.state) {
                        .invalid =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpChunkInvalid,
                        .data =&gt; {
                            <span class="tok-kw">if</span> (cp.chunk_len == <span class="tok-number">0</span>) {<span class="tok-comment">
                                // The next bytes in the stream are trailers,
                                // or \r\n to indicate end of chunked body.
                                //
                                // This function must append the trailers at
                                // head_end so that headers and trailers are
                                // together.
                                //
                                // Since returning 0 would indicate end of
                                // stream, this function must read all the
                                // trailers before returning.
                                </span><span class="tok-kw">if</span> (s.next_request_start &gt; head_end) <a href="std.http.Server.html#std.http.Server.rebase">rebase</a>(s, head_end);
                                <span class="tok-kw">var</span> hp: <a href="std.http.html">http</a>.<a href="std.http.HeadParser.html">HeadParser</a> = .{};
                                {
                                    <span class="tok-kw">const</span> bytes = s.read_buffer[head_end..s.read_buffer_len];
                                    <span class="tok-kw">const</span> end = hp.feed(bytes);
                                    <span class="tok-kw">if</span> (hp.state == .finished) {
                                        cp.state = .invalid;
                                        s.state = .ready;
                                        s.next_request_start = s.read_buffer_len - bytes.len + end;
                                        <span class="tok-kw">return</span> out_end;
                                    }
                                }
                                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                                    <span class="tok-kw">const</span> buf = s.read_buffer[s.read_buffer_len..];
                                    <span class="tok-kw">if</span> (buf.len == <span class="tok-number">0</span>)
                                        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpHeadersOversize;
                                    <span class="tok-kw">const</span> read_n = <span class="tok-kw">try</span> s.connection.stream.read(buf);
                                    s.read_buffer_len += read_n;
                                    <span class="tok-kw">const</span> bytes = buf[<span class="tok-number">0</span>..read_n];
                                    <span class="tok-kw">const</span> end = hp.feed(bytes);
                                    <span class="tok-kw">if</span> (hp.state == .finished) {
                                        cp.state = .invalid;
                                        s.state = .ready;
                                        s.next_request_start = s.read_buffer_len - bytes.len + end;
                                        <span class="tok-kw">return</span> out_end;
                                    }
                                }
                            }
                            <span class="tok-kw">const</span> data = available[n..];
                            <span class="tok-kw">const</span> len = <span class="tok-builtin">@min</span>(cp.chunk_len, data.len, buffer.len);
                            <span class="tok-builtin">@memcpy</span>(buffer[<span class="tok-number">0</span>..len], data[<span class="tok-number">0</span>..len]);
                            cp.chunk_len -= len;
                            <span class="tok-kw">if</span> (cp.chunk_len == <span class="tok-number">0</span>)
                                cp.state = .data_suffix;
                            out_end += len;
                            s.next_request_start += n + len;
                            <span class="tok-kw">continue</span>;
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,
                    }
                },
            }
        }
        <span class="tok-kw">return</span> out_end;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ReaderError = <a href="std.http.Server.Response.html">Response</a>.<a href="std.posix.html#std.posix.WriteError">WriteError</a> || <span class="tok-kw">error</span>{
        <span class="tok-comment">/// The client sent an expect HTTP header value other than</span>
        <span class="tok-comment">/// &quot;100-continue&quot;.</span>
        HttpExpectationFailed,
    };

    <span class="tok-comment">/// In the case that the request contains &quot;expect: 100-continue&quot;, this</span>
    <span class="tok-comment">/// function writes the continuation header, which means it can fail with a</span>
    <span class="tok-comment">/// write error. After sending the continuation header, it sets the</span>
    <span class="tok-comment">/// request's expect field to `null`.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Asserts that this function is only called once.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reader</span>(request: *<a href="std.http.Server.Request.html">Request</a>) <a href="std.http.Server.Request.html#std.http.Server.Request.ReaderError">ReaderError</a>!<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.Reader.html">AnyReader</a> {
        <span class="tok-kw">const</span> s = request.server;
        <a href="std.debug.html#std.debug.assert">assert</a>(s.state == .received_head);
        s.state = .receiving_body;
        s.next_request_start = request.head_end;

        <span class="tok-kw">if</span> (request.head.expect) |expect| {
            <span class="tok-kw">if</span> (<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, expect, <span class="tok-str">&quot;100-continue&quot;</span>)) {
                <span class="tok-kw">try</span> request.server.connection.stream.writeAll(<span class="tok-str">&quot;HTTP/1.1 100 Continue\r\n\r\n&quot;</span>);
                request.head.expect = <span class="tok-null">null</span>;
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.HttpExpectationFailed;
            }
        }

        <span class="tok-kw">switch</span> (request.head.transfer_encoding) {
            .chunked =&gt; {
                request.reader_state = .{ .chunk_parser = <a href="std.http.html">http</a>.<a href="std.http.ChunkParser.html">ChunkParser</a>.<a href="std.http.ChunkParser.html#std.http.ChunkParser.init">init</a> };
                <span class="tok-kw">return</span> .{
                    .readFn = <a href="std.http.Server.Request.html#std.http.Server.Request.read_chunked">read_chunked</a>,
                    .context = request,
                };
            },
            .none =&gt; {
                request.reader_state = .{
                    .remaining_content_length = request.head.content_length <span class="tok-kw">orelse</span> <span class="tok-number">0</span>,
                };
                <span class="tok-kw">return</span> .{
                    .readFn = <a href="std.http.Server.Request.html#std.http.Server.Request.read_cl">read_cl</a>,
                    .context = request,
                };
            },
        }
    }

    <span class="tok-comment">/// Returns whether the connection should remain persistent.</span>
    <span class="tok-comment">/// If it would fail, it instead sets the Server state to `receiving_body`</span>
    <span class="tok-comment">/// and returns false.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">discardBody</span>(request: *<a href="std.http.Server.Request.html">Request</a>, keep_alive: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {<span class="tok-comment">
        // Prepare to receive another request on the same connection.
        // There are two factors to consider:
        // * Any body the client sent must be discarded.
        // * The Server's read_buffer may already have some bytes in it from
        //   whatever came after the head, which may be the next HTTP request
        //   or the request body.
        // If the connection won't be kept alive, then none of this matters
        // because the connection will be severed after the response is sent.
        </span><span class="tok-kw">const</span> s = request.server;
        <span class="tok-kw">if</span> (keep_alive <span class="tok-kw">and</span> request.head.keep_alive) <span class="tok-kw">switch</span> (s.state) {
            .received_head =&gt; {
                <span class="tok-kw">const</span> r = request.reader() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                _ = r.discard() <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                <a href="std.debug.html#std.debug.assert">assert</a>(s.state == .ready);
                <span class="tok-kw">return</span> <span class="tok-null">true</span>;
            },
            .receiving_body, .ready =&gt; <span class="tok-kw">return</span> <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };<span class="tok-comment">

        // Avoid clobbering the state in case a reading stream already exists.
        </span><span class="tok-kw">switch</span> (s.state) {
            .received_head =&gt; s.state = .closing,
            <span class="tok-kw">else</span> =&gt; {},
        }
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
