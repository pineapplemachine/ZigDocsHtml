<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">zig</a></li><li><a href="std.zig.html" class="">llvm</a></li><li><a href="std.zig.llvm.Builder.html" class="active">Builder</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.zig.llvm.Builder" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.zig.llvm.Builder</span><a href="#src.zig-std.zig.llvm.Builder">[src]</a></h1><div class="sectContainers"><h2 class="sectionHeader">Container Types</h2><ul class="listContainers columns"><li><a href="std.zig.llvm.Builder.Options.html">std.zig.llvm.Builder.Options</a></li><li><a href="std.zig.llvm.Builder.String.html">std.zig.llvm.Builder.String</a></li><li><a href="std.zig.llvm.Builder.BinaryOpcode.html">std.zig.llvm.Builder.BinaryOpcode</a></li><li><a href="std.zig.llvm.Builder.CastOpcode.html">std.zig.llvm.Builder.CastOpcode</a></li><li><a href="std.zig.llvm.Builder.CmpPredicate.html">std.zig.llvm.Builder.CmpPredicate</a></li><li><a href="std.zig.llvm.Builder.Type.html">std.zig.llvm.Builder.Type</a></li><li><a href="std.zig.llvm.Builder.Attribute.html">std.zig.llvm.Builder.Attribute</a></li><li><a href="std.zig.llvm.Builder.Attributes.html">std.zig.llvm.Builder.Attributes</a></li><li><a href="std.zig.llvm.Builder.FunctionAttributes.html">std.zig.llvm.Builder.FunctionAttributes</a></li><li><a href="std.zig.llvm.Builder.Linkage.html">std.zig.llvm.Builder.Linkage</a></li><li><a href="std.zig.llvm.Builder.Preemption.html">std.zig.llvm.Builder.Preemption</a></li><li><a href="std.zig.llvm.Builder.Visibility.html">std.zig.llvm.Builder.Visibility</a></li><li><a href="std.zig.llvm.Builder.DllStorageClass.html">std.zig.llvm.Builder.DllStorageClass</a></li><li><a href="std.zig.llvm.Builder.ThreadLocal.html">std.zig.llvm.Builder.ThreadLocal</a></li><li><a href="std.zig.llvm.Builder.Mutability.html">std.zig.llvm.Builder.Mutability</a></li><li><a href="std.zig.llvm.Builder.UnnamedAddr.html">std.zig.llvm.Builder.UnnamedAddr</a></li><li><a href="std.zig.llvm.Builder.AddrSpace.html">std.zig.llvm.Builder.AddrSpace</a></li><li><a href="std.zig.llvm.Builder.ExternallyInitialized.html">std.zig.llvm.Builder.ExternallyInitialized</a></li><li><a href="std.zig.llvm.Builder.Alignment.html">std.zig.llvm.Builder.Alignment</a></li><li><a href="std.zig.llvm.Builder.CallConv.html">std.zig.llvm.Builder.CallConv</a></li><li><a href="std.zig.llvm.Builder.StrtabString.html">std.zig.llvm.Builder.StrtabString</a></li><li><a href="std.zig.llvm.Builder.Global.html">std.zig.llvm.Builder.Global</a></li><li><a href="std.zig.llvm.Builder.Alias.html">std.zig.llvm.Builder.Alias</a></li><li><a href="std.zig.llvm.Builder.Variable.html">std.zig.llvm.Builder.Variable</a></li><li><a href="std.zig.llvm.Builder.Intrinsic.html">std.zig.llvm.Builder.Intrinsic</a></li><li><a href="std.zig.llvm.Builder.Function.html">std.zig.llvm.Builder.Function</a></li><li><a href="std.zig.llvm.Builder.DebugLocation.html">std.zig.llvm.Builder.DebugLocation</a></li><li><a href="std.zig.llvm.Builder.WipFunction.html">std.zig.llvm.Builder.WipFunction</a></li><li><a href="std.zig.llvm.Builder.FloatCondition.html">std.zig.llvm.Builder.FloatCondition</a></li><li><a href="std.zig.llvm.Builder.IntegerCondition.html">std.zig.llvm.Builder.IntegerCondition</a></li><li><a href="std.zig.llvm.Builder.MemoryAccessKind.html">std.zig.llvm.Builder.MemoryAccessKind</a></li><li><a href="std.zig.llvm.Builder.SyncScope.html">std.zig.llvm.Builder.SyncScope</a></li><li><a href="std.zig.llvm.Builder.AtomicOrdering.html">std.zig.llvm.Builder.AtomicOrdering</a></li><li><a href="std.zig.llvm.Builder.FastMath.html">std.zig.llvm.Builder.FastMath</a></li><li><a href="std.zig.llvm.Builder.FastMathKind.html">std.zig.llvm.Builder.FastMathKind</a></li><li><a href="std.zig.llvm.Builder.Constant.html">std.zig.llvm.Builder.Constant</a></li><li><a href="std.zig.llvm.Builder.Value.html">std.zig.llvm.Builder.Value</a></li><li><a href="std.zig.llvm.Builder.MetadataString.html">std.zig.llvm.Builder.MetadataString</a></li><li><a href="std.zig.llvm.Builder.Metadata.html">std.zig.llvm.Builder.Metadata</a></li><li><a href="std.zig.llvm.Builder.Producer.html">std.zig.llvm.Builder.Producer</a></li></ul></div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>strip: <span class="tok-type">bool</span></code></pre></div><div><pre><code>source_filename: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div><pre><code>data_layout: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div><pre><code>target_triple: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div><pre><code>module_asm: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>string_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>string_indices: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>string_bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>types: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.Type.html">Type</a>)</code></pre></div><div><pre><code>next_unnamed_type: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div><pre><code>next_unique_type_id: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <span class="tok-type">u32</span>)</code></pre></div><div><pre><code>type_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>type_items: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>)</code></pre></div><div><pre><code>type_extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>attributes: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Storage.html">Storage</a>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>attributes_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>attributes_indices: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>attributes_extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>function_attributes_set: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>globals: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, <a href="std.zig.llvm.Builder.Global.html">Global</a>)</code></pre></div><div><pre><code>next_unnamed_global: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>next_replaced_global: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>next_unique_global_id: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, <span class="tok-type">u32</span>)</code></pre></div><div><pre><code>aliases: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Alias.html">Alias</a>)</code></pre></div><div><pre><code>variables: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Variable.html">Variable</a>)</code></pre></div><div><pre><code>functions: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.html">Function</a>)</code></pre></div><div><pre><code>strtab_string_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>strtab_string_indices: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>strtab_string_bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)</code></pre></div><div><pre><code>constant_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>constant_items: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>)</code></pre></div><div><pre><code>constant_extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>constant_limbs: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)</code></pre></div><div><pre><code>metadata_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>metadata_items: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>)</code></pre></div><div><pre><code>metadata_extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>metadata_limbs: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)</code></pre></div><div><pre><code>metadata_forward_references: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>)</code></pre></div><div><pre><code>metadata_named: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, <span class="tok-kw">struct</span> {
    len: <span class="tok-type">u32</span>,
    index: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a>,
})</code></pre></div><div><pre><code>metadata_string_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>)</code></pre></div><div><pre><code>metadata_string_indices: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>)</code></pre></div><div><pre><code>metadata_string_bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>)</code></pre></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.zig.llvm.Builder.expected_args_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">expected_args_len</span><a href="#src.zig-std.zig.llvm.Builder.expected_args_len">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.expected_args_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_args_len = <span class="tok-number">16</span></code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.expected_attrs_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">expected_attrs_len</span><a href="#src.zig-std.zig.llvm.Builder.expected_attrs_len">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.expected_attrs_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_attrs_len = <span class="tok-number">16</span></code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.expected_fields_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">expected_fields_len</span><a href="#src.zig-std.zig.llvm.Builder.expected_fields_len">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.expected_fields_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_fields_len = <span class="tok-number">32</span></code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.expected_gep_indices_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">expected_gep_indices_len</span><a href="#src.zig-std.zig.llvm.Builder.expected_gep_indices_len">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.expected_gep_indices_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_gep_indices_len = <span class="tok-number">8</span></code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.expected_cases_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">expected_cases_len</span><a href="#src.zig-std.zig.llvm.Builder.expected_cases_len">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.expected_cases_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_cases_len = <span class="tok-number">8</span></code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.expected_incoming_len" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">expected_incoming_len</span><a href="#src.zig-std.zig.llvm.Builder.expected_incoming_len">[src]</a></h2><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.expected_incoming_len">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_incoming_len = <span class="tok-number">8</span></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.zig.llvm.Builder.strtabString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">strtabString</span><a href="#src.zig-std.zig.llvm.Builder.strtabString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.strtabString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">try</span> self.strtab_string_bytes.ensureUnusedCapacity(self.gpa, bytes.len);
    <span class="tok-kw">try</span> self.strtab_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.strtab_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> gop = self.strtab_string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        self.strtab_string_bytes.appendSliceAssumeCapacity(bytes);
        self.strtab_string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.strtab_string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.html#std.zig.llvm.Builder.StrtabString.fromIndex">fromIndex</a>(gop.index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.strtabStringIfExists" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">strtabStringIfExists</span><a href="#src.zig-std.zig.llvm.Builder.strtabStringIfExists">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringIfExists</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.strtabStringIfExists">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringIfExists</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.html#std.zig.llvm.Builder.StrtabString.fromIndex">fromIndex</a>(
        self.strtab_string_map.getIndexAdapted(bytes, <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.Adapter.html">Adapter</a>{ .builder = self }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.strtabStringFmt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">strtabStringFmt</span><a href="#src.zig-std.zig.llvm.Builder.strtabStringFmt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringFmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.strtabStringFmt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringFmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">try</span> self.strtab_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.strtab_string_bytes.ensureUnusedCapacity(self.gpa, <span class="tok-builtin">@intCast</span>(<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(fmt_str, fmt_args)));
    <span class="tok-kw">try</span> self.strtab_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.strtabStringFmtAssumeCapacity(fmt_str, fmt_args);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.strtabStringFmtAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">strtabStringFmtAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.strtabStringFmtAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringFmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.strtabStringFmtAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringFmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    self.strtab_string_bytes.writer(<span class="tok-null">undefined</span>).print(fmt_str, fmt_args) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> self.trailingStrtabStringAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.trailingStrtabString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trailingStrtabString</span><a href="#src.zig-std.zig.llvm.Builder.trailingStrtabString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStrtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.trailingStrtabString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStrtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">try</span> self.strtab_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.strtab_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.trailingStrtabStringAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.trailingStrtabStringAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trailingStrtabStringAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.trailingStrtabStringAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStrtabStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.trailingStrtabStringAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStrtabStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">const</span> start = self.strtab_string_indices.getLast();
    <span class="tok-kw">const</span> bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = self.strtab_string_bytes.items[start..];
    <span class="tok-kw">const</span> gop = self.strtab_string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (gop.found_existing) {
        self.strtab_string_bytes.shrinkRetainingCapacity(start);
    } <span class="tok-kw">else</span> {
        self.strtab_string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.strtab_string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.html#std.zig.llvm.Builder.StrtabString.fromIndex">fromIndex</a>(gop.index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.zig.llvm.Builder.init">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.zig.llvm.Builder.Options.html">Options</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>options: <a href="std.zig.llvm.Builder.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.init">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.zig.llvm.Builder.Options.html">Options</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.html">Builder</a> {
    <span class="tok-kw">var</span> self: <a href="std.zig.llvm.Builder.html">Builder</a> = .{
        .gpa = options.allocator,
        .strip = options.strip,

        .source_filename = .none,
        .data_layout = .none,
        .target_triple = .none,
        .module_asm = .{},

        .string_map = .{},
        .string_indices = .{},
        .string_bytes = .{},

        .types = .{},
        .next_unnamed_type = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
        .next_unique_type_id = .{},
        .type_map = .{},
        .type_items = .{},
        .type_extra = .{},

        .attributes = .{},
        .attributes_map = .{},
        .attributes_indices = .{},
        .attributes_extra = .{},

        .function_attributes_set = .{},

        .globals = .{},
        .next_unnamed_global = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
        .next_replaced_global = .none,
        .next_unique_global_id = .{},
        .aliases = .{},
        .variables = .{},
        .functions = .{},

        .strtab_string_map = .{},
        .strtab_string_indices = .{},
        .strtab_string_bytes = .{},

        .constant_map = .{},
        .constant_items = .{},
        .constant_extra = .{},
        .constant_limbs = .{},

        .metadata_map = .{},
        .metadata_items = .{},
        .metadata_extra = .{},
        .metadata_limbs = .{},
        .metadata_forward_references = .{},
        .metadata_named = .{},
        .metadata_string_map = .{},
        .metadata_string_indices = .{},
        .metadata_string_bytes = .{},
    };
    <span class="tok-kw">errdefer</span> self.deinit();

    <span class="tok-kw">try</span> self.string_indices.append(self.gpa, <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.string(<span class="tok-str">&quot;&quot;</span>) == .empty);

    <span class="tok-kw">try</span> self.strtab_string_indices.append(self.gpa, <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.strtabString(<span class="tok-str">&quot;&quot;</span>) == .empty);

    <span class="tok-kw">if</span> (options.name.len &gt; <span class="tok-number">0</span>) self.source_filename = <span class="tok-kw">try</span> self.string(options.name);

    <span class="tok-kw">if</span> (options.triple.len &gt; <span class="tok-number">0</span>) {
        self.target_triple = <span class="tok-kw">try</span> self.string(options.triple);
    }

    {
        <span class="tok-kw">const</span> static_len = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>).@&quot;enum&quot;.fields.len - <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> self.type_map.ensureTotalCapacity(self.gpa, static_len);
        <span class="tok-kw">try</span> self.type_items.ensureTotalCapacity(self.gpa, static_len);
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Simple.html">Simple</a>).@&quot;enum&quot;.fields) |simple_field| {
            <span class="tok-kw">const</span> result = self.getOrPutTypeNoExtraAssumeCapacity(
                .{ .tag = .simple, .data = simple_field.value },
            );
            <a href="std.debug.html#std.debug.assert">assert</a>(result.new <span class="tok-kw">and</span> result.<span class="tok-type">type</span> == <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, simple_field.name));
        }
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{ <span class="tok-number">1</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">29</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span>, <span class="tok-number">80</span>, <span class="tok-number">128</span> }) |bits|
            <a href="std.debug.html#std.debug.assert">assert</a>(self.intTypeAssumeCapacity(bits) ==
                <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;i{d}&quot;</span>, .{bits})));
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{ <span class="tok-number">0</span>, <span class="tok-number">4</span> }) |addr_space_index| {
            <span class="tok-kw">const</span> addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(addr_space_index);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.ptrTypeAssumeCapacity(addr_space) ==
                <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;ptr{ }&quot;</span>, .{addr_space})));
        }
    }

    {
        <span class="tok-kw">try</span> self.attributes_indices.append(self.gpa, <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.attrs(&amp;.{}) == .none);
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.fnAttrs(&amp;.{}) == .none);
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.intConst(.<span class="tok-type">i1</span>, <span class="tok-number">0</span>) == .<span class="tok-null">false</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.intConst(.<span class="tok-type">i1</span>, <span class="tok-number">1</span>) == .<span class="tok-null">true</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">0</span>) == .@&quot;0&quot;);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">1</span>) == .@&quot;1&quot;);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.noneConst(.token) == .none);

    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.metadataNone() == .none);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.metadataTuple(&amp;.{}) == .empty_tuple);

    <span class="tok-kw">try</span> self.metadata_string_indices.append(self.gpa, <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.metadataString(<span class="tok-str">&quot;&quot;</span>) == .none);

    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.zig.llvm.Builder.clearAndFree">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.clearAndFree">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
    self.module_asm.clearAndFree(self.gpa);

    self.string_map.clearAndFree(self.gpa);
    self.string_indices.clearAndFree(self.gpa);
    self.string_bytes.clearAndFree(self.gpa);

    self.types.clearAndFree(self.gpa);
    self.next_unique_type_id.clearAndFree(self.gpa);
    self.type_map.clearAndFree(self.gpa);
    self.type_items.clearAndFree(self.gpa);
    self.type_extra.clearAndFree(self.gpa);

    self.attributes.clearAndFree(self.gpa);
    self.attributes_map.clearAndFree(self.gpa);
    self.attributes_indices.clearAndFree(self.gpa);
    self.attributes_extra.clearAndFree(self.gpa);

    self.function_attributes_set.clearAndFree(self.gpa);

    self.globals.clearAndFree(self.gpa);
    self.next_unique_global_id.clearAndFree(self.gpa);
    self.aliases.clearAndFree(self.gpa);
    self.variables.clearAndFree(self.gpa);
    <span class="tok-kw">for</span> (self.functions.items) |*function| function.deinit(self.gpa);
    self.functions.clearAndFree(self.gpa);

    self.strtab_string_map.clearAndFree(self.gpa);
    self.strtab_string_indices.clearAndFree(self.gpa);
    self.strtab_string_bytes.clearAndFree(self.gpa);

    self.constant_map.clearAndFree(self.gpa);
    self.constant_items.shrinkAndFree(self.gpa, <span class="tok-number">0</span>);
    self.constant_extra.clearAndFree(self.gpa);
    self.constant_limbs.clearAndFree(self.gpa);

    self.metadata_map.clearAndFree(self.gpa);
    self.metadata_items.shrinkAndFree(self.gpa, <span class="tok-number">0</span>);
    self.metadata_extra.clearAndFree(self.gpa);
    self.metadata_limbs.clearAndFree(self.gpa);
    self.metadata_forward_references.clearAndFree(self.gpa);
    self.metadata_named.clearAndFree(self.gpa);

    self.metadata_string_map.clearAndFree(self.gpa);
    self.metadata_string_indices.clearAndFree(self.gpa);
    self.metadata_string_bytes.clearAndFree(self.gpa);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.zig.llvm.Builder.deinit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.deinit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
    self.module_asm.deinit(self.gpa);

    self.string_map.deinit(self.gpa);
    self.string_indices.deinit(self.gpa);
    self.string_bytes.deinit(self.gpa);

    self.types.deinit(self.gpa);
    self.next_unique_type_id.deinit(self.gpa);
    self.type_map.deinit(self.gpa);
    self.type_items.deinit(self.gpa);
    self.type_extra.deinit(self.gpa);

    self.attributes.deinit(self.gpa);
    self.attributes_map.deinit(self.gpa);
    self.attributes_indices.deinit(self.gpa);
    self.attributes_extra.deinit(self.gpa);

    self.function_attributes_set.deinit(self.gpa);

    self.globals.deinit(self.gpa);
    self.next_unique_global_id.deinit(self.gpa);
    self.aliases.deinit(self.gpa);
    self.variables.deinit(self.gpa);
    <span class="tok-kw">for</span> (self.functions.items) |*function| function.deinit(self.gpa);
    self.functions.deinit(self.gpa);

    self.strtab_string_map.deinit(self.gpa);
    self.strtab_string_indices.deinit(self.gpa);
    self.strtab_string_bytes.deinit(self.gpa);

    self.constant_map.deinit(self.gpa);
    self.constant_items.deinit(self.gpa);
    self.constant_extra.deinit(self.gpa);
    self.constant_limbs.deinit(self.gpa);

    self.metadata_map.deinit(self.gpa);
    self.metadata_items.deinit(self.gpa);
    self.metadata_extra.deinit(self.gpa);
    self.metadata_limbs.deinit(self.gpa);
    self.metadata_forward_references.deinit(self.gpa);
    self.metadata_named.deinit(self.gpa);

    self.metadata_string_map.deinit(self.gpa);
    self.metadata_string_indices.deinit(self.gpa);
    self.metadata_string_bytes.deinit(self.gpa);

    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.setModuleAsm" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setModuleAsm</span><a href="#src.zig-std.zig.llvm.Builder.setModuleAsm">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).Writer</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.setModuleAsm">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).Writer {
    self.module_asm.clearRetainingCapacity();
    <span class="tok-kw">return</span> self.appendModuleAsm();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.appendModuleAsm" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">appendModuleAsm</span><a href="#src.zig-std.zig.llvm.Builder.appendModuleAsm">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).Writer</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.appendModuleAsm">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).Writer {
    <span class="tok-kw">return</span> self.module_asm.writer(self.gpa);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.finishModuleAsm" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">finishModuleAsm</span><a href="#src.zig-std.zig.llvm.Builder.finishModuleAsm">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finishModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.finishModuleAsm">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finishModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.module_asm.getLastOrNull()) |last| <span class="tok-kw">if</span> (last != <span class="tok-str">'\n'</span>)
        <span class="tok-kw">try</span> self.module_asm.append(self.gpa, <span class="tok-str">'\n'</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.string" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">string</span><a href="#src.zig-std.zig.llvm.Builder.string">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">string</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.string">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">string</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">try</span> self.string_bytes.ensureUnusedCapacity(self.gpa, bytes.len);
    <span class="tok-kw">try</span> self.string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> gop = self.string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        self.string_bytes.appendSliceAssumeCapacity(bytes);
        self.string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.html#std.zig.llvm.Builder.String.fromIndex">fromIndex</a>(gop.index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.stringNull" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringNull</span><a href="#src.zig-std.zig.llvm.Builder.stringNull">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringNull</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>bytes: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.stringNull">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringNull</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">return</span> self.string(bytes[<span class="tok-number">0</span> .. bytes.len + <span class="tok-number">1</span>]);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.stringIfExists" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringIfExists</span><a href="#src.zig-std.zig.llvm.Builder.stringIfExists">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringIfExists</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.stringIfExists">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringIfExists</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.html#std.zig.llvm.Builder.String.fromIndex">fromIndex</a>(
        self.string_map.getIndexAdapted(bytes, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>{ .builder = self }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.fmt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fmt</span><a href="#src.zig-std.zig.llvm.Builder.fmt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.fmt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">try</span> self.string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.string_bytes.ensureUnusedCapacity(self.gpa, <span class="tok-builtin">@intCast</span>(<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(fmt_str, fmt_args)));
    <span class="tok-kw">try</span> self.string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.fmtAssumeCapacity(fmt_str, fmt_args);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.fmtAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fmtAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.fmtAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.fmtAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.String.html">String</a> {
    self.string_bytes.writer(<span class="tok-null">undefined</span>).print(fmt_str, fmt_args) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> self.trailingStringAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.trailingString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trailingString</span><a href="#src.zig-std.zig.llvm.Builder.trailingString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.trailingString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">try</span> self.string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.trailingStringAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.trailingStringAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trailingStringAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.trailingStringAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.trailingStringAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">const</span> start = self.string_indices.getLast();
    <span class="tok-kw">const</span> bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = self.string_bytes.items[start..];
    <span class="tok-kw">const</span> gop = self.string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (gop.found_existing) {
        self.string_bytes.shrinkRetainingCapacity(start);
    } <span class="tok-kw">else</span> {
        self.string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.html#std.zig.llvm.Builder.String.fromIndex">fromIndex</a>(gop.index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.fnType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fnType</span><a href="#src.zig-std.zig.llvm.Builder.fnType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ret: <a href="std.zig.llvm.Builder.Type.html">Type</a>, params: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>, kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Type.Function.Kind.html">Kind</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ret: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>params: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Type.Function.Kind.html">Kind</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.fnType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ret: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    params: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Type.Function.Kind.html">Kind</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, params.len);
    <span class="tok-kw">switch</span> (kind) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |comptime_kind| <span class="tok-kw">return</span> self.fnTypeAssumeCapacity(ret, params, comptime_kind),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.intType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intType</span><a href="#src.zig-std.zig.llvm.Builder.intType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bits: <span class="tok-type">u24</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>bits: <span class="tok-type">u24</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.intType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bits: <span class="tok-type">u24</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.intTypeAssumeCapacity(bits);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.ptrType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ptrType</span><a href="#src.zig-std.zig.llvm.Builder.ptrType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.ptrType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.ptrTypeAssumeCapacity(addr_space);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.vectorType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">vectorType</span><a href="#src.zig-std.zig.llvm.Builder.vectorType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a>, len: <span class="tok-type">u32</span>, child: <a href="std.zig.llvm.Builder.Type.html">Type</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a></code></pre></div><div><pre><code>len: <span class="tok-type">u32</span></code></pre></div><div><pre><code>child: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.vectorType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a>,
    len: <span class="tok-type">u32</span>,
    child: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">switch</span> (kind) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |comptime_kind| <span class="tok-kw">return</span> self.vectorTypeAssumeCapacity(comptime_kind, len, child),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.arrayType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayType</span><a href="#src.zig-std.zig.llvm.Builder.arrayType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, len: <span class="tok-type">u64</span>, child: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>len: <span class="tok-type">u64</span></code></pre></div><div><pre><code>child: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.arrayType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, len: <span class="tok-type">u64</span>, child: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>) &gt;= <span class="tok-builtin">@sizeOf</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>));
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.arrayTypeAssumeCapacity(len, child);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.structType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">structType</span><a href="#src.zig-std.zig.llvm.Builder.structType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>.<a href="std.zig.llvm.Builder.Type.Structure.Kind.html">Kind</a>, fields: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>.<a href="std.zig.llvm.Builder.Type.Structure.Kind.html">Kind</a></code></pre></div><div><pre><code>fields: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.structType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>.<a href="std.zig.llvm.Builder.Type.Structure.Kind.html">Kind</a>,
    fields: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, fields.len);
    <span class="tok-kw">switch</span> (kind) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |comptime_kind| <span class="tok-kw">return</span> self.structTypeAssumeCapacity(comptime_kind, fields),
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.opaqueType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">opaqueType</span><a href="#src.zig-std.zig.llvm.Builder.opaqueType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">opaqueType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.opaqueType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">opaqueType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (name.slice(self)) |id| {
        <span class="tok-kw">const</span> count: <span class="tok-type">usize</span> = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(<span class="tok-str">&quot;{d}&quot;</span>, .{<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>)});
        <span class="tok-kw">try</span> self.string_bytes.ensureUnusedCapacity(self.gpa, id.len + count);
    }
    <span class="tok-kw">try</span> self.string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.types.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.next_unique_type_id.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.opaqueTypeAssumeCapacity(name);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.namedTypeSetBody" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">namedTypeSetBody</span><a href="#src.zig-std.zig.llvm.Builder.namedTypeSetBody">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">namedTypeSetBody</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, named_type: <a href="std.zig.llvm.Builder.Type.html">Type</a>, body_type: <a href="std.zig.llvm.Builder.Type.html">Type</a>, ) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>named_type: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>body_type: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.namedTypeSetBody">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">namedTypeSetBody</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    named_type: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    body_type: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> named_item = self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(named_type)];
    self.type_extra.items[named_item.data + <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fieldIndex">fieldIndex</a>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, <span class="tok-str">&quot;body&quot;</span>).?] =
        <span class="tok-builtin">@intFromEnum</span>(body_type);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.attr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">attr</span><a href="#src.zig-std.zig.llvm.Builder.attr">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attr</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, attribute: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>attribute: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.attr">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attr</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, attribute: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a> {
    <span class="tok-kw">try</span> self.attributes.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> gop = self.attributes.getOrPutAssumeCapacity(attribute.toStorage());
    <span class="tok-kw">if</span> (!gop.found_existing) gop.value_ptr.* = {};
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.attrs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">attrs</span><a href="#src.zig-std.zig.llvm.Builder.attrs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attrs</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, attributes: []<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>attributes: []<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.zig.llvm.Builder.attrs.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.zig.llvm.Builder.attrs.lessThan">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, lhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, rhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>lhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a></code></pre></div><div><pre><code>rhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.attrs.lessThan">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, lhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, rhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>) <span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> lhs_kind = lhs.getKind(builder);
    <span class="tok-kw">const</span> rhs_kind = rhs.getKind(builder);
    <a href="std.debug.html#std.debug.assert">assert</a>(lhs_kind != rhs_kind);
    <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(lhs_kind) &lt; <span class="tok-builtin">@intFromEnum</span>(rhs_kind);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.attrs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attrs</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, attributes: []<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.heap">heap</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, attributes, self, <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, lhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, rhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> lhs_kind = lhs.getKind(builder);
            <span class="tok-kw">const</span> rhs_kind = rhs.getKind(builder);
            <a href="std.debug.html#std.debug.assert">assert</a>(lhs_kind != rhs_kind);
            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(lhs_kind) &lt; <span class="tok-builtin">@intFromEnum</span>(rhs_kind);
        }
    }.lessThan);
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">try</span> self.attrGeneric(<span class="tok-builtin">@ptrCast</span>(attributes)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.fnAttrs" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fnAttrs</span><a href="#src.zig-std.zig.llvm.Builder.fnAttrs">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnAttrs</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, fn_attributes: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>fn_attributes: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.fnAttrs">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnAttrs</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, fn_attributes: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> {
    <span class="tok-kw">try</span> self.function_attributes_set.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">try</span> self.attrGeneric(<span class="tok-builtin">@ptrCast</span>(
        fn_attributes[<span class="tok-number">0</span>..<span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lastIndexOfNone">lastIndexOfNone</a>(<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>, fn_attributes, &amp;.{.none})) |last|
            last + <span class="tok-number">1</span>
        <span class="tok-kw">else</span>
            <span class="tok-number">0</span>],
    )));

    _ = self.function_attributes_set.getOrPutAssumeCapacity(function_attributes);
    <span class="tok-kw">return</span> function_attributes;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.addGlobal" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addGlobal</span><a href="#src.zig-std.zig.llvm.Builder.addGlobal">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addGlobal</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, global: <a href="std.zig.llvm.Builder.Global.html">Global</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>global: <a href="std.zig.llvm.Builder.Global.html">Global</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.addGlobal">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addGlobal</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, global: <a href="std.zig.llvm.Builder.Global.html">Global</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedGlobalCapacity(name);
    <span class="tok-kw">return</span> self.addGlobalAssumeCapacity(name, global);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.addGlobalAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addGlobalAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.addGlobalAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addGlobalAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, global: <a href="std.zig.llvm.Builder.Global.html">Global</a>) <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>global: <a href="std.zig.llvm.Builder.Global.html">Global</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.addGlobalAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addGlobalAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, global: <a href="std.zig.llvm.Builder.Global.html">Global</a>) <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
    _ = self.ptrTypeAssumeCapacity(global.addr_space);
    <span class="tok-kw">var</span> id = name;
    <span class="tok-kw">if</span> (name == .empty) {
        id = self.next_unnamed_global;
        <a href="std.debug.html#std.debug.assert">assert</a>(id != self.next_replaced_global);
        self.next_unnamed_global = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(id) + <span class="tok-number">1</span>);
    }
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> global_gop = self.globals.getOrPutAssumeCapacity(id);
        <span class="tok-kw">if</span> (!global_gop.found_existing) {
            global_gop.value_ptr.* = global;
            <span class="tok-kw">const</span> global_index: <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(global_gop.index);
            global_index.updateDsoLocal(self);
            <span class="tok-kw">return</span> global_index;
        }

        <span class="tok-kw">const</span> unique_gop = self.next_unique_global_id.getOrPutAssumeCapacity(name);
        <span class="tok-kw">if</span> (!unique_gop.found_existing) unique_gop.value_ptr.* = <span class="tok-number">2</span>;
        id = self.strtabStringFmtAssumeCapacity(<span class="tok-str">&quot;{s}.{d}&quot;</span>, .{ name.slice(self).?, unique_gop.value_ptr.* });
        unique_gop.value_ptr.* += <span class="tok-number">1</span>;
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.getGlobal" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getGlobal</span><a href="#src.zig-std.zig.llvm.Builder.getGlobal">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGlobal</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) ?<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.getGlobal">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGlobal</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) ?<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(self.globals.getIndex(name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.addAlias" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addAlias</span><a href="#src.zig-std.zig.llvm.Builder.addAlias">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAlias</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>, aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a></code></pre></div><div><pre><code>aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.addAlias">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAlias</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
    aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedGlobalCapacity(name);
    <span class="tok-kw">try</span> self.aliases.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addAliasAssumeCapacity(name, ty, addr_space, aliasee);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.addAliasAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addAliasAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.addAliasAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAliasAssumeCapacity</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>, aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ) <a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a></code></pre></div><div><pre><code>aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.addAliasAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAliasAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
    aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a> {
    <span class="tok-kw">const</span> alias_index: <a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.aliases.items.len);
    self.aliases.appendAssumeCapacity(.{ .global = self.addGlobalAssumeCapacity(name, .{
        .addr_space = addr_space,
        .<span class="tok-type">type</span> = ty,
        .kind = .{ .alias = alias_index },
    }), .aliasee = aliasee });
    <span class="tok-kw">return</span> alias_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.addVariable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addVariable</span><a href="#src.zig-std.zig.llvm.Builder.addVariable">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addVariable</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.addVariable">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addVariable</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedGlobalCapacity(name);
    <span class="tok-kw">try</span> self.variables.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addVariableAssumeCapacity(ty, name, addr_space);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.addVariableAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addVariableAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.addVariableAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addVariableAssumeCapacity</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>, ) <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.addVariableAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addVariableAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
) <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a> {
    <span class="tok-kw">const</span> variable_index: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.variables.items.len);
    self.variables.appendAssumeCapacity(.{ .global = self.addGlobalAssumeCapacity(name, .{
        .addr_space = addr_space,
        .<span class="tok-type">type</span> = ty,
        .kind = .{ .variable = variable_index },
    }) });
    <span class="tok-kw">return</span> variable_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.addFunction" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFunction</span><a href="#src.zig-std.zig.llvm.Builder.addFunction">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFunction</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.addFunction">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFunction</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedGlobalCapacity(name);
    <span class="tok-kw">try</span> self.functions.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addFunctionAssumeCapacity(ty, name, addr_space);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.addFunctionAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">addFunctionAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.addFunctionAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFunctionAssumeCapacity</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>, ) <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div><div><pre><code>addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.addFunctionAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFunctionAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
) <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ty.isFunction(self));
    <span class="tok-kw">const</span> function_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.functions.items.len);
    self.functions.appendAssumeCapacity(.{
        .global = self.addGlobalAssumeCapacity(name, .{
            .addr_space = addr_space,
            .<span class="tok-type">type</span> = ty,
            .kind = .{ .function = function_index },
        }),
        .strip = <span class="tok-null">undefined</span>,
    });
    <span class="tok-kw">return</span> function_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.getIntrinsic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIntrinsic</span><a href="#src.zig-std.zig.llvm.Builder.getIntrinsic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIntrinsic</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>, overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a></code></pre></div><div><pre><code>overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.getIntrinsic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIntrinsic</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>,
    overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> {
    <span class="tok-kw">const</span> ExpectedContents = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
        attrs: <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
            params: [<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.expected_args_len">expected_args_len</a>]<a href="std.zig.llvm.Builder.Type.html">Type</a>,
            fn_attrs: [<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.expected_args_len">expected_args_len</a>]<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>,
            attrs: [<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.expected_attrs_len">expected_attrs_len</a>]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>,
            fields: [<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.expected_fields_len">expected_fields_len</a>]<a href="std.zig.llvm.Builder.Type.html">Type</a>,
        },
    };
    <span class="tok-kw">var</span> stack <span class="tok-kw">align</span>(<span class="tok-builtin">@max</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.StackFallbackAllocator">StackFallbackAllocator</a>(<span class="tok-number">0</span>)), <span class="tok-builtin">@alignOf</span>(ExpectedContents))) =
        <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-builtin">@sizeOf</span>(ExpectedContents), self.gpa);
    <span class="tok-kw">const</span> allocator = stack.get();

    <span class="tok-kw">const</span> name = name: {
        <span class="tok-kw">const</span> writer = self.strtab_string_bytes.writer(self.gpa);
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;llvm.{s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(id)});
        <span class="tok-kw">for</span> (overload) |ty| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;.{m}&quot;</span>, .{ty.fmt(self)});
        <span class="tok-kw">break</span> :name <span class="tok-kw">try</span> self.trailingStrtabString();
    };
    <span class="tok-kw">if</span> (self.getGlobal(name)) |global| <span class="tok-kw">return</span> global.ptrConst(self).kind.function;

    <span class="tok-kw">const</span> signature = <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>.<a href="std.zig.llvm.Builder.Intrinsic.html#std.zig.llvm.Builder.Intrinsic.signatures">signatures</a>.<a href="#">get</a>(id);
    <span class="tok-kw">const</span> param_types = <span class="tok-kw">try</span> allocator.alloc(<a href="std.zig.llvm.Builder.Type.html">Type</a>, signature.params.len);
    <span class="tok-kw">defer</span> allocator.free(param_types);
    <span class="tok-kw">const</span> function_attributes = <span class="tok-kw">try</span> allocator.alloc(
        <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>,
        <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + (signature.params.len - signature.ret_len),
    );
    <span class="tok-kw">defer</span> allocator.free(function_attributes);

    <span class="tok-kw">var</span> attributes: <span class="tok-kw">struct</span> {
        builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
        list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>),

        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(state: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            state.list.deinit();
            state.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(state: *<span class="tok-builtin">@This</span>(), attributes: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
            <span class="tok-kw">try</span> state.list.resize(attributes.len);
            <span class="tok-kw">for</span> (state.list.items, attributes) |*item, attribute|
                item.* = <span class="tok-kw">try</span> state.builder.attr(attribute);
            <span class="tok-kw">return</span> state.builder.attrs(state.list.items);
        }
    } = .{ .builder = self, .list = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>).init(allocator) };
    <span class="tok-kw">defer</span> attributes.deinit();

    <span class="tok-kw">var</span> overload_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    function_attributes[<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.function_index">function_index</a>] = <span class="tok-kw">try</span> attributes.get(signature.attrs);
    function_attributes[<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.return_index">return_index</a>] = .none;<span class="tok-comment"> // needed for void return
    </span><span class="tok-kw">for</span> (<span class="tok-number">0</span>.., param_types, signature.params) |param_index, *param_type, signature_param| {
        <span class="tok-kw">switch</span> (signature_param.kind) {
            .<span class="tok-type">type</span> =&gt; |ty| param_type.* = ty,
            .overloaded =&gt; {
                param_type.* = overload[overload_index];
                overload_index += <span class="tok-number">1</span>;
            },
            .matches, .matches_scalar, .matches_changed_scalar =&gt; {},
        }
        function_attributes[
            <span class="tok-kw">if</span> (param_index &lt; signature.ret_len)
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.return_index">return_index</a>
            <span class="tok-kw">else</span>
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + (param_index - signature.ret_len)
        ] = <span class="tok-kw">try</span> attributes.get(signature_param.attrs);
    }
    <a href="std.debug.html#std.debug.assert">assert</a>(overload_index == overload.len);
    <span class="tok-kw">for</span> (param_types, signature.params) |*param_type, signature_param| {
        param_type.* = <span class="tok-kw">switch</span> (signature_param.kind) {
            .<span class="tok-type">type</span>, .overloaded =&gt; <span class="tok-kw">continue</span>,
            .matches =&gt; |param_index| param_types[param_index],
            .matches_scalar =&gt; |param_index| param_types[param_index].scalarType(self),
            .matches_changed_scalar =&gt; |info| <span class="tok-kw">try</span> param_types[info.index]
                .changeScalar(info.scalar, self),
        };
    }

    <span class="tok-kw">const</span> function_index = <span class="tok-kw">try</span> self.addFunction(<span class="tok-kw">try</span> self.fnType(<span class="tok-kw">switch</span> (signature.ret_len) {
        <span class="tok-number">0</span> =&gt; .<span class="tok-type">void</span>,
        <span class="tok-number">1</span> =&gt; param_types[<span class="tok-number">0</span>],
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> self.structType(.normal, param_types[<span class="tok-number">0</span>..signature.ret_len]),
    }, param_types[signature.ret_len..], .normal), name, .default);
    function_index.ptr(self).attributes = <span class="tok-kw">try</span> self.fnAttrs(function_attributes);
    <span class="tok-kw">return</span> function_index;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.intConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intConst</span><a href="#src.zig-std.zig.llvm.Builder.intConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.intConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> int_value = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value))) {
        .int, .<span class="tok-type">comptime_int</span> =&gt; value,
        .@&quot;enum&quot; =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;intConst expected an integral value, got &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value))),
    };
    <span class="tok-kw">var</span> limbs: [
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(int_value))) {
            .int =&gt; |info| <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(info.bits),
            .<span class="tok-type">comptime_int</span> =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(int_value),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    ]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> self.bigIntConst(ty, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(&amp;limbs, int_value).toConst());
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.intValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">intValue</span><a href="#src.zig-std.zig.llvm.Builder.intValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.intValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.intConst(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.bigIntConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bigIntConst</span><a href="#src.zig-std.zig.llvm.Builder.bigIntConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigIntConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.bigIntConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigIntConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.constant_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.constant_items.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.constant_limbs.ensureUnusedCapacity(self.gpa, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> + value.limbs.len);
    <span class="tok-kw">return</span> self.bigIntConstAssumeCapacity(ty, value);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.bigIntValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bigIntValue</span><a href="#src.zig-std.zig.llvm.Builder.bigIntValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigIntValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.bigIntValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigIntValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.bigIntConst(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.fpConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fpConst</span><a href="#src.zig-std.zig.llvm.Builder.fpConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fpConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, <span class="tok-kw">comptime</span> val: <span class="tok-type">comptime_float</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>val: <span class="tok-type">comptime_float</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.fpConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fpConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, <span class="tok-kw">comptime</span> val: <span class="tok-type">comptime_float</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (ty) {
        .half =&gt; <span class="tok-kw">try</span> self.halfConst(val),
        .bfloat =&gt; <span class="tok-kw">try</span> self.bfloatConst(val),
        .float =&gt; <span class="tok-kw">try</span> self.floatConst(val),
        .double =&gt; <span class="tok-kw">try</span> self.doubleConst(val),
        .fp128 =&gt; <span class="tok-kw">try</span> self.fp128Const(val),
        .x86_fp80 =&gt; <span class="tok-kw">try</span> self.x86_fp80Const(val),
        .ppc_fp128 =&gt; <span class="tok-kw">try</span> self.ppc_fp128Const(.{ val, -<span class="tok-number">0.0</span> }),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.fpValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fpValue</span><a href="#src.zig-std.zig.llvm.Builder.fpValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fpValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, <span class="tok-kw">comptime</span> value: <span class="tok-type">comptime_float</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <span class="tok-type">comptime_float</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.fpValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fpValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, <span class="tok-kw">comptime</span> value: <span class="tok-type">comptime_float</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.fpConst(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.nanConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nanConst</span><a href="#src.zig-std.zig.llvm.Builder.nanConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.nanConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (ty) {
        .half =&gt; <span class="tok-kw">try</span> self.halfConst(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f16</span>)),
        .bfloat =&gt; <span class="tok-kw">try</span> self.bfloatConst(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f32</span>)),
        .float =&gt; <span class="tok-kw">try</span> self.floatConst(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f32</span>)),
        .double =&gt; <span class="tok-kw">try</span> self.doubleConst(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f64</span>)),
        .fp128 =&gt; <span class="tok-kw">try</span> self.fp128Const(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f128</span>)),
        .x86_fp80 =&gt; <span class="tok-kw">try</span> self.x86_fp80Const(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f80</span>)),
        .ppc_fp128 =&gt; <span class="tok-kw">try</span> self.ppc_fp128Const(.{<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f64</span>)} ** <span class="tok-number">2</span>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.nanValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nanValue</span><a href="#src.zig-std.zig.llvm.Builder.nanValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.nanValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.nanConst(ty)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.halfConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">halfConst</span><a href="#src.zig-std.zig.llvm.Builder.halfConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">halfConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f16</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <span class="tok-type">f16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.halfConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">halfConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f16</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.halfConstAssumeCapacity(val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.halfValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">halfValue</span><a href="#src.zig-std.zig.llvm.Builder.halfValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">halfValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f16</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <span class="tok-type">f16</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.halfValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">halfValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f16</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.halfConst(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.bfloatConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bfloatConst</span><a href="#src.zig-std.zig.llvm.Builder.bfloatConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bfloatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <span class="tok-type">f32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.bfloatConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bfloatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.bfloatConstAssumeCapacity(val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.bfloatValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">bfloatValue</span><a href="#src.zig-std.zig.llvm.Builder.bfloatValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bfloatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <span class="tok-type">f32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.bfloatValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bfloatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.bfloatConst(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.floatConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">floatConst</span><a href="#src.zig-std.zig.llvm.Builder.floatConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <span class="tok-type">f32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.floatConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.floatConstAssumeCapacity(val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.floatValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">floatValue</span><a href="#src.zig-std.zig.llvm.Builder.floatValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <span class="tok-type">f32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.floatValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.floatConst(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.doubleConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">doubleConst</span><a href="#src.zig-std.zig.llvm.Builder.doubleConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doubleConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <span class="tok-type">f64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.doubleConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doubleConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Double.html">Double</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.doubleConstAssumeCapacity(val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.doubleValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">doubleValue</span><a href="#src.zig-std.zig.llvm.Builder.doubleValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doubleValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <span class="tok-type">f64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.doubleValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doubleValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.doubleConst(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.fp128Const" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fp128Const</span><a href="#src.zig-std.zig.llvm.Builder.fp128Const">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fp128Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f128</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <span class="tok-type">f128</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.fp128Const">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fp128Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f128</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.fp128ConstAssumeCapacity(val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.fp128Value" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fp128Value</span><a href="#src.zig-std.zig.llvm.Builder.fp128Value">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fp128Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f128</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <span class="tok-type">f128</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.fp128Value">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fp128Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f128</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.fp128Const(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.x86_fp80Const" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">x86_fp80Const</span><a href="#src.zig-std.zig.llvm.Builder.x86_fp80Const">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">x86_fp80Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f80</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <span class="tok-type">f80</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.x86_fp80Const">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">x86_fp80Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f80</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp80.html">Fp80</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.x86_fp80ConstAssumeCapacity(val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.x86_fp80Value" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">x86_fp80Value</span><a href="#src.zig-std.zig.llvm.Builder.x86_fp80Value">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">x86_fp80Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f80</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: <span class="tok-type">f80</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.x86_fp80Value">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">x86_fp80Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f80</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.x86_fp80Const(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.ppc_fp128Const" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ppc_fp128Const</span><a href="#src.zig-std.zig.llvm.Builder.ppc_fp128Const">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppc_fp128Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: [<span class="tok-number">2</span>]<span class="tok-type">f64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.ppc_fp128Const">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppc_fp128Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.ppc_fp128ConstAssumeCapacity(val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.ppc_fp128Value" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ppc_fp128Value</span><a href="#src.zig-std.zig.llvm.Builder.ppc_fp128Value">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppc_fp128Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>value: [<span class="tok-number">2</span>]<span class="tok-type">f64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.ppc_fp128Value">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppc_fp128Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.ppc_fp128Const(ty, value)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.nullConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nullConst</span><a href="#src.zig-std.zig.llvm.Builder.nullConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.nullConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.nullConstAssumeCapacity(ty);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.nullValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">nullValue</span><a href="#src.zig-std.zig.llvm.Builder.nullValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.nullValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.nullConst(ty)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.noneConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">noneConst</span><a href="#src.zig-std.zig.llvm.Builder.noneConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noneConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.noneConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noneConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.noneConstAssumeCapacity(ty);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.noneValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">noneValue</span><a href="#src.zig-std.zig.llvm.Builder.noneValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noneValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.noneValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noneValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.noneConst(ty)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.structConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">structConst</span><a href="#src.zig-std.zig.llvm.Builder.structConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.structConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, vals.len);
    <span class="tok-kw">return</span> self.structConstAssumeCapacity(ty, vals);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.structValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">structValue</span><a href="#src.zig-std.zig.llvm.Builder.structValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.structValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.structConst(ty, vals)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.arrayConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayConst</span><a href="#src.zig-std.zig.llvm.Builder.arrayConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.arrayConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, vals.len);
    <span class="tok-kw">return</span> self.arrayConstAssumeCapacity(ty, vals);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.arrayValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">arrayValue</span><a href="#src.zig-std.zig.llvm.Builder.arrayValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.arrayValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.arrayConst(ty, vals)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.stringConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringConst</span><a href="#src.zig-std.zig.llvm.Builder.stringConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.stringConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.stringConstAssumeCapacity(val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.stringValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">stringValue</span><a href="#src.zig-std.zig.llvm.Builder.stringValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.stringValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.stringConst(val)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.vectorConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">vectorConst</span><a href="#src.zig-std.zig.llvm.Builder.vectorConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.vectorConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, vals.len);
    <span class="tok-kw">return</span> self.vectorConstAssumeCapacity(ty, vals);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.vectorValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">vectorValue</span><a href="#src.zig-std.zig.llvm.Builder.vectorValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.vectorValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.vectorConst(ty, vals)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.splatConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splatConst</span><a href="#src.zig-std.zig.llvm.Builder.splatConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.splatConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.splatConstAssumeCapacity(ty, val);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.splatValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">splatValue</span><a href="#src.zig-std.zig.llvm.Builder.splatValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.splatValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.splatConst(ty, val)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.zeroInitConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">zeroInitConst</span><a href="#src.zig-std.zig.llvm.Builder.zeroInitConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInitConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.zeroInitConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInitConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.constant_limbs.ensureUnusedCapacity(
        self.gpa,
        <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> + <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(<span class="tok-number">0</span>),
    );
    <span class="tok-kw">return</span> self.zeroInitConstAssumeCapacity(ty);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.zeroInitValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">zeroInitValue</span><a href="#src.zig-std.zig.llvm.Builder.zeroInitValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInitValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.zeroInitValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInitValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.zeroInitConst(ty)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.undefConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">undefConst</span><a href="#src.zig-std.zig.llvm.Builder.undefConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">undefConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.undefConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">undefConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.undefConstAssumeCapacity(ty);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.undefValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">undefValue</span><a href="#src.zig-std.zig.llvm.Builder.undefValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">undefValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.undefValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">undefValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.undefConst(ty)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.poisonConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">poisonConst</span><a href="#src.zig-std.zig.llvm.Builder.poisonConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poisonConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.poisonConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poisonConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.poisonConstAssumeCapacity(ty);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.poisonValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">poisonValue</span><a href="#src.zig-std.zig.llvm.Builder.poisonValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poisonValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.poisonValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poisonValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.poisonConst(ty)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.blockAddrConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">blockAddrConst</span><a href="#src.zig-std.zig.llvm.Builder.blockAddrConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">blockAddrConst</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div><div><pre><code>block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.blockAddrConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">blockAddrConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.blockAddrConstAssumeCapacity(function, block);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.blockAddrValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">blockAddrValue</span><a href="#src.zig-std.zig.llvm.Builder.blockAddrValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">blockAddrValue</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div><div><pre><code>block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.blockAddrValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">blockAddrValue</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.blockAddrConst(function, block)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.dsoLocalEquivalentConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dsoLocalEquivalentConst</span><a href="#src.zig-std.zig.llvm.Builder.dsoLocalEquivalentConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dsoLocalEquivalentConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.dsoLocalEquivalentConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dsoLocalEquivalentConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.dsoLocalEquivalentConstAssumeCapacity(function);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.dsoLocalEquivalentValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dsoLocalEquivalentValue</span><a href="#src.zig-std.zig.llvm.Builder.dsoLocalEquivalentValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dsoLocalEquivalentValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.dsoLocalEquivalentValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dsoLocalEquivalentValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.dsoLocalEquivalentConst(function)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.noCfiConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">noCfiConst</span><a href="#src.zig-std.zig.llvm.Builder.noCfiConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noCfiConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.noCfiConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noCfiConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.noCfiConstAssumeCapacity(function);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.noCfiValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">noCfiValue</span><a href="#src.zig-std.zig.llvm.Builder.noCfiValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noCfiValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.noCfiValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noCfiValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.noCfiConst(function)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.convConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">convConst</span><a href="#src.zig-std.zig.llvm.Builder.convConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convConst</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.convConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.convConstAssumeCapacity(val, ty);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.convValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">convValue</span><a href="#src.zig-std.zig.llvm.Builder.convValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convValue</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.convValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convValue</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.convConst(val, ty)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.castConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">castConst</span><a href="#src.zig-std.zig.llvm.Builder.castConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.castConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.castConstAssumeCapacity(tag, val, ty);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.castValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">castValue</span><a href="#src.zig-std.zig.llvm.Builder.castValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a></code></pre></div><div><pre><code>val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.castValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.castConst(tag, val, ty)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.gepConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gepConst</span><a href="#src.zig-std.zig.llvm.Builder.gepConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepConst</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, inrange: ?<span class="tok-type">u16</span>, indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div><pre><code>inrange: ?<span class="tok-type">u16</span></code></pre></div><div><pre><code>indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.gepConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    inrange: ?<span class="tok-type">u16</span>,
    indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>, indices.len);
    <span class="tok-kw">return</span> self.gepConstAssumeCapacity(kind, ty, base, inrange, indices);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.gepValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">gepValue</span><a href="#src.zig-std.zig.llvm.Builder.gepValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepValue</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, inrange: ?<span class="tok-type">u16</span>, indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div><pre><code>inrange: ?<span class="tok-type">u16</span></code></pre></div><div><pre><code>indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.gepValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepValue</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    inrange: ?<span class="tok-type">u16</span>,
    indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.gepConst(kind, ty, base, inrange, indices)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.binConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">binConst</span><a href="#src.zig-std.zig.llvm.Builder.binConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binConst</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a></code></pre></div><div><pre><code>lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div><pre><code>rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.binConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>,
    lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.binConstAssumeCapacity(tag, lhs, rhs);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.binValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">binValue</span><a href="#src.zig-std.zig.llvm.Builder.binValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a></code></pre></div><div><pre><code>lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div><pre><code>rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.binValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.binConst(tag, lhs, rhs)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.asmConst" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">asmConst</span><a href="#src.zig-std.zig.llvm.Builder.asmConst">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmConst</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>, assembly: <a href="std.zig.llvm.Builder.String.html">String</a>, constraints: <a href="std.zig.llvm.Builder.String.html">String</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a></code></pre></div><div><pre><code>assembly: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div><pre><code>constraints: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.asmConst">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>,
    assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
    constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.asmConstAssumeCapacity(ty, info, assembly, constraints);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.asmValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">asmValue</span><a href="#src.zig-std.zig.llvm.Builder.asmValue">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmValue</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>, assembly: <a href="std.zig.llvm.Builder.String.html">String</a>, constraints: <a href="std.zig.llvm.Builder.String.html">String</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Type.html">Type</a></code></pre></div><div><pre><code>info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a></code></pre></div><div><pre><code>assembly: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div><div><pre><code>constraints: <a href="std.zig.llvm.Builder.String.html">String</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.asmValue">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmValue</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>,
    assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
    constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.asmConst(ty, info, assembly, constraints)).toValue();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.dump" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">dump</span><a href="#src.zig-std.zig.llvm.Builder.dump">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.dump">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
    self.print(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer()) <span class="tok-kw">catch</span> {};
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.printToFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">printToFile</span><a href="#src.zig-std.zig.llvm.Builder.printToFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printToFile</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.printToFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printToFile</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> file = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().createFile(path, .{}) <span class="tok-kw">catch</span> |err| {
        <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.log">log</a>.<a href="#">err</a>(<span class="tok-str">&quot;failed printing LLVM module to \&quot;{s}\&quot;: {s}&quot;</span>, .{ path, <span class="tok-builtin">@errorName</span>(err) });
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    };
    <span class="tok-kw">defer</span> file.close();
    self.print(file.writer()) <span class="tok-kw">catch</span> |err| {
        <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.log">log</a>.<a href="#">err</a>(<span class="tok-str">&quot;failed printing LLVM module to \&quot;{s}\&quot;: {s}&quot;</span>, .{ path, <span class="tok-builtin">@errorName</span>(err) });
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    };
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.print" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">print</span><a href="#src.zig-std.zig.llvm.Builder.print">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, writer: <span class="tok-kw">anytype</span>) (<span class="tok-builtin">@TypeOf</span>(writer).Error || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>)!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.print">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, writer: <span class="tok-kw">anytype</span>) (<span class="tok-builtin">@TypeOf</span>(writer).Error || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>)!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> bw = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.buffered_writer.html#std.io.buffered_writer.bufferedWriter">bufferedWriter</a>(writer);
    <span class="tok-kw">try</span> self.printUnbuffered(bw.writer());
    <span class="tok-kw">try</span> bw.flush();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.printUnbuffered" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">printUnbuffered</span><a href="#src.zig-std.zig.llvm.Builder.printUnbuffered">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printUnbuffered</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, backing_writer: <span class="tok-kw">anytype</span>, ) (<span class="tok-builtin">@TypeOf</span>(backing_writer).Error || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>)!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.printUnbuffered">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printUnbuffered</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    backing_writer: <span class="tok-kw">anytype</span>,
) (<span class="tok-builtin">@TypeOf</span>(backing_writer).Error || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>)!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> writer_with_errors = <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.writerWithErrors">writerWithErrors</a>(backing_writer, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>);
    <span class="tok-kw">const</span> writer = writer_with_errors.writer();

    <span class="tok-kw">var</span> need_newline = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> metadata_formatter: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Formatter.html">Formatter</a> = .{ .builder = self, .need_comma = <span class="tok-null">undefined</span> };
    <span class="tok-kw">defer</span> metadata_formatter.map.deinit(self.gpa);

    <span class="tok-kw">if</span> (self.source_filename != .none <span class="tok-kw">or</span> self.data_layout != .none <span class="tok-kw">or</span> self.target_triple != .none) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (self.source_filename != .none) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\; ModuleID = '{s}'</span>
            <span class="tok-str">\\source_filename = {&quot;}</span>
            <span class="tok-str">\\</span>
        , .{ self.source_filename.slice(self).?, self.source_filename.fmt(self) });
        <span class="tok-kw">if</span> (self.data_layout != .none) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\target datalayout = {&quot;}</span>
            <span class="tok-str">\\</span>
        , .{self.data_layout.fmt(self)});
        <span class="tok-kw">if</span> (self.target_triple != .none) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\target triple = {&quot;}</span>
            <span class="tok-str">\\</span>
        , .{self.target_triple.fmt(self)});
    }

    <span class="tok-kw">if</span> (self.module_asm.items.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">var</span> line_it = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, self.module_asm.items, <span class="tok-str">'\n'</span>);
        <span class="tok-kw">while</span> (line_it.next()) |line| {
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;module asm &quot;</span>);
            <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printEscapedString">printEscapedString</a>(line, .always_quote, writer);
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
        }
    }

    <span class="tok-kw">if</span> (self.types.count() &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (self.types.keys(), self.types.values()) |id, ty| <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\%{} = type {}</span>
            <span class="tok-str">\\</span>
        , .{ id.fmt(self), ty.fmt(self) });
    }

    <span class="tok-kw">if</span> (self.variables.items.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (self.variables.items) |variable| {
            <span class="tok-kw">if</span> (variable.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;
            <span class="tok-kw">const</span> global = variable.global.ptrConst(self);
            metadata_formatter.need_comma = <span class="tok-null">true</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\{} ={}{}{}{}{ }{}{ }{} {s} {%}{ }{, }{}</span>
                <span class="tok-str">\\</span>
            , .{
                variable.global.fmt(self),
                <a href="std.zig.llvm.Builder.Linkage.html">Linkage</a>.<a href="std.zig.llvm.Builder.Linkage.html#std.zig.llvm.Builder.Linkage.fmtOptional">fmtOptional</a>(<span class="tok-kw">if</span> (global.linkage == .external <span class="tok-kw">and</span>
                    variable.init != .no_init) <span class="tok-null">null</span> <span class="tok-kw">else</span> global.linkage),
                global.preemption,
                global.visibility,
                global.dll_storage_class,
                variable.thread_local,
                global.unnamed_addr,
                global.addr_space,
                global.externally_initialized,
                <span class="tok-builtin">@tagName</span>(variable.mutability),
                global.<span class="tok-type">type</span>.fmt(self),
                variable.init.fmt(self),
                variable.alignment,
                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;!dbg &quot;</span>, global.dbg),
            });
        }
    }

    <span class="tok-kw">if</span> (self.aliases.items.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (self.aliases.items) |alias| {
            <span class="tok-kw">if</span> (alias.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;
            <span class="tok-kw">const</span> global = alias.global.ptrConst(self);
            metadata_formatter.need_comma = <span class="tok-null">true</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\{} ={}{}{}{}{ }{} alias {%}, {%}{}</span>
                <span class="tok-str">\\</span>
            , .{
                alias.global.fmt(self),
                global.linkage,
                global.preemption,
                global.visibility,
                global.dll_storage_class,
                alias.thread_local,
                global.unnamed_addr,
                global.<span class="tok-type">type</span>.fmt(self),
                alias.aliasee.fmt(self),
                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;!dbg &quot;</span>, global.dbg),
            });
        }
    }

    <span class="tok-kw">var</span> attribute_groups: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>, <span class="tok-type">void</span>) = .empty;
    <span class="tok-kw">defer</span> attribute_groups.deinit(self.gpa);

    <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., self.functions.items) |function_i, function| {
        <span class="tok-kw">if</span> (function.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">const</span> function_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function_i);
        <span class="tok-kw">const</span> global = function.global.ptrConst(self);
        <span class="tok-kw">const</span> params_len = global.<span class="tok-type">type</span>.functionParameters(self).len;
        <span class="tok-kw">const</span> function_attributes = function.attributes.func(self);
        <span class="tok-kw">if</span> (function_attributes != .none) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\; Function Attrs:{}</span>
            <span class="tok-str">\\</span>
        , .{function_attributes.fmt(self)});
        <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\{s}{}{}{}{}{}{&quot;} {%} {}(</span>
        , .{
            <span class="tok-kw">if</span> (function.instructions.len &gt; <span class="tok-number">0</span>) <span class="tok-str">&quot;define&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;declare&quot;</span>,
            global.linkage,
            global.preemption,
            global.visibility,
            global.dll_storage_class,
            function.call_conv,
            function.attributes.ret(self).fmt(self),
            global.<span class="tok-type">type</span>.functionReturn(self).fmt(self),
            function.global.fmt(self),
        });
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |arg| {
            <span class="tok-kw">if</span> (arg &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\{%}{&quot;}</span>
            , .{
                global.<span class="tok-type">type</span>.functionParameters(self)[arg].fmt(self),
                function.attributes.param(arg, self).fmt(self),
            });
            <span class="tok-kw">if</span> (function.instructions.len &gt; <span class="tok-number">0</span>)
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {}&quot;</span>, .{function.arg(<span class="tok-builtin">@intCast</span>(arg)).fmt(function_index, self)})
            <span class="tok-kw">else</span>
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; %{d}&quot;</span>, .{arg});
        }
        <span class="tok-kw">switch</span> (global.<span class="tok-type">type</span>.functionKind(self)) {
            .normal =&gt; {},
            .vararg =&gt; {
                <span class="tok-kw">if</span> (params_len &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;...&quot;</span>);
            },
        }
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;){}{ }&quot;</span>, .{ global.unnamed_addr, global.addr_space });
        <span class="tok-kw">if</span> (function_attributes != .none) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; #{d}&quot;</span>, .{
            (<span class="tok-kw">try</span> attribute_groups.getOrPutValue(self.gpa, function_attributes, {})).index,
        });
        {
            metadata_formatter.need_comma = <span class="tok-null">false</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{ }{}&quot;</span>, .{
                function.alignment,
                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot; !dbg &quot;</span>, global.dbg),
            });
        }
        <span class="tok-kw">if</span> (function.instructions.len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">var</span> block_incoming_len: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; {\n&quot;</span>);
            <span class="tok-kw">var</span> maybe_dbg_index: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
            <span class="tok-kw">for</span> (params_len..function.instructions.len) |instruction_i| {
                <span class="tok-kw">const</span> instruction_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(instruction_i);
                <span class="tok-kw">const</span> instruction = function.instructions.get(<span class="tok-builtin">@intFromEnum</span>(instruction_index));
                <span class="tok-kw">if</span> (function.debug_locations.get(instruction_index)) |debug_location| <span class="tok-kw">switch</span> (debug_location) {
                    .no_location =&gt; maybe_dbg_index = <span class="tok-null">null</span>,
                    .location =&gt; |location| {
                        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> metadata_formatter.map.getOrPut(self.gpa, .{
                            .debug_location = location,
                        });
                        maybe_dbg_index = <span class="tok-builtin">@intCast</span>(gop.index);
                    },
                };
                <span class="tok-kw">switch</span> (instruction.tag) {
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .@&quot;add nuw nsw&quot;,
                    .@&quot;and&quot;,
                    .ashr,
                    .@&quot;ashr exact&quot;,
                    .fadd,
                    .@&quot;fadd fast&quot;,
                    .@&quot;fcmp false&quot;,
                    .@&quot;fcmp fast false&quot;,
                    .@&quot;fcmp fast oeq&quot;,
                    .@&quot;fcmp fast oge&quot;,
                    .@&quot;fcmp fast ogt&quot;,
                    .@&quot;fcmp fast ole&quot;,
                    .@&quot;fcmp fast olt&quot;,
                    .@&quot;fcmp fast one&quot;,
                    .@&quot;fcmp fast ord&quot;,
                    .@&quot;fcmp fast true&quot;,
                    .@&quot;fcmp fast ueq&quot;,
                    .@&quot;fcmp fast uge&quot;,
                    .@&quot;fcmp fast ugt&quot;,
                    .@&quot;fcmp fast ule&quot;,
                    .@&quot;fcmp fast ult&quot;,
                    .@&quot;fcmp fast une&quot;,
                    .@&quot;fcmp fast uno&quot;,
                    .@&quot;fcmp oeq&quot;,
                    .@&quot;fcmp oge&quot;,
                    .@&quot;fcmp ogt&quot;,
                    .@&quot;fcmp ole&quot;,
                    .@&quot;fcmp olt&quot;,
                    .@&quot;fcmp one&quot;,
                    .@&quot;fcmp ord&quot;,
                    .@&quot;fcmp true&quot;,
                    .@&quot;fcmp ueq&quot;,
                    .@&quot;fcmp uge&quot;,
                    .@&quot;fcmp ugt&quot;,
                    .@&quot;fcmp ule&quot;,
                    .@&quot;fcmp ult&quot;,
                    .@&quot;fcmp une&quot;,
                    .@&quot;fcmp uno&quot;,
                    .fdiv,
                    .@&quot;fdiv fast&quot;,
                    .fmul,
                    .@&quot;fmul fast&quot;,
                    .frem,
                    .@&quot;frem fast&quot;,
                    .fsub,
                    .@&quot;fsub fast&quot;,
                    .@&quot;icmp eq&quot;,
                    .@&quot;icmp ne&quot;,
                    .@&quot;icmp sge&quot;,
                    .@&quot;icmp sgt&quot;,
                    .@&quot;icmp sle&quot;,
                    .@&quot;icmp slt&quot;,
                    .@&quot;icmp uge&quot;,
                    .@&quot;icmp ugt&quot;,
                    .@&quot;icmp ule&quot;,
                    .@&quot;icmp ult&quot;,
                    .lshr,
                    .@&quot;lshr exact&quot;,
                    .mul,
                    .@&quot;mul nsw&quot;,
                    .@&quot;mul nuw&quot;,
                    .@&quot;mul nuw nsw&quot;,
                    .@&quot;or&quot;,
                    .sdiv,
                    .@&quot;sdiv exact&quot;,
                    .srem,
                    .shl,
                    .@&quot;shl nsw&quot;,
                    .@&quot;shl nuw&quot;,
                    .@&quot;shl nuw nsw&quot;,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .@&quot;sub nuw nsw&quot;,
                    .udiv,
                    .@&quot;udiv exact&quot;,
                    .urem,
                    .xor,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.lhs.fmt(function_index, self),
                            extra.rhs.fmt(function_index, self),
                        });
                    },
                    .addrspacecast,
                    .bitcast,
                    .fpext,
                    .fptosi,
                    .fptoui,
                    .fptrunc,
                    .inttoptr,
                    .ptrtoint,
                    .sext,
                    .sitofp,
                    .trunc,
                    .uitofp,
                    .zext,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%} to {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.val.fmt(function_index, self),
                            extra.<span class="tok-type">type</span>.fmt(self),
                        });
                    },
                    .alloca,
                    .@&quot;alloca inalloca&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}{,%}{, }{, }&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.<span class="tok-type">type</span>.fmt(self),
                            <a href="std.zig.llvm.Builder.Value.html">Value</a>.<a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.fmt">fmt</a>(<span class="tok-kw">switch</span> (extra.len) {
                                .@&quot;1&quot; =&gt; .none,
                                <span class="tok-kw">else</span> =&gt; extra.len,
                            }, function_index, self),
                            extra.info.alignment,
                            extra.info.addr_space,
                        });
                    },
                    .arg =&gt; <span class="tok-kw">unreachable</span>,
                    .atomicrmw =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s}{ } {s} {%}, {%}{ }{ }{, }&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.info.access_kind,
                            <span class="tok-builtin">@tagName</span>(extra.info.atomic_rmw_operation),
                            extra.ptr.fmt(function_index, self),
                            extra.val.fmt(function_index, self),
                            extra.info.sync_scope,
                            extra.info.success_ordering,
                            extra.info.alignment,
                        });
                    },
                    .block =&gt; {
                        block_incoming_len = instruction.data;
                        <span class="tok-kw">const</span> name = instruction_index.name(&amp;function);
                        <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(instruction_index) &gt; params_len)
                            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}:\n&quot;</span>, .{name.fmt(self)});
                        <span class="tok-kw">continue</span>;
                    },
                    .br =&gt; |tag| {
                        <span class="tok-kw">const</span> target: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s} {%}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag), target.toInst(&amp;function).fmt(function_index, self),
                        });
                    },
                    .br_cond =&gt; {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  br {%}, {%}, {%}&quot;</span>, .{
                            extra.cond.fmt(function_index, self),
                            extra.then.toInst(&amp;function).fmt(function_index, self),
                            extra.@&quot;else&quot;.toInst(&amp;function).fmt(function_index, self),
                        });
                        metadata_formatter.need_comma = <span class="tok-null">true</span>;
                        <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
                        <span class="tok-kw">switch</span> (extra.weights) {
                            .none =&gt; {},
                            .unpredictable =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;!unpredictable !{}&quot;</span>),
                            _ =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}&quot;</span>, .{
                                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;!prof &quot;</span>, <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(extra.weights)))),
                            }),
                        }
                    },
                    .call,
                    .@&quot;call fast&quot;,
                    .@&quot;musttail call&quot;,
                    .@&quot;musttail call fast&quot;,
                    .@&quot;notail call&quot;,
                    .@&quot;notail call fast&quot;,
                    .@&quot;tail call&quot;,
                    .@&quot;tail call fast&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra =
                            function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, instruction.data);
                        <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;  &quot;</span>);
                        <span class="tok-kw">const</span> ret_ty = extra.data.ty.functionReturn(self);
                        <span class="tok-kw">switch</span> (ret_ty) {
                            .<span class="tok-type">void</span> =&gt; {},
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;%{} = &quot;</span>, .{
                                instruction_index.name(&amp;function).fmt(self),
                            }),
                            .none =&gt; <span class="tok-kw">unreachable</span>,
                        }
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}{}{}{} {%} {}(&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.info.call_conv,
                            extra.data.attributes.ret(self).fmt(self),
                            extra.data.callee.typeOf(function_index, self).pointerAddrSpace(self),
                            <span class="tok-kw">switch</span> (extra.data.ty.functionKind(self)) {
                                .normal =&gt; ret_ty,
                                .vararg =&gt; extra.data.ty,
                            }.fmt(self),
                            extra.data.callee.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., args) |arg_index, arg| {
                            <span class="tok-kw">if</span> (arg_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            metadata_formatter.need_comma = <span class="tok-null">false</span>;
                            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%}{}{}&quot;</span>, .{
                                arg.typeOf(function_index, self).fmt(self),
                                extra.data.attributes.param(arg_index, self).fmt(self),
                                <span class="tok-kw">try</span> metadata_formatter.fmtLocal(<span class="tok-str">&quot; &quot;</span>, arg, function_index),
                            });
                        }
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
                        <span class="tok-kw">if</span> (extra.data.info.has_op_bundle_cold) {
                            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; [ \&quot;cold\&quot;() ]&quot;</span>);
                        }
                        <span class="tok-kw">const</span> call_function_attributes = extra.data.attributes.func(self);
                        <span class="tok-kw">if</span> (call_function_attributes != .none) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; #{d}&quot;</span>, .{
                            (<span class="tok-kw">try</span> attribute_groups.getOrPutValue(
                                self.gpa,
                                call_function_attributes,
                                {},
                            )).index,
                        });
                    },
                    .cmpxchg,
                    .@&quot;cmpxchg weak&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s}{ } {%}, {%}, {%}{ }{ }{ }{, }&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.info.access_kind,
                            extra.ptr.fmt(function_index, self),
                            extra.cmp.fmt(function_index, self),
                            extra.new.fmt(function_index, self),
                            extra.info.sync_scope,
                            extra.info.success_ordering,
                            extra.info.failure_ordering,
                            extra.info.alignment,
                        });
                    },
                    .extractelement =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.val.fmt(function_index, self),
                            extra.index.fmt(function_index, self),
                        });
                    },
                    .extractvalue =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = function.extraDataTrail(
                            <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>,
                            instruction.data,
                        );
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.val.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (indices) |index| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {d}&quot;</span>, .{index});
                    },
                    .fence =&gt; |tag| {
                        <span class="tok-kw">const</span> info: <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a> = <span class="tok-builtin">@bitCast</span>(instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s}{ }{ }&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            info.sync_scope,
                            info.success_ordering,
                        });
                    },
                    .fneg,
                    .@&quot;fneg fast&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> val: <a href="std.zig.llvm.Builder.Value.html">Value</a> = <span class="tok-builtin">@enumFromInt</span>(instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            val.fmt(function_index, self),
                        });
                    },
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = function.extraDataTrail(
                            <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>,
                            instruction.data,
                        );
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.<span class="tok-type">type</span>.fmt(self),
                            extra.data.base.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (indices) |index| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {%}&quot;</span>, .{
                            index.fmt(function_index, self),
                        });
                    },
                    .indirectbr =&gt; |tag| {
                        <span class="tok-kw">var</span> extra =
                            function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, instruction.data);
                        <span class="tok-kw">const</span> targets =
                            extra.trail.next(extra.data.targets_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s} {%}, [&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.addr.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., targets) |target_index, target| {
                            <span class="tok-kw">if</span> (target_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%}&quot;</span>, .{
                                target.toInst(&amp;function).fmt(function_index, self),
                            });
                        }
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">']'</span>);
                    },
                    .insertelement =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.val.fmt(function_index, self),
                            extra.elem.fmt(function_index, self),
                            extra.index.fmt(function_index, self),
                        });
                    },
                    .insertvalue =&gt; |tag| {
                        <span class="tok-kw">var</span> extra =
                            function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.val.fmt(function_index, self),
                            extra.data.elem.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (indices) |index| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {d}&quot;</span>, .{index});
                    },
                    .load,
                    .@&quot;load atomic&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s}{ } {%}, {%}{ }{ }{, }&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.info.access_kind,
                            extra.<span class="tok-type">type</span>.fmt(self),
                            extra.ptr.fmt(function_index, self),
                            extra.info.sync_scope,
                            extra.info.success_ordering,
                            extra.info.alignment,
                        });
                    },
                    .phi,
                    .@&quot;phi fast&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data);
                        <span class="tok-kw">const</span> vals = extra.trail.next(block_incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;function);
                        <span class="tok-kw">const</span> blocks =
                            extra.trail.next(block_incoming_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%} &quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            vals[<span class="tok-number">0</span>].typeOf(function_index, self).fmt(self),
                        });
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., vals, blocks) |incoming_index, incoming_val, incoming_block| {
                            <span class="tok-kw">if</span> (incoming_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;[ {}, {} ]&quot;</span>, .{
                                incoming_val.fmt(function_index, self),
                                incoming_block.toInst(&amp;function).fmt(function_index, self),
                            });
                        }
                    },
                    .ret =&gt; |tag| {
                        <span class="tok-kw">const</span> val: <a href="std.zig.llvm.Builder.Value.html">Value</a> = <span class="tok-builtin">@enumFromInt</span>(instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s} {%}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            val.fmt(function_index, self),
                        });
                    },
                    .@&quot;ret void&quot;,
                    .@&quot;unreachable&quot;,
                    =&gt; |tag| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(tag)}),
                    .select,
                    .@&quot;select fast&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.cond.fmt(function_index, self),
                            extra.lhs.fmt(function_index, self),
                            extra.rhs.fmt(function_index, self),
                        });
                    },
                    .shufflevector =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.lhs.fmt(function_index, self),
                            extra.rhs.fmt(function_index, self),
                            extra.mask.fmt(function_index, self),
                        });
                    },
                    .store,
                    .@&quot;store atomic&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s}{ } {%}, {%}{ }{ }{, }&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.info.access_kind,
                            extra.val.fmt(function_index, self),
                            extra.ptr.fmt(function_index, self),
                            extra.info.sync_scope,
                            extra.info.success_ordering,
                            extra.info.alignment,
                        });
                    },
                    .@&quot;switch&quot; =&gt; |tag| {
                        <span class="tok-kw">var</span> extra =
                            function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
                        <span class="tok-kw">const</span> vals = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, &amp;function);
                        <span class="tok-kw">const</span> blocks =
                            extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s} {%}, {%} [\n&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.val.fmt(function_index, self),
                            extra.data.default.toInst(&amp;function).fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (vals, blocks) |case_val, case_block| <span class="tok-kw">try</span> writer.print(
                            <span class="tok-str">&quot;    {%}, {%}\n&quot;</span>,
                            .{
                                case_val.fmt(self),
                                case_block.toInst(&amp;function).fmt(function_index, self),
                            },
                        );
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;  ]&quot;</span>);
                        metadata_formatter.need_comma = <span class="tok-null">true</span>;
                        <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
                        <span class="tok-kw">switch</span> (extra.data.weights) {
                            .none =&gt; {},
                            .unpredictable =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;!unpredictable !{}&quot;</span>),
                            _ =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}&quot;</span>, .{
                                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;!prof &quot;</span>, <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(extra.data.weights)))),
                            }),
                        }
                    },
                    .va_arg =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.list.fmt(function_index, self),
                            extra.<span class="tok-type">type</span>.fmt(self),
                        });
                    },
                }

                <span class="tok-kw">if</span> (maybe_dbg_index) |dbg_index| {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, !dbg !{}&quot;</span>, .{dbg_index});
                }
                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
            }
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'}'</span>);
        }
        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
    }

    <span class="tok-kw">if</span> (attribute_groups.count() &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., attribute_groups.keys()) |attribute_group_index, attribute_group|
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\attributes #{d} = {{{#&quot;} }}</span>
                <span class="tok-str">\\</span>
            , .{ attribute_group_index, attribute_group.fmt(self) });
    }

    <span class="tok-kw">if</span> (self.metadata_named.count() &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (self.metadata_named.keys(), self.metadata_named.values()) |name, data| {
            <span class="tok-kw">const</span> elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> =
                <span class="tok-builtin">@ptrCast</span>(self.metadata_extra.items[data.index..][<span class="tok-number">0</span>..data.len]);
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'!'</span>);
            <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printEscapedString">printEscapedString</a>(name.slice(self), .quote_unless_valid_identifier, writer);
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; = !{&quot;</span>);
            metadata_formatter.need_comma = <span class="tok-null">false</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (elements) |element| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}&quot;</span>, .{<span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, element)});
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;}\n&quot;</span>);
        }
    }

    <span class="tok-kw">if</span> (metadata_formatter.map.count() &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">var</span> metadata_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (metadata_index &lt; metadata_formatter.map.count()) : (metadata_index += <span class="tok-number">1</span>) {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">10_000</span>);
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;!{} = &quot;</span>, .{metadata_index});
            metadata_formatter.need_comma = <span class="tok-null">false</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;

            <span class="tok-kw">const</span> key = metadata_formatter.map.keys()[metadata_index];
            <span class="tok-kw">const</span> metadata_item = <span class="tok-kw">switch</span> (key) {
                .debug_location =&gt; |location| {
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DILocation, .{
                        .line = location.line,
                        .column = location.column,
                        .scope = location.scope,
                        .inlinedAt = location.inlined_at,
                        .isImplicitCode = <span class="tok-null">false</span>,
                    }, writer);
                    <span class="tok-kw">continue</span>;
                },
                .metadata =&gt; |metadata| self.metadata_items.get(<span class="tok-builtin">@intFromEnum</span>(metadata)),
            };

            <span class="tok-kw">switch</span> (metadata_item.tag) {
                .none, .expression, .constant =&gt; <span class="tok-kw">unreachable</span>,
                .file =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.File.html">File</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIFile, .{
                        .filename = extra.filename,
                        .directory = extra.directory,
                        .checksumkind = <span class="tok-null">null</span>,
                        .checksum = <span class="tok-null">null</span>,
                        .source = <span class="tok-null">null</span>,
                    }, writer);
                },
                .compile_unit,
                .@&quot;compile_unit optimized&quot;,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;distinct !&quot;, .DICompileUnit, .{
                        .language = .DW_LANG_C99,
                        .file = extra.file,
                        .producer = extra.producer,
                        .isOptimized = <span class="tok-kw">switch</span> (kind) {
                            .compile_unit =&gt; <span class="tok-null">false</span>,
                            .@&quot;compile_unit optimized&quot; =&gt; <span class="tok-null">true</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                        .flags = <span class="tok-null">null</span>,
                        .runtimeVersion = <span class="tok-number">0</span>,
                        .splitDebugFilename = <span class="tok-null">null</span>,
                        .emissionKind = .FullDebug,
                        .enums = extra.enums,
                        .retainedTypes = <span class="tok-null">null</span>,
                        .globals = extra.globals,
                        .imports = <span class="tok-null">null</span>,
                        .macros = <span class="tok-null">null</span>,
                        .dwoId = <span class="tok-null">null</span>,
                        .splitDebugInlining = <span class="tok-null">false</span>,
                        .debugInfoForProfiling = <span class="tok-null">null</span>,
                        .nameTableKind = <span class="tok-null">null</span>,
                        .rangesBaseAddress = <span class="tok-null">null</span>,
                        .sysroot = <span class="tok-null">null</span>,
                        .sdk = <span class="tok-null">null</span>,
                    }, writer);
                },
                .subprogram,
                .@&quot;subprogram local&quot;,
                .@&quot;subprogram definition&quot;,
                .@&quot;subprogram local definition&quot;,
                .@&quot;subprogram optimized&quot;,
                .@&quot;subprogram optimized local&quot;,
                .@&quot;subprogram optimized definition&quot;,
                .@&quot;subprogram optimized local definition&quot;,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;distinct !&quot;, .DISubprogram, .{
                        .name = extra.name,
                        .linkageName = extra.linkage_name,
                        .scope = extra.file,
                        .file = extra.file,
                        .line = extra.line,
                        .<span class="tok-type">type</span> = extra.ty,
                        .scopeLine = extra.scope_line,
                        .containingType = <span class="tok-null">null</span>,
                        .virtualIndex = <span class="tok-null">null</span>,
                        .thisAdjustment = <span class="tok-null">null</span>,
                        .flags = extra.di_flags,
                        .spFlags = <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.DISPFlags.html">DISPFlags</a>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(
                            <span class="tok-builtin">@intFromEnum</span>(kind) - <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">subprogram</a>),
                        ))) &lt;&lt; <span class="tok-number">2</span>)),
                        .unit = extra.compile_unit,
                        .templateParams = <span class="tok-null">null</span>,
                        .declaration = <span class="tok-null">null</span>,
                        .retainedNodes = <span class="tok-null">null</span>,
                        .thrownTypes = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                        .targetFuncName = <span class="tok-null">null</span>,
                    }, writer);
                },
                .lexical_block =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LexicalBlock.html">LexicalBlock</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;distinct !&quot;, .DILexicalBlock, .{
                        .scope = extra.scope,
                        .file = extra.file,
                        .line = extra.line,
                        .column = extra.column,
                    }, writer);
                },
                .location =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Location.html">Location</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DILocation, .{
                        .line = extra.line,
                        .column = extra.column,
                        .scope = extra.scope,
                        .inlinedAt = extra.inlined_at,
                        .isImplicitCode = <span class="tok-null">false</span>,
                    }, writer);
                },
                .basic_bool_type,
                .basic_unsigned_type,
                .basic_signed_type,
                .basic_float_type,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIBasicType, .{
                        .tag = <span class="tok-null">null</span>,
                        .name = <span class="tok-kw">switch</span> (extra.name) {
                            .none =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; extra.name,
                        },
                        .size = extra.bitSize(),
                        .@&quot;align&quot; = <span class="tok-null">null</span>,
                        .encoding = <span class="tok-builtin">@as</span>(<span class="tok-kw">enum</span> {
                            DW_ATE_boolean,
                            DW_ATE_unsigned,
                            DW_ATE_signed,
                            DW_ATE_float,
                        }, <span class="tok-kw">switch</span> (kind) {
                            .basic_bool_type =&gt; .DW_ATE_boolean,
                            .basic_unsigned_type =&gt; .DW_ATE_unsigned,
                            .basic_signed_type =&gt; .DW_ATE_signed,
                            .basic_float_type =&gt; .DW_ATE_float,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }),
                        .flags = <span class="tok-null">null</span>,
                    }, writer);
                },
                .composite_struct_type,
                .composite_union_type,
                .composite_enumeration_type,
                .composite_array_type,
                .composite_vector_type,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DICompositeType, .{
                        .tag = <span class="tok-builtin">@as</span>(<span class="tok-kw">enum</span> {
                            DW_TAG_structure_type,
                            DW_TAG_union_type,
                            DW_TAG_enumeration_type,
                            DW_TAG_array_type,
                        }, <span class="tok-kw">switch</span> (kind) {
                            .composite_struct_type =&gt; .DW_TAG_structure_type,
                            .composite_union_type =&gt; .DW_TAG_union_type,
                            .composite_enumeration_type =&gt; .DW_TAG_enumeration_type,
                            .composite_array_type, .composite_vector_type =&gt; .DW_TAG_array_type,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }),
                        .name = <span class="tok-kw">switch</span> (extra.name) {
                            .none =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; extra.name,
                        },
                        .scope = extra.scope,
                        .file = <span class="tok-null">null</span>,
                        .line = <span class="tok-null">null</span>,
                        .baseType = extra.underlying_type,
                        .size = extra.bitSize(),
                        .@&quot;align&quot; = extra.bitAlign(),
                        .offset = <span class="tok-null">null</span>,
                        .flags = <span class="tok-null">null</span>,
                        .elements = extra.fields_tuple,
                        .runtimeLang = <span class="tok-null">null</span>,
                        .vtableHolder = <span class="tok-null">null</span>,
                        .templateParams = <span class="tok-null">null</span>,
                        .identifier = <span class="tok-null">null</span>,
                        .discriminator = <span class="tok-null">null</span>,
                        .dataLocation = <span class="tok-null">null</span>,
                        .associated = <span class="tok-null">null</span>,
                        .allocated = <span class="tok-null">null</span>,
                        .rank = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .derived_pointer_type,
                .derived_member_type,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIDerivedType, .{
                        .tag = <span class="tok-builtin">@as</span>(<span class="tok-kw">enum</span> {
                            DW_TAG_pointer_type,
                            DW_TAG_member,
                        }, <span class="tok-kw">switch</span> (kind) {
                            .derived_pointer_type =&gt; .DW_TAG_pointer_type,
                            .derived_member_type =&gt; .DW_TAG_member,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }),
                        .name = <span class="tok-kw">switch</span> (extra.name) {
                            .none =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; extra.name,
                        },
                        .scope = extra.scope,
                        .file = <span class="tok-null">null</span>,
                        .line = <span class="tok-null">null</span>,
                        .baseType = extra.underlying_type,
                        .size = extra.bitSize(),
                        .@&quot;align&quot; = extra.bitAlign(),
                        .offset = <span class="tok-kw">switch</span> (extra.bitOffset()) {
                            <span class="tok-number">0</span> =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; |bit_offset| bit_offset,
                        },
                        .flags = <span class="tok-null">null</span>,
                        .extraData = <span class="tok-null">null</span>,
                        .dwarfAddressSpace = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .subroutine_type =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.SubroutineType.html">SubroutineType</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DISubroutineType, .{
                        .flags = <span class="tok-null">null</span>,
                        .cc = <span class="tok-null">null</span>,
                        .types = extra.types_tuple,
                    }, writer);
                },
                .enumerator_unsigned,
                .enumerator_signed_positive,
                .enumerator_signed_negative,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Enumerator.html">Enumerator</a>, metadata_item.data);

                    <span class="tok-kw">const</span> ExpectedContents = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
                        <span class="tok-kw">const</span> expected_limbs = <span class="tok-builtin">@divExact</span>(<span class="tok-number">512</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                        string: [
                            (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>{
                                .limbs = &amp;([<span class="tok-number">1</span>]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>{
                                    <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>),
                                } ** <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printUnbuffered.expected_limbs">expected_limbs</a>),
                                .positive = <span class="tok-null">false</span>,
                            }).sizeInBaseUpperBound(<span class="tok-number">10</span>)
                        ]<span class="tok-type">u8</span>,
                        limbs: [
                            <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcToStringLimbsBufferLen">calcToStringLimbsBufferLen</a>(<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printUnbuffered.expected_limbs">expected_limbs</a>, <span class="tok-number">10</span>)
                        ]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
                    };
                    <span class="tok-kw">var</span> stack <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(ExpectedContents)) =
                        <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-builtin">@sizeOf</span>(ExpectedContents), self.gpa);
                    <span class="tok-kw">const</span> allocator = stack.get();

                    <span class="tok-kw">const</span> limbs = self.metadata_limbs.items[extra.limbs_index..][<span class="tok-number">0</span>..extra.limbs_len];
                    <span class="tok-kw">const</span> bigint: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a> = .{
                        .limbs = limbs,
                        .positive = <span class="tok-kw">switch</span> (kind) {
                            .enumerator_unsigned,
                            .enumerator_signed_positive,
                            =&gt; <span class="tok-null">true</span>,
                            .enumerator_signed_negative =&gt; <span class="tok-null">false</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                    };
                    <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> bigint.toStringAlloc(allocator, <span class="tok-number">10</span>, <span class="tok-null">undefined</span>);
                    <span class="tok-kw">defer</span> allocator.free(str);

                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIEnumerator, .{
                        .name = extra.name,
                        .value = str,
                        .isUnsigned = <span class="tok-kw">switch</span> (kind) {
                            .enumerator_unsigned =&gt; <span class="tok-null">true</span>,
                            .enumerator_signed_positive,
                            .enumerator_signed_negative,
                            =&gt; <span class="tok-null">false</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                    }, writer);
                },
                .subrange =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subrange.html">Subrange</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DISubrange, .{
                        .count = extra.count,
                        .lowerBound = extra.lower_bound,
                        .upperBound = <span class="tok-null">null</span>,
                        .stride = <span class="tok-null">null</span>,
                    }, writer);
                },
                .tuple =&gt; {
                    <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tuple.html">Tuple</a>, metadata_item.data);
                    <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, self);
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;!{&quot;</span>);
                    <span class="tok-kw">for</span> (elements) |element| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{[element]%}&quot;</span>, .{
                        .element = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, element),
                    });
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;}\n&quot;</span>);
                },
                .str_tuple =&gt; {
                    <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.StrTuple.html">StrTuple</a>, metadata_item.data);
                    <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, self);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;!{{{[str]%}&quot;</span>, .{
                        .str = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, extra.data.str),
                    });
                    <span class="tok-kw">for</span> (elements) |element| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{[element]%}&quot;</span>, .{
                        .element = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, element),
                    });
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;}\n&quot;</span>);
                },
                .module_flag =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.ModuleFlag.html">ModuleFlag</a>, metadata_item.data);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;!{{{[behavior]%}{[name]%}{[constant]%}}}\n&quot;</span>, .{
                        .behavior = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, extra.behavior),
                        .name = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, extra.name),
                        .constant = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, extra.constant),
                    });
                },
                .local_var =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LocalVar.html">LocalVar</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DILocalVariable, .{
                        .name = extra.name,
                        .arg = <span class="tok-null">null</span>,
                        .scope = extra.scope,
                        .file = extra.file,
                        .line = extra.line,
                        .<span class="tok-type">type</span> = extra.ty,
                        .flags = <span class="tok-null">null</span>,
                        .@&quot;align&quot; = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .parameter =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Parameter.html">Parameter</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DILocalVariable, .{
                        .name = extra.name,
                        .arg = extra.arg_no,
                        .scope = extra.scope,
                        .file = extra.file,
                        .line = extra.line,
                        .<span class="tok-type">type</span> = extra.ty,
                        .flags = <span class="tok-null">null</span>,
                        .@&quot;align&quot; = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .global_var,
                .@&quot;global_var local&quot;,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;distinct !&quot;, .DIGlobalVariable, .{
                        .name = extra.name,
                        .linkageName = extra.linkage_name,
                        .scope = extra.scope,
                        .file = extra.file,
                        .line = extra.line,
                        .<span class="tok-type">type</span> = extra.ty,
                        .isLocal = <span class="tok-kw">switch</span> (kind) {
                            .global_var =&gt; <span class="tok-null">false</span>,
                            .@&quot;global_var local&quot; =&gt; <span class="tok-null">true</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                        .isDefinition = <span class="tok-null">true</span>,
                        .declaration = <span class="tok-null">null</span>,
                        .templateParams = <span class="tok-null">null</span>,
                        .@&quot;align&quot; = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .global_var_expression =&gt; {
                    <span class="tok-kw">const</span> extra =
                        self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVarExpression.html">GlobalVarExpression</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIGlobalVariableExpression, .{
                        .@&quot;var&quot; = extra.variable,
                        .expr = extra.expression,
                    }, writer);
                },
            }
        }
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataString</span><a href="#src.zig-std.zig.llvm.Builder.metadataString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">try</span> self.metadata_string_bytes.ensureUnusedCapacity(self.gpa, bytes.len);
    <span class="tok-kw">try</span> self.metadata_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.metadata_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> gop = self.metadata_string_map.getOrPutAssumeCapacityAdapted(
        bytes,
        <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>.<a href="std.zig.llvm.Builder.MetadataString.Adapter.html">Adapter</a>{ .builder = self },
    );
    <span class="tok-kw">if</span> (!gop.found_existing) {
        self.metadata_string_bytes.appendSliceAssumeCapacity(bytes);
        self.metadata_string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.metadata_string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataStringFromStrtabString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataStringFromStrtabString</span><a href="#src.zig-std.zig.llvm.Builder.metadataStringFromStrtabString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFromStrtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, str: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>str: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataStringFromStrtabString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFromStrtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, str: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">if</span> (str == .none <span class="tok-kw">or</span> str == .empty) <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>.<a href="#">none</a>;
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.metadataString(str.slice(self).?);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataStringFmt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataStringFmt</span><a href="#src.zig-std.zig.llvm.Builder.metadataStringFmt">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataStringFmt">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">try</span> self.metadata_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.metadata_string_bytes.ensureUnusedCapacity(self.gpa, <span class="tok-builtin">@intCast</span>(<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(fmt_str, fmt_args)));
    <span class="tok-kw">try</span> self.metadata_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.metadataStringFmtAssumeCapacity(fmt_str, fmt_args);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataStringFmtAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataStringFmtAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.metadataStringFmtAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataStringFmtAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    self.metadata_string_bytes.writer(<span class="tok-null">undefined</span>).print(fmt_str, fmt_args) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> self.trailingMetadataStringAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.trailingMetadataString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trailingMetadataString</span><a href="#src.zig-std.zig.llvm.Builder.trailingMetadataString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingMetadataString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.trailingMetadataString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingMetadataString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">try</span> self.metadata_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.metadata_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.trailingMetadataStringAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.trailingMetadataStringAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">trailingMetadataStringAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.trailingMetadataStringAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingMetadataStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.trailingMetadataStringAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingMetadataStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">const</span> start = self.metadata_string_indices.getLast();
    <span class="tok-kw">const</span> bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = self.metadata_string_bytes.items[start..];
    <span class="tok-kw">const</span> gop = self.metadata_string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (gop.found_existing) {
        self.metadata_string_bytes.shrinkRetainingCapacity(start);
    } <span class="tok-kw">else</span> {
        self.metadata_string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.metadata_string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataNamed" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataNamed</span><a href="#src.zig-std.zig.llvm.Builder.metadataNamed">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataNamed</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, operands: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>operands: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataNamed">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataNamed</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, operands: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.metadata_extra.ensureUnusedCapacity(self.gpa, operands.len);
    <span class="tok-kw">try</span> self.metadata_named.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    self.metadataNamedAssumeCapacity(name, operands);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugFile" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugFile</span><a href="#src.zig-std.zig.llvm.Builder.debugFile">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugFile</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, filename: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, directory: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>filename: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>directory: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugFile">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugFile</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    filename: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    directory: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.File.html">File</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugFileAssumeCapacity(filename, directory);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugCompileUnit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugCompileUnit</span><a href="#src.zig-std.zig.llvm.Builder.debugCompileUnit">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugCompileUnit</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.Options.html">Options</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugCompileUnit">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugCompileUnit</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.Options.html">Options</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugCompileUnitAssumeCapacity(file, producer, enums, globals, options);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugSubprogram" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugSubprogram</span><a href="#src.zig-std.zig.llvm.Builder.debugSubprogram">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubprogram</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, line: <span class="tok-type">u32</span>, scope_line: <span class="tok-type">u32</span>, ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.Options.html">Options</a>, compile_unit: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>scope_line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.Options.html">Options</a></code></pre></div><div><pre><code>compile_unit: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugSubprogram">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubprogram</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    line: <span class="tok-type">u32</span>,
    scope_line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.Options.html">Options</a>,
    compile_unit: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugSubprogramAssumeCapacity(
        file,
        name,
        linkage_name,
        line,
        scope_line,
        ty,
        options,
        compile_unit,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugLexicalBlock" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugLexicalBlock</span><a href="#src.zig-std.zig.llvm.Builder.debugLexicalBlock">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLexicalBlock</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, column: <span class="tok-type">u32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>column: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugLexicalBlock">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLexicalBlock</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, column: <span class="tok-type">u32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LexicalBlock.html">LexicalBlock</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugLexicalBlockAssumeCapacity(scope, file, line, column);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugLocation" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugLocation</span><a href="#src.zig-std.zig.llvm.Builder.debugLocation">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLocation</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, line: <span class="tok-type">u32</span>, column: <span class="tok-type">u32</span>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, inlined_at: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>column: <span class="tok-type">u32</span></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>inlined_at: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugLocation">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLocation</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, line: <span class="tok-type">u32</span>, column: <span class="tok-type">u32</span>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, inlined_at: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Location.html">Location</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugLocationAssumeCapacity(line, column, scope, inlined_at);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugBoolType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugBoolType</span><a href="#src.zig-std.zig.llvm.Builder.debugBoolType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugBoolType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugBoolType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugBoolType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugBoolTypeAssumeCapacity(name, size_in_bits);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugUnsignedType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugUnsignedType</span><a href="#src.zig-std.zig.llvm.Builder.debugUnsignedType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugUnsignedType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugUnsignedType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugUnsignedType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugUnsignedTypeAssumeCapacity(name, size_in_bits);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugSignedType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugSignedType</span><a href="#src.zig-std.zig.llvm.Builder.debugSignedType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSignedType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugSignedType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSignedType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugSignedTypeAssumeCapacity(name, size_in_bits);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugFloatType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugFloatType</span><a href="#src.zig-std.zig.llvm.Builder.debugFloatType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugFloatType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugFloatType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugFloatType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugFloatTypeAssumeCapacity(name, size_in_bits);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugForwardReference" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugForwardReference</span><a href="#src.zig-std.zig.llvm.Builder.debugForwardReference">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugForwardReference</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugForwardReference">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugForwardReference</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.metadata_forward_references.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.debugForwardReferenceAssumeCapacity();
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugStructType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugStructType</span><a href="#src.zig-std.zig.llvm.Builder.debugStructType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugStructType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, size_in_bits: <span class="tok-type">u64</span>, align_in_bits: <span class="tok-type">u64</span>, fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>align_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugStructType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugStructType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugStructTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugUnionType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugUnionType</span><a href="#src.zig-std.zig.llvm.Builder.debugUnionType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugUnionType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, size_in_bits: <span class="tok-type">u64</span>, align_in_bits: <span class="tok-type">u64</span>, fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>align_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugUnionType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugUnionType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugUnionTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugEnumerationType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugEnumerationType</span><a href="#src.zig-std.zig.llvm.Builder.debugEnumerationType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugEnumerationType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, size_in_bits: <span class="tok-type">u64</span>, align_in_bits: <span class="tok-type">u64</span>, fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>align_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugEnumerationType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugEnumerationType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugEnumerationTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugArrayType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugArrayType</span><a href="#src.zig-std.zig.llvm.Builder.debugArrayType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugArrayType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, size_in_bits: <span class="tok-type">u64</span>, align_in_bits: <span class="tok-type">u64</span>, fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>align_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugArrayType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugArrayType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugArrayTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugVectorType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugVectorType</span><a href="#src.zig-std.zig.llvm.Builder.debugVectorType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugVectorType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, size_in_bits: <span class="tok-type">u64</span>, align_in_bits: <span class="tok-type">u64</span>, fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>align_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugVectorType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugVectorType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugVectorTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugPointerType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugPointerType</span><a href="#src.zig-std.zig.llvm.Builder.debugPointerType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugPointerType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, size_in_bits: <span class="tok-type">u64</span>, align_in_bits: <span class="tok-type">u64</span>, offset_in_bits: <span class="tok-type">u64</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>align_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>offset_in_bits: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugPointerType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugPointerType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    offset_in_bits: <span class="tok-type">u64</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugPointerTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        offset_in_bits,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugMemberType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugMemberType</span><a href="#src.zig-std.zig.llvm.Builder.debugMemberType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugMemberType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, size_in_bits: <span class="tok-type">u64</span>, align_in_bits: <span class="tok-type">u64</span>, offset_in_bits: <span class="tok-type">u64</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>size_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>align_in_bits: <span class="tok-type">u64</span></code></pre></div><div><pre><code>offset_in_bits: <span class="tok-type">u64</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugMemberType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugMemberType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    offset_in_bits: <span class="tok-type">u64</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugMemberTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        offset_in_bits,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugSubroutineType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugSubroutineType</span><a href="#src.zig-std.zig.llvm.Builder.debugSubroutineType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubroutineType</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, types_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>types_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugSubroutineType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubroutineType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    types_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.SubroutineType.html">SubroutineType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugSubroutineTypeAssumeCapacity(types_tuple);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugEnumerator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugEnumerator</span><a href="#src.zig-std.zig.llvm.Builder.debugEnumerator">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugEnumerator</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, unsigned: <span class="tok-type">bool</span>, bit_width: <span class="tok-type">u32</span>, value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>unsigned: <span class="tok-type">bool</span></code></pre></div><div><pre><code>bit_width: <span class="tok-type">u32</span></code></pre></div><div><pre><code>value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugEnumerator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugEnumerator</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    unsigned: <span class="tok-type">bool</span>,
    bit_width: <span class="tok-type">u32</span>,
    value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!(unsigned <span class="tok-kw">and</span> !value.positive));
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Enumerator.html">Enumerator</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.metadata_limbs.ensureUnusedCapacity(self.gpa, value.limbs.len);
    <span class="tok-kw">return</span> self.debugEnumeratorAssumeCapacity(name, unsigned, bit_width, value);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugSubrange" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugSubrange</span><a href="#src.zig-std.zig.llvm.Builder.debugSubrange">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubrange</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, lower_bound: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, count: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>lower_bound: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>count: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugSubrange">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubrange</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    lower_bound: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    count: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subrange.html">Subrange</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugSubrangeAssumeCapacity(lower_bound, count);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugExpression" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugExpression</span><a href="#src.zig-std.zig.llvm.Builder.debugExpression">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugExpression</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, elements: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>elements: []<span class="tok-kw">const</span> <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugExpression">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugExpression</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    elements: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Expression.html">Expression</a>, elements.len);
    <span class="tok-kw">return</span> self.debugExpressionAssumeCapacity(elements);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataTuple" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataTuple</span><a href="#src.zig-std.zig.llvm.Builder.metadataTuple">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataTuple</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataTuple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataTuple</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tuple.html">Tuple</a>, elements.len);
    <span class="tok-kw">return</span> self.metadataTupleAssumeCapacity(elements);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.strTuple" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">strTuple</span><a href="#src.zig-std.zig.llvm.Builder.strTuple">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strTuple</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, str: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>str: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.strTuple">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strTuple</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    str: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.StrTuple.html">StrTuple</a>, elements.len);
    <span class="tok-kw">return</span> self.strTupleAssumeCapacity(str, elements);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataModuleFlag" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataModuleFlag</span><a href="#src.zig-std.zig.llvm.Builder.metadataModuleFlag">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataModuleFlag</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, behavior: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, constant: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>behavior: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>constant: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataModuleFlag">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataModuleFlag</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    behavior: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    constant: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.ModuleFlag.html">ModuleFlag</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.metadataModuleFlagAssumeCapacity(behavior, name, constant);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugLocalVar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugLocalVar</span><a href="#src.zig-std.zig.llvm.Builder.debugLocalVar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLocalVar</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugLocalVar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLocalVar</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LocalVar.html">LocalVar</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugLocalVarAssumeCapacity(name, file, scope, line, ty);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugParameter" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugParameter</span><a href="#src.zig-std.zig.llvm.Builder.debugParameter">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugParameter</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, arg_no: <span class="tok-type">u32</span>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>arg_no: <span class="tok-type">u32</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugParameter">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugParameter</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    arg_no: <span class="tok-type">u32</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Parameter.html">Parameter</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugParameterAssumeCapacity(name, file, scope, line, ty, arg_no);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugGlobalVar" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugGlobalVar</span><a href="#src.zig-std.zig.llvm.Builder.debugGlobalVar">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugGlobalVar</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, variable: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.Options.html">Options</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>line: <span class="tok-type">u32</span></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>variable: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a></code></pre></div><div><pre><code>options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugGlobalVar">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugGlobalVar</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    variable: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.Options.html">Options</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugGlobalVarAssumeCapacity(
        name,
        linkage_name,
        file,
        scope,
        line,
        ty,
        variable,
        options,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugGlobalVarExpression" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugGlobalVarExpression</span><a href="#src.zig-std.zig.llvm.Builder.debugGlobalVarExpression">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugGlobalVarExpression</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, variable: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, expression: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>variable: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>expression: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugGlobalVarExpression">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugGlobalVarExpression</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    variable: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    expression: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVarExpression.html">GlobalVarExpression</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugGlobalVarExpressionAssumeCapacity(variable, expression);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataConstant" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataConstant</span><a href="#src.zig-std.zig.llvm.Builder.metadataConstant">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataConstant</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, value: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>value: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataConstant">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataConstant</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, value: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.metadataConstantAssumeCapacity(value);
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugForwardReferenceSetType" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugForwardReferenceSetType</span><a href="#src.zig-std.zig.llvm.Builder.debugForwardReferenceSetType">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugForwardReferenceSetType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, fwd_ref: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>fwd_ref: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugForwardReferenceSetType">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugForwardReferenceSetType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, fwd_ref: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(
        <span class="tok-builtin">@intFromEnum</span>(fwd_ref) &gt;= <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_forward_reference">first_forward_reference</a> <span class="tok-kw">and</span>
            <span class="tok-builtin">@intFromEnum</span>(fwd_ref) &lt;= <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a>,
    );
    <span class="tok-kw">const</span> index = <span class="tok-builtin">@intFromEnum</span>(fwd_ref) - <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_forward_reference">first_forward_reference</a>;
    self.metadata_forward_references.items[index] = ty;
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.metadataNoneAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">metadataNoneAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.metadataNoneAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataNoneAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.metadataNoneAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataNoneAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.none, .{});
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.debugCompileUnitAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">debugCompileUnitAssumeCapacity</span><a href="#src.zig-std.zig.llvm.Builder.debugCompileUnitAssumeCapacity">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugCompileUnitAssumeCapacity</span>( self: *<a href="std.zig.llvm.Builder.html">Builder</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.Options.html">Options</a>, ) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div><div><pre><code>enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div><div><pre><code>options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.Options.html">Options</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.debugCompileUnitAssumeCapacity">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugCompileUnitAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.Options.html">Options</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataDistinctAssumeCapacity(
        <span class="tok-kw">if</span> (options.optimized) .@&quot;compile_unit optimized&quot; <span class="tok-kw">else</span> .compile_unit,
        <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>{
            .file = file,
            .producer = producer,
            .enums = enums,
            .globals = globals,
        },
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.zig.llvm.Builder.toBitcode" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">toBitcode</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBitcode</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, producer: <a href="std.zig.llvm.Builder.Producer.html">Producer</a>) <a href="std.zig.llvm.bitcode_writer.html">bitcode_writer</a>.<a href="std.zig.llvm.bitcode_writer.html#std.zig.llvm.bitcode_writer.Error">Error</a>![]<span class="tok-kw">const</span> <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>self: *<a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>producer: <a href="std.zig.llvm.Builder.Producer.html">Producer</a></code></pre></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), param: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(param)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), param: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(param) {
    _ = field_name;
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(param)) {
        <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getConstantIndex(param)),
        <span class="tok-kw">else</span> =&gt; param,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.getConstantIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getConstantIndex</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.getConstantIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getConstantIndex</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>, constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a></code></pre></div><div><pre><code>constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.getConstantIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getConstantIndex</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>, constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (constant.unwrap()) {
        .constant =&gt; |c| c + adapter.numGlobals(),
        .global =&gt; |global| <span class="tok-builtin">@intCast</span>(adapter.globals.getIndex(global.unwrap(adapter.builder)).?),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.numConstants" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">numConstants</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.numConstants">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">numConstants</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.numConstants">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">numConstants</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.globals.count() + adapter.builder.constant_items.len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.numGlobals" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">numGlobals</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.numGlobals">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">numGlobals</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.numGlobals">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">numGlobals</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.globals.count());
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>( builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, const_adapter: ConstantAdapter, ) <span class="tok-builtin">@This</span>()</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a></code></pre></div><div><pre><code>const_adapter: ConstantAdapter</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(
    builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    const_adapter: ConstantAdapter,
) <span class="tok-builtin">@This</span>() {
    <span class="tok-kw">return</span> .{
        .builder = builder,
        .constant_adapter = const_adapter,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), value: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), value: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(value) {
    _ = field_name;
    <span class="tok-kw">const</span> Ty = <span class="tok-builtin">@TypeOf</span>(value);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (Ty) {
        <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getMetadataIndex(value)),
        <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getMetadataStringIndex(value)),
        <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.constant_adapter.getConstantIndex(value)),
        <span class="tok-kw">else</span> =&gt; value,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.getMetadataIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getMetadataIndex</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.getMetadataIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMetadataIndex</span>(adapter: <span class="tok-builtin">@This</span>(), metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.getMetadataIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMetadataIndex</span>(adapter: <span class="tok-builtin">@This</span>(), metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (metadata == .none) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.builder.metadata_string_map.count() +
        <span class="tok-builtin">@intFromEnum</span>(metadata.unwrap(adapter.builder)) - <span class="tok-number">1</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.getMetadataStringIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getMetadataStringIndex</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.getMetadataStringIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMetadataStringIndex</span>(_: <span class="tok-builtin">@This</span>(), metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>_: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.getMetadataStringIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMetadataStringIndex</span>(_: <span class="tok-builtin">@This</span>(), metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(metadata_string);
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), value: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), value: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(value) {
    _ = field_name;
    <span class="tok-kw">const</span> Ty = <span class="tok-builtin">@TypeOf</span>(value);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (Ty) {
        <a href="std.zig.llvm.Builder.Value.html">Value</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getOffsetValueIndex(value)),
        <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getOffsetConstantIndex(value)),
        <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">switch</span> (value) {
            .none =&gt; <span class="tok-number">0</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-number">1</span> + adapter.constant_adapter.builder.function_attributes_set.getIndex(value).?,
        }),
        <span class="tok-kw">else</span> =&gt; value,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.getValueIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getValueIndex</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.getValueIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getValueIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>value: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.getValueIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getValueIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-kw">switch</span> (value.unwrap()) {
        .instruction =&gt; |instruction| instruction.valueIndex(adapter.func) + adapter.firstInstr(),
        .constant =&gt; |constant| adapter.constant_adapter.getConstantIndex(constant),
        .metadata =&gt; |metadata| {
            <span class="tok-kw">const</span> real_metadata = metadata.unwrap(adapter.metadata_adapter.builder);
            <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(real_metadata) &lt; <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a>)
                <span class="tok-kw">return</span> adapter.metadata_adapter.getMetadataIndex(real_metadata) - <span class="tok-number">1</span>;

            <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(metadata) -
                <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a> +
                adapter.metadata_adapter.builder.metadata_string_map.count() - <span class="tok-number">1</span> +
                adapter.metadata_adapter.builder.metadata_map.count() - <span class="tok-number">1</span>);
        },
    });
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.getOffsetValueIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOffsetValueIndex</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.getOffsetValueIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetValueIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>value: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.getOffsetValueIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetValueIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> adapter.offset() -% adapter.getValueIndex(value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.getOffsetValueSignedIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOffsetValueSignedIndex</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.getOffsetValueSignedIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetValueSignedIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">i32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>value: <a href="std.zig.llvm.Builder.Value.html">Value</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.getOffsetValueSignedIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetValueSignedIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> signed_offset: <span class="tok-type">i32</span> = <span class="tok-builtin">@intCast</span>(adapter.offset());
    <span class="tok-kw">const</span> signed_value: <span class="tok-type">i32</span> = <span class="tok-builtin">@intCast</span>(adapter.getValueIndex(value));
    <span class="tok-kw">return</span> signed_offset - signed_value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.getOffsetConstantIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOffsetConstantIndex</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.getOffsetConstantIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetConstantIndex</span>(adapter: <span class="tok-builtin">@This</span>(), constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.getOffsetConstantIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetConstantIndex</span>(adapter: <span class="tok-builtin">@This</span>(), constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> adapter.offset() - adapter.constant_adapter.getConstantIndex(constant);
}</code></pre></details></div></div><div class="decl"><h3 id="std.zig.llvm.Builder.toBitcode.offset" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">offset</span><a href="#src.zig-std.zig.llvm.Builder.toBitcode.offset">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">offset</span>(adapter: <span class="tok-builtin">@This</span>()) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>adapter: <span class="tok-builtin">@This</span>()</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode.offset">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">offset</span>(adapter: <span class="tok-builtin">@This</span>()) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> adapter.instruction_index.valueIndex(adapter.func) + adapter.firstInstr();
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.zig.llvm.Builder.toBitcode">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBitcode</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, producer: <a href="std.zig.llvm.Builder.Producer.html">Producer</a>) <a href="std.zig.llvm.bitcode_writer.html">bitcode_writer</a>.<a href="std.zig.llvm.bitcode_writer.html#std.zig.llvm.bitcode_writer.Error">Error</a>![]<span class="tok-kw">const</span> <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> BitcodeWriter = <a href="std.zig.llvm.bitcode_writer.html">bitcode_writer</a>.<a href="std.zig.llvm.bitcode_writer.html#std.zig.llvm.bitcode_writer.BitcodeWriter">BitcodeWriter</a>(&amp;.{ <a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> });
    <span class="tok-kw">var</span> bitcode = BitcodeWriter.init(allocator, .{
        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, self.type_items.items.len),
        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> + self.function_attributes_set.count()),
    });
    <span class="tok-kw">errdefer</span> bitcode.deinit();<span class="tok-comment">

    // Write LLVM IR magic
    </span><span class="tok-kw">try</span> bitcode.writeBits(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.html#std.zig.llvm.ir.MAGIC">MAGIC</a>, <span class="tok-number">32</span>);

    <span class="tok-kw">var</span> record: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u64</span>) = .empty;
    <span class="tok-kw">defer</span> record.deinit(self.gpa);<span class="tok-comment">

    // IDENTIFICATION_BLOCK
    </span>{
        <span class="tok-kw">const</span> Identification = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Identification.html">Identification</a>;
        <span class="tok-kw">var</span> identification_block = <span class="tok-kw">try</span> bitcode.enterTopBlock(Identification);

        <span class="tok-kw">const</span> producer_str = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(self.gpa, <span class="tok-str">&quot;{s} {d}.{d}.{d}&quot;</span>, .{
            producer.name,
            producer.version.major,
            producer.version.minor,
            producer.version.patch,
        });
        <span class="tok-kw">defer</span> self.gpa.free(producer_str);

        <span class="tok-kw">try</span> identification_block.writeAbbrev(Identification.Version{ .string = producer_str });
        <span class="tok-kw">try</span> identification_block.writeAbbrev(Identification.Epoch{ .epoch = <span class="tok-number">0</span> });

        <span class="tok-kw">try</span> identification_block.end();
    }<span class="tok-comment">

    // MODULE_BLOCK
    </span>{
        <span class="tok-kw">const</span> Module = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Module.html">Module</a>;
        <span class="tok-kw">var</span> module_block = <span class="tok-kw">try</span> bitcode.enterTopBlock(Module);

        <span class="tok-kw">try</span> module_block.writeAbbrev(Module.Version{});

        <span class="tok-kw">if</span> (self.target_triple.slice(self)) |triple| {
            <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                .code = <span class="tok-number">2</span>,
                .string = triple,
            });
        }

        <span class="tok-kw">if</span> (self.data_layout.slice(self)) |data_layout| {
            <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                .code = <span class="tok-number">3</span>,
                .string = data_layout,
            });
        }

        <span class="tok-kw">if</span> (self.source_filename.slice(self)) |source_filename| {
            <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                .code = <span class="tok-number">16</span>,
                .string = source_filename,
            });
        }

        <span class="tok-kw">if</span> (self.module_asm.items.len != <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                .code = <span class="tok-number">4</span>,
                .string = self.module_asm.items,
            });
        }<span class="tok-comment">

        // TYPE_BLOCK
        </span>{
            <span class="tok-kw">var</span> type_block = <span class="tok-kw">try</span> module_block.enterSubBlock(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>, <span class="tok-null">true</span>);

            <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.NumEntry.html">NumEntry</a>{ .num = <span class="tok-builtin">@intCast</span>(self.type_items.items.len) });

            <span class="tok-kw">for</span> (self.type_items.items, <span class="tok-number">0</span>..) |item, i| {
                <span class="tok-kw">const</span> ty: <a href="std.zig.llvm.Builder.Type.html">Type</a> = <span class="tok-builtin">@enumFromInt</span>(i);

                <span class="tok-kw">switch</span> (item.tag) {
                    .simple =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Simple.html">Simple</a>{ .code = <span class="tok-builtin">@truncate</span>(item.data) }),
                    .integer =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Integer.html">Integer</a>{ .width = item.data }),
                    .structure,
                    .packed_structure,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> is_packed = <span class="tok-kw">switch</span> (kind) {
                            .structure =&gt; <span class="tok-null">false</span>,
                            .packed_structure =&gt; <span class="tok-null">true</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        };
                        <span class="tok-kw">var</span> extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, item.data);
                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.StructAnon.html">StructAnon</a>{
                            .is_packed = is_packed,
                            .types = extra.trail.next(extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self),
                        });
                    },
                    .named_structure =&gt; {
                        <span class="tok-kw">const</span> extra = self.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data);
                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.StructName.html">StructName</a>{
                            .string = extra.id.slice(self).?,
                        });

                        <span class="tok-kw">switch</span> (extra.body) {
                            .none =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Opaque.html">Opaque</a>{}),
                            <span class="tok-kw">else</span> =&gt; {
                                <span class="tok-kw">const</span> real_struct = self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(extra.body)];
                                <span class="tok-kw">const</span> is_packed: <span class="tok-type">bool</span> = <span class="tok-kw">switch</span> (real_struct.tag) {
                                    .structure =&gt; <span class="tok-null">false</span>,
                                    .packed_structure =&gt; <span class="tok-null">true</span>,
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                };

                                <span class="tok-kw">var</span> real_extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, real_struct.data);
                                <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.StructNamed.html">StructNamed</a>{
                                    .is_packed = is_packed,
                                    .types = real_extra.trail.next(real_extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self),
                                });
                            },
                        }
                    },
                    .array,
                    .small_array,
                    =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Array.html">Array</a>{
                        .len = ty.aggregateLen(self),
                        .child = ty.childType(self),
                    }),
                    .vector,
                    .scalable_vector,
                    =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Vector.html">Vector</a>{
                        .len = ty.aggregateLen(self),
                        .child = ty.childType(self),
                    }),
                    .pointer =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Pointer.html">Pointer</a>{
                        .addr_space = ty.pointerAddrSpace(self),
                    }),
                    .target =&gt; {
                        <span class="tok-kw">var</span> extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Target.html">Target</a>, item.data);
                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.StructName.html">StructName</a>{
                            .string = extra.data.name.slice(self).?,
                        });

                        <span class="tok-kw">const</span> types = extra.trail.next(extra.data.types_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self);
                        <span class="tok-kw">const</span> ints = extra.trail.next(extra.data.ints_len, <span class="tok-type">u32</span>, self);

                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Target.html">Target</a>{
                            .num_types = extra.data.types_len,
                            .types = types,
                            .ints = ints,
                        });
                    },
                    .function, .vararg_function =&gt; |kind| {
                        <span class="tok-kw">const</span> is_vararg = <span class="tok-kw">switch</span> (kind) {
                            .function =&gt; <span class="tok-null">false</span>,
                            .vararg_function =&gt; <span class="tok-null">true</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        };
                        <span class="tok-kw">var</span> extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, item.data);
                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Function.html">Function</a>{
                            .is_vararg = is_vararg,
                            .return_type = extra.data.ret,
                            .param_types = extra.trail.next(extra.data.params_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self),
                        });
                    },
                }
            }

            <span class="tok-kw">try</span> type_block.end();
        }

        <span class="tok-kw">var</span> attributes_set: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-kw">struct</span> {
            attributes: <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>,
            index: <span class="tok-type">u32</span>,
        }, <span class="tok-type">void</span>) = .{};
        <span class="tok-kw">defer</span> attributes_set.deinit(self.gpa);<span class="tok-comment">

        // PARAMATTR_GROUP_BLOCK
        </span>{
            <span class="tok-kw">const</span> ParamattrGroup = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.ParamattrGroup.html">ParamattrGroup</a>;

            <span class="tok-kw">var</span> paramattr_group_block = <span class="tok-kw">try</span> module_block.enterSubBlock(ParamattrGroup, <span class="tok-null">true</span>);

            <span class="tok-kw">for</span> (self.function_attributes_set.keys()) |func_attributes| {
                <span class="tok-kw">for</span> (func_attributes.slice(self), <span class="tok-number">0</span>..) |attributes, i| {
                    <span class="tok-kw">const</span> attributes_slice = attributes.slice(self);
                    <span class="tok-kw">if</span> (attributes_slice.len == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

                    <span class="tok-kw">const</span> attr_gop = <span class="tok-kw">try</span> attributes_set.getOrPut(self.gpa, .{
                        .attributes = attributes,
                        .index = <span class="tok-builtin">@intCast</span>(i),
                    });

                    <span class="tok-kw">if</span> (attr_gop.found_existing) <span class="tok-kw">continue</span>;

                    record.clearRetainingCapacity();
                    <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">2</span>);

                    record.appendAssumeCapacity(attr_gop.index);
                    record.appendAssumeCapacity(<span class="tok-kw">switch</span> (i) {
                        <span class="tok-number">0</span> =&gt; <span class="tok-number">0xffffffff</span>,
                        <span class="tok-kw">else</span> =&gt; i - <span class="tok-number">1</span>,
                    });

                    <span class="tok-kw">for</span> (attributes_slice) |attr_index| {
                        <span class="tok-kw">const</span> kind = attr_index.getKind(self);
                        <span class="tok-kw">switch</span> (attr_index.toAttribute(self)) {
                            .zeroext,
                            .signext,
                            .inreg,
                            .@&quot;noalias&quot;,
                            .nocapture,
                            .nofree,
                            .nest,
                            .returned,
                            .nonnull,
                            .swiftself,
                            .swiftasync,
                            .swifterror,
                            .immarg,
                            .noundef,
                            .allocalign,
                            .allocptr,
                            .readnone,
                            .readonly,
                            .writeonly,
                            .alwaysinline,
                            .builtin,
                            .cold,
                            .convergent,
                            .disable_sanitizer_information,
                            .fn_ret_thunk_extern,
                            .hot,
                            .inlinehint,
                            .jumptable,
                            .minsize,
                            .naked,
                            .nobuiltin,
                            .nocallback,
                            .noduplicate,
                            .noimplicitfloat,
                            .@&quot;noinline&quot;,
                            .nomerge,
                            .nonlazybind,
                            .noprofile,
                            .skipprofile,
                            .noredzone,
                            .<span class="tok-type">noreturn</span>,
                            .norecurse,
                            .willreturn,
                            .nosync,
                            .nounwind,
                            .nosanitize_bounds,
                            .nosanitize_coverage,
                            .null_pointer_is_valid,
                            .optforfuzzing,
                            .optnone,
                            .optsize,
                            .returns_twice,
                            .safestack,
                            .sanitize_address,
                            .sanitize_memory,
                            .sanitize_thread,
                            .sanitize_hwaddress,
                            .sanitize_memtag,
                            .speculative_load_hardening,
                            .speculatable,
                            .ssp,
                            .sspstrong,
                            .sspreq,
                            .strictfp,
                            .nocf_check,
                            .shadowcallstack,
                            .mustprogress,
                            .no_sanitize_address,
                            .no_sanitize_hwaddress,
                            .sanitize_address_dyninit,
                            =&gt; {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">2</span>);
                                record.appendAssumeCapacity(<span class="tok-number">0</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                            },
                            .byval,
                            .byref,
                            .preallocated,
                            .inalloca,
                            .sret,
                            .elementtype,
                            =&gt; |ty| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">6</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(ty));
                            },
                            .@&quot;align&quot;,
                            .alignstack,
                            =&gt; |alignment| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(alignment.toByteUnits() <span class="tok-kw">orelse</span> <span class="tok-number">0</span>);
                            },
                            .dereferenceable,
                            .dereferenceable_or_null,
                            =&gt; |size| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(size);
                            },
                            .nofpclass =&gt; |fpclass| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(fpclass)));
                            },
                            .allockind =&gt; |allockind| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(allockind)));
                            },

                            .allocsize =&gt; |allocsize| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@bitCast</span>(allocsize.toLlvm()));
                            },
                            .memory =&gt; |memory| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(memory)));
                            },
                            .uwtable =&gt; |uwtable| <span class="tok-kw">if</span> (uwtable != .none) {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(uwtable));
                            },
                            .vscale_range =&gt; |vscale_range| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@bitCast</span>(vscale_range.toLlvm()));
                            },
                            .string =&gt; |string_attr| {
                                <span class="tok-kw">const</span> string_attr_kind_slice = string_attr.kind.slice(self).?;
                                <span class="tok-kw">const</span> string_attr_value_slice = <span class="tok-kw">if</span> (string_attr.value != .none)
                                    string_attr.value.slice(self).?
                                <span class="tok-kw">else</span>
                                    <span class="tok-null">null</span>;

                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(
                                    self.gpa,
                                    <span class="tok-number">2</span> + string_attr_kind_slice.len + <span class="tok-kw">if</span> (string_attr_value_slice) |slice| slice.len + <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-number">0</span>,
                                );
                                record.appendAssumeCapacity(<span class="tok-kw">if</span> (string_attr.value == .none) <span class="tok-number">3</span> <span class="tok-kw">else</span> <span class="tok-number">4</span>);
                                <span class="tok-kw">for</span> (string_attr.kind.slice(self).?) |c| {
                                    record.appendAssumeCapacity(c);
                                }
                                record.appendAssumeCapacity(<span class="tok-number">0</span>);
                                <span class="tok-kw">if</span> (string_attr_value_slice) |slice| {
                                    <span class="tok-kw">for</span> (slice) |c| {
                                        record.appendAssumeCapacity(c);
                                    }
                                    record.appendAssumeCapacity(<span class="tok-number">0</span>);
                                }
                            },
                            .none =&gt; <span class="tok-kw">unreachable</span>,
                        }
                    }

                    <span class="tok-kw">try</span> paramattr_group_block.writeUnabbrev(<span class="tok-number">3</span>, record.items);
                }
            }

            <span class="tok-kw">try</span> paramattr_group_block.end();
        }<span class="tok-comment">

        // PARAMATTR_BLOCK
        </span>{
            <span class="tok-kw">const</span> Paramattr = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Paramattr.html">Paramattr</a>;
            <span class="tok-kw">var</span> paramattr_block = <span class="tok-kw">try</span> module_block.enterSubBlock(Paramattr, <span class="tok-null">true</span>);

            <span class="tok-kw">for</span> (self.function_attributes_set.keys()) |func_attributes| {
                <span class="tok-kw">const</span> func_attributes_slice = func_attributes.slice(self);
                record.clearRetainingCapacity();
                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, func_attributes_slice.len);
                <span class="tok-kw">for</span> (func_attributes_slice, <span class="tok-number">0</span>..) |attributes, i| {
                    <span class="tok-kw">const</span> attributes_slice = attributes.slice(self);
                    <span class="tok-kw">if</span> (attributes_slice.len == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

                    <span class="tok-kw">const</span> group_index = attributes_set.getIndex(.{
                        .attributes = attributes,
                        .index = <span class="tok-builtin">@intCast</span>(i),
                    }).?;
                    record.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(group_index));
                }

                <span class="tok-kw">try</span> paramattr_block.writeAbbrev(Paramattr.Entry{ .group_indices = record.items });
            }

            <span class="tok-kw">try</span> paramattr_block.end();
        }

        <span class="tok-kw">var</span> globals: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, <span class="tok-type">void</span>) = .empty;
        <span class="tok-kw">defer</span> globals.deinit(self.gpa);
        <span class="tok-kw">try</span> globals.ensureUnusedCapacity(
            self.gpa,
            self.variables.items.len +
                self.functions.items.len +
                self.aliases.items.len,
        );

        <span class="tok-kw">for</span> (self.variables.items) |variable| {
            <span class="tok-kw">if</span> (variable.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

            globals.putAssumeCapacity(variable.global, {});
        }

        <span class="tok-kw">for</span> (self.functions.items) |function| {
            <span class="tok-kw">if</span> (function.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

            globals.putAssumeCapacity(function.global, {});
        }

        <span class="tok-kw">for</span> (self.aliases.items) |alias| {
            <span class="tok-kw">if</span> (alias.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

            globals.putAssumeCapacity(alias.global, {});
        }

        <span class="tok-kw">const</span> ConstantAdapter = <span class="tok-kw">struct</span> {
            <span class="tok-kw">const</span> ConstantAdapter = <span class="tok-builtin">@This</span>();
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
            globals: *<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, <span class="tok-type">void</span>),

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), param: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(param) {
                _ = field_name;
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(param)) {
                    <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getConstantIndex(param)),
                    <span class="tok-kw">else</span> =&gt; param,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getConstantIndex</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>, constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (constant.unwrap()) {
                    .constant =&gt; |c| c + adapter.numGlobals(),
                    .global =&gt; |global| <span class="tok-builtin">@intCast</span>(adapter.globals.getIndex(global.unwrap(adapter.builder)).?),
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">numConstants</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.globals.count() + adapter.builder.constant_items.len);
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">numGlobals</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.globals.count());
            }
        };

        <span class="tok-kw">const</span> constant_adapter = ConstantAdapter{
            .builder = self,
            .globals = &amp;globals,
        };<span class="tok-comment">

        // Globals
        </span>{
            <span class="tok-kw">var</span> section_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <span class="tok-type">void</span>) = .empty;
            <span class="tok-kw">defer</span> section_map.deinit(self.gpa);
            <span class="tok-kw">try</span> section_map.ensureUnusedCapacity(self.gpa, globals.count());

            <span class="tok-kw">for</span> (self.variables.items) |variable| {
                <span class="tok-kw">if</span> (variable.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> section = blk: {
                    <span class="tok-kw">if</span> (variable.section == .none) <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
                    <span class="tok-kw">const</span> gop = section_map.getOrPutAssumeCapacity(variable.section);
                    <span class="tok-kw">if</span> (!gop.found_existing) {
                        <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                            .code = <span class="tok-number">5</span>,
                            .string = variable.section.slice(self).?,
                        });
                    }
                    <span class="tok-kw">break</span> :blk gop.index + <span class="tok-number">1</span>;
                };

                <span class="tok-kw">const</span> initid = <span class="tok-kw">if</span> (variable.init == .no_init)
                    <span class="tok-number">0</span>
                <span class="tok-kw">else</span>
                    (constant_adapter.getConstantIndex(variable.init) + <span class="tok-number">1</span>);

                <span class="tok-kw">const</span> strtab = variable.global.strtab(self);

                <span class="tok-kw">const</span> global = variable.global.ptrConst(self);
                <span class="tok-kw">try</span> module_block.writeAbbrev(Module.Variable{
                    .strtab_offset = strtab.offset,
                    .strtab_size = strtab.size,
                    .type_index = global.<span class="tok-type">type</span>,
                    .is_const = .{
                        .is_const = <span class="tok-kw">switch</span> (variable.mutability) {
                            .global =&gt; <span class="tok-null">false</span>,
                            .constant =&gt; <span class="tok-null">true</span>,
                        },
                        .addr_space = global.addr_space,
                    },
                    .initid = initid,
                    .linkage = global.linkage,
                    .alignment = variable.alignment.toLlvm(),
                    .section = section,
                    .visibility = global.visibility,
                    .thread_local = variable.thread_local,
                    .unnamed_addr = global.unnamed_addr,
                    .externally_initialized = global.externally_initialized,
                    .dllstorageclass = global.dll_storage_class,
                    .preemption = global.preemption,
                });
            }

            <span class="tok-kw">for</span> (self.functions.items) |func| {
                <span class="tok-kw">if</span> (func.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> section = blk: {
                    <span class="tok-kw">if</span> (func.section == .none) <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
                    <span class="tok-kw">const</span> gop = section_map.getOrPutAssumeCapacity(func.section);
                    <span class="tok-kw">if</span> (!gop.found_existing) {
                        <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                            .code = <span class="tok-number">5</span>,
                            .string = func.section.slice(self).?,
                        });
                    }
                    <span class="tok-kw">break</span> :blk gop.index + <span class="tok-number">1</span>;
                };

                <span class="tok-kw">const</span> paramattr_index = <span class="tok-kw">if</span> (self.function_attributes_set.getIndex(func.attributes)) |index|
                    index + <span class="tok-number">1</span>
                <span class="tok-kw">else</span>
                    <span class="tok-number">0</span>;

                <span class="tok-kw">const</span> strtab = func.global.strtab(self);

                <span class="tok-kw">const</span> global = func.global.ptrConst(self);
                <span class="tok-kw">try</span> module_block.writeAbbrev(Module.Function{
                    .strtab_offset = strtab.offset,
                    .strtab_size = strtab.size,
                    .type_index = global.<span class="tok-type">type</span>,
                    .call_conv = func.call_conv,
                    .is_proto = func.instructions.len == <span class="tok-number">0</span>,
                    .linkage = global.linkage,
                    .paramattr = paramattr_index,
                    .alignment = func.alignment.toLlvm(),
                    .section = section,
                    .visibility = global.visibility,
                    .unnamed_addr = global.unnamed_addr,
                    .dllstorageclass = global.dll_storage_class,
                    .preemption = global.preemption,
                    .addr_space = global.addr_space,
                });
            }

            <span class="tok-kw">for</span> (self.aliases.items) |alias| {
                <span class="tok-kw">if</span> (alias.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> strtab = alias.global.strtab(self);

                <span class="tok-kw">const</span> global = alias.global.ptrConst(self);
                <span class="tok-kw">try</span> module_block.writeAbbrev(Module.Alias{
                    .strtab_offset = strtab.offset,
                    .strtab_size = strtab.size,
                    .type_index = global.<span class="tok-type">type</span>,
                    .addr_space = global.addr_space,
                    .aliasee = constant_adapter.getConstantIndex(alias.aliasee),
                    .linkage = global.linkage,
                    .visibility = global.visibility,
                    .thread_local = alias.thread_local,
                    .unnamed_addr = global.unnamed_addr,
                    .dllstorageclass = global.dll_storage_class,
                    .preemption = global.preemption,
                });
            }
        }<span class="tok-comment">

        // CONSTANTS_BLOCK
        </span>{
            <span class="tok-kw">const</span> Constants = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Constants.html">Constants</a>;
            <span class="tok-kw">var</span> constants_block = <span class="tok-kw">try</span> module_block.enterSubBlock(Constants, <span class="tok-null">true</span>);

            <span class="tok-kw">var</span> current_type: <a href="std.zig.llvm.Builder.Type.html">Type</a> = .none;
            <span class="tok-kw">const</span> tags = self.constant_items.items(.tag);
            <span class="tok-kw">const</span> datas = self.constant_items.items(.data);
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.constant_items.len) |index| {
                record.clearRetainingCapacity();
                <span class="tok-kw">const</span> constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> = <span class="tok-builtin">@enumFromInt</span>(index);
                <span class="tok-kw">const</span> constant_type = constant.typeOf(self);
                <span class="tok-kw">if</span> (constant_type != current_type) {
                    <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.SetType{ .type_id = constant_type });
                    current_type = constant_type;
                }
                <span class="tok-kw">const</span> data = datas[index];
                <span class="tok-kw">switch</span> (tags[index]) {
                    .<span class="tok-null">null</span>,
                    .zeroinitializer,
                    .none,
                    =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Null{}),
                    .undef =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Undef{}),
                    .poison =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Poison{}),
                    .positive_integer,
                    .negative_integer,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra: *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a> =
                            <span class="tok-builtin">@ptrCast</span>(self.constant_limbs.items[data..][<span class="tok-number">0</span>..<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a>]);
                        <span class="tok-kw">const</span> bigint: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a> = .{
                            .limbs = self.constant_limbs
                                .items[data + <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> ..][<span class="tok-number">0</span>..extra.limbs_len],
                            .positive = <span class="tok-kw">switch</span> (tag) {
                                .positive_integer =&gt; <span class="tok-null">true</span>,
                                .negative_integer =&gt; <span class="tok-null">false</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> bit_count = extra.<span class="tok-type">type</span>.scalarBits(self);
                        <span class="tok-kw">const</span> val: <span class="tok-type">i64</span> = <span class="tok-kw">if</span> (bit_count &lt;= <span class="tok-number">64</span>)
                            bigint.toInt(<span class="tok-type">i64</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>
                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (bigint.toInt(<span class="tok-type">u64</span>)) |val|
                            <span class="tok-builtin">@bitCast</span>(val)
                        <span class="tok-kw">else</span> |_| {
                            <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> record.addManyAsSlice(
                                self.gpa,
                                <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">u24</span>, bit_count, <span class="tok-number">64</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
                            );
                            bigint.writeTwosComplement(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(limbs), .little);
                            <span class="tok-kw">for</span> (limbs) |*limb| {
                                <span class="tok-kw">const</span> val = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(<span class="tok-type">i64</span>, <span class="tok-builtin">@bitCast</span>(limb.*));
                                limb.* = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (val &gt;= <span class="tok-number">0</span>)
                                    val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">0</span>
                                <span class="tok-kw">else</span>
                                    -%val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">1</span>);
                            }
                            <span class="tok-kw">try</span> constants_block.writeUnabbrev(<span class="tok-number">5</span>, record.items);
                            <span class="tok-kw">continue</span>;
                        };
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Integer{
                            .value = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (val &gt;= <span class="tok-number">0</span>)
                                val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">0</span>
                            <span class="tok-kw">else</span>
                                -%val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">1</span>),
                        });
                    },
                    .half,
                    .bfloat,
                    =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Half{ .value = <span class="tok-builtin">@truncate</span>(data) }),
                    .float =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Float{ .value = data }),
                    .double =&gt; {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Double.html">Double</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Double{
                            .value = (<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.hi) &lt;&lt; <span class="tok-number">32</span>) | extra.lo,
                        });
                    },
                    .x86_fp80 =&gt; {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp80.html">Fp80</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Fp80{
                            .hi = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.hi) &lt;&lt; <span class="tok-number">48</span> | <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.lo_hi) &lt;&lt; <span class="tok-number">16</span> |
                                extra.lo_lo &gt;&gt; <span class="tok-number">16</span>,
                            .lo = <span class="tok-builtin">@truncate</span>(extra.lo_lo),
                        });
                    },
                    .fp128,
                    .ppc_fp128,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Fp128{
                            .lo = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.lo_hi) &lt;&lt; <span class="tok-number">32</span> | <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.lo_lo),
                            .hi = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.hi_hi) &lt;&lt; <span class="tok-number">32</span> | <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.hi_lo),
                        });
                    },
                    .array,
                    .vector,
                    .structure,
                    .packed_structure,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = self.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, data);
                        <span class="tok-kw">const</span> len: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(extra.data.<span class="tok-type">type</span>.aggregateLen(self));
                        <span class="tok-kw">const</span> values = extra.trail.next(len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, self);

                        <span class="tok-kw">try</span> constants_block.writeAbbrevAdapted(
                            Constants.Aggregate{ .values = values },
                            constant_adapter,
                        );
                    },
                    .splat =&gt; {
                        <span class="tok-kw">const</span> ConstantsWriter = <span class="tok-builtin">@TypeOf</span>(constants_block);
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>, data);
                        <span class="tok-kw">const</span> vector_len = extra.<span class="tok-type">type</span>.vectorLen(self);
                        <span class="tok-kw">const</span> c = constant_adapter.getConstantIndex(extra.value);

                        <span class="tok-kw">try</span> bitcode.writeBits(
                            ConstantsWriter.abbrevId(Constants.Aggregate),
                            ConstantsWriter.abbrev_len,
                        );
                        <span class="tok-kw">try</span> bitcode.writeVBR(vector_len, <span class="tok-number">6</span>);
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..vector_len) |_| {
                            <span class="tok-kw">try</span> bitcode.writeBits(c, Constants.Aggregate.ops[<span class="tok-number">1</span>].array_fixed);
                        }
                    },
                    .string =&gt; {
                        <span class="tok-kw">const</span> str: <a href="std.zig.llvm.Builder.String.html">String</a> = <span class="tok-builtin">@enumFromInt</span>(data);
                        <span class="tok-kw">if</span> (str == .none) {
                            <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Null{});
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">const</span> slice = str.slice(self).?;
                            <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> slice[slice.len - <span class="tok-number">1</span>] == <span class="tok-number">0</span>)
                                <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.CString{ .string = slice[<span class="tok-number">0</span> .. slice.len - <span class="tok-number">1</span>] })
                            <span class="tok-kw">else</span>
                                <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.String{ .string = slice });
                        }
                    },
                    .bitcast,
                    .inttoptr,
                    .ptrtoint,
                    .addrspacecast,
                    .trunc,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrevAdapted(Constants.Cast{
                            .type_index = extra.<span class="tok-type">type</span>,
                            .val = extra.val,
                            .opcode = tag.toCastOpcode(),
                        }, constant_adapter);
                    },
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .shl,
                    .xor,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrevAdapted(Constants.Binary{
                            .opcode = tag.toBinaryOpcode(),
                            .lhs = extra.lhs,
                            .rhs = extra.rhs,
                        }, constant_adapter);
                    },
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = self.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>, data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.info.indices_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, self);
                        <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span> + <span class="tok-number">2</span> + <span class="tok-number">2</span> * indices.len);

                        record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.<span class="tok-type">type</span>));

                        record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.base.typeOf(self)));
                        record.appendAssumeCapacity(constant_adapter.getConstantIndex(extra.data.base));

                        <span class="tok-kw">for</span> (indices) |i| {
                            record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(i.typeOf(self)));
                            record.appendAssumeCapacity(constant_adapter.getConstantIndex(i));
                        }

                        <span class="tok-kw">try</span> constants_block.writeUnabbrev(<span class="tok-kw">switch</span> (tag) {
                            .getelementptr =&gt; <span class="tok-number">12</span>,
                            .@&quot;getelementptr inbounds&quot; =&gt; <span class="tok-number">20</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }, record.items);
                    },
                    .@&quot;asm&quot;,
                    .@&quot;asm sideeffect&quot;,
                    .@&quot;asm alignstack&quot;,
                    .@&quot;asm sideeffect alignstack&quot;,
                    .@&quot;asm inteldialect&quot;,
                    .@&quot;asm sideeffect inteldialect&quot;,
                    .@&quot;asm alignstack inteldialect&quot;,
                    .@&quot;asm sideeffect alignstack inteldialect&quot;,
                    .@&quot;asm unwind&quot;,
                    .@&quot;asm sideeffect unwind&quot;,
                    .@&quot;asm alignstack unwind&quot;,
                    .@&quot;asm sideeffect alignstack unwind&quot;,
                    .@&quot;asm inteldialect unwind&quot;,
                    .@&quot;asm sideeffect inteldialect unwind&quot;,
                    .@&quot;asm alignstack inteldialect unwind&quot;,
                    .@&quot;asm sideeffect alignstack inteldialect unwind&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>, data);

                        <span class="tok-kw">const</span> assembly_slice = extra.assembly.slice(self).?;
                        <span class="tok-kw">const</span> constraints_slice = extra.constraints.slice(self).?;

                        <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">4</span> + assembly_slice.len + constraints_slice.len);

                        record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.<span class="tok-type">type</span>));
                        record.appendAssumeCapacity(<span class="tok-kw">switch</span> (tag) {
                            .@&quot;asm&quot; =&gt; <span class="tok-number">0</span>,
                            .@&quot;asm sideeffect&quot; =&gt; <span class="tok-number">0b0001</span>,
                            .@&quot;asm sideeffect alignstack&quot; =&gt; <span class="tok-number">0b0011</span>,
                            .@&quot;asm sideeffect inteldialect&quot; =&gt; <span class="tok-number">0b0101</span>,
                            .@&quot;asm sideeffect alignstack inteldialect&quot; =&gt; <span class="tok-number">0b0111</span>,
                            .@&quot;asm sideeffect unwind&quot; =&gt; <span class="tok-number">0b1001</span>,
                            .@&quot;asm sideeffect alignstack unwind&quot; =&gt; <span class="tok-number">0b1011</span>,
                            .@&quot;asm sideeffect inteldialect unwind&quot; =&gt; <span class="tok-number">0b1101</span>,
                            .@&quot;asm sideeffect alignstack inteldialect unwind&quot; =&gt; <span class="tok-number">0b1111</span>,
                            .@&quot;asm alignstack&quot; =&gt; <span class="tok-number">0b0010</span>,
                            .@&quot;asm inteldialect&quot; =&gt; <span class="tok-number">0b0100</span>,
                            .@&quot;asm alignstack inteldialect&quot; =&gt; <span class="tok-number">0b0110</span>,
                            .@&quot;asm unwind&quot; =&gt; <span class="tok-number">0b1000</span>,
                            .@&quot;asm alignstack unwind&quot; =&gt; <span class="tok-number">0b1010</span>,
                            .@&quot;asm inteldialect unwind&quot; =&gt; <span class="tok-number">0b1100</span>,
                            .@&quot;asm alignstack inteldialect unwind&quot; =&gt; <span class="tok-number">0b1110</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        });

                        record.appendAssumeCapacity(assembly_slice.len);
                        <span class="tok-kw">for</span> (assembly_slice) |c| record.appendAssumeCapacity(c);

                        record.appendAssumeCapacity(constraints_slice.len);
                        <span class="tok-kw">for</span> (constraints_slice) |c| record.appendAssumeCapacity(c);

                        <span class="tok-kw">try</span> constants_block.writeUnabbrev(<span class="tok-number">30</span>, record.items);
                    },
                    .blockaddress =&gt; {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.BlockAddress{
                            .type_id = extra.function.typeOf(self),
                            .function = constant_adapter.getConstantIndex(extra.function.toConst(self)),
                            .block = <span class="tok-builtin">@intFromEnum</span>(extra.block),
                        });
                    },
                    .dso_local_equivalent,
                    .no_cfi,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.DsoLocalEquivalentOrNoCfi{
                            .code = <span class="tok-kw">switch</span> (tag) {
                                .dso_local_equivalent =&gt; <span class="tok-number">27</span>,
                                .no_cfi =&gt; <span class="tok-number">29</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .type_id = function.typeOf(self),
                            .function = constant_adapter.getConstantIndex(function.toConst(self)),
                        });
                    },
                }
            }

            <span class="tok-kw">try</span> constants_block.end();
        }<span class="tok-comment">

        // METADATA_KIND_BLOCK
        </span>{
            <span class="tok-kw">const</span> MetadataKindBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataKindBlock.html">MetadataKindBlock</a>;
            <span class="tok-kw">var</span> metadata_kind_block = <span class="tok-kw">try</span> module_block.enterSubBlock(MetadataKindBlock, <span class="tok-null">true</span>);

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FixedMetadataKind.html">FixedMetadataKind</a>).@&quot;enum&quot;.fields) |field| {<span class="tok-comment">
                // don't include `dbg` in stripped functions
                </span><span class="tok-kw">if</span> (!(self.strip <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field.name, <span class="tok-str">&quot;dbg&quot;</span>))) {
                    <span class="tok-kw">try</span> metadata_kind_block.writeAbbrev(MetadataKindBlock.Kind{
                        .id = field.value,
                        .name = field.name,
                    });
                }
            }

            <span class="tok-kw">try</span> metadata_kind_block.end();
        }

        <span class="tok-kw">const</span> MetadataAdapter = <span class="tok-kw">struct</span> {
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
            constant_adapter: ConstantAdapter,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(
                builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
                const_adapter: ConstantAdapter,
            ) <span class="tok-builtin">@This</span>() {
                <span class="tok-kw">return</span> .{
                    .builder = builder,
                    .constant_adapter = const_adapter,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), value: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(value) {
                _ = field_name;
                <span class="tok-kw">const</span> Ty = <span class="tok-builtin">@TypeOf</span>(value);
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (Ty) {
                    <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getMetadataIndex(value)),
                    <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getMetadataStringIndex(value)),
                    <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.constant_adapter.getConstantIndex(value)),
                    <span class="tok-kw">else</span> =&gt; value,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMetadataIndex</span>(adapter: <span class="tok-builtin">@This</span>(), metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">if</span> (metadata == .none) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.builder.metadata_string_map.count() +
                    <span class="tok-builtin">@intFromEnum</span>(metadata.unwrap(adapter.builder)) - <span class="tok-number">1</span>);
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMetadataStringIndex</span>(_: <span class="tok-builtin">@This</span>(), metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(metadata_string);
            }
        };

        <span class="tok-kw">const</span> metadata_adapter = MetadataAdapter.init(self, constant_adapter);<span class="tok-comment">

        // METADATA_BLOCK
        </span>{
            <span class="tok-kw">const</span> MetadataBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataBlock.html">MetadataBlock</a>;
            <span class="tok-kw">var</span> metadata_block = <span class="tok-kw">try</span> module_block.enterSubBlock(MetadataBlock, <span class="tok-null">true</span>);

            <span class="tok-kw">const</span> MetadataBlockWriter = <span class="tok-builtin">@TypeOf</span>(metadata_block);<span class="tok-comment">

            // Emit all MetadataStrings
            </span><span class="tok-kw">if</span> (self.metadata_string_map.count() &gt; <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> strings_offset, <span class="tok-kw">const</span> strings_size = blk: {
                    <span class="tok-kw">var</span> strings_offset: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">var</span> strings_size: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">for</span> (<span class="tok-number">1</span>..self.metadata_string_map.count()) |metadata_string_index| {
                        <span class="tok-kw">const</span> metadata_string: MetadataString = <span class="tok-builtin">@enumFromInt</span>(metadata_string_index);
                        <span class="tok-kw">const</span> slice = metadata_string.slice(self);
                        strings_offset += bitcode.bitsVBR(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)), <span class="tok-number">6</span>);
                        strings_size += <span class="tok-builtin">@intCast</span>(slice.len * <span class="tok-number">8</span>);
                    }
                    <span class="tok-kw">break</span> :blk .{
                        std.mem.alignForward(<span class="tok-type">u32</span>, strings_offset, <span class="tok-number">32</span>) / <span class="tok-number">8</span>,
                        std.mem.alignForward(<span class="tok-type">u32</span>, strings_size, <span class="tok-number">32</span>) / <span class="tok-number">8</span>,
                    };
                };

                <span class="tok-kw">try</span> bitcode.writeBits(
                    <span class="tok-kw">comptime</span> MetadataBlockWriter.abbrevId(MetadataBlock.Strings),
                    MetadataBlockWriter.abbrev_len,
                );

                <span class="tok-kw">try</span> bitcode.writeVBR(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(self.metadata_string_map.count() - <span class="tok-number">1</span>)), <span class="tok-number">6</span>);
                <span class="tok-kw">try</span> bitcode.writeVBR(strings_offset, <span class="tok-number">6</span>);

                <span class="tok-kw">try</span> bitcode.writeVBR(strings_size + strings_offset, <span class="tok-number">6</span>);

                <span class="tok-kw">try</span> bitcode.alignTo32();

                <span class="tok-kw">for</span> (<span class="tok-number">1</span>..self.metadata_string_map.count()) |metadata_string_index| {
                    <span class="tok-kw">const</span> metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> = <span class="tok-builtin">@enumFromInt</span>(metadata_string_index);
                    <span class="tok-kw">const</span> slice = metadata_string.slice(self);
                    <span class="tok-kw">try</span> bitcode.writeVBR(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)), <span class="tok-number">6</span>);
                }

                <span class="tok-kw">try</span> bitcode.writeBlob(self.metadata_string_bytes.items);
            }

            <span class="tok-kw">for</span> (
                self.metadata_items.items(.tag)[<span class="tok-number">1</span>..],
                self.metadata_items.items(.data)[<span class="tok-number">1</span>..],
            ) |tag, data| {
                record.clearRetainingCapacity();
                <span class="tok-kw">switch</span> (tag) {
                    .none =&gt; <span class="tok-kw">unreachable</span>,
                    .file =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.File.html">File</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.File{
                            .filename = extra.filename,
                            .directory = extra.directory,
                        }, metadata_adapter);
                    },
                    .compile_unit,
                    .@&quot;compile_unit optimized&quot;,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.CompileUnit{
                            .file = extra.file,
                            .producer = extra.producer,
                            .is_optimized = <span class="tok-kw">switch</span> (kind) {
                                .compile_unit =&gt; <span class="tok-null">false</span>,
                                .@&quot;compile_unit optimized&quot; =&gt; <span class="tok-null">true</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .enums = extra.enums,
                            .globals = extra.globals,
                        }, metadata_adapter);
                    },
                    .subprogram,
                    .@&quot;subprogram local&quot;,
                    .@&quot;subprogram definition&quot;,
                    .@&quot;subprogram local definition&quot;,
                    .@&quot;subprogram optimized&quot;,
                    .@&quot;subprogram optimized local&quot;,
                    .@&quot;subprogram optimized definition&quot;,
                    .@&quot;subprogram optimized local definition&quot;,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Subprogram{
                            .scope = extra.file,
                            .name = extra.name,
                            .linkage_name = extra.linkage_name,
                            .file = extra.file,
                            .line = extra.line,
                            .ty = extra.ty,
                            .scope_line = extra.scope_line,
                            .sp_flags = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(
                                <span class="tok-builtin">@intFromEnum</span>(kind) - <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">subprogram</a>),
                            ))) &lt;&lt; <span class="tok-number">2</span>),
                            .flags = extra.di_flags,
                            .compile_unit = extra.compile_unit,
                        }, metadata_adapter);
                    },
                    .lexical_block =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LexicalBlock.html">LexicalBlock</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.LexicalBlock{
                            .scope = extra.scope,
                            .file = extra.file,
                            .line = extra.line,
                            .column = extra.column,
                        }, metadata_adapter);
                    },
                    .location =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Location.html">Location</a>, data);
                        <a href="std.debug.html#std.debug.assert">assert</a>(extra.scope != .none);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Location{
                            .line = extra.line,
                            .column = extra.column,
                            .scope = metadata_adapter.getMetadataIndex(extra.scope) - <span class="tok-number">1</span>,
                            .inlined_at = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(extra.inlined_at)),
                        });
                    },
                    .basic_bool_type,
                    .basic_unsigned_type,
                    .basic_signed_type,
                    .basic_float_type,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.BasicType{
                            .name = extra.name,
                            .size_in_bits = extra.bitSize(),
                            .encoding = <span class="tok-kw">switch</span> (kind) {
                                .basic_bool_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.ATE.html">ATE</a>.<a href="std.dwarf.ATE.html#std.dwarf.ATE.boolean">boolean</a>,
                                .basic_unsigned_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.ATE.html">ATE</a>.<a href="std.dwarf.ATE.html#std.dwarf.ATE.unsigned">unsigned</a>,
                                .basic_signed_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.ATE.html">ATE</a>.<a href="std.dwarf.ATE.html#std.dwarf.ATE.signed">signed</a>,
                                .basic_float_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.ATE.html">ATE</a>.<a href="std.dwarf.ATE.html#std.dwarf.ATE.float">float</a>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        }, metadata_adapter);
                    },
                    .composite_struct_type,
                    .composite_union_type,
                    .composite_enumeration_type,
                    .composite_array_type,
                    .composite_vector_type,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.CompositeType{
                            .tag = <span class="tok-kw">switch</span> (kind) {
                                .composite_struct_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.structure_type">structure_type</a>,
                                .composite_union_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.union_type">union_type</a>,
                                .composite_enumeration_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.enumeration_type">enumeration_type</a>,
                                .composite_array_type, .composite_vector_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.array_type">array_type</a>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .name = extra.name,
                            .file = extra.file,
                            .line = extra.line,
                            .scope = extra.scope,
                            .underlying_type = extra.underlying_type,
                            .size_in_bits = extra.bitSize(),
                            .align_in_bits = extra.bitAlign(),
                            .flags = <span class="tok-kw">if</span> (kind == .composite_vector_type) .{ .Vector = <span class="tok-null">true</span> } <span class="tok-kw">else</span> .{},
                            .elements = extra.fields_tuple,
                        }, metadata_adapter);
                    },
                    .derived_pointer_type,
                    .derived_member_type,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.DerivedType{
                            .tag = <span class="tok-kw">switch</span> (kind) {
                                .derived_pointer_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.pointer_type">pointer_type</a>,
                                .derived_member_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.member">member</a>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .name = extra.name,
                            .file = extra.file,
                            .line = extra.line,
                            .scope = extra.scope,
                            .underlying_type = extra.underlying_type,
                            .size_in_bits = extra.bitSize(),
                            .align_in_bits = extra.bitAlign(),
                            .offset_in_bits = extra.bitOffset(),
                        }, metadata_adapter);
                    },
                    .subroutine_type =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.SubroutineType.html">SubroutineType</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.SubroutineType{
                            .types = extra.types_tuple,
                        }, metadata_adapter);
                    },
                    .enumerator_unsigned,
                    .enumerator_signed_positive,
                    .enumerator_signed_negative,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Enumerator.html">Enumerator</a>, data);
                        <span class="tok-kw">const</span> bigint: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a> = .{
                            .limbs = self.metadata_limbs.items[extra.limbs_index..][<span class="tok-number">0</span>..extra.limbs_len],
                            .positive = <span class="tok-kw">switch</span> (kind) {
                                .enumerator_unsigned,
                                .enumerator_signed_positive,
                                =&gt; <span class="tok-null">true</span>,
                                .enumerator_signed_negative =&gt; <span class="tok-null">false</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> flags: MetadataBlock.Enumerator.Flags = .{
                            .unsigned = <span class="tok-kw">switch</span> (kind) {
                                .enumerator_unsigned =&gt; <span class="tok-null">true</span>,
                                .enumerator_signed_positive,
                                .enumerator_signed_negative,
                                =&gt; <span class="tok-null">false</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> val: <span class="tok-type">i64</span> = <span class="tok-kw">if</span> (bigint.toInt(<span class="tok-type">i64</span>)) |val|
                            val
                        <span class="tok-kw">else</span> |_| <span class="tok-kw">if</span> (bigint.toInt(<span class="tok-type">u64</span>)) |val|
                            <span class="tok-builtin">@bitCast</span>(val)
                        <span class="tok-kw">else</span> |_| {
                            <span class="tok-kw">const</span> limbs_len = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">u32</span>, extra.bit_width, <span class="tok-number">64</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                            <span class="tok-kw">try</span> record.ensureTotalCapacity(self.gpa, <span class="tok-number">3</span> + limbs_len);
                            record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(
                                <span class="tok-builtin">@typeInfo</span>(MetadataBlock.Enumerator.Flags).@&quot;struct&quot;.backing_integer.?,
                                <span class="tok-builtin">@bitCast</span>(flags),
                            ));
                            record.appendAssumeCapacity(extra.bit_width);
                            record.appendAssumeCapacity(metadata_adapter.getMetadataStringIndex(extra.name));
                            <span class="tok-kw">const</span> limbs = record.addManyAsSliceAssumeCapacity(limbs_len);
                            bigint.writeTwosComplement(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(limbs), .little);
                            <span class="tok-kw">for</span> (limbs) |*limb| {
                                <span class="tok-kw">const</span> val = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(<span class="tok-type">i64</span>, <span class="tok-builtin">@bitCast</span>(limb.*));
                                limb.* = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (val &gt;= <span class="tok-number">0</span>)
                                    val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">0</span>
                                <span class="tok-kw">else</span>
                                    -%val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">1</span>);
                            }
                            <span class="tok-kw">try</span> metadata_block.writeUnabbrev(<span class="tok-builtin">@intFromEnum</span>(MetadataBlock.Enumerator.id), record.items);
                            <span class="tok-kw">continue</span>;
                        };
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Enumerator{
                            .flags = flags,
                            .bit_width = extra.bit_width,
                            .name = extra.name,
                            .value = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (val &gt;= <span class="tok-number">0</span>)
                                val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">0</span>
                            <span class="tok-kw">else</span>
                                -%val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">1</span>),
                        }, metadata_adapter);
                    },
                    .subrange =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subrange.html">Subrange</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Subrange{
                            .count = extra.count,
                            .lower_bound = extra.lower_bound,
                        }, metadata_adapter);
                    },
                    .expression =&gt; {
                        <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Expression.html">Expression</a>, data);

                        <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <span class="tok-type">u32</span>, self);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Expression{
                            .elements = elements,
                        }, metadata_adapter);
                    },
                    .tuple =&gt; {
                        <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tuple.html">Tuple</a>, data);

                        <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, self);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Node{
                            .elements = elements,
                        }, metadata_adapter);
                    },
                    .str_tuple =&gt; {
                        <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.StrTuple.html">StrTuple</a>, data);

                        <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, self);

                        <span class="tok-kw">const</span> all_elems = <span class="tok-kw">try</span> self.gpa.alloc(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, elements.len + <span class="tok-number">1</span>);
                        <span class="tok-kw">defer</span> self.gpa.free(all_elems);
                        all_elems[<span class="tok-number">0</span>] = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataStringIndex(extra.data.str));
                        <span class="tok-kw">for</span> (elements, all_elems[<span class="tok-number">1</span>..]) |elem, *out_elem| {
                            out_elem.* = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(elem));
                        }

                        <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Node{
                            .elements = all_elems,
                        });
                    },
                    .module_flag =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.ModuleFlag.html">ModuleFlag</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Node{
                            .elements = &amp;.{
                                <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(extra.behavior)),
                                <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataStringIndex(extra.name)),
                                <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(extra.constant)),
                            },
                        });
                    },
                    .local_var =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LocalVar.html">LocalVar</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.LocalVar{
                            .scope = extra.scope,
                            .name = extra.name,
                            .file = extra.file,
                            .line = extra.line,
                            .ty = extra.ty,
                        }, metadata_adapter);
                    },
                    .parameter =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Parameter.html">Parameter</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Parameter{
                            .scope = extra.scope,
                            .name = extra.name,
                            .file = extra.file,
                            .line = extra.line,
                            .ty = extra.ty,
                            .arg = extra.arg_no,
                        }, metadata_adapter);
                    },
                    .global_var,
                    .@&quot;global_var local&quot;,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.GlobalVar{
                            .scope = extra.scope,
                            .name = extra.name,
                            .linkage_name = extra.linkage_name,
                            .file = extra.file,
                            .line = extra.line,
                            .ty = extra.ty,
                            .local = kind == .@&quot;global_var local&quot;,
                        }, metadata_adapter);
                    },
                    .global_var_expression =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVarExpression.html">GlobalVarExpression</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.GlobalVarExpression{
                            .variable = extra.variable,
                            .expression = extra.expression,
                        }, metadata_adapter);
                    },
                    .constant =&gt; {
                        <span class="tok-kw">const</span> constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> = <span class="tok-builtin">@enumFromInt</span>(data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Constant{
                            .ty = constant.typeOf(self),
                            .constant = constant,
                        }, metadata_adapter);
                    },
                }
            }<span class="tok-comment">

            // Write named metadata
            </span><span class="tok-kw">for</span> (self.metadata_named.keys(), self.metadata_named.values()) |name, operands| {
                <span class="tok-kw">const</span> slice = name.slice(self);
                <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Name{
                    .name = slice,
                });

                <span class="tok-kw">const</span> elements = self.metadata_extra.items[operands.index..][<span class="tok-number">0</span>..operands.len];
                <span class="tok-kw">for</span> (elements) |*e| {
                    e.* = metadata_adapter.getMetadataIndex(<span class="tok-builtin">@enumFromInt</span>(e.*)) - <span class="tok-number">1</span>;
                }

                <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.NamedNode{
                    .elements = <span class="tok-builtin">@ptrCast</span>(elements),
                });
            }<span class="tok-comment">

            // Write global attached metadata
            </span>{
                <span class="tok-kw">for</span> (globals.keys()) |global| {
                    <span class="tok-kw">const</span> global_ptr = global.ptrConst(self);
                    <span class="tok-kw">if</span> (global_ptr.dbg == .none) <span class="tok-kw">continue</span>;

                    <span class="tok-kw">switch</span> (global_ptr.kind) {
                        .function =&gt; |f| <span class="tok-kw">if</span> (f.ptrConst(self).instructions.len != <span class="tok-number">0</span>) <span class="tok-kw">continue</span>,
                        <span class="tok-kw">else</span> =&gt; {},
                    }

                    <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.GlobalDeclAttachment{
                        .value = <span class="tok-builtin">@enumFromInt</span>(constant_adapter.getConstantIndex(global.toConst())),
                        .kind = .dbg,
                        .metadata = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(global_ptr.dbg) - <span class="tok-number">1</span>),
                    });
                }
            }

            <span class="tok-kw">try</span> metadata_block.end();
        }<span class="tok-comment">

        // OPERAND_BUNDLE_TAGS_BLOCK
        </span>{
            <span class="tok-kw">const</span> OperandBundleTags = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.OperandBundleTags.html">OperandBundleTags</a>;
            <span class="tok-kw">var</span> operand_bundle_tags_block = <span class="tok-kw">try</span> module_block.enterSubBlock(OperandBundleTags, <span class="tok-null">true</span>);

            <span class="tok-kw">try</span> operand_bundle_tags_block.writeAbbrev(OperandBundleTags.OperandBundleTag{
                .tag = <span class="tok-str">&quot;cold&quot;</span>,
            });

            <span class="tok-kw">try</span> operand_bundle_tags_block.end();
        }<span class="tok-comment">

        // Block info
        </span>{
            <span class="tok-kw">const</span> BlockInfo = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.BlockInfo.html">BlockInfo</a>;
            <span class="tok-kw">var</span> block_info_block = <span class="tok-kw">try</span> module_block.enterSubBlock(BlockInfo, <span class="tok-null">true</span>);

            <span class="tok-kw">try</span> block_info_block.writeUnabbrev(BlockInfo.set_block_id, &amp;.{<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionBlock.html">FunctionBlock</a>.<a href="std.zig.llvm.ir.FunctionBlock.html#std.zig.llvm.ir.FunctionBlock.id">id</a>});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionBlock.html">FunctionBlock</a>.<a href="std.zig.llvm.ir.FunctionBlock.html#std.zig.llvm.ir.FunctionBlock.abbrevs">abbrevs</a>) |abbrev| {
                <span class="tok-kw">try</span> block_info_block.defineAbbrev(&amp;abbrev.ops);
            }

            <span class="tok-kw">try</span> block_info_block.writeUnabbrev(BlockInfo.set_block_id, &amp;.{<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html">FunctionValueSymbolTable</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html#std.zig.llvm.ir.FunctionValueSymbolTable.id">id</a>});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html">FunctionValueSymbolTable</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html#std.zig.llvm.ir.FunctionValueSymbolTable.abbrevs">abbrevs</a>) |abbrev| {
                <span class="tok-kw">try</span> block_info_block.defineAbbrev(&amp;abbrev.ops);
            }

            <span class="tok-kw">try</span> block_info_block.writeUnabbrev(BlockInfo.set_block_id, &amp;.{<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html">FunctionMetadataBlock</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html#std.zig.llvm.ir.FunctionMetadataBlock.id">id</a>});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html">FunctionMetadataBlock</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html#std.zig.llvm.ir.FunctionMetadataBlock.abbrevs">abbrevs</a>) |abbrev| {
                <span class="tok-kw">try</span> block_info_block.defineAbbrev(&amp;abbrev.ops);
            }

            <span class="tok-kw">try</span> block_info_block.writeUnabbrev(BlockInfo.set_block_id, &amp;.{<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html">MetadataAttachmentBlock</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html#std.zig.llvm.ir.MetadataAttachmentBlock.id">id</a>});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html">MetadataAttachmentBlock</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html#std.zig.llvm.ir.MetadataAttachmentBlock.abbrevs">abbrevs</a>) |abbrev| {
                <span class="tok-kw">try</span> block_info_block.defineAbbrev(&amp;abbrev.ops);
            }

            <span class="tok-kw">try</span> block_info_block.end();
        }<span class="tok-comment">

        // FUNCTION_BLOCKS
        </span>{
            <span class="tok-kw">const</span> FunctionAdapter = <span class="tok-kw">struct</span> {
                constant_adapter: ConstantAdapter,
                metadata_adapter: MetadataAdapter,
                func: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>,
                instruction_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), value: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(value) {
                    _ = field_name;
                    <span class="tok-kw">const</span> Ty = <span class="tok-builtin">@TypeOf</span>(value);
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (Ty) {
                        <a href="std.zig.llvm.Builder.Value.html">Value</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getOffsetValueIndex(value)),
                        <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getOffsetConstantIndex(value)),
                        <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">switch</span> (value) {
                            .none =&gt; <span class="tok-number">0</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-number">1</span> + adapter.constant_adapter.builder.function_attributes_set.getIndex(value).?,
                        }),
                        <span class="tok-kw">else</span> =&gt; value,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getValueIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-kw">switch</span> (value.unwrap()) {
                        .instruction =&gt; |instruction| instruction.valueIndex(adapter.func) + adapter.firstInstr(),
                        .constant =&gt; |constant| adapter.constant_adapter.getConstantIndex(constant),
                        .metadata =&gt; |metadata| {
                            <span class="tok-kw">const</span> real_metadata = metadata.unwrap(adapter.metadata_adapter.builder);
                            <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(real_metadata) &lt; <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a>)
                                <span class="tok-kw">return</span> adapter.metadata_adapter.getMetadataIndex(real_metadata) - <span class="tok-number">1</span>;

                            <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(metadata) -
                                <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a> +
                                adapter.metadata_adapter.builder.metadata_string_map.count() - <span class="tok-number">1</span> +
                                adapter.metadata_adapter.builder.metadata_map.count() - <span class="tok-number">1</span>);
                        },
                    });
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetValueIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> adapter.offset() -% adapter.getValueIndex(value);
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetValueSignedIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">i32</span> {
                    <span class="tok-kw">const</span> signed_offset: <span class="tok-type">i32</span> = <span class="tok-builtin">@intCast</span>(adapter.offset());
                    <span class="tok-kw">const</span> signed_value: <span class="tok-type">i32</span> = <span class="tok-builtin">@intCast</span>(adapter.getValueIndex(value));
                    <span class="tok-kw">return</span> signed_offset - signed_value;
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetConstantIndex</span>(adapter: <span class="tok-builtin">@This</span>(), constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> adapter.offset() - adapter.constant_adapter.getConstantIndex(constant);
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">offset</span>(adapter: <span class="tok-builtin">@This</span>()) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> adapter.instruction_index.valueIndex(adapter.func) + adapter.firstInstr();
                }

                <span class="tok-kw">fn</span> <span class="tok-fn">firstInstr</span>(adapter: <span class="tok-builtin">@This</span>()) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> adapter.constant_adapter.numConstants();
                }
            };

            <span class="tok-kw">for</span> (self.functions.items, <span class="tok-number">0</span>..) |func, func_index| {
                <span class="tok-kw">const</span> FunctionBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionBlock.html">FunctionBlock</a>;
                <span class="tok-kw">if</span> (func.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

                <span class="tok-kw">if</span> (func.instructions.len == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

                <span class="tok-kw">var</span> function_block = <span class="tok-kw">try</span> module_block.enterSubBlock(FunctionBlock, <span class="tok-null">false</span>);

                <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.DeclareBlocks{ .num_blocks = func.blocks.len });

                <span class="tok-kw">var</span> adapter: FunctionAdapter = .{
                    .constant_adapter = constant_adapter,
                    .metadata_adapter = metadata_adapter,
                    .func = &amp;func,
                    .instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
                };<span class="tok-comment">

                // Emit function level metadata block
                </span><span class="tok-kw">if</span> (!func.strip <span class="tok-kw">and</span> func.debug_values.len &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> MetadataBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html">FunctionMetadataBlock</a>;
                    <span class="tok-kw">var</span> metadata_block = <span class="tok-kw">try</span> function_block.enterSubBlock(MetadataBlock, <span class="tok-null">false</span>);

                    <span class="tok-kw">for</span> (func.debug_values) |value| {
                        <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Value{
                            .ty = value.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self),
                            .value = <span class="tok-builtin">@enumFromInt</span>(adapter.getValueIndex(value.toValue())),
                        });
                    }

                    <span class="tok-kw">try</span> metadata_block.end();
                }

                <span class="tok-kw">const</span> tags = func.instructions.items(.tag);
                <span class="tok-kw">const</span> datas = func.instructions.items(.data);

                <span class="tok-kw">var</span> has_location = <span class="tok-null">false</span>;

                <span class="tok-kw">var</span> block_incoming_len: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">for</span> (tags, datas, <span class="tok-number">0</span>..) |tag, data, instr_index| {
                    adapter.instruction_index = <span class="tok-builtin">@enumFromInt</span>(instr_index);
                    record.clearRetainingCapacity();

                    <span class="tok-kw">switch</span> (tag) {
                        .arg =&gt; <span class="tok-kw">continue</span>,
                        .block =&gt; {
                            block_incoming_len = data;
                            <span class="tok-kw">continue</span>;
                        },
                        .@&quot;unreachable&quot; =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Unreachable{}),
                        .call,
                        .@&quot;musttail call&quot;,
                        .@&quot;notail call&quot;,
                        .@&quot;tail call&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, data);

                            <span class="tok-kw">if</span> (extra.data.info.has_op_bundle_cold) {
                                <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ColdOperandBundle{});
                            }

                            <span class="tok-kw">const</span> call_conv = extra.data.info.call_conv;
                            <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrevAdapted(FunctionBlock.Call{
                                .attributes = extra.data.attributes,
                                .call_type = <span class="tok-kw">switch</span> (kind) {
                                    .call =&gt; .{ .call_conv = call_conv },
                                    .@&quot;tail call&quot; =&gt; .{ .tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    .@&quot;musttail call&quot; =&gt; .{ .must_tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    .@&quot;notail call&quot; =&gt; .{ .no_tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                },
                                .type_id = extra.data.ty,
                                .callee = extra.data.callee,
                                .args = args,
                            }, adapter);
                        },
                        .@&quot;call fast&quot;,
                        .@&quot;musttail call fast&quot;,
                        .@&quot;notail call fast&quot;,
                        .@&quot;tail call fast&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, data);

                            <span class="tok-kw">if</span> (extra.data.info.has_op_bundle_cold) {
                                <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ColdOperandBundle{});
                            }

                            <span class="tok-kw">const</span> call_conv = extra.data.info.call_conv;
                            <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrevAdapted(FunctionBlock.CallFast{
                                .attributes = extra.data.attributes,
                                .call_type = <span class="tok-kw">switch</span> (kind) {
                                    .@&quot;call fast&quot; =&gt; .{ .call_conv = call_conv },
                                    .@&quot;tail call fast&quot; =&gt; .{ .tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    .@&quot;musttail call fast&quot; =&gt; .{ .must_tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    .@&quot;notail call fast&quot; =&gt; .{ .no_tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                },
                                .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                                .type_id = extra.data.ty,
                                .callee = extra.data.callee,
                                .args = args,
                            }, adapter);
                        },
                        .add,
                        .@&quot;and&quot;,
                        .fadd,
                        .fdiv,
                        .fmul,
                        .mul,
                        .frem,
                        .fsub,
                        .sdiv,
                        .sub,
                        .udiv,
                        .xor,
                        .shl,
                        .lshr,
                        .@&quot;or&quot;,
                        .urem,
                        .srem,
                        .ashr,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Binary{
                                .opcode = kind.toBinaryOpcode(),
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                            });
                        },
                        .@&quot;sdiv exact&quot;,
                        .@&quot;udiv exact&quot;,
                        .@&quot;lshr exact&quot;,
                        .@&quot;ashr exact&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BinaryExact{
                                .opcode = kind.toBinaryOpcode(),
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                            });
                        },
                        .@&quot;add nsw&quot;,
                        .@&quot;add nuw&quot;,
                        .@&quot;add nuw nsw&quot;,
                        .@&quot;mul nsw&quot;,
                        .@&quot;mul nuw&quot;,
                        .@&quot;mul nuw nsw&quot;,
                        .@&quot;sub nsw&quot;,
                        .@&quot;sub nuw&quot;,
                        .@&quot;sub nuw nsw&quot;,
                        .@&quot;shl nsw&quot;,
                        .@&quot;shl nuw&quot;,
                        .@&quot;shl nuw nsw&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BinaryNoWrap{
                                .opcode = kind.toBinaryOpcode(),
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .flags = <span class="tok-kw">switch</span> (kind) {
                                    .@&quot;add nsw&quot;,
                                    .@&quot;mul nsw&quot;,
                                    .@&quot;sub nsw&quot;,
                                    .@&quot;shl nsw&quot;,
                                    =&gt; .{ .no_unsigned_wrap = <span class="tok-null">false</span>, .no_signed_wrap = <span class="tok-null">true</span> },
                                    .@&quot;add nuw&quot;,
                                    .@&quot;mul nuw&quot;,
                                    .@&quot;sub nuw&quot;,
                                    .@&quot;shl nuw&quot;,
                                    =&gt; .{ .no_unsigned_wrap = <span class="tok-null">true</span>, .no_signed_wrap = <span class="tok-null">false</span> },
                                    .@&quot;add nuw nsw&quot;,
                                    .@&quot;mul nuw nsw&quot;,
                                    .@&quot;sub nuw nsw&quot;,
                                    .@&quot;shl nuw nsw&quot;,
                                    =&gt; .{ .no_unsigned_wrap = <span class="tok-null">true</span>, .no_signed_wrap = <span class="tok-null">true</span> },
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                },
                            });
                        },
                        .@&quot;fadd fast&quot;,
                        .@&quot;fdiv fast&quot;,
                        .@&quot;fmul fast&quot;,
                        .@&quot;frem fast&quot;,
                        .@&quot;fsub fast&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BinaryFast{
                                .opcode = kind.toBinaryOpcode(),
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                            });
                        },
                        .alloca,
                        .@&quot;alloca inalloca&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, data);
                            <span class="tok-kw">const</span> alignment = extra.info.alignment.toLlvm();
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Alloca{
                                .inst_type = extra.<span class="tok-type">type</span>,
                                .len_type = extra.len.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self),
                                .len_value = adapter.getValueIndex(extra.len),
                                .flags = .{
                                    .align_lower = <span class="tok-builtin">@truncate</span>(alignment),
                                    .inalloca = kind == .@&quot;alloca inalloca&quot;,
                                    .explicit_type = <span class="tok-null">true</span>,
                                    .swift_error = <span class="tok-null">false</span>,
                                    .align_upper = <span class="tok-builtin">@truncate</span>(alignment &lt;&lt; <span class="tok-number">5</span>),
                                },
                            });
                        },
                        .bitcast,
                        .inttoptr,
                        .ptrtoint,
                        .fptosi,
                        .fptoui,
                        .sitofp,
                        .uitofp,
                        .addrspacecast,
                        .fptrunc,
                        .trunc,
                        .fpext,
                        .sext,
                        .zext,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Cast{
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .type_index = extra.<span class="tok-type">type</span>,
                                .opcode = kind.toCastOpcode(),
                            });
                        },
                        .@&quot;fcmp false&quot;,
                        .@&quot;fcmp oeq&quot;,
                        .@&quot;fcmp oge&quot;,
                        .@&quot;fcmp ogt&quot;,
                        .@&quot;fcmp ole&quot;,
                        .@&quot;fcmp olt&quot;,
                        .@&quot;fcmp one&quot;,
                        .@&quot;fcmp ord&quot;,
                        .@&quot;fcmp true&quot;,
                        .@&quot;fcmp ueq&quot;,
                        .@&quot;fcmp uge&quot;,
                        .@&quot;fcmp ugt&quot;,
                        .@&quot;fcmp ule&quot;,
                        .@&quot;fcmp ult&quot;,
                        .@&quot;fcmp une&quot;,
                        .@&quot;fcmp uno&quot;,
                        .@&quot;icmp eq&quot;,
                        .@&quot;icmp ne&quot;,
                        .@&quot;icmp sge&quot;,
                        .@&quot;icmp sgt&quot;,
                        .@&quot;icmp sle&quot;,
                        .@&quot;icmp slt&quot;,
                        .@&quot;icmp uge&quot;,
                        .@&quot;icmp ugt&quot;,
                        .@&quot;icmp ule&quot;,
                        .@&quot;icmp ult&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Cmp{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .pred = kind.toCmpPredicate(),
                            });
                        },
                        .@&quot;fcmp fast false&quot;,
                        .@&quot;fcmp fast oeq&quot;,
                        .@&quot;fcmp fast oge&quot;,
                        .@&quot;fcmp fast ogt&quot;,
                        .@&quot;fcmp fast ole&quot;,
                        .@&quot;fcmp fast olt&quot;,
                        .@&quot;fcmp fast one&quot;,
                        .@&quot;fcmp fast ord&quot;,
                        .@&quot;fcmp fast true&quot;,
                        .@&quot;fcmp fast ueq&quot;,
                        .@&quot;fcmp fast uge&quot;,
                        .@&quot;fcmp fast ugt&quot;,
                        .@&quot;fcmp fast ule&quot;,
                        .@&quot;fcmp fast ult&quot;,
                        .@&quot;fcmp fast une&quot;,
                        .@&quot;fcmp fast uno&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.CmpFast{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .pred = kind.toCmpPredicate(),
                                .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                            });
                        },
                        .fneg =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.FNeg{
                            .val = adapter.getOffsetValueIndex(<span class="tok-builtin">@enumFromInt</span>(data)),
                        }),
                        .@&quot;fneg fast&quot; =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.FNegFast{
                            .val = adapter.getOffsetValueIndex(<span class="tok-builtin">@enumFromInt</span>(data)),
                            .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                        }),
                        .extractvalue =&gt; {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, data);
                            <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ExtractValue{
                                .val = adapter.getOffsetValueIndex(extra.data.val),
                                .indices = indices,
                            });
                        },
                        .extractelement =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ExtractElement{
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .index = adapter.getOffsetValueIndex(extra.index),
                            });
                        },
                        .indirectbr =&gt; {
                            <span class="tok-kw">var</span> extra =
                                func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, datas[instr_index]);
                            <span class="tok-kw">const</span> targets =
                                extra.trail.next(extra.data.targets_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrevAdapted(
                                FunctionBlock.IndirectBr{
                                    .ty = extra.data.addr.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self),
                                    .addr = extra.data.addr,
                                    .targets = targets,
                                },
                                adapter,
                            );
                        },
                        .insertelement =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.InsertElement{
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .elem = adapter.getOffsetValueIndex(extra.elem),
                                .index = adapter.getOffsetValueIndex(extra.index),
                            });
                        },
                        .insertvalue =&gt; {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, datas[instr_index]);
                            <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.InsertValue{
                                .val = adapter.getOffsetValueIndex(extra.data.val),
                                .elem = adapter.getOffsetValueIndex(extra.data.elem),
                                .indices = indices,
                            });
                        },
                        .select =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Select{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .cond = adapter.getOffsetValueIndex(extra.cond),
                            });
                        },
                        .@&quot;select fast&quot; =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.SelectFast{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .cond = adapter.getOffsetValueIndex(extra.cond),
                                .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                            });
                        },
                        .shufflevector =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ShuffleVector{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .mask = adapter.getOffsetValueIndex(extra.mask),
                            });
                        },
                        .getelementptr,
                        .@&quot;getelementptr inbounds&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, data);
                            <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrevAdapted(
                                FunctionBlock.GetElementPtr{
                                    .is_inbounds = kind == .@&quot;getelementptr inbounds&quot;,
                                    .type_index = extra.data.<span class="tok-type">type</span>,
                                    .base = extra.data.base,
                                    .indices = indices,
                                },
                                adapter,
                            );
                        },
                        .load =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Load{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .ty = extra.<span class="tok-type">type</span>,
                                .alignment = extra.info.alignment.toLlvm(),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                            });
                        },
                        .@&quot;load atomic&quot; =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.LoadAtomic{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .ty = extra.<span class="tok-type">type</span>,
                                .alignment = extra.info.alignment.toLlvm(),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                                .success_ordering = extra.info.success_ordering,
                                .sync_scope = extra.info.sync_scope,
                            });
                        },
                        .store =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Store{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .alignment = extra.info.alignment.toLlvm(),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                            });
                        },
                        .@&quot;store atomic&quot; =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.StoreAtomic{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .alignment = extra.info.alignment.toLlvm(),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                                .success_ordering = extra.info.success_ordering,
                                .sync_scope = extra.info.sync_scope,
                            });
                        },
                        .br =&gt; {
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BrUnconditional{
                                .block = data,
                            });
                        },
                        .br_cond =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BrConditional{
                                .then_block = <span class="tok-builtin">@intFromEnum</span>(extra.then),
                                .else_block = <span class="tok-builtin">@intFromEnum</span>(extra.@&quot;else&quot;),
                                .condition = adapter.getOffsetValueIndex(extra.cond),
                            });
                        },
                        .@&quot;switch&quot; =&gt; {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, data);

                            <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span> + extra.data.cases_len * <span class="tok-number">2</span>);<span class="tok-comment">

                            // Conditional type
                            </span>record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.val.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self)));<span class="tok-comment">

                            // Conditional
                            </span>record.appendAssumeCapacity(adapter.getOffsetValueIndex(extra.data.val));<span class="tok-comment">

                            // Default block
                            </span>record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.default));

                            <span class="tok-kw">const</span> vals = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, &amp;func);
                            <span class="tok-kw">const</span> blocks = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;func);
                            <span class="tok-kw">for</span> (vals, blocks) |val, block| {
                                record.appendAssumeCapacity(adapter.constant_adapter.getConstantIndex(val));
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(block));
                            }

                            <span class="tok-kw">try</span> function_block.writeUnabbrev(<span class="tok-number">12</span>, record.items);
                        },
                        .va_arg =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.VaArg{
                                .list_type = extra.list.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self),
                                .list = adapter.getOffsetValueIndex(extra.list),
                                .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                            });
                        },
                        .phi,
                        .@&quot;phi fast&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, data);
                            <span class="tok-kw">const</span> vals = extra.trail.next(block_incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;func);
                            <span class="tok-kw">const</span> blocks = extra.trail.next(block_incoming_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;func);

                            <span class="tok-kw">try</span> record.ensureUnusedCapacity(
                                self.gpa,
                                <span class="tok-number">1</span> + block_incoming_len * <span class="tok-number">2</span> + <span class="tok-builtin">@intFromBool</span>(kind == .@&quot;phi fast&quot;),
                            );

                            record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.<span class="tok-type">type</span>));

                            <span class="tok-kw">for</span> (vals, blocks) |val, block| {
                                <span class="tok-kw">const</span> offset_value = adapter.getOffsetValueSignedIndex(val);
                                <span class="tok-kw">const</span> abs_value: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@abs</span>(offset_value));
                                <span class="tok-kw">const</span> signed_vbr = <span class="tok-kw">if</span> (offset_value &gt; <span class="tok-number">0</span>) abs_value &lt;&lt; <span class="tok-number">1</span> <span class="tok-kw">else</span> ((abs_value &lt;&lt; <span class="tok-number">1</span>) | <span class="tok-number">1</span>);
                                record.appendAssumeCapacity(signed_vbr);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(block));
                            }

                            <span class="tok-kw">if</span> (kind == .@&quot;phi fast&quot;) record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>{})));

                            <span class="tok-kw">try</span> function_block.writeUnabbrev(<span class="tok-number">16</span>, record.items);
                        },
                        .ret =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Ret{
                            .val = adapter.getOffsetValueIndex(<span class="tok-builtin">@enumFromInt</span>(data)),
                        }),
                        .@&quot;ret void&quot; =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.RetVoid{}),
                        .atomicrmw =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.AtomicRmw{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .operation = extra.info.atomic_rmw_operation,
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                                .success_ordering = extra.info.success_ordering,
                                .sync_scope = extra.info.sync_scope,
                                .alignment = extra.info.alignment.toLlvm(),
                            });
                        },
                        .cmpxchg,
                        .@&quot;cmpxchg weak&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, data);

                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.CmpXchg{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .cmp = adapter.getOffsetValueIndex(extra.cmp),
                                .new = adapter.getOffsetValueIndex(extra.new),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                                .success_ordering = extra.info.success_ordering,
                                .sync_scope = extra.info.sync_scope,
                                .failure_ordering = extra.info.failure_ordering,
                                .is_weak = kind == .@&quot;cmpxchg weak&quot;,
                                .alignment = extra.info.alignment.toLlvm(),
                            });
                        },
                        .fence =&gt; {
                            <span class="tok-kw">const</span> info: <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a> = <span class="tok-builtin">@bitCast</span>(data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Fence{
                                .ordering = info.success_ordering,
                                .sync_scope = info.sync_scope,
                            });
                        },
                    }

                    <span class="tok-kw">if</span> (!func.strip) {
                        <span class="tok-kw">if</span> (func.debug_locations.get(adapter.instruction_index)) |debug_location| {
                            <span class="tok-kw">switch</span> (debug_location) {
                                .no_location =&gt; has_location = <span class="tok-null">false</span>,
                                .location =&gt; |location| {
                                    <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.DebugLoc{
                                        .line = location.line,
                                        .column = location.column,
                                        .scope = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(location.scope)),
                                        .inlined_at = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(location.inlined_at)),
                                    });
                                    has_location = <span class="tok-null">true</span>;
                                },
                            }
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (has_location) {
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.DebugLocAgain{});
                        }
                    }
                }<span class="tok-comment">

                // VALUE_SYMTAB
                </span><span class="tok-kw">if</span> (!func.strip) {
                    <span class="tok-kw">const</span> ValueSymbolTable = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html">FunctionValueSymbolTable</a>;

                    <span class="tok-kw">var</span> value_symtab_block = <span class="tok-kw">try</span> function_block.enterSubBlock(ValueSymbolTable, <span class="tok-null">false</span>);

                    <span class="tok-kw">for</span> (func.blocks, <span class="tok-number">0</span>..) |block, block_index| {
                        <span class="tok-kw">const</span> name = block.instruction.name(&amp;func);

                        <span class="tok-kw">if</span> (name == .none <span class="tok-kw">or</span> name == .empty) <span class="tok-kw">continue</span>;

                        <span class="tok-kw">try</span> value_symtab_block.writeAbbrev(ValueSymbolTable.BlockEntry{
                            .value_id = <span class="tok-builtin">@intCast</span>(block_index),
                            .string = name.slice(self).?,
                        });
                    }<span class="tok-comment">

                    // TODO: Emit non block entries if the builder ever starts assigning names to non blocks

                    </span><span class="tok-kw">try</span> value_symtab_block.end();
                }<span class="tok-comment">

                // METADATA_ATTACHMENT_BLOCK
                </span>{
                    <span class="tok-kw">const</span> MetadataAttachmentBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html">MetadataAttachmentBlock</a>;
                    <span class="tok-kw">var</span> metadata_attach_block = <span class="tok-kw">try</span> function_block.enterSubBlock(MetadataAttachmentBlock, <span class="tok-null">false</span>);

                    dbg: {
                        <span class="tok-kw">if</span> (func.strip) <span class="tok-kw">break</span> :dbg;
                        <span class="tok-kw">const</span> dbg = func.global.ptrConst(self).dbg;
                        <span class="tok-kw">if</span> (dbg == .none) <span class="tok-kw">break</span> :dbg;
                        <span class="tok-kw">try</span> metadata_attach_block.writeAbbrev(MetadataAttachmentBlock.AttachmentGlobalSingle{
                            .kind = .dbg,
                            .metadata = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(dbg) - <span class="tok-number">1</span>),
                        });
                    }

                    <span class="tok-kw">var</span> instr_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">for</span> (func.instructions.items(.tag), func.instructions.items(.data)) |instr_tag, data| <span class="tok-kw">switch</span> (instr_tag) {
                        .arg, .block =&gt; {},<span class="tok-comment"> // not an actual instruction
                        </span><span class="tok-kw">else</span> =&gt; {
                            instr_index += <span class="tok-number">1</span>;
                        },
                        .br_cond, .@&quot;switch&quot; =&gt; {
                            <span class="tok-kw">const</span> weights = <span class="tok-kw">switch</span> (instr_tag) {
                                .br_cond =&gt; func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, data).weights,
                                .@&quot;switch&quot; =&gt; func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, data).weights,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            };
                            <span class="tok-kw">switch</span> (weights) {
                                .none =&gt; {},
                                .unpredictable =&gt; <span class="tok-kw">try</span> metadata_attach_block.writeAbbrev(MetadataAttachmentBlock.AttachmentInstructionSingle{
                                    .inst = instr_index,
                                    .kind = .unpredictable,
                                    .metadata = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(.empty_tuple) - <span class="tok-number">1</span>),
                                }),
                                _ =&gt; <span class="tok-kw">try</span> metadata_attach_block.writeAbbrev(MetadataAttachmentBlock.AttachmentInstructionSingle{
                                    .inst = instr_index,
                                    .kind = .prof,
                                    .metadata = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(<span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(weights))) - <span class="tok-number">1</span>),
                                }),
                            }
                            instr_index += <span class="tok-number">1</span>;
                        },
                    };

                    <span class="tok-kw">try</span> metadata_attach_block.end();
                }

                <span class="tok-kw">try</span> function_block.end();
            }
        }

        <span class="tok-kw">try</span> module_block.end();
    }<span class="tok-comment">

    // STRTAB_BLOCK
    </span>{
        <span class="tok-kw">const</span> Strtab = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Strtab.html">Strtab</a>;
        <span class="tok-kw">var</span> strtab_block = <span class="tok-kw">try</span> bitcode.enterTopBlock(Strtab);

        <span class="tok-kw">try</span> strtab_block.writeAbbrev(Strtab.Blob{ .blob = self.strtab_string_bytes.items });

        <span class="tok-kw">try</span> strtab_block.end();
    }

    <span class="tok-kw">return</span> bitcode.toOwnedSlice();
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.zig.llvm.Builder">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText">gpa: <a href="std.mem.Allocator.html">Allocator</a>,
strip: <span class="tok-type">bool</span>,

source_filename: <a href="std.zig.llvm.Builder.String.html">String</a>,
data_layout: <a href="std.zig.llvm.Builder.String.html">String</a>,
target_triple: <a href="std.zig.llvm.Builder.String.html">String</a>,
module_asm: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),

string_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>),
string_indices: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
string_bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),

types: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.Type.html">Type</a>),
next_unnamed_type: <a href="std.zig.llvm.Builder.String.html">String</a>,
next_unique_type_id: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <span class="tok-type">u32</span>),
type_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>),
type_items: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>),
type_extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),

attributes: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Storage.html">Storage</a>, <span class="tok-type">void</span>),
attributes_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>),
attributes_indices: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
attributes_extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),

function_attributes_set: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, <span class="tok-type">void</span>),

globals: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, <a href="std.zig.llvm.Builder.Global.html">Global</a>),
next_unnamed_global: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
next_replaced_global: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
next_unique_global_id: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, <span class="tok-type">u32</span>),
aliases: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Alias.html">Alias</a>),
variables: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Variable.html">Variable</a>),
functions: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.html">Function</a>),

strtab_string_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>),
strtab_string_indices: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
strtab_string_bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),

constant_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>),
constant_items: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>),
constant_extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
constant_limbs: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>),

metadata_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>),
metadata_items: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>),
metadata_extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
metadata_limbs: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>),
metadata_forward_references: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>),
metadata_named: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, <span class="tok-kw">struct</span> {
    len: <span class="tok-type">u32</span>,
    index: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a>,
}),

metadata_string_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">void</span>, <span class="tok-type">void</span>),
metadata_string_indices: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),
metadata_string_bytes: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>),

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_args_len = <span class="tok-number">16</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_attrs_len = <span class="tok-number">16</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_fields_len = <span class="tok-number">32</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_gep_indices_len = <span class="tok-number">8</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_cases_len = <span class="tok-number">8</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> expected_incoming_len = <span class="tok-number">8</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
    allocator: <a href="std.mem.Allocator.html">Allocator</a>,
    strip: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},
    target: <a href="std.html">std</a>.<a href="std.Target.html">Target</a> = <a href="builtin.html">builtin</a>.<a href="builtin.html#builtin.target">target</a>,
    triple: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;.{},
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> String = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>),
    empty,
    _,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAnon</span>(self: <a href="std.zig.llvm.Builder.String.html">String</a>) <span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self != .none);
        <span class="tok-kw">return</span> self.toIndex() == <span class="tok-null">null</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <a href="std.zig.llvm.Builder.String.html">String</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> index = self.toIndex() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> start = builder.string_indices.items[index];
        <span class="tok-kw">const</span> end = builder.string_indices.items[index + <span class="tok-number">1</span>];
        <span class="tok-kw">return</span> builder.string_bytes.items[start..end];
    }

    <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
        string: <a href="std.zig.llvm.Builder.String.html">String</a>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    };
    <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        data: <a href="std.zig.llvm.Builder.String.FormatData.html">FormatData</a>,
        <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;\&quot;r&quot;</span>)) |_|
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid format string: '&quot;</span> ++ fmt_str ++ <span class="tok-str">&quot;'&quot;</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(data.string != .none);
        <span class="tok-kw">const</span> string_slice = data.string.slice(data.builder) <span class="tok-kw">orelse</span>
            <span class="tok-kw">return</span> writer.print(<span class="tok-str">&quot;{d}&quot;</span>, .{<span class="tok-builtin">@intFromEnum</span>(data.string)});
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">'r'</span>)) |_|
            <span class="tok-kw">return</span> writer.writeAll(string_slice);
        <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printEscapedString">printEscapedString</a>(
            string_slice,
            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">'&quot;'</span>)) |_|
                .always_quote
            <span class="tok-kw">else</span>
                .quote_unless_valid_identifier,
            writer,
        );
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.String.html">String</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.String.html#std.zig.llvm.Builder.String.format">format</a>) {
        <span class="tok-kw">return</span> .{ .data = .{ .string = self, .builder = builder } };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fromIndex</span>(index: ?<span class="tok-type">usize</span>) <a href="std.zig.llvm.Builder.String.html">String</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>((index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .none) +
            <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.String.html">String</a>.<a href="#">empty</a>))));
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">toIndex</span>(self: <a href="std.zig.llvm.Builder.String.html">String</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intFromEnum</span>(self), <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.String.html">String</a>.<a href="#">empty</a>)) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, key));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>, lhs_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_key, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.html#std.zig.llvm.Builder.String.fromIndex">fromIndex</a>(rhs_index).slice(ctx.builder).?);
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> BinaryOpcode = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
    add = <span class="tok-number">0</span>,
    sub = <span class="tok-number">1</span>,
    mul = <span class="tok-number">2</span>,
    udiv = <span class="tok-number">3</span>,
    sdiv = <span class="tok-number">4</span>,
    urem = <span class="tok-number">5</span>,
    srem = <span class="tok-number">6</span>,
    shl = <span class="tok-number">7</span>,
    lshr = <span class="tok-number">8</span>,
    ashr = <span class="tok-number">9</span>,
    @&quot;and&quot; = <span class="tok-number">10</span>,
    @&quot;or&quot; = <span class="tok-number">11</span>,
    xor = <span class="tok-number">12</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CastOpcode = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
    trunc = <span class="tok-number">0</span>,
    zext = <span class="tok-number">1</span>,
    sext = <span class="tok-number">2</span>,
    fptoui = <span class="tok-number">3</span>,
    fptosi = <span class="tok-number">4</span>,
    uitofp = <span class="tok-number">5</span>,
    sitofp = <span class="tok-number">6</span>,
    fptrunc = <span class="tok-number">7</span>,
    fpext = <span class="tok-number">8</span>,
    ptrtoint = <span class="tok-number">9</span>,
    inttoptr = <span class="tok-number">10</span>,
    bitcast = <span class="tok-number">11</span>,
    addrspacecast = <span class="tok-number">12</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CmpPredicate = <span class="tok-kw">enum</span>(<span class="tok-type">u6</span>) {
    fcmp_false = <span class="tok-number">0</span>,
    fcmp_oeq = <span class="tok-number">1</span>,
    fcmp_ogt = <span class="tok-number">2</span>,
    fcmp_oge = <span class="tok-number">3</span>,
    fcmp_olt = <span class="tok-number">4</span>,
    fcmp_ole = <span class="tok-number">5</span>,
    fcmp_one = <span class="tok-number">6</span>,
    fcmp_ord = <span class="tok-number">7</span>,
    fcmp_uno = <span class="tok-number">8</span>,
    fcmp_ueq = <span class="tok-number">9</span>,
    fcmp_ugt = <span class="tok-number">10</span>,
    fcmp_uge = <span class="tok-number">11</span>,
    fcmp_ult = <span class="tok-number">12</span>,
    fcmp_ule = <span class="tok-number">13</span>,
    fcmp_une = <span class="tok-number">14</span>,
    fcmp_true = <span class="tok-number">15</span>,
    icmp_eq = <span class="tok-number">32</span>,
    icmp_ne = <span class="tok-number">33</span>,
    icmp_ugt = <span class="tok-number">34</span>,
    icmp_uge = <span class="tok-number">35</span>,
    icmp_ult = <span class="tok-number">36</span>,
    icmp_ule = <span class="tok-number">37</span>,
    icmp_sgt = <span class="tok-number">38</span>,
    icmp_sge = <span class="tok-number">39</span>,
    icmp_slt = <span class="tok-number">40</span>,
    icmp_sle = <span class="tok-number">41</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    <span class="tok-type">void</span>,
    half,
    bfloat,
    float,
    double,
    fp128,
    x86_fp80,
    ppc_fp128,
    x86_amx,
    x86_mmx,
    label,
    token,
    metadata,

    <span class="tok-type">i1</span>,
    <span class="tok-type">i8</span>,
    <span class="tok-type">i16</span>,
    <span class="tok-type">i29</span>,
    <span class="tok-type">i32</span>,
    <span class="tok-type">i64</span>,
    <span class="tok-type">i80</span>,
    <span class="tok-type">i128</span>,
    ptr,
    @&quot;ptr addrspace(4)&quot;,

    none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
    _,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ptr_amdgpu_constant =
        <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;ptr{ }&quot;</span>, .{<a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>.<a href="std.zig.llvm.Builder.AddrSpace.amdgpu.html">amdgpu</a>.<a href="std.zig.llvm.Builder.AddrSpace.amdgpu.html#std.zig.llvm.Builder.AddrSpace.amdgpu.constant">constant</a>}));

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
        simple,
        function,
        vararg_function,
        integer,
        pointer,
        target,
        vector,
        scalable_vector,
        small_array,
        array,
        structure,
        packed_structure,
        named_structure,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Simple = <span class="tok-kw">enum</span>(<span class="tok-type">u5</span>) {
        <span class="tok-type">void</span> = <span class="tok-number">2</span>,
        half = <span class="tok-number">10</span>,
        bfloat = <span class="tok-number">23</span>,
        float = <span class="tok-number">3</span>,
        double = <span class="tok-number">4</span>,
        fp128 = <span class="tok-number">14</span>,
        x86_fp80 = <span class="tok-number">13</span>,
        ppc_fp128 = <span class="tok-number">15</span>,
        x86_amx = <span class="tok-number">24</span>,
        x86_mmx = <span class="tok-number">17</span>,
        label = <span class="tok-number">5</span>,
        token = <span class="tok-number">22</span>,
        metadata = <span class="tok-number">16</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Function = <span class="tok-kw">struct</span> {
        ret: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        params_len: <span class="tok-type">u32</span>,<span class="tok-comment">
        //params: [params_len]Value,

        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> { normal, vararg };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Target = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.String.html">String</a>,
        types_len: <span class="tok-type">u32</span>,
        ints_len: <span class="tok-type">u32</span>,<span class="tok-comment">
        //types: [types_len]Type,
        //ints: [ints_len]u32,
    </span>};

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Vector = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        len: <span class="tok-type">u32</span>,
        child: <a href="std.zig.llvm.Builder.Type.html">Type</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: <a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> self.len;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> { normal, scalable };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Array = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        len_lo: <span class="tok-type">u32</span>,
        len_hi: <span class="tok-type">u32</span>,
        child: <a href="std.zig.llvm.Builder.Type.html">Type</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: <a href="std.zig.llvm.Builder.Type.Array.html">Array</a>) <span class="tok-type">u64</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, self.len_hi) &lt;&lt; <span class="tok-number">32</span> | self.len_lo;
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Structure = <span class="tok-kw">struct</span> {
        fields_len: <span class="tok-type">u32</span>,<span class="tok-comment">
        //fields: [fields_len]Type,

        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> { normal, @&quot;packed&quot; };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> NamedStructure = <span class="tok-kw">struct</span> {
        id: <a href="std.zig.llvm.Builder.String.html">String</a>,
        body: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        tag: <a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a>,
        data: <a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExtraIndex = <span class="tok-type">u28</span>;
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">tag</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a> {
        <span class="tok-kw">return</span> builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)].tag;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unnamedTag</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            .named_structure =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data).body
                .unnamedTag(builder),
            <span class="tok-kw">else</span> =&gt; item.tag,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scalarTag</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            .vector, .scalable_vector =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data)
                .child.tag(builder),
            <span class="tok-kw">else</span> =&gt; item.tag,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isFloatingPoint</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            .half, .bfloat, .float, .double, .fp128, .x86_fp80, .ppc_fp128 =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isInteger</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            .<span class="tok-type">i1</span>, .<span class="tok-type">i8</span>, .<span class="tok-type">i16</span>, .<span class="tok-type">i29</span>, .<span class="tok-type">i32</span>, .<span class="tok-type">i64</span>, .<span class="tok-type">i80</span>, .<span class="tok-type">i128</span> =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (self.tag(builder)) {
                .integer =&gt; <span class="tok-null">true</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
            },
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isPointer</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            .ptr =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (self.tag(builder)) {
                .pointer =&gt; <span class="tok-null">true</span>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
            },
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pointerAddrSpace</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> {
        <span class="tok-kw">switch</span> (self) {
            .ptr =&gt; <span class="tok-kw">return</span> .default,
            <span class="tok-kw">else</span> =&gt; {
                <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
                <a href="std.debug.html#std.debug.assert">assert</a>(item.tag == .pointer);
                <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(item.data);
            },
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isFunction</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.tag(builder)) {
            .function, .vararg_function =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">functionKind</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Type.Function.Kind.html">Kind</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.tag(builder)) {
            .function =&gt; .normal,
            .vararg_function =&gt; .vararg,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">functionParameters</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">switch</span> (item.tag) {
            .function,
            .vararg_function,
            =&gt; {
                <span class="tok-kw">var</span> extra = builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, item.data);
                <span class="tok-kw">return</span> extra.trail.next(extra.data.params_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder);
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">functionReturn</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">switch</span> (item.tag) {
            .function,
            .vararg_function,
            =&gt; <span class="tok-kw">return</span> builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, item.data).ret,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isVector</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.tag(builder)) {
            .vector, .scalable_vector =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorKind</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.tag(builder)) {
            .vector =&gt; .normal,
            .scalable_vector =&gt; .scalable,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isStruct</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.tag(builder)) {
            .structure, .packed_structure, .named_structure =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structKind</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>.<a href="std.zig.llvm.Builder.Type.Structure.Kind.html">Kind</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.unnamedTag(builder)) {
            .structure =&gt; .normal,
            .packed_structure =&gt; .@&quot;packed&quot;,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAggregate</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.tag(builder)) {
            .small_array, .array, .structure, .packed_structure, .named_structure =&gt; <span class="tok-null">true</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scalarBits</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">u24</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            .<span class="tok-type">void</span>, .label, .token, .metadata, .none, .x86_amx =&gt; <span class="tok-kw">unreachable</span>,
            .<span class="tok-type">i1</span> =&gt; <span class="tok-number">1</span>,
            .<span class="tok-type">i8</span> =&gt; <span class="tok-number">8</span>,
            .half, .bfloat, .<span class="tok-type">i16</span> =&gt; <span class="tok-number">16</span>,
            .<span class="tok-type">i29</span> =&gt; <span class="tok-number">29</span>,
            .float, .<span class="tok-type">i32</span> =&gt; <span class="tok-number">32</span>,
            .double, .<span class="tok-type">i64</span>, .x86_mmx =&gt; <span class="tok-number">64</span>,
            .x86_fp80, .<span class="tok-type">i80</span> =&gt; <span class="tok-number">80</span>,
            .fp128, .ppc_fp128, .<span class="tok-type">i128</span> =&gt; <span class="tok-number">128</span>,
            .ptr, .@&quot;ptr addrspace(4)&quot; =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO: query data layout&quot;</span>),
            _ =&gt; {
                <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
                    .simple,
                    .function,
                    .vararg_function,
                    =&gt; <span class="tok-kw">unreachable</span>,
                    .integer =&gt; <span class="tok-builtin">@intCast</span>(item.data),
                    .pointer =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO: query data layout&quot;</span>),
                    .target =&gt; <span class="tok-kw">unreachable</span>,
                    .vector,
                    .scalable_vector,
                    =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).child.scalarBits(builder),
                    .small_array,
                    .array,
                    .structure,
                    .packed_structure,
                    .named_structure,
                    =&gt; <span class="tok-kw">unreachable</span>,
                };
            },
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">childType</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            .vector,
            .scalable_vector,
            .small_array,
            =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).child,
            .array =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, item.data).child,
            .named_structure =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data).body,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">scalarType</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">if</span> (self.isFloatingPoint()) <span class="tok-kw">return</span> self;
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            .integer,
            .pointer,
            =&gt; self,
            .vector,
            .scalable_vector,
            =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).child,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">changeScalar</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, scalar: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">try</span> builder.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> self.changeScalarAssumeCapacity(scalar, builder);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">changeScalarAssumeCapacity</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, scalar: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">if</span> (self.isFloatingPoint()) <span class="tok-kw">return</span> scalar;
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            .integer,
            .pointer,
            =&gt; scalar,
            <span class="tok-kw">inline</span> .vector,
            .scalable_vector,
            =&gt; |kind| builder.vectorTypeAssumeCapacity(
                <span class="tok-kw">switch</span> (kind) {
                    .vector =&gt; .normal,
                    .scalable_vector =&gt; .scalable,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                },
                builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).len,
                scalar,
            ),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorLen</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">u32</span> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            .vector,
            .scalable_vector,
            =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).len,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">changeLength</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, len: <span class="tok-type">u32</span>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">try</span> builder.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> self.changeLengthAssumeCapacity(len, builder);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">changeLengthAssumeCapacity</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, len: <span class="tok-type">u32</span>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            <span class="tok-kw">inline</span> .vector,
            .scalable_vector,
            =&gt; |kind| builder.vectorTypeAssumeCapacity(
                <span class="tok-kw">switch</span> (kind) {
                    .vector =&gt; .normal,
                    .scalable_vector =&gt; .scalable,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                },
                len,
                builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).child,
            ),
            .small_array =&gt; builder.arrayTypeAssumeCapacity(
                len,
                builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).child,
            ),
            .array =&gt; builder.arrayTypeAssumeCapacity(
                len,
                builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, item.data).child,
            ),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">aggregateLen</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            .vector,
            .scalable_vector,
            .small_array,
            =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).len,
            .array =&gt; <span class="tok-builtin">@intCast</span>(builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, item.data).length()),
            .structure,
            .packed_structure,
            =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, item.data).fields_len,
            .named_structure =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data).body
                .aggregateLen(builder),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structFields</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">switch</span> (item.tag) {
            .structure,
            .packed_structure,
            =&gt; {
                <span class="tok-kw">var</span> extra = builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, item.data);
                <span class="tok-kw">return</span> extra.trail.next(extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder);
            },
            .named_structure =&gt; <span class="tok-kw">return</span> builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data).body
                .structFields(builder),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">childTypeAt</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">if</span> (indices.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> self;
        <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
            .small_array =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data).child
                .childTypeAt(indices[<span class="tok-number">1</span>..], builder),
            .array =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, item.data).child
                .childTypeAt(indices[<span class="tok-number">1</span>..], builder),
            .structure,
            .packed_structure,
            =&gt; {
                <span class="tok-kw">var</span> extra = builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, item.data);
                <span class="tok-kw">const</span> fields = extra.trail.next(extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder);
                <span class="tok-kw">return</span> fields[indices[<span class="tok-number">0</span>]].childTypeAt(indices[<span class="tok-number">1</span>..], builder);
            },
            .named_structure =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data).body
                .childTypeAt(indices, builder),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">targetLayoutType</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        _ = self;
        _ = builder;
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;TODO: implement targetLayoutType&quot;</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isSized</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
        <span class="tok-kw">var</span> visited: <a href="std.zig.llvm.Builder.Type.html#std.zig.llvm.Builder.Type.IsSizedVisited">IsSizedVisited</a> = .{};
        <span class="tok-kw">defer</span> visited.deinit(builder.gpa);
        <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.isSizedVisited(&amp;visited, builder);
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
        <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    };
    <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        data: <a href="std.zig.llvm.Builder.Type.FormatData.html">FormatData</a>,
        <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        fmt_opts: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(data.<span class="tok-type">type</span> != .none);
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;m&quot;</span>)) {
            <span class="tok-kw">const</span> item = data.builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(data.<span class="tok-type">type</span>)];
            <span class="tok-kw">switch</span> (item.tag) {
                .simple =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Type.Simple.html">Simple</a>, <span class="tok-builtin">@enumFromInt</span>(item.data))) {
                    .<span class="tok-type">void</span> =&gt; <span class="tok-str">&quot;isVoid&quot;</span>,
                    .half =&gt; <span class="tok-str">&quot;f16&quot;</span>,
                    .bfloat =&gt; <span class="tok-str">&quot;bf16&quot;</span>,
                    .float =&gt; <span class="tok-str">&quot;f32&quot;</span>,
                    .double =&gt; <span class="tok-str">&quot;f64&quot;</span>,
                    .fp128 =&gt; <span class="tok-str">&quot;f128&quot;</span>,
                    .x86_fp80 =&gt; <span class="tok-str">&quot;f80&quot;</span>,
                    .ppc_fp128 =&gt; <span class="tok-str">&quot;ppcf128&quot;</span>,
                    .x86_amx =&gt; <span class="tok-str">&quot;x86amx&quot;</span>,
                    .x86_mmx =&gt; <span class="tok-str">&quot;x86mmx&quot;</span>,
                    .label, .token =&gt; <span class="tok-kw">unreachable</span>,
                    .metadata =&gt; <span class="tok-str">&quot;Metadata&quot;</span>,
                }),
                .function, .vararg_function =&gt; |kind| {
                    <span class="tok-kw">var</span> extra = data.builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, item.data);
                    <span class="tok-kw">const</span> params = extra.trail.next(extra.data.params_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, data.builder);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;f_{m}&quot;</span>, .{extra.data.ret.fmt(data.builder)});
                    <span class="tok-kw">for</span> (params) |param| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{m}&quot;</span>, .{param.fmt(data.builder)});
                    <span class="tok-kw">switch</span> (kind) {
                        .function =&gt; {},
                        .vararg_function =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;vararg&quot;</span>),
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    }
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'f'</span>);
                },
                .integer =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;i{d}&quot;</span>, .{item.data}),
                .pointer =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;p{d}&quot;</span>, .{item.data}),
                .target =&gt; {
                    <span class="tok-kw">var</span> extra = data.builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Target.html">Target</a>, item.data);
                    <span class="tok-kw">const</span> types = extra.trail.next(extra.data.types_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, data.builder);
                    <span class="tok-kw">const</span> ints = extra.trail.next(extra.data.ints_len, <span class="tok-type">u32</span>, data.builder);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;t{s}&quot;</span>, .{extra.data.name.slice(data.builder).?});
                    <span class="tok-kw">for</span> (types) |ty| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;_{m}&quot;</span>, .{ty.fmt(data.builder)});
                    <span class="tok-kw">for</span> (ints) |int| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;_{d}&quot;</span>, .{int});
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'t'</span>);
                },
                .vector, .scalable_vector =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = data.builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}v{d}{m}&quot;</span>, .{
                        <span class="tok-kw">switch</span> (kind) {
                            .vector =&gt; <span class="tok-str">&quot;&quot;</span>,
                            .scalable_vector =&gt; <span class="tok-str">&quot;nx&quot;</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                        extra.len,
                        extra.child.fmt(data.builder),
                    });
                },
                <span class="tok-kw">inline</span> .small_array, .array =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = data.builder.typeExtraData(<span class="tok-kw">switch</span> (kind) {
                        .small_array =&gt; <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>,
                        .array =&gt; <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    }, item.data);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;a{d}{m}&quot;</span>, .{ extra.length(), extra.child.fmt(data.builder) });
                },
                .structure, .packed_structure =&gt; {
                    <span class="tok-kw">var</span> extra = data.builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, item.data);
                    <span class="tok-kw">const</span> fields = extra.trail.next(extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, data.builder);
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;sl_&quot;</span>);
                    <span class="tok-kw">for</span> (fields) |field| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{m}&quot;</span>, .{field.fmt(data.builder)});
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'s'</span>);
                },
                .named_structure =&gt; {
                    <span class="tok-kw">const</span> extra = data.builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data);
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;s_&quot;</span>);
                    <span class="tok-kw">if</span> (extra.id.slice(data.builder)) |id| <span class="tok-kw">try</span> writer.writeAll(id);
                },
            }
            <span class="tok-kw">return</span>;
        }
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.tagName">tagName</a>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, data.<span class="tok-type">type</span>)) |name| <span class="tok-kw">return</span> writer.writeAll(name);
        <span class="tok-kw">const</span> item = data.builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(data.<span class="tok-type">type</span>)];
        <span class="tok-kw">switch</span> (item.tag) {
            .simple =&gt; <span class="tok-kw">unreachable</span>,
            .function, .vararg_function =&gt; |kind| {
                <span class="tok-kw">var</span> extra = data.builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, item.data);
                <span class="tok-kw">const</span> params = extra.trail.next(extra.data.params_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, data.builder);
                <span class="tok-kw">if</span> (!<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;&gt;&quot;</span>))
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%} &quot;</span>, .{extra.data.ret.fmt(data.builder)});
                <span class="tok-kw">if</span> (!<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;&lt;&quot;</span>)) {
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'('</span>);
                    <span class="tok-kw">for</span> (params, <span class="tok-number">0</span>..) |param, index| {
                        <span class="tok-kw">if</span> (index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%}&quot;</span>, .{param.fmt(data.builder)});
                    }
                    <span class="tok-kw">switch</span> (kind) {
                        .function =&gt; {},
                        .vararg_function =&gt; {
                            <span class="tok-kw">if</span> (params.len &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;...&quot;</span>);
                        },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    }
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
                }
            },
            .integer =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;i{d}&quot;</span>, .{item.data}),
            .pointer =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;ptr{ }&quot;</span>, .{<span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>, <span class="tok-builtin">@enumFromInt</span>(item.data))}),
            .target =&gt; {
                <span class="tok-kw">var</span> extra = data.builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Target.html">Target</a>, item.data);
                <span class="tok-kw">const</span> types = extra.trail.next(extra.data.types_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, data.builder);
                <span class="tok-kw">const</span> ints = extra.trail.next(extra.data.ints_len, <span class="tok-type">u32</span>, data.builder);
                <span class="tok-kw">try</span> writer.print(
                    <span class="tok-str">\\target({&quot;}</span>
                , .{extra.data.name.fmt(data.builder)});
                <span class="tok-kw">for</span> (types) |ty| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {%}&quot;</span>, .{ty.fmt(data.builder)});
                <span class="tok-kw">for</span> (ints) |int| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {d}&quot;</span>, .{int});
                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
            },
            .vector, .scalable_vector =&gt; |kind| {
                <span class="tok-kw">const</span> extra = data.builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data);
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;&lt;{s}{d} x {%}&gt;&quot;</span>, .{
                    <span class="tok-kw">switch</span> (kind) {
                        .vector =&gt; <span class="tok-str">&quot;&quot;</span>,
                        .scalable_vector =&gt; <span class="tok-str">&quot;vscale x &quot;</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    },
                    extra.len,
                    extra.child.fmt(data.builder),
                });
            },
            <span class="tok-kw">inline</span> .small_array, .array =&gt; |kind| {
                <span class="tok-kw">const</span> extra = data.builder.typeExtraData(<span class="tok-kw">switch</span> (kind) {
                    .small_array =&gt; <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>,
                    .array =&gt; <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }, item.data);
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;[{d} x {%}]&quot;</span>, .{ extra.length(), extra.child.fmt(data.builder) });
            },
            .structure, .packed_structure =&gt; |kind| {
                <span class="tok-kw">var</span> extra = data.builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, item.data);
                <span class="tok-kw">const</span> fields = extra.trail.next(extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, data.builder);
                <span class="tok-kw">switch</span> (kind) {
                    .structure =&gt; {},
                    .packed_structure =&gt; <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'&lt;'</span>),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;{ &quot;</span>);
                <span class="tok-kw">for</span> (fields, <span class="tok-number">0</span>..) |field, index| {
                    <span class="tok-kw">if</span> (index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%}&quot;</span>, .{field.fmt(data.builder)});
                }
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; }&quot;</span>);
                <span class="tok-kw">switch</span> (kind) {
                    .structure =&gt; {},
                    .packed_structure =&gt; <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'&gt;'</span>),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }
            },
            .named_structure =&gt; {
                <span class="tok-kw">const</span> extra = data.builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data);
                <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;%&quot;</span>)) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;%{}&quot;</span>, .{
                    extra.id.fmt(data.builder),
                }) <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (extra.body) {
                    .none =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;opaque&quot;</span>),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.Type.html#std.zig.llvm.Builder.Type.format">format</a>(.{
                        .<span class="tok-type">type</span> = extra.body,
                        .builder = data.builder,
                    }, fmt_str, fmt_opts, writer),
                }
            },
        }
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Type.html#std.zig.llvm.Builder.Type.format">format</a>) {
        <span class="tok-kw">return</span> .{ .data = .{ .<span class="tok-type">type</span> = self, .builder = builder } };
    }

    <span class="tok-kw">const</span> IsSizedVisited = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, <span class="tok-type">void</span>);
    <span class="tok-kw">fn</span> <span class="tok-fn">isSizedVisited</span>(
        self: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        visited: *<a href="std.zig.llvm.Builder.Type.html#std.zig.llvm.Builder.Type.IsSizedVisited">IsSizedVisited</a>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            .<span class="tok-type">void</span>,
            .label,
            .token,
            .metadata,
            =&gt; <span class="tok-null">false</span>,
            .half,
            .bfloat,
            .float,
            .double,
            .fp128,
            .x86_fp80,
            .ppc_fp128,
            .x86_amx,
            .x86_mmx,
            .<span class="tok-type">i1</span>,
            .<span class="tok-type">i8</span>,
            .<span class="tok-type">i16</span>,
            .<span class="tok-type">i29</span>,
            .<span class="tok-type">i32</span>,
            .<span class="tok-type">i64</span>,
            .<span class="tok-type">i80</span>,
            .<span class="tok-type">i128</span>,
            .ptr,
            .@&quot;ptr addrspace(4)&quot;,
            =&gt; <span class="tok-null">true</span>,
            .none =&gt; <span class="tok-kw">unreachable</span>,
            _ =&gt; {
                <span class="tok-kw">const</span> item = builder.type_items.items[<span class="tok-builtin">@intFromEnum</span>(self)];
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
                    .simple =&gt; <span class="tok-kw">unreachable</span>,
                    .function,
                    .vararg_function,
                    =&gt; <span class="tok-null">false</span>,
                    .integer,
                    .pointer,
                    =&gt; <span class="tok-null">true</span>,
                    .target =&gt; self.targetLayoutType(builder).isSizedVisited(visited, builder),
                    .vector,
                    .scalable_vector,
                    .small_array,
                    =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, item.data)
                        .child.isSizedVisited(visited, builder),
                    .array =&gt; builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, item.data)
                        .child.isSizedVisited(visited, builder),
                    .structure,
                    .packed_structure,
                    =&gt; {
                        <span class="tok-kw">if</span> (<span class="tok-kw">try</span> visited.fetchPut(builder.gpa, self, {})) |_| <span class="tok-kw">return</span> <span class="tok-null">false</span>;

                        <span class="tok-kw">var</span> extra = builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, item.data);
                        <span class="tok-kw">const</span> fields = extra.trail.next(extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder);
                        <span class="tok-kw">for</span> (fields) |field| {
                            <span class="tok-kw">if</span> (field.isVector(builder) <span class="tok-kw">and</span> field.vectorKind(builder) == .scalable)
                                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                            <span class="tok-kw">if</span> (!<span class="tok-kw">try</span> field.isSizedVisited(visited, builder))
                                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                        }
                        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                    },
                    .named_structure =&gt; {
                        <span class="tok-kw">const</span> body = builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data).body;
                        <span class="tok-kw">return</span> body != .none <span class="tok-kw">and</span> <span class="tok-kw">try</span> body.isSizedVisited(visited, builder);
                    },
                };
            },
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Attribute = <span class="tok-kw">union</span>(Kind) {<span class="tok-comment">
    // Parameter Attributes
    </span>zeroext,
    signext,
    inreg,
    byval: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    byref: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    preallocated: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    inalloca: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    sret: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    elementtype: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    @&quot;align&quot;: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    @&quot;noalias&quot;,
    nocapture,
    nofree,
    nest,
    returned,
    nonnull,
    dereferenceable: <span class="tok-type">u32</span>,
    dereferenceable_or_null: <span class="tok-type">u32</span>,
    swiftself,
    swiftasync,
    swifterror,
    immarg,
    noundef,
    nofpclass: <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>,
    alignstack: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    allocalign,
    allocptr,
    readnone,
    readonly,
    writeonly,<span class="tok-comment">

    // Function Attributes
    //alignstack: Alignment,
    </span>allockind: <a href="std.zig.llvm.Builder.Attribute.AllocKind.html">AllocKind</a>,
    allocsize: <a href="std.zig.llvm.Builder.Attribute.AllocSize.html">AllocSize</a>,
    alwaysinline,
    <a href="builtin.html">builtin</a>,
    cold,
    convergent,
    disable_sanitizer_information,
    fn_ret_thunk_extern,
    hot,
    inlinehint,
    jumptable,
    memory: <a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>,
    minsize,
    naked,
    nobuiltin,
    nocallback,
    noduplicate,<span class="tok-comment">
    //nofree,
    </span>noimplicitfloat,
    @&quot;noinline&quot;,
    nomerge,
    nonlazybind,
    noprofile,
    skipprofile,
    noredzone,
    <span class="tok-type">noreturn</span>,
    norecurse,
    willreturn,
    nosync,
    nounwind,
    nosanitize_bounds,
    nosanitize_coverage,
    null_pointer_is_valid,
    optforfuzzing,
    optnone,
    optsize,<span class="tok-comment">
    //preallocated: Type,
    </span>returns_twice,
    safestack,
    sanitize_address,
    sanitize_memory,
    sanitize_thread,
    sanitize_hwaddress,
    sanitize_memtag,
    speculative_load_hardening,
    speculatable,
    ssp,
    sspstrong,
    sspreq,
    strictfp,
    uwtable: <a href="std.zig.llvm.Builder.Attribute.UwTable.html">UwTable</a>,
    nocf_check,
    shadowcallstack,
    mustprogress,
    vscale_range: <a href="std.zig.llvm.Builder.Attribute.VScaleRange.html">VScaleRange</a>,<span class="tok-comment">

    // Global Attributes
    </span>no_sanitize_address,
    no_sanitize_hwaddress,<span class="tok-comment">
    //sanitize_memtag,
    </span>sanitize_address_dyninit,

    string: <span class="tok-kw">struct</span> { kind: <a href="std.zig.llvm.Builder.String.html">String</a>, value: <a href="std.zig.llvm.Builder.String.html">String</a> },
    none: <span class="tok-type">noreturn</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKind</span>(self: <a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a> {
            <span class="tok-kw">return</span> self.toStorage(builder).kind;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toAttribute</span>(self: <a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a> {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">2_000</span>);
            <span class="tok-kw">const</span> storage = self.toStorage(builder);
            <span class="tok-kw">if</span> (storage.kind.toString()) |kind| <span class="tok-kw">return</span> .{ .string = .{
                .kind = kind,
                .value = <span class="tok-builtin">@enumFromInt</span>(storage.value),
            } } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (storage.kind) {
                <span class="tok-kw">inline</span> .zeroext,
                .signext,
                .inreg,
                .byval,
                .byref,
                .preallocated,
                .inalloca,
                .sret,
                .elementtype,
                .@&quot;align&quot;,
                .@&quot;noalias&quot;,
                .nocapture,
                .nofree,
                .nest,
                .returned,
                .nonnull,
                .dereferenceable,
                .dereferenceable_or_null,
                .swiftself,
                .swiftasync,
                .swifterror,
                .immarg,
                .noundef,
                .nofpclass,
                .alignstack,
                .allocalign,
                .allocptr,
                .readnone,
                .readonly,
                .writeonly,<span class="tok-comment">
                //.alignstack,
                </span>.allockind,
                .allocsize,
                .alwaysinline,
                .builtin,
                .cold,
                .convergent,
                .disable_sanitizer_information,
                .fn_ret_thunk_extern,
                .hot,
                .inlinehint,
                .jumptable,
                .memory,
                .minsize,
                .naked,
                .nobuiltin,
                .nocallback,
                .noduplicate,<span class="tok-comment">
                //.nofree,
                </span>.noimplicitfloat,
                .@&quot;noinline&quot;,
                .nomerge,
                .nonlazybind,
                .noprofile,
                .skipprofile,
                .noredzone,
                .<span class="tok-type">noreturn</span>,
                .norecurse,
                .willreturn,
                .nosync,
                .nounwind,
                .nosanitize_bounds,
                .nosanitize_coverage,
                .null_pointer_is_valid,
                .optforfuzzing,
                .optnone,
                .optsize,<span class="tok-comment">
                //.preallocated,
                </span>.returns_twice,
                .safestack,
                .sanitize_address,
                .sanitize_memory,
                .sanitize_thread,
                .sanitize_hwaddress,
                .sanitize_memtag,
                .speculative_load_hardening,
                .speculatable,
                .ssp,
                .sspstrong,
                .sspreq,
                .strictfp,
                .uwtable,
                .nocf_check,
                .shadowcallstack,
                .mustprogress,
                .vscale_range,
                .no_sanitize_address,
                .no_sanitize_hwaddress,
                .sanitize_address_dyninit,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> field = <span class="tok-kw">comptime</span> blk: {
                        <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">10_000</span>);
                        <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>).@&quot;union&quot;.fields) |field| {
                            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field.name, <span class="tok-builtin">@tagName</span>(kind))) <span class="tok-kw">break</span> :blk field;
                        }
                        <span class="tok-kw">unreachable</span>;
                    };
                    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(kind), field.name));
                    <span class="tok-kw">return</span> <span class="tok-builtin">@unionInit</span>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>, field.name, <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                        <span class="tok-type">void</span> =&gt; {},
                        <span class="tok-type">u32</span> =&gt; storage.value,
                        <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, <a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.zig.llvm.Builder.Attribute.UwTable.html">UwTable</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(storage.value),
                        <a href="std.zig.llvm.Builder.Attribute.AllocKind.html">AllocKind</a>, <a href="std.zig.llvm.Builder.Attribute.AllocSize.html">AllocSize</a>, <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>, <a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>, <a href="std.zig.llvm.Builder.Attribute.VScaleRange.html">VScaleRange</a> =&gt; <span class="tok-builtin">@bitCast</span>(storage.value),
                        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad payload type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++
                            <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
                    });
                },
                .string, .none =&gt; <span class="tok-kw">unreachable</span>,
                _ =&gt; <span class="tok-kw">unreachable</span>,
            };
        }

        <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
            attribute_index: <a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>,
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        };
        <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
            data: <a href="std.zig.llvm.Builder.Attribute.Index.FormatData.html">FormatData</a>,
            <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
            writer: <span class="tok-kw">anytype</span>,
        ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;\&quot;#&quot;</span>)) |_|
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid format string: '&quot;</span> ++ fmt_str ++ <span class="tok-str">&quot;'&quot;</span>);
            <span class="tok-kw">const</span> attribute = data.attribute_index.toAttribute(data.builder);
            <span class="tok-kw">switch</span> (attribute) {
                .zeroext,
                .signext,
                .inreg,
                .@&quot;noalias&quot;,
                .nocapture,
                .nofree,
                .nest,
                .returned,
                .nonnull,
                .swiftself,
                .swiftasync,
                .swifterror,
                .immarg,
                .noundef,
                .allocalign,
                .allocptr,
                .readnone,
                .readonly,
                .writeonly,
                .alwaysinline,
                .builtin,
                .cold,
                .convergent,
                .disable_sanitizer_information,
                .fn_ret_thunk_extern,
                .hot,
                .inlinehint,
                .jumptable,
                .minsize,
                .naked,
                .nobuiltin,
                .nocallback,
                .noduplicate,
                .noimplicitfloat,
                .@&quot;noinline&quot;,
                .nomerge,
                .nonlazybind,
                .noprofile,
                .skipprofile,
                .noredzone,
                .<span class="tok-type">noreturn</span>,
                .norecurse,
                .willreturn,
                .nosync,
                .nounwind,
                .nosanitize_bounds,
                .nosanitize_coverage,
                .null_pointer_is_valid,
                .optforfuzzing,
                .optnone,
                .optsize,
                .returns_twice,
                .safestack,
                .sanitize_address,
                .sanitize_memory,
                .sanitize_thread,
                .sanitize_hwaddress,
                .sanitize_memtag,
                .speculative_load_hardening,
                .speculatable,
                .ssp,
                .sspstrong,
                .sspreq,
                .strictfp,
                .nocf_check,
                .shadowcallstack,
                .mustprogress,
                .no_sanitize_address,
                .no_sanitize_hwaddress,
                .sanitize_address_dyninit,
                =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(attribute)}),
                .byval,
                .byref,
                .preallocated,
                .inalloca,
                .sret,
                .elementtype,
                =&gt; |ty| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}({%})&quot;</span>, .{ <span class="tok-builtin">@tagName</span>(attribute), ty.fmt(data.builder) }),
                .@&quot;align&quot; =&gt; |alignment| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{ }&quot;</span>, .{alignment}),
                .dereferenceable,
                .dereferenceable_or_null,
                =&gt; |size| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}({d})&quot;</span>, .{ <span class="tok-builtin">@tagName</span>(attribute), size }),
                .nofpclass =&gt; |fpclass| {
                    <span class="tok-kw">const</span> Int = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>).@&quot;struct&quot;.backing_integer.?;
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}(&quot;</span>, .{<span class="tok-builtin">@tagName</span>(attribute)});
                    <span class="tok-kw">var</span> any = <span class="tok-null">false</span>;
                    <span class="tok-kw">var</span> remaining: Int = <span class="tok-builtin">@bitCast</span>(fpclass);
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>).@&quot;struct&quot;.decls) |decl| {
                        <span class="tok-kw">const</span> pattern: Int = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>, decl.name));
                        <span class="tok-kw">if</span> (remaining &amp; pattern == pattern) {
                            <span class="tok-kw">if</span> (!any) {
                                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">' '</span>);
                                any = <span class="tok-null">true</span>;
                            }
                            <span class="tok-kw">try</span> writer.writeAll(decl.name);
                            remaining &amp;= ~pattern;
                        }
                    }
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
                },
                .alignstack =&gt; |alignment| <span class="tok-kw">try</span> writer.print(
                    <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">'#'</span>) != <span class="tok-null">null</span>)
                        <span class="tok-str">&quot; {s}={d}&quot;</span>
                    <span class="tok-kw">else</span>
                        <span class="tok-str">&quot; {s}({d})&quot;</span>,
                    .{ <span class="tok-builtin">@tagName</span>(attribute), alignment.toByteUnits() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> },
                ),
                .allockind =&gt; |allockind| {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}(\&quot;&quot;</span>, .{<span class="tok-builtin">@tagName</span>(attribute)});
                    <span class="tok-kw">var</span> any = <span class="tok-null">false</span>;
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Attribute.AllocKind.html">AllocKind</a>).@&quot;struct&quot;.fields) |field| {
                        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field.name, <span class="tok-str">&quot;_&quot;</span>)) <span class="tok-kw">continue</span>;
                        <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(allockind, field.name)) {
                            <span class="tok-kw">if</span> (!any) {
                                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">','</span>);
                                any = <span class="tok-null">true</span>;
                            }
                            <span class="tok-kw">try</span> writer.writeAll(field.name);
                        }
                    }
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\&quot;)&quot;</span>);
                },
                .allocsize =&gt; |allocsize| {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}({d}&quot;</span>, .{ <span class="tok-builtin">@tagName</span>(attribute), allocsize.elem_size });
                    <span class="tok-kw">if</span> (allocsize.num_elems != <a href="std.zig.llvm.Builder.Attribute.AllocSize.html">AllocSize</a>.<a href="std.zig.llvm.Builder.Attribute.AllocSize.html#std.zig.llvm.Builder.Attribute.AllocSize.none">none</a>)
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;,{d}&quot;</span>, .{allocsize.num_elems});
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
                },
                .memory =&gt; |memory| {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}(&quot;</span>, .{<span class="tok-builtin">@tagName</span>(attribute)});
                    <span class="tok-kw">var</span> any = memory.other != .none <span class="tok-kw">or</span>
                        (memory.argmem == .none <span class="tok-kw">and</span> memory.inaccessiblemem == .none);
                    <span class="tok-kw">if</span> (any) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-builtin">@tagName</span>(memory.other));
                    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{ <span class="tok-str">&quot;argmem&quot;</span>, <span class="tok-str">&quot;inaccessiblemem&quot;</span> }) |kind| {
                        <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(memory, kind) != memory.other) {
                            <span class="tok-kw">if</span> (any) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}: {s}&quot;</span>, .{ kind, <span class="tok-builtin">@tagName</span>(<span class="tok-builtin">@field</span>(memory, kind)) });
                            any = <span class="tok-null">true</span>;
                        }
                    }
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
                },
                .uwtable =&gt; |uwtable| <span class="tok-kw">if</span> (uwtable != .none) {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(attribute)});
                    <span class="tok-kw">if</span> (uwtable != <a href="std.zig.llvm.Builder.Attribute.UwTable.html">UwTable</a>.<a href="std.zig.llvm.Builder.Attribute.UwTable.html#std.zig.llvm.Builder.Attribute.UwTable.default">default</a>) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;({s})&quot;</span>, .{<span class="tok-builtin">@tagName</span>(uwtable)});
                },
                .vscale_range =&gt; |vscale_range| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}({d},{d})&quot;</span>, .{
                    <span class="tok-builtin">@tagName</span>(attribute),
                    vscale_range.min.toByteUnits().?,
                    vscale_range.max.toByteUnits() <span class="tok-kw">orelse</span> <span class="tok-number">0</span>,
                }),
                .string =&gt; |string_attr| <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">'&quot;'</span>) != <span class="tok-null">null</span>) {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {\&quot;}&quot;</span>, .{string_attr.kind.fmt(data.builder)});
                    <span class="tok-kw">if</span> (string_attr.value != .empty)
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;={\&quot;}&quot;</span>, .{string_attr.value.fmt(data.builder)});
                },
                .none =&gt; <span class="tok-kw">unreachable</span>,
            }
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Attribute.Index.html#std.zig.llvm.Builder.Attribute.Index.format">format</a>) {
            <span class="tok-kw">return</span> .{ .data = .{ .attribute_index = self, .builder = builder } };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">toStorage</span>(self: <a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Attribute.Storage.html">Storage</a> {
            <span class="tok-kw">return</span> builder.attributes.keys()[<span class="tok-builtin">@intFromEnum</span>(self)];
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {<span class="tok-comment">
        // Parameter Attributes
        </span>zeroext = <span class="tok-number">34</span>,
        signext = <span class="tok-number">24</span>,
        inreg = <span class="tok-number">5</span>,
        byval = <span class="tok-number">3</span>,
        byref = <span class="tok-number">69</span>,
        preallocated = <span class="tok-number">65</span>,
        inalloca = <span class="tok-number">38</span>,
        sret = <span class="tok-number">29</span>,<span class="tok-comment"> // TODO: ?
        </span>elementtype = <span class="tok-number">77</span>,
        @&quot;align&quot; = <span class="tok-number">1</span>,
        @&quot;noalias&quot; = <span class="tok-number">9</span>,
        nocapture = <span class="tok-number">11</span>,
        nofree = <span class="tok-number">62</span>,
        nest = <span class="tok-number">8</span>,
        returned = <span class="tok-number">22</span>,
        nonnull = <span class="tok-number">39</span>,
        dereferenceable = <span class="tok-number">41</span>,
        dereferenceable_or_null = <span class="tok-number">42</span>,
        swiftself = <span class="tok-number">46</span>,
        swiftasync = <span class="tok-number">75</span>,
        swifterror = <span class="tok-number">47</span>,
        immarg = <span class="tok-number">60</span>,
        noundef = <span class="tok-number">68</span>,
        nofpclass = <span class="tok-number">87</span>,
        alignstack = <span class="tok-number">25</span>,
        allocalign = <span class="tok-number">80</span>,
        allocptr = <span class="tok-number">81</span>,
        readnone = <span class="tok-number">20</span>,
        readonly = <span class="tok-number">21</span>,
        writeonly = <span class="tok-number">52</span>,<span class="tok-comment">

        // Function Attributes
        //alignstack,
        </span>allockind = <span class="tok-number">82</span>,
        allocsize = <span class="tok-number">51</span>,
        alwaysinline = <span class="tok-number">2</span>,
        <a href="builtin.html">builtin</a> = <span class="tok-number">35</span>,
        cold = <span class="tok-number">36</span>,
        convergent = <span class="tok-number">43</span>,
        disable_sanitizer_information = <span class="tok-number">78</span>,
        fn_ret_thunk_extern = <span class="tok-number">84</span>,
        hot = <span class="tok-number">72</span>,
        inlinehint = <span class="tok-number">4</span>,
        jumptable = <span class="tok-number">40</span>,
        memory = <span class="tok-number">86</span>,
        minsize = <span class="tok-number">6</span>,
        naked = <span class="tok-number">7</span>,
        nobuiltin = <span class="tok-number">10</span>,
        nocallback = <span class="tok-number">71</span>,
        noduplicate = <span class="tok-number">12</span>,<span class="tok-comment">
        //nofree,
        </span>noimplicitfloat = <span class="tok-number">13</span>,
        @&quot;noinline&quot; = <span class="tok-number">14</span>,
        nomerge = <span class="tok-number">66</span>,
        nonlazybind = <span class="tok-number">15</span>,
        noprofile = <span class="tok-number">73</span>,
        skipprofile = <span class="tok-number">85</span>,
        noredzone = <span class="tok-number">16</span>,
        <span class="tok-type">noreturn</span> = <span class="tok-number">17</span>,
        norecurse = <span class="tok-number">48</span>,
        willreturn = <span class="tok-number">61</span>,
        nosync = <span class="tok-number">63</span>,
        nounwind = <span class="tok-number">18</span>,
        nosanitize_bounds = <span class="tok-number">79</span>,
        nosanitize_coverage = <span class="tok-number">76</span>,
        null_pointer_is_valid = <span class="tok-number">67</span>,
        optforfuzzing = <span class="tok-number">57</span>,
        optnone = <span class="tok-number">37</span>,
        optsize = <span class="tok-number">19</span>,<span class="tok-comment">
        //preallocated,
        </span>returns_twice = <span class="tok-number">23</span>,
        safestack = <span class="tok-number">44</span>,
        sanitize_address = <span class="tok-number">30</span>,
        sanitize_memory = <span class="tok-number">32</span>,
        sanitize_thread = <span class="tok-number">31</span>,
        sanitize_hwaddress = <span class="tok-number">55</span>,
        sanitize_memtag = <span class="tok-number">64</span>,
        speculative_load_hardening = <span class="tok-number">59</span>,
        speculatable = <span class="tok-number">53</span>,
        ssp = <span class="tok-number">26</span>,
        sspstrong = <span class="tok-number">28</span>,
        sspreq = <span class="tok-number">27</span>,
        strictfp = <span class="tok-number">54</span>,
        uwtable = <span class="tok-number">33</span>,
        nocf_check = <span class="tok-number">56</span>,
        shadowcallstack = <span class="tok-number">58</span>,
        mustprogress = <span class="tok-number">70</span>,
        vscale_range = <span class="tok-number">74</span>,<span class="tok-comment">

        // Global Attributes
        </span>no_sanitize_address = <span class="tok-number">100</span>,
        no_sanitize_hwaddress = <span class="tok-number">101</span>,<span class="tok-comment">
        //sanitize_memtag,
        </span>sanitize_address_dyninit = <span class="tok-number">102</span>,

        <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.string">string</a> = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>),
        none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> len = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>).@&quot;enum&quot;.fields.len - <span class="tok-number">2</span>;

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromString</span>(str: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a> {
            <a href="std.debug.html#std.debug.assert">assert</a>(!str.isAnon());
            <span class="tok-kw">const</span> kind: <a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(str));
            <a href="std.debug.html#std.debug.assert">assert</a>(kind != .none);
            <span class="tok-kw">return</span> kind;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">toString</span>(self: <a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>) ?<a href="std.zig.llvm.Builder.String.html">String</a> {
            <a href="std.debug.html#std.debug.assert">assert</a>(self != .none);
            <span class="tok-kw">const</span> str: <a href="std.zig.llvm.Builder.String.html">String</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(self));
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (str.isAnon()) <span class="tok-null">null</span> <span class="tok-kw">else</span> str;
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FpClass = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        signaling_nan: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        quiet_nan: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        negative_infinity: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        negative_normal: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        negative_subnormal: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        negative_zero: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        positive_zero: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        positive_subnormal: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        positive_normal: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        positive_infinity: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        _: <span class="tok-type">u22</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> all = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{
            .signaling_nan = <span class="tok-null">true</span>,
            .quiet_nan = <span class="tok-null">true</span>,
            .negative_infinity = <span class="tok-null">true</span>,
            .negative_normal = <span class="tok-null">true</span>,
            .negative_subnormal = <span class="tok-null">true</span>,
            .negative_zero = <span class="tok-null">true</span>,
            .positive_zero = <span class="tok-null">true</span>,
            .positive_subnormal = <span class="tok-null">true</span>,
            .positive_normal = <span class="tok-null">true</span>,
            .positive_infinity = <span class="tok-null">true</span>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> nan = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .signaling_nan = <span class="tok-null">true</span>, .quiet_nan = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> snan = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .signaling_nan = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> qnan = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .quiet_nan = <span class="tok-null">true</span> };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> inf = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .negative_infinity = <span class="tok-null">true</span>, .positive_infinity = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ninf = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .negative_infinity = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> pinf = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .positive_infinity = <span class="tok-null">true</span> };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> zero = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .positive_zero = <span class="tok-null">true</span>, .negative_zero = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> nzero = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .negative_zero = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> pzero = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .positive_zero = <span class="tok-null">true</span> };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> sub = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .positive_subnormal = <span class="tok-null">true</span>, .negative_subnormal = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> nsub = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .negative_subnormal = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> psub = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .positive_subnormal = <span class="tok-null">true</span> };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> norm = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .positive_normal = <span class="tok-null">true</span>, .negative_normal = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> nnorm = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .negative_normal = <span class="tok-null">true</span> };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> pnorm = <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>{ .positive_normal = <span class="tok-null">true</span> };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocKind = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        alloc: <span class="tok-type">bool</span>,
        realloc: <span class="tok-type">bool</span>,
        free: <span class="tok-type">bool</span>,
        uninitialized: <span class="tok-type">bool</span>,
        zeroed: <span class="tok-type">bool</span>,
        aligned: <span class="tok-type">bool</span>,
        _: <span class="tok-type">u26</span> = <span class="tok-number">0</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AllocSize = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        elem_size: <span class="tok-type">u16</span>,
        num_elems: <span class="tok-type">u16</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u16</span>);

        <span class="tok-kw">fn</span> <span class="tok-fn">toLlvm</span>(self: <a href="std.zig.llvm.Builder.Attribute.AllocSize.html">AllocSize</a>) <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u64</span>) { num_elems: <span class="tok-type">u32</span>, elem_size: <span class="tok-type">u32</span> } {
            <span class="tok-kw">return</span> .{ .num_elems = <span class="tok-kw">switch</span> (self.num_elems) {
                <span class="tok-kw">else</span> =&gt; self.num_elems,
                <a href="std.zig.llvm.Builder.Attribute.AllocSize.html#std.zig.llvm.Builder.Attribute.AllocSize.none">none</a> =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
            }, .elem_size = self.elem_size };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Memory = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        argmem: <a href="std.zig.llvm.Builder.Attribute.Memory.Effect.html">Effect</a> = .none,
        inaccessiblemem: <a href="std.zig.llvm.Builder.Attribute.Memory.Effect.html">Effect</a> = .none,
        other: <a href="std.zig.llvm.Builder.Attribute.Memory.Effect.html">Effect</a> = .none,
        _: <span class="tok-type">u26</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Effect = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) { none, read, write, readwrite };

        <span class="tok-kw">fn</span> <span class="tok-fn">all</span>(effect: <a href="std.zig.llvm.Builder.Attribute.Memory.Effect.html">Effect</a>) <a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a> {
            <span class="tok-kw">return</span> .{ .argmem = effect, .inaccessiblemem = effect, .other = effect };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UwTable = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        none,
        sync,
        @&quot;async&quot;,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> default = <a href="std.zig.llvm.Builder.Attribute.UwTable.html">UwTable</a>.<a href="#"async"">@&quot;async&quot;</a>;
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> VScaleRange = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        min: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        max: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        _: <span class="tok-type">u20</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">toLlvm</span>(self: <a href="std.zig.llvm.Builder.Attribute.VScaleRange.html">VScaleRange</a>) <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u64</span>) { max: <span class="tok-type">u32</span>, min: <span class="tok-type">u32</span> } {
            <span class="tok-kw">return</span> .{
                .max = <span class="tok-builtin">@intCast</span>(self.max.toByteUnits() <span class="tok-kw">orelse</span> <span class="tok-number">0</span>),
                .min = <span class="tok-builtin">@intCast</span>(self.min.toByteUnits().?),
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKind</span>(self: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>) <a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            <span class="tok-kw">else</span> =&gt; self,
            .string =&gt; |string_attr| <a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>.<a href="std.zig.llvm.Builder.Attribute.Kind.html#std.zig.llvm.Builder.Attribute.Kind.fromString">fromString</a>(string_attr.kind),
        };
    }

    <span class="tok-kw">const</span> Storage = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        kind: <a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>,
        value: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">toStorage</span>(self: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>) <a href="std.zig.llvm.Builder.Attribute.Storage.html">Storage</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |value, tag| .{ .kind = <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>, self), .value = <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(value)) {
                <span class="tok-type">void</span> =&gt; <span class="tok-number">0</span>,
                <span class="tok-type">u32</span> =&gt; value,
                <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, <a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.zig.llvm.Builder.Attribute.UwTable.html">UwTable</a> =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
                <a href="std.zig.llvm.Builder.Attribute.AllocKind.html">AllocKind</a>, <a href="std.zig.llvm.Builder.Attribute.AllocSize.html">AllocSize</a>, <a href="std.zig.llvm.Builder.Attribute.FpClass.html">FpClass</a>, <a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>, <a href="std.zig.llvm.Builder.Attribute.VScaleRange.html">VScaleRange</a> =&gt; <span class="tok-builtin">@bitCast</span>(value),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad payload type: &quot;</span> ++ <span class="tok-builtin">@tagName</span>(tag) ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value))),
            } },
            .string =&gt; |string_attr| .{
                .kind = <a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>.<a href="std.zig.llvm.Builder.Attribute.Kind.html#std.zig.llvm.Builder.Attribute.Kind.fromString">fromString</a>(string_attr.kind),
                .value = <span class="tok-builtin">@intFromEnum</span>(string_attr.value),
            },
            .none =&gt; <span class="tok-kw">unreachable</span>,
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Attributes = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    none,
    _,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a> {
        <span class="tok-kw">const</span> start = builder.attributes_indices.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">const</span> end = builder.attributes_indices.items[<span class="tok-builtin">@intFromEnum</span>(self) + <span class="tok-number">1</span>];
        <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(builder.attributes_extra.items[start..end]);
    }

    <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
        attributes: <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    };
    <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        data: <a href="std.zig.llvm.Builder.Attributes.FormatData.html">FormatData</a>,
        <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        fmt_opts: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">for</span> (data.attributes.slice(data.builder)) |attribute_index| <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html#std.zig.llvm.Builder.Attribute.Index.format">format</a>(.{
            .attribute_index = attribute_index,
            .builder = data.builder,
        }, fmt_str, fmt_opts, writer);
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Attributes.html#std.zig.llvm.Builder.Attributes.format">format</a>) {
        <span class="tok-kw">return</span> .{ .data = .{ .attributes = self, .builder = builder } };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FunctionAttributes = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    none,
    _,

    <span class="tok-kw">const</span> function_index = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> return_index = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> params_index = <span class="tok-number">2</span>;

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Wip = <span class="tok-kw">struct</span> {
        maps: <a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html#std.zig.llvm.Builder.FunctionAttributes.Wip.Maps">Maps</a> = .{},

        <span class="tok-kw">const</span> Map = <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>, <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>);
        <span class="tok-kw">const</span> Maps = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html#std.zig.llvm.Builder.FunctionAttributes.Wip.Map">Map</a>);

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">for</span> (self.maps.items) |*map| map.deinit(builder.gpa);
            self.maps.deinit(builder.gpa);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFnAttr</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, attribute: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.addAttr(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.function_index">function_index</a>, attribute, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFnAttrIndex</span>(
            self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>,
            attribute_index: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>,
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.addAttrIndex(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.function_index">function_index</a>, attribute_index, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeFnAttr</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, attribute_kind: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.removeAttr(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.function_index">function_index</a>, attribute_kind);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRetAttr</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, attribute: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.addAttr(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.return_index">return_index</a>, attribute, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addRetAttrIndex</span>(
            self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>,
            attribute_index: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>,
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.addAttrIndex(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.return_index">return_index</a>, attribute_index, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeRetAttr</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, attribute_kind: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.removeAttr(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.return_index">return_index</a>, attribute_kind);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addParamAttr</span>(
            self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>,
            param_index: <span class="tok-type">usize</span>,
            attribute: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>,
            builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.addAttr(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + param_index, attribute, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addParamAttrIndex</span>(
            self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>,
            param_index: <span class="tok-type">usize</span>,
            attribute_index: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>,
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.addAttrIndex(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + param_index, attribute_index, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">removeParamAttr</span>(
            self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>,
            param_index: <span class="tok-type">usize</span>,
            attribute_kind: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.removeAttr(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + param_index, attribute_kind);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> {
            <span class="tok-kw">const</span> attributes = <span class="tok-kw">try</span> builder.gpa.alloc(<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>, self.maps.items.len);
            <span class="tok-kw">defer</span> builder.gpa.free(attributes);
            <span class="tok-kw">for</span> (attributes, self.maps.items) |*attribute, map|
                attribute.* = <span class="tok-kw">try</span> builder.attrs(map.values());
            <span class="tok-kw">return</span> builder.fnAttrs(attributes);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">addAttr</span>(
            self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>,
            index: <span class="tok-type">usize</span>,
            attribute: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>,
            builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> map = <span class="tok-kw">try</span> self.getOrPutMap(builder.gpa, index);
            <span class="tok-kw">try</span> map.put(builder.gpa, attribute.getKind(), <span class="tok-kw">try</span> builder.attr(attribute));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">addAttrIndex</span>(
            self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>,
            index: <span class="tok-type">usize</span>,
            attribute_index: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>,
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> map = <span class="tok-kw">try</span> self.getOrPutMap(builder.gpa, index);
            <span class="tok-kw">try</span> map.put(builder.gpa, attribute_index.getKind(builder), attribute_index);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeAttr</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, index: <span class="tok-type">usize</span>, attribute_kind: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Kind.html">Kind</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> map = self.getMap(index) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">return</span> map.swapRemove(attribute_kind);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutMap</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html#std.zig.llvm.Builder.FunctionAttributes.Wip.Map">Map</a> {
            <span class="tok-kw">if</span> (index &gt;= self.maps.items.len)
                <span class="tok-kw">try</span> self.maps.appendNTimes(allocator, .{}, index + <span class="tok-number">1</span> - self.maps.items.len);
            <span class="tok-kw">return</span> &amp;self.maps.items[index];
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getMap</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, index: <span class="tok-type">usize</span>) ?*<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html#std.zig.llvm.Builder.FunctionAttributes.Wip.Map">Map</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">if</span> (index &gt;= self.maps.items.len) <span class="tok-null">null</span> <span class="tok-kw">else</span> &amp;self.maps.items[index];
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalLength</span>(self: *<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a>, new_len: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.maps.appendNTimes(
                .{},
                <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">usize</span>, new_len, self.maps.items.len) <span class="tok-kw">catch</span> <span class="tok-kw">return</span>,
            );
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">func</span>(self: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
        <span class="tok-kw">return</span> self.get(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.function_index">function_index</a>, builder);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ret</span>(self: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
        <span class="tok-kw">return</span> self.get(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.return_index">return_index</a>, builder);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">param</span>(self: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, param_index: <span class="tok-type">usize</span>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
        <span class="tok-kw">return</span> self.get(<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + param_index, builder);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toWip</span>(self: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a> {
        <span class="tok-kw">var</span> wip: <a href="std.zig.llvm.Builder.FunctionAttributes.Wip.html">Wip</a> = .{};
        <span class="tok-kw">errdefer</span> wip.deinit(builder);
        <span class="tok-kw">const</span> attributes_slice = self.slice(builder);
        <span class="tok-kw">try</span> wip.maps.ensureTotalCapacityPrecise(builder.gpa, attributes_slice.len);
        <span class="tok-kw">for</span> (attributes_slice) |attributes| {
            <span class="tok-kw">const</span> map = wip.maps.addOneAssumeCapacity();
            map.* = .{};
            <span class="tok-kw">const</span> attribute_slice = attributes.slice(builder);
            <span class="tok-kw">try</span> map.ensureTotalCapacity(builder.gpa, attribute_slice.len);
            <span class="tok-kw">for</span> (attributes.slice(builder)) |attribute|
                map.putAssumeCapacityNoClobber(attribute.getKind(builder), attribute);
        }
        <span class="tok-kw">return</span> wip;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, index: <span class="tok-type">usize</span>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
        <span class="tok-kw">const</span> attribute_slice = self.slice(builder);
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (index &lt; attribute_slice.len) attribute_slice[index] <span class="tok-kw">else</span> .none;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
        <span class="tok-kw">const</span> start = builder.attributes_indices.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        <span class="tok-kw">const</span> end = builder.attributes_indices.items[<span class="tok-builtin">@intFromEnum</span>(self) + <span class="tok-number">1</span>];
        <span class="tok-kw">return</span> <span class="tok-builtin">@ptrCast</span>(builder.attributes_extra.items[start..end]);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Linkage = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
    private = <span class="tok-number">9</span>,
    internal = <span class="tok-number">3</span>,
    weak = <span class="tok-number">1</span>,
    weak_odr = <span class="tok-number">10</span>,
    linkonce = <span class="tok-number">4</span>,
    linkonce_odr = <span class="tok-number">11</span>,
    available_externally = <span class="tok-number">12</span>,
    appending = <span class="tok-number">2</span>,
    common = <span class="tok-number">8</span>,
    extern_weak = <span class="tok-number">7</span>,
    external = <span class="tok-number">0</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.Linkage.html">Linkage</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self != .external) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(self)});
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">formatOptional</span>(
        data: ?<a href="std.zig.llvm.Builder.Linkage.html">Linkage</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (data) |linkage| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(linkage)});
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmtOptional</span>(self: ?<a href="std.zig.llvm.Builder.Linkage.html">Linkage</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Linkage.html#std.zig.llvm.Builder.Linkage.formatOptional">formatOptional</a>) {
        <span class="tok-kw">return</span> .{ .data = self };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Preemption = <span class="tok-kw">enum</span> {
    dso_preemptable,
    dso_local,
    implicit_dso_local,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.Preemption.html">Preemption</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self == .dso_local) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(self)});
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Visibility = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    default = <span class="tok-number">0</span>,
    hidden = <span class="tok-number">1</span>,
    protected = <span class="tok-number">2</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.Visibility.html">Visibility</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self != .default) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(self)});
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DllStorageClass = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    default = <span class="tok-number">0</span>,
    dllimport = <span class="tok-number">1</span>,
    dllexport = <span class="tok-number">2</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.DllStorageClass.html">DllStorageClass</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self != .default) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(self)});
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ThreadLocal = <span class="tok-kw">enum</span>(<span class="tok-type">u3</span>) {
    default = <span class="tok-number">0</span>,
    generaldynamic = <span class="tok-number">1</span>,
    localdynamic = <span class="tok-number">2</span>,
    initialexec = <span class="tok-number">3</span>,
    localexec = <span class="tok-number">4</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.ThreadLocal.html">ThreadLocal</a>,
        <span class="tok-kw">comptime</span> prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self == .default) <span class="tok-kw">return</span>;
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}thread_local&quot;</span>, .{prefix});
        <span class="tok-kw">if</span> (self != .generaldynamic) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;({s})&quot;</span>, .{<span class="tok-builtin">@tagName</span>(self)});
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Mutability = <span class="tok-kw">enum</span> { global, constant };

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnnamedAddr = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    default = <span class="tok-number">0</span>,
    unnamed_addr = <span class="tok-number">1</span>,
    local_unnamed_addr = <span class="tok-number">2</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.UnnamedAddr.html">UnnamedAddr</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self != .default) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(self)});
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AddrSpace = <span class="tok-kw">enum</span>(<span class="tok-type">u24</span>) {
    default,
    _,<span class="tok-comment">

    // See llvm/lib/Target/X86/X86.h
    </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> x86 = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> gs: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">256</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> fs: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">257</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ss: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">258</span>);

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ptr32_sptr: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">270</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ptr32_uptr: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">271</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ptr64: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">272</span>);
    };
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> x86_64 = <a href="std.zig.llvm.Builder.AddrSpace.x86.html">x86</a>;<span class="tok-comment">

    // See llvm/lib/Target/AVR/AVR.h
    </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> avr = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> data: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> program: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">1</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> program1: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">2</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> program2: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">3</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> program3: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">4</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> program4: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">5</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> program5: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">6</span>);
    };<span class="tok-comment">

    // See llvm/lib/Target/NVPTX/NVPTX.h
    </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> nvptx = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> generic: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> global: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">1</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">2</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> shared: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">3</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> param: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">4</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> local: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">5</span>);
    };<span class="tok-comment">

    // See llvm/lib/Target/AMDGPU/AMDGPU.h
    </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> amdgpu = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> flat: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> global: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">1</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> region: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">2</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> local: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">3</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">4</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> private: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">5</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_32bit: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">6</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> buffer_fat_pointer: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">7</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> buffer_resource: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">8</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> buffer_strided_pointer: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">9</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> param_d: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">6</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> param_i: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">7</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_0: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">8</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_1: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">9</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_2: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">10</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_3: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">11</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_4: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">12</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_5: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">13</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_6: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">14</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_7: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">15</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_8: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">16</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_9: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">17</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_10: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">18</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_11: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">19</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_12: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">20</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_13: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">21</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_14: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">22</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> constant_buffer_15: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">23</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> streamout_register: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">128</span>);
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> spirv = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> function: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> cross_workgroup: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">1</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> uniform_constant: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">2</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> workgroup: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">3</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> generic: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">4</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> device_only_intel: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">5</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> host_only_intel: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">6</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> input: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">7</span>);
    };<span class="tok-comment">

    // See llvm/include/llvm/CodeGen/WasmAddressSpaces.h
    </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> wasm = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> default: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> variable: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">1</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> externref: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">10</span>);
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> funcref: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">20</span>);
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
        <span class="tok-kw">comptime</span> prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self != .default) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}addrspace({d})&quot;</span>, .{ prefix, <span class="tok-builtin">@intFromEnum</span>(self) });
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExternallyInitialized = <span class="tok-kw">enum</span> {
    default,
    externally_initialized,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.ExternallyInitialized.html">ExternallyInitialized</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self == .default) <span class="tok-kw">return</span>;
        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">' '</span>);
        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-builtin">@tagName</span>(self));
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Alignment = <span class="tok-kw">enum</span>(<span class="tok-type">u6</span>) {
    default = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u6</span>),
    _,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromByteUnits</span>(bytes: <span class="tok-type">u64</span>) <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a> {
        <span class="tok-kw">if</span> (bytes == <span class="tok-number">0</span>) <span class="tok-kw">return</span> .default;
        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.isPowerOfTwo">isPowerOfTwo</a>(bytes));
        <a href="std.debug.html#std.debug.assert">assert</a>(bytes &lt;= <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">32</span>);
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@ctz</span>(bytes));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toByteUnits</span>(self: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>) ?<span class="tok-type">u64</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self == .default) <span class="tok-null">null</span> <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@intFromEnum</span>(self);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLlvm</span>(self: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>) <span class="tok-type">u6</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (self == .default) <span class="tok-number">0</span> <span class="tok-kw">else</span> (<span class="tok-builtin">@intFromEnum</span>(self) + <span class="tok-number">1</span>);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        <span class="tok-kw">comptime</span> prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}align {d}&quot;</span>, .{ prefix, self.toByteUnits() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> });
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallConv = <span class="tok-kw">enum</span>(<span class="tok-type">u10</span>) {
    ccc,

    fastcc = <span class="tok-number">8</span>,
    coldcc,
    ghccc,

    webkit_jscc = <span class="tok-number">12</span>,
    anyregcc,
    preserve_mostcc,
    preserve_allcc,
    swiftcc,
    cxx_fast_tlscc,
    tailcc,
    cfguard_checkcc,
    swifttailcc,

    x86_stdcallcc = <span class="tok-number">64</span>,
    x86_fastcallcc,
    arm_apcscc,
    arm_aapcscc,
    arm_aapcs_vfpcc,
    msp430_intrcc,
    x86_thiscallcc,
    ptx_kernel,
    ptx_device,

    spir_func = <span class="tok-number">75</span>,
    spir_kernel,
    intel_ocl_bicc,
    x86_64_sysvcc,
    win64cc,
    x86_vectorcallcc,
    hhvmcc,
    hhvm_ccc,
    x86_intrcc,
    avr_intrcc,
    avr_signalcc,
    avr_builtincc,

    amdgpu_vs = <span class="tok-number">87</span>,
    amdgpu_gs,
    amdgpu_ps,
    amdgpu_cs,
    amdgpu_kernel,
    x86_regcallcc,
    amdgpu_hs,
    msp430_builtincc,

    amdgpu_ls = <span class="tok-number">95</span>,
    amdgpu_es,
    aarch64_vector_pcs,
    aarch64_sve_vector_pcs,

    amdgpu_gfx = <span class="tok-number">100</span>,

    m68k_intrcc,

    aarch64_sme_preservemost_from_x0 = <span class="tok-number">102</span>,
    aarch64_sme_preservemost_from_x2,

    m68k_rtdcc = <span class="tok-number">106</span>,

    riscv_vectorcallcc = <span class="tok-number">110</span>,

    _,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> default = <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="#">ccc</a>;

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (self) {
            <a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a> =&gt; {},
            .fastcc,
            .coldcc,
            .ghccc,
            .webkit_jscc,
            .anyregcc,
            .preserve_mostcc,
            .preserve_allcc,
            .swiftcc,
            .cxx_fast_tlscc,
            .tailcc,
            .cfguard_checkcc,
            .swifttailcc,
            .x86_stdcallcc,
            .x86_fastcallcc,
            .arm_apcscc,
            .arm_aapcscc,
            .arm_aapcs_vfpcc,
            .msp430_intrcc,
            .x86_thiscallcc,
            .ptx_kernel,
            .ptx_device,
            .spir_func,
            .spir_kernel,
            .intel_ocl_bicc,
            .x86_64_sysvcc,
            .win64cc,
            .x86_vectorcallcc,
            .hhvmcc,
            .hhvm_ccc,
            .x86_intrcc,
            .avr_intrcc,
            .avr_signalcc,
            .avr_builtincc,
            .amdgpu_vs,
            .amdgpu_gs,
            .amdgpu_ps,
            .amdgpu_cs,
            .amdgpu_kernel,
            .x86_regcallcc,
            .amdgpu_hs,
            .msp430_builtincc,
            .amdgpu_ls,
            .amdgpu_es,
            .aarch64_vector_pcs,
            .aarch64_sve_vector_pcs,
            .amdgpu_gfx,
            .m68k_intrcc,
            .aarch64_sme_preservemost_from_x0,
            .aarch64_sme_preservemost_from_x2,
            .m68k_rtdcc,
            .riscv_vectorcallcc,
            =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(self)}),
            _ =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; cc{d}&quot;</span>, .{<span class="tok-builtin">@intFromEnum</span>(self)}),
        }
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StrtabString = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>),
    empty,
    _,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isAnon</span>(self: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) <span class="tok-type">bool</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(self != .none);
        <span class="tok-kw">return</span> self.toIndex() == <span class="tok-null">null</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> index = self.toIndex() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
        <span class="tok-kw">const</span> start = builder.strtab_string_indices.items[index];
        <span class="tok-kw">const</span> end = builder.strtab_string_indices.items[index + <span class="tok-number">1</span>];
        <span class="tok-kw">return</span> builder.strtab_string_bytes.items[start..end];
    }

    <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
        string: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    };
    <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        data: <a href="std.zig.llvm.Builder.StrtabString.FormatData.html">FormatData</a>,
        <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;\&quot;r&quot;</span>)) |_|
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid format string: '&quot;</span> ++ fmt_str ++ <span class="tok-str">&quot;'&quot;</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(data.string != .none);
        <span class="tok-kw">const</span> string_slice = data.string.slice(data.builder) <span class="tok-kw">orelse</span>
            <span class="tok-kw">return</span> writer.print(<span class="tok-str">&quot;{d}&quot;</span>, .{<span class="tok-builtin">@intFromEnum</span>(data.string)});
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">'r'</span>)) |_|
            <span class="tok-kw">return</span> writer.writeAll(string_slice);
        <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printEscapedString">printEscapedString</a>(
            string_slice,
            <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">'&quot;'</span>)) |_|
                .always_quote
            <span class="tok-kw">else</span>
                .quote_unless_valid_identifier,
            writer,
        );
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.StrtabString.html#std.zig.llvm.Builder.StrtabString.format">format</a>) {
        <span class="tok-kw">return</span> .{ .data = .{ .string = self, .builder = builder } };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">fromIndex</span>(index: ?<span class="tok-type">usize</span>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>((index <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .none) +
            <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="#">empty</a>))));
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">toIndex</span>(self: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) ?<span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.sub">sub</a>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intFromEnum</span>(self), <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="#">empty</a>)) <span class="tok-kw">catch</span> <span class="tok-null">null</span>;
    }

    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <a href="std.zig.llvm.Builder.StrtabString.Adapter.html">Adapter</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, key));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <a href="std.zig.llvm.Builder.StrtabString.Adapter.html">Adapter</a>, lhs_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_key, <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.html#std.zig.llvm.Builder.StrtabString.fromIndex">fromIndex</a>(rhs_index).slice(ctx.builder).?);
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">try</span> self.strtab_string_bytes.ensureUnusedCapacity(self.gpa, bytes.len);
    <span class="tok-kw">try</span> self.strtab_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.strtab_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> gop = self.strtab_string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        self.strtab_string_bytes.appendSliceAssumeCapacity(bytes);
        self.strtab_string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.strtab_string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.html#std.zig.llvm.Builder.StrtabString.fromIndex">fromIndex</a>(gop.index);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringIfExists</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.html#std.zig.llvm.Builder.StrtabString.fromIndex">fromIndex</a>(
        self.strtab_string_map.getIndexAdapted(bytes, <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.Adapter.html">Adapter</a>{ .builder = self }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringFmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">try</span> self.strtab_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.strtab_string_bytes.ensureUnusedCapacity(self.gpa, <span class="tok-builtin">@intCast</span>(<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(fmt_str, fmt_args)));
    <span class="tok-kw">try</span> self.strtab_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.strtabStringFmtAssumeCapacity(fmt_str, fmt_args);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtabStringFmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    self.strtab_string_bytes.writer(<span class="tok-null">undefined</span>).print(fmt_str, fmt_args) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> self.trailingStrtabStringAssumeCapacity();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStrtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">try</span> self.strtab_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.strtab_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.trailingStrtabStringAssumeCapacity();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStrtabStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
    <span class="tok-kw">const</span> start = self.strtab_string_indices.getLast();
    <span class="tok-kw">const</span> bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = self.strtab_string_bytes.items[start..];
    <span class="tok-kw">const</span> gop = self.strtab_string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (gop.found_existing) {
        self.strtab_string_bytes.shrinkRetainingCapacity(start);
    } <span class="tok-kw">else</span> {
        self.strtab_string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.strtab_string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>.<a href="std.zig.llvm.Builder.StrtabString.html#std.zig.llvm.Builder.StrtabString.fromIndex">fromIndex</a>(gop.index);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Global = <span class="tok-kw">struct</span> {
    linkage: <a href="std.zig.llvm.Builder.Linkage.html">Linkage</a> = .external,
    preemption: <a href="std.zig.llvm.Builder.Preemption.html">Preemption</a> = .dso_preemptable,
    visibility: <a href="std.zig.llvm.Builder.Visibility.html">Visibility</a> = .default,
    dll_storage_class: <a href="std.zig.llvm.Builder.DllStorageClass.html">DllStorageClass</a> = .default,
    unnamed_addr: <a href="std.zig.llvm.Builder.UnnamedAddr.html">UnnamedAddr</a> = .default,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = .default,
    externally_initialized: <a href="std.zig.llvm.Builder.ExternallyInitialized.html">ExternallyInitialized</a> = .default,
    <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    partition: <a href="std.zig.llvm.Builder.String.html">String</a> = .none,
    dbg: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> = .none,
    kind: <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        alias: <a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>,
        variable: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>,
        function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
        replaced: <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>,
    },

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
            <span class="tok-kw">var</span> cur = self;
            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                <span class="tok-kw">const</span> replacement = cur.getReplacement(builder);
                <span class="tok-kw">if</span> (replacement == .none) <span class="tok-kw">return</span> cur;
                cur = replacement;
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, other: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unwrap(builder) == other.unwrap(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) *<a href="std.zig.llvm.Builder.Global.html">Global</a> {
            <span class="tok-kw">return</span> &amp;builder.globals.values()[<span class="tok-builtin">@intFromEnum</span>(self.unwrap(builder))];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Global.html">Global</a> {
            <span class="tok-kw">return</span> &amp;builder.globals.values()[<span class="tok-builtin">@intFromEnum</span>(self.unwrap(builder))];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
            <span class="tok-kw">return</span> builder.globals.keys()[<span class="tok-builtin">@intFromEnum</span>(self.unwrap(builder))];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strtab</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-kw">struct</span> {
            offset: <span class="tok-type">u32</span>,
            size: <span class="tok-type">u32</span>,
        } {
            <span class="tok-kw">const</span> name_index = self.name(builder).toIndex() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> .{
                .offset = <span class="tok-number">0</span>,
                .size = <span class="tok-number">0</span>,
            };

            <span class="tok-kw">return</span> .{
                .offset = builder.strtab_string_indices.items[name_index],
                .size = builder.strtab_string_indices.items[name_index + <span class="tok-number">1</span>] -
                    builder.strtab_string_indices.items[name_index],
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).<span class="tok-type">type</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.html#std.zig.llvm.Builder.Constant.first_global">first_global</a>) + <span class="tok-builtin">@intFromEnum</span>(self));
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLinkage</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, linkage: <a href="std.zig.llvm.Builder.Linkage.html">Linkage</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).linkage = linkage;
            self.updateDsoLocal(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setVisibility</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, visibility: <a href="std.zig.llvm.Builder.Visibility.html">Visibility</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).visibility = visibility;
            self.updateDsoLocal(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setDllStorageClass</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, class: <a href="std.zig.llvm.Builder.DllStorageClass.html">DllStorageClass</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).dll_storage_class = class;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnnamedAddr</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, unnamed_addr: <a href="std.zig.llvm.Builder.UnnamedAddr.html">UnnamedAddr</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).unnamed_addr = unnamed_addr;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setDebugMetadata</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, dbg: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).dbg = dbg;
        }

        <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
            global: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>,
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        };
        <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
            data: <a href="std.zig.llvm.Builder.Global.Index.FormatData.html">FormatData</a>,
            <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
            writer: <span class="tok-kw">anytype</span>,
        ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;@{}&quot;</span>, .{
                data.global.unwrap(data.builder).name(data.builder).fmt(data.builder),
            });
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Global.Index.html#std.zig.llvm.Builder.Global.Index.format">format</a>) {
            <span class="tok-kw">return</span> .{ .data = .{ .global = self, .builder = builder } };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, new_name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> builder.ensureUnusedGlobalCapacity(new_name);
            self.renameAssumeCapacity(new_name, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">takeName</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, other: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> builder.ensureUnusedGlobalCapacity(.empty);
            self.takeNameAssumeCapacity(other, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replace</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, other: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> builder.ensureUnusedGlobalCapacity(.empty);
            self.replaceAssumeCapacity(other, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">delete</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).kind = .{ .replaced = .none };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">updateDsoLocal</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> self_ptr = self.ptr(builder);
            <span class="tok-kw">switch</span> (self_ptr.linkage) {
                .private, .internal =&gt; {
                    self_ptr.visibility = .default;
                    self_ptr.dll_storage_class = .default;
                    self_ptr.preemption = .implicit_dso_local;
                },
                .extern_weak =&gt; <span class="tok-kw">if</span> (self_ptr.preemption == .implicit_dso_local) {
                    self_ptr.preemption = .dso_local;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (self_ptr.visibility) {
                    .default =&gt; <span class="tok-kw">if</span> (self_ptr.preemption == .implicit_dso_local) {
                        self_ptr.preemption = .dso_local;
                    },
                    <span class="tok-kw">else</span> =&gt; self_ptr.preemption = .implicit_dso_local,
                },
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">renameAssumeCapacity</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, new_name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> old_name = self.name(builder);
            <span class="tok-kw">if</span> (new_name == old_name) <span class="tok-kw">return</span>;
            <span class="tok-kw">const</span> index = <span class="tok-builtin">@intFromEnum</span>(self.unwrap(builder));
            _ = builder.addGlobalAssumeCapacity(new_name, builder.globals.values()[index]);
            builder.globals.swapRemoveAt(index);
            <span class="tok-kw">if</span> (!old_name.isAnon()) <span class="tok-kw">return</span>;
            builder.next_unnamed_global = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(builder.next_unnamed_global) - <span class="tok-number">1</span>);
            <span class="tok-kw">if</span> (builder.next_unnamed_global == old_name) <span class="tok-kw">return</span>;
            builder.getGlobal(builder.next_unnamed_global).?.renameAssumeCapacity(old_name, builder);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">takeNameAssumeCapacity</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, other: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> other_name = other.name(builder);
            other.renameAssumeCapacity(.empty, builder);
            self.renameAssumeCapacity(other_name, builder);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">replaceAssumeCapacity</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, other: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.eql(other, builder)) <span class="tok-kw">return</span>;
            builder.next_replaced_global = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(builder.next_replaced_global) - <span class="tok-number">1</span>);
            self.renameAssumeCapacity(builder.next_replaced_global, builder);
            self.ptr(builder).kind = .{ .replaced = other.unwrap(builder) };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getReplacement</span>(self: <a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (builder.globals.values()[<span class="tok-builtin">@intFromEnum</span>(self)].kind) {
                .replaced =&gt; |replacement| replacement,
                <span class="tok-kw">else</span> =&gt; .none,
            };
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Alias = <span class="tok-kw">struct</span> {
    global: <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>,
    thread_local: <a href="std.zig.llvm.Builder.ThreadLocal.html">ThreadLocal</a> = .default,
    aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> = .no_init,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) *<a href="std.zig.llvm.Builder.Alias.html">Alias</a> {
            <span class="tok-kw">return</span> &amp;builder.aliases.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Alias.html">Alias</a> {
            <span class="tok-kw">return</span> &amp;builder.aliases.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.name(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, new_name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.rename(new_name, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.typeOf(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.toConst();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toValue</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
            <span class="tok-kw">return</span> self.toConst(builder).toValue();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAliasee</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
            <span class="tok-kw">const</span> aliasee = self.ptrConst(builder).aliasee.getBase(builder);
            <a href="std.debug.html#std.debug.assert">assert</a>(aliasee != .none);
            <span class="tok-kw">return</span> aliasee;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAliasee</span>(self: <a href="std.zig.llvm.Builder.Alias.Index.html">Index</a>, aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).aliasee = aliasee;
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Variable = <span class="tok-kw">struct</span> {
    global: <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>,
    thread_local: <a href="std.zig.llvm.Builder.ThreadLocal.html">ThreadLocal</a> = .default,
    mutability: <a href="std.zig.llvm.Builder.Mutability.html">Mutability</a> = .global,
    init: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> = .no_init,
    section: <a href="std.zig.llvm.Builder.String.html">String</a> = .none,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a> = .default,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) *<a href="std.zig.llvm.Builder.Variable.html">Variable</a> {
            <span class="tok-kw">return</span> &amp;builder.variables.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Variable.html">Variable</a> {
            <span class="tok-kw">return</span> &amp;builder.variables.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.name(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, new_name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.rename(new_name, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.typeOf(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.toConst();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toValue</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
            <span class="tok-kw">return</span> self.toConst(builder).toValue();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLinkage</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, linkage: <a href="std.zig.llvm.Builder.Linkage.html">Linkage</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.setLinkage(linkage, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setDllStorageClass</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, class: <a href="std.zig.llvm.Builder.DllStorageClass.html">DllStorageClass</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.setDllStorageClass(class, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnnamedAddr</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, unnamed_addr: <a href="std.zig.llvm.Builder.UnnamedAddr.html">UnnamedAddr</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.setUnnamedAddr(unnamed_addr, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setThreadLocal</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, thread_local: <a href="std.zig.llvm.Builder.ThreadLocal.html">ThreadLocal</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).thread_local = thread_local;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setMutability</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, mutability: <a href="std.zig.llvm.Builder.Mutability.html">Mutability</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).mutability = mutability;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setInitializer</span>(
            self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>,
            initializer: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
            builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (initializer != .no_init) {
                <span class="tok-kw">const</span> variable = self.ptrConst(builder);
                <span class="tok-kw">const</span> global = variable.global.ptr(builder);
                <span class="tok-kw">const</span> initializer_type = initializer.typeOf(builder);
                global.<span class="tok-type">type</span> = initializer_type;
            }
            self.ptr(builder).init = initializer;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setSection</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, section: <a href="std.zig.llvm.Builder.String.html">String</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).section = section;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAlignment</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).alignment = alignment;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAlignment</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a> {
            <span class="tok-kw">return</span> self.ptr(builder).alignment;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setGlobalVariableExpression</span>(self: <a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, expression: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptrConst(builder).global.setDebugMetadata(expression, builder);
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Intrinsic = <span class="tok-kw">enum</span> {<span class="tok-comment">
    // Variable Argument Handling
    </span>va_start,
    va_end,
    va_copy,<span class="tok-comment">

    // Code Generator
    </span>returnaddress,
    addressofreturnaddress,
    sponentry,
    frameaddress,
    prefetch,
    @&quot;thread.pointer&quot;,<span class="tok-comment">

    // Standard C/C++ Library
    </span>abs,
    smax,
    smin,
    umax,
    umin,
    memcpy,
    @&quot;memcpy.inline&quot;,
    memmove,
    memset,
    @&quot;memset.inline&quot;,
    sqrt,
    powi,
    sin,
    cos,
    pow,
    exp,
    exp10,
    exp2,
    ldexp,
    frexp,
    <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.log">log</a>,
    log10,
    log2,
    fma,
    fabs,
    minnum,
    maxnum,
    minimum,
    maximum,
    copysign,
    floor,
    ceil,
    trunc,
    rint,
    nearbyint,
    round,
    roundeven,
    lround,
    llround,
    lrint,
    llrint,<span class="tok-comment">

    // Bit Manipulation
    </span>bitreverse,
    bswap,
    ctpop,
    ctlz,
    cttz,
    fshl,
    fshr,<span class="tok-comment">

    // Arithmetic with Overflow
    </span>@&quot;sadd.with.overflow&quot;,
    @&quot;uadd.with.overflow&quot;,
    @&quot;ssub.with.overflow&quot;,
    @&quot;usub.with.overflow&quot;,
    @&quot;smul.with.overflow&quot;,
    @&quot;umul.with.overflow&quot;,<span class="tok-comment">

    // Saturation Arithmetic
    </span>@&quot;sadd.sat&quot;,
    @&quot;uadd.sat&quot;,
    @&quot;ssub.sat&quot;,
    @&quot;usub.sat&quot;,
    @&quot;sshl.sat&quot;,
    @&quot;ushl.sat&quot;,<span class="tok-comment">

    // Fixed Point Arithmetic
    </span>@&quot;smul.fix&quot;,
    @&quot;umul.fix&quot;,
    @&quot;smul.fix.sat&quot;,
    @&quot;umul.fix.sat&quot;,
    @&quot;sdiv.fix&quot;,
    @&quot;udiv.fix&quot;,
    @&quot;sdiv.fix.sat&quot;,
    @&quot;udiv.fix.sat&quot;,<span class="tok-comment">

    // Specialised Arithmetic
    </span>canonicalize,
    fmuladd,<span class="tok-comment">

    // Vector Reduction
    </span>@&quot;vector.reduce.add&quot;,
    @&quot;vector.reduce.fadd&quot;,
    @&quot;vector.reduce.mul&quot;,
    @&quot;vector.reduce.fmul&quot;,
    @&quot;vector.reduce.and&quot;,
    @&quot;vector.reduce.or&quot;,
    @&quot;vector.reduce.xor&quot;,
    @&quot;vector.reduce.smax&quot;,
    @&quot;vector.reduce.smin&quot;,
    @&quot;vector.reduce.umax&quot;,
    @&quot;vector.reduce.umin&quot;,
    @&quot;vector.reduce.fmax&quot;,
    @&quot;vector.reduce.fmin&quot;,
    @&quot;vector.reduce.fmaximum&quot;,
    @&quot;vector.reduce.fminimum&quot;,
    @&quot;vector.insert&quot;,
    @&quot;vector.extract&quot;,<span class="tok-comment">

    // Floating-Point Test
    </span>@&quot;is.fpclass&quot;,<span class="tok-comment">

    // General
    </span>@&quot;var.annotation&quot;,
    @&quot;ptr.annotation&quot;,
    annotation,
    @&quot;codeview.annotation&quot;,
    trap,
    debugtrap,
    ubsantrap,
    stackprotector,
    stackguard,
    objectsize,
    expect,
    @&quot;expect.with.probability&quot;,
    assume,
    @&quot;ssa.copy&quot;,
    @&quot;type.test&quot;,
    @&quot;type.checked.load&quot;,
    @&quot;type.checked.load.relative&quot;,
    @&quot;arithmetic.fence&quot;,
    donothing,
    @&quot;load.relative&quot;,
    sideeffect,
    @&quot;is.constant&quot;,
    ptrmask,
    @&quot;threadlocal.address&quot;,
    vscale,<span class="tok-comment">

    // Debug
    </span>@&quot;dbg.declare&quot;,
    @&quot;dbg.value&quot;,<span class="tok-comment">

    // AMDGPU
    </span>@&quot;amdgcn.workitem.id.x&quot;,
    @&quot;amdgcn.workitem.id.y&quot;,
    @&quot;amdgcn.workitem.id.z&quot;,
    @&quot;amdgcn.workgroup.id.x&quot;,
    @&quot;amdgcn.workgroup.id.y&quot;,
    @&quot;amdgcn.workgroup.id.z&quot;,
    @&quot;amdgcn.dispatch.ptr&quot;,<span class="tok-comment">

    // NVPTX
    </span>@&quot;nvvm.read.ptx.sreg.tid.x&quot;,
    @&quot;nvvm.read.ptx.sreg.tid.y&quot;,
    @&quot;nvvm.read.ptx.sreg.tid.z&quot;,
    @&quot;nvvm.read.ptx.sreg.ntid.x&quot;,
    @&quot;nvvm.read.ptx.sreg.ntid.y&quot;,
    @&quot;nvvm.read.ptx.sreg.ntid.z&quot;,
    @&quot;nvvm.read.ptx.sreg.ctaid.x&quot;,
    @&quot;nvvm.read.ptx.sreg.ctaid.y&quot;,
    @&quot;nvvm.read.ptx.sreg.ctaid.z&quot;,<span class="tok-comment">

    // WebAssembly
    </span>@&quot;wasm.memory.size&quot;,
    @&quot;wasm.memory.grow&quot;,

    <span class="tok-kw">const</span> Signature = <span class="tok-kw">struct</span> {
        ret_len: <span class="tok-type">u8</span>,
        params: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Intrinsic.Signature.Parameter.html">Parameter</a>,
        attrs: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a> = &amp;.{},

        <span class="tok-kw">const</span> Parameter = <span class="tok-kw">struct</span> {
            kind: <a href="std.zig.llvm.Builder.Intrinsic.Signature.Parameter.Kind.html">Kind</a>,
            attrs: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a> = &amp;.{},

            <span class="tok-kw">const</span> Kind = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
                <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                overloaded,
                matches: <span class="tok-type">u8</span>,
                matches_scalar: <span class="tok-type">u8</span>,
                matches_changed_scalar: <span class="tok-kw">struct</span> {
                    index: <span class="tok-type">u8</span>,
                    scalar: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                },
            };
        };
    };

    <span class="tok-kw">const</span> signatures = <a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.EnumArray">EnumArray</a>(<a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>, <a href="std.zig.llvm.Builder.Intrinsic.Signature.html">Signature</a>).init(.{
        .va_start = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn },
        },
        .va_end = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn },
        },
        .va_copy = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn },
        },

        .returnaddress = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .addressofreturnaddress = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .sponentry = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .frameaddress = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .prefetch = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded, .attrs = &amp;.{ .nocapture, .readonly } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.readwrite) } },
        },
        .@&quot;thread.pointer&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .abs = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .smax = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .smin = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .umax = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .umin = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .memcpy = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded, .attrs = &amp;.{ .@&quot;noalias&quot;, .nocapture, .writeonly } },
                .{ .kind = .overloaded, .attrs = &amp;.{ .@&quot;noalias&quot;, .nocapture, .readonly } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nounwind, .willreturn, .{ .memory = .{ .argmem = .readwrite } } },
        },
        .@&quot;memcpy.inline&quot; = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded, .attrs = &amp;.{ .@&quot;noalias&quot;, .nocapture, .writeonly } },
                .{ .kind = .overloaded, .attrs = &amp;.{ .@&quot;noalias&quot;, .nocapture, .readonly } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nounwind, .willreturn, .{ .memory = .{ .argmem = .readwrite } } },
        },
        .memmove = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded, .attrs = &amp;.{ .nocapture, .writeonly } },
                .{ .kind = .overloaded, .attrs = &amp;.{ .nocapture, .readonly } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nounwind, .willreturn, .{ .memory = .{ .argmem = .readwrite } } },
        },
        .memset = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded, .attrs = &amp;.{ .nocapture, .writeonly } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i8</span> } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nounwind, .willreturn, .{ .memory = .{ .argmem = .write } } },
        },
        .@&quot;memset.inline&quot; = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded, .attrs = &amp;.{ .nocapture, .writeonly } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i8</span> } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nounwind, .willreturn, .{ .memory = .{ .argmem = .write } } },
        },
        .sqrt = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .powi = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .sin = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .cos = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .pow = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .exp = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .exp2 = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .exp10 = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .ldexp = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .frexp = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .log = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .log10 = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .log2 = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .fma = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .fabs = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .minnum = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .maxnum = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .minimum = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .maximum = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .copysign = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .floor = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .ceil = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .trunc = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .rint = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .nearbyint = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .round = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .roundeven = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .lround = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .llround = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .lrint = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .llrint = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .bitreverse = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .bswap = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .ctpop = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .ctlz = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .cttz = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .fshl = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .fshr = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;sadd.with.overflow&quot; = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches_changed_scalar = .{ .index = <span class="tok-number">0</span>, .scalar = .<span class="tok-type">i1</span> } } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;uadd.with.overflow&quot; = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches_changed_scalar = .{ .index = <span class="tok-number">0</span>, .scalar = .<span class="tok-type">i1</span> } } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;ssub.with.overflow&quot; = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches_changed_scalar = .{ .index = <span class="tok-number">0</span>, .scalar = .<span class="tok-type">i1</span> } } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;usub.with.overflow&quot; = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches_changed_scalar = .{ .index = <span class="tok-number">0</span>, .scalar = .<span class="tok-type">i1</span> } } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;smul.with.overflow&quot; = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches_changed_scalar = .{ .index = <span class="tok-number">0</span>, .scalar = .<span class="tok-type">i1</span> } } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;umul.with.overflow&quot; = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches_changed_scalar = .{ .index = <span class="tok-number">0</span>, .scalar = .<span class="tok-type">i1</span> } } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;sadd.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;uadd.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;ssub.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;usub.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;sshl.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;ushl.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;smul.fix&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;umul.fix&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;smul.fix.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;umul.fix.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;sdiv.fix&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;udiv.fix&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;sdiv.fix.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;udiv.fix.sat&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .canonicalize = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .fmuladd = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;vector.reduce.add&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.fadd&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">2</span> } },
                .{ .kind = .{ .matches_scalar = <span class="tok-number">2</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.mul&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.fmul&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">2</span> } },
                .{ .kind = .{ .matches_scalar = <span class="tok-number">2</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.and&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.or&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.xor&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.smax&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.smin&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.umax&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.umin&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.fmax&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.fmin&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.fmaximum&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.reduce.fminimum&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_scalar = <span class="tok-number">1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.insert&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i64</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;vector.extract&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i64</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;is.fpclass&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .matches_changed_scalar = .{ .index = <span class="tok-number">1</span>, .scalar = .<span class="tok-type">i1</span> } } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;var.annotation&quot; = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">1</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">1</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = .{ .inaccessiblemem = .readwrite } } },
        },
        .@&quot;ptr.annotation&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">2</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">2</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = .{ .inaccessiblemem = .readwrite } } },
        },
        .annotation = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">2</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = .{ .inaccessiblemem = .readwrite } } },
        },
        .@&quot;codeview.annotation&quot; = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
            },
            .attrs = &amp;.{ .nocallback, .noduplicate, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = .{ .inaccessiblemem = .readwrite } } },
        },
        .trap = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{},
            .attrs = &amp;.{ .cold, .<span class="tok-type">noreturn</span>, .nounwind, .{ .memory = .{ .inaccessiblemem = .write } } },
        },
        .debugtrap = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{},
            .attrs = &amp;.{.nounwind},
        },
        .ubsantrap = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i8</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .cold, .<span class="tok-type">noreturn</span>, .nounwind },
        },
        .stackprotector = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn },
        },
        .stackguard = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn },
        },
        .objectsize = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .expect = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;expect.with.probability&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .double }, .attrs = &amp;.{.immarg} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .assume = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> }, .attrs = &amp;.{.noundef} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = .{ .inaccessiblemem = .write } } },
        },
        .@&quot;ssa.copy&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> }, .attrs = &amp;.{.returned} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;type.test&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;type.checked.load&quot; = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;type.checked.load.relative&quot; = .{
            .ret_len = <span class="tok-number">2</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;arithmetic.fence&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .donothing = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{},
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;load.relative&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .ptr } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = .{ .argmem = .read } } },
        },
        .sideeffect = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{},
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = .{ .inaccessiblemem = .readwrite } } },
        },
        .@&quot;is.constant&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i1</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .convergent, .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .ptrmask = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;threadlocal.address&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded, .attrs = &amp;.{.nonnull} },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> }, .attrs = &amp;.{.nonnull} },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .vscale = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;dbg.declare&quot; = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;dbg.value&quot; = .{
            .ret_len = <span class="tok-number">0</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
                .{ .kind = .{ .<span class="tok-type">type</span> = .metadata } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;amdgcn.workitem.id.x&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;amdgcn.workitem.id.y&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;amdgcn.workitem.id.z&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;amdgcn.workgroup.id.x&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;amdgcn.workgroup.id.y&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;amdgcn.workgroup.id.z&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;amdgcn.dispatch.ptr&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{
                    .kind = .{ .<span class="tok-type">type</span> = <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.html#std.zig.llvm.Builder.Type.ptr_amdgpu_constant">ptr_amdgpu_constant</a> },
                    .attrs = &amp;.{.{ .@&quot;align&quot; = <a href="std.zig.llvm.Builder.html">Builder</a>.<a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>.<a href="std.zig.llvm.Builder.Alignment.html#std.zig.llvm.Builder.Alignment.fromByteUnits">fromByteUnits</a>(<span class="tok-number">4</span>) }},
                },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .speculatable, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },

        .@&quot;nvvm.read.ptx.sreg.tid.x&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },
        .@&quot;nvvm.read.ptx.sreg.tid.y&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },
        .@&quot;nvvm.read.ptx.sreg.tid.z&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },

        .@&quot;nvvm.read.ptx.sreg.ntid.x&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },
        .@&quot;nvvm.read.ptx.sreg.ntid.y&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },
        .@&quot;nvvm.read.ptx.sreg.ntid.z&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },

        .@&quot;nvvm.read.ptx.sreg.ctaid.x&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },
        .@&quot;nvvm.read.ptx.sreg.ctaid.y&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },
        .@&quot;nvvm.read.ptx.sreg.ctaid.z&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nounwind, .readnone },
        },

        .@&quot;wasm.memory.size&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn, .{ .memory = <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html">Memory</a>.<a href="std.zig.llvm.Builder.Attribute.Memory.html#std.zig.llvm.Builder.Attribute.Memory.all">all</a>(.none) } },
        },
        .@&quot;wasm.memory.grow&quot; = .{
            .ret_len = <span class="tok-number">1</span>,
            .params = &amp;.{
                .{ .kind = .overloaded },
                .{ .kind = .{ .<span class="tok-type">type</span> = .<span class="tok-type">i32</span> } },
                .{ .kind = .{ .matches = <span class="tok-number">0</span> } },
            },
            .attrs = &amp;.{ .nocallback, .nofree, .nosync, .nounwind, .willreturn },
        },
    });
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Function = <span class="tok-kw">struct</span> {
    global: <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>,
    call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a> = <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>,
    attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> = .none,
    section: <a href="std.zig.llvm.Builder.String.html">String</a> = .none,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a> = .default,
    blocks: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.Block.html">Block</a> = &amp;.{},
    instructions: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>) = .{},
    names: [*]<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.String.html">String</a> = &amp;[<span class="tok-number">0</span>]<a href="std.zig.llvm.Builder.String.html">String</a>{},
    value_indices: [*]<span class="tok-kw">const</span> <span class="tok-type">u32</span> = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u32</span>{},
    strip: <span class="tok-type">bool</span>,
    debug_locations: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>) = .empty,
    debug_values: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = &amp;.{},
    extra: []<span class="tok-kw">const</span> <span class="tok-type">u32</span> = &amp;.{},

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
        none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>),
        _,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) *<a href="std.zig.llvm.Builder.Function.html">Function</a> {
            <span class="tok-kw">return</span> &amp;builder.functions.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a> {
            <span class="tok-kw">return</span> &amp;builder.functions.items[<span class="tok-builtin">@intFromEnum</span>(self)];
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.name(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">rename</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, new_name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.rename(new_name, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.typeOf(builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.toConst();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toValue</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
            <span class="tok-kw">return</span> self.toConst(builder).toValue();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setLinkage</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, linkage: <a href="std.zig.llvm.Builder.Linkage.html">Linkage</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.setLinkage(linkage, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setUnnamedAddr</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, unnamed_addr: <a href="std.zig.llvm.Builder.UnnamedAddr.html">UnnamedAddr</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ptrConst(builder).global.setUnnamedAddr(unnamed_addr, builder);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setCallConv</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).call_conv = call_conv;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAttributes</span>(
            self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
            new_function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
            builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
        ) <span class="tok-type">void</span> {
            self.ptr(builder).attributes = new_function_attributes;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setSection</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, section: <a href="std.zig.llvm.Builder.String.html">String</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).section = section;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setAlignment</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptr(builder).alignment = alignment;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setSubprogram</span>(self: <a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, subprogram: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
            self.ptrConst(builder).global.setDebugMetadata(subprogram, builder);
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Block = <span class="tok-kw">struct</span> {
        instruction: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>;
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Instruction = <span class="tok-kw">struct</span> {
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        data: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
            add,
            @&quot;add nsw&quot;,
            @&quot;add nuw&quot;,
            @&quot;add nuw nsw&quot;,
            addrspacecast,
            alloca,
            @&quot;alloca inalloca&quot;,
            @&quot;and&quot;,
            <a href="std.zig.llvm.Builder.Function.html#std.zig.llvm.Builder.Function.arg">arg</a>,
            ashr,
            @&quot;ashr exact&quot;,
            atomicrmw,
            bitcast,
            block,
            br,
            br_cond,
            call,
            @&quot;call fast&quot;,
            cmpxchg,
            @&quot;cmpxchg weak&quot;,
            extractelement,
            extractvalue,
            fadd,
            @&quot;fadd fast&quot;,
            @&quot;fcmp false&quot;,
            @&quot;fcmp fast false&quot;,
            @&quot;fcmp fast oeq&quot;,
            @&quot;fcmp fast oge&quot;,
            @&quot;fcmp fast ogt&quot;,
            @&quot;fcmp fast ole&quot;,
            @&quot;fcmp fast olt&quot;,
            @&quot;fcmp fast one&quot;,
            @&quot;fcmp fast ord&quot;,
            @&quot;fcmp fast true&quot;,
            @&quot;fcmp fast ueq&quot;,
            @&quot;fcmp fast uge&quot;,
            @&quot;fcmp fast ugt&quot;,
            @&quot;fcmp fast ule&quot;,
            @&quot;fcmp fast ult&quot;,
            @&quot;fcmp fast une&quot;,
            @&quot;fcmp fast uno&quot;,
            @&quot;fcmp oeq&quot;,
            @&quot;fcmp oge&quot;,
            @&quot;fcmp ogt&quot;,
            @&quot;fcmp ole&quot;,
            @&quot;fcmp olt&quot;,
            @&quot;fcmp one&quot;,
            @&quot;fcmp ord&quot;,
            @&quot;fcmp true&quot;,
            @&quot;fcmp ueq&quot;,
            @&quot;fcmp uge&quot;,
            @&quot;fcmp ugt&quot;,
            @&quot;fcmp ule&quot;,
            @&quot;fcmp ult&quot;,
            @&quot;fcmp une&quot;,
            @&quot;fcmp uno&quot;,
            fdiv,
            @&quot;fdiv fast&quot;,
            fence,
            fmul,
            @&quot;fmul fast&quot;,
            fneg,
            @&quot;fneg fast&quot;,
            fpext,
            fptosi,
            fptoui,
            fptrunc,
            frem,
            @&quot;frem fast&quot;,
            fsub,
            @&quot;fsub fast&quot;,
            getelementptr,
            @&quot;getelementptr inbounds&quot;,
            @&quot;icmp eq&quot;,
            @&quot;icmp ne&quot;,
            @&quot;icmp sge&quot;,
            @&quot;icmp sgt&quot;,
            @&quot;icmp sle&quot;,
            @&quot;icmp slt&quot;,
            @&quot;icmp uge&quot;,
            @&quot;icmp ugt&quot;,
            @&quot;icmp ule&quot;,
            @&quot;icmp ult&quot;,
            indirectbr,
            insertelement,
            insertvalue,
            inttoptr,
            load,
            @&quot;load atomic&quot;,
            lshr,
            @&quot;lshr exact&quot;,
            mul,
            @&quot;mul nsw&quot;,
            @&quot;mul nuw&quot;,
            @&quot;mul nuw nsw&quot;,
            @&quot;musttail call&quot;,
            @&quot;musttail call fast&quot;,
            @&quot;notail call&quot;,
            @&quot;notail call fast&quot;,
            @&quot;or&quot;,
            phi,
            @&quot;phi fast&quot;,
            ptrtoint,
            ret,
            @&quot;ret void&quot;,
            sdiv,
            @&quot;sdiv exact&quot;,
            select,
            @&quot;select fast&quot;,
            sext,
            shl,
            @&quot;shl nsw&quot;,
            @&quot;shl nuw&quot;,
            @&quot;shl nuw nsw&quot;,
            shufflevector,
            sitofp,
            srem,
            store,
            @&quot;store atomic&quot;,
            sub,
            @&quot;sub nsw&quot;,
            @&quot;sub nuw&quot;,
            @&quot;sub nuw nsw&quot;,
            @&quot;switch&quot;,
            @&quot;tail call&quot;,
            @&quot;tail call fast&quot;,
            trunc,
            udiv,
            @&quot;udiv exact&quot;,
            urem,
            uitofp,
            @&quot;unreachable&quot;,
            va_arg,
            xor,
            zext,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBinaryOpcode</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>) <a href="std.zig.llvm.Builder.BinaryOpcode.html">BinaryOpcode</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .@&quot;add nuw nsw&quot;,
                    .fadd,
                    .@&quot;fadd fast&quot;,
                    =&gt; .add,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .@&quot;sub nuw nsw&quot;,
                    .fsub,
                    .@&quot;fsub fast&quot;,
                    =&gt; .sub,
                    .sdiv,
                    .@&quot;sdiv exact&quot;,
                    .fdiv,
                    .@&quot;fdiv fast&quot;,
                    =&gt; .sdiv,
                    .fmul,
                    .@&quot;fmul fast&quot;,
                    .mul,
                    .@&quot;mul nsw&quot;,
                    .@&quot;mul nuw&quot;,
                    .@&quot;mul nuw nsw&quot;,
                    =&gt; .mul,
                    .srem,
                    .frem,
                    .@&quot;frem fast&quot;,
                    =&gt; .srem,
                    .udiv,
                    .@&quot;udiv exact&quot;,
                    =&gt; .udiv,
                    .shl,
                    .@&quot;shl nsw&quot;,
                    .@&quot;shl nuw&quot;,
                    .@&quot;shl nuw nsw&quot;,
                    =&gt; .shl,
                    .lshr,
                    .@&quot;lshr exact&quot;,
                    =&gt; .lshr,
                    .ashr,
                    .@&quot;ashr exact&quot;,
                    =&gt; .ashr,
                    .@&quot;and&quot; =&gt; .@&quot;and&quot;,
                    .@&quot;or&quot; =&gt; .@&quot;or&quot;,
                    .xor =&gt; .xor,
                    .urem =&gt; .urem,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toCastOpcode</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>) <a href="std.zig.llvm.Builder.CastOpcode.html">CastOpcode</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
                    .trunc =&gt; .trunc,
                    .zext =&gt; .zext,
                    .sext =&gt; .sext,
                    .fptoui =&gt; .fptoui,
                    .fptosi =&gt; .fptosi,
                    .uitofp =&gt; .uitofp,
                    .sitofp =&gt; .sitofp,
                    .fptrunc =&gt; .fptrunc,
                    .fpext =&gt; .fpext,
                    .ptrtoint =&gt; .ptrtoint,
                    .inttoptr =&gt; .inttoptr,
                    .bitcast =&gt; .bitcast,
                    .addrspacecast =&gt; .addrspacecast,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toCmpPredicate</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>) <a href="std.zig.llvm.Builder.CmpPredicate.html">CmpPredicate</a> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
                    .@&quot;fcmp false&quot;,
                    .@&quot;fcmp fast false&quot;,
                    =&gt; .fcmp_false,
                    .@&quot;fcmp oeq&quot;,
                    .@&quot;fcmp fast oeq&quot;,
                    =&gt; .fcmp_oeq,
                    .@&quot;fcmp oge&quot;,
                    .@&quot;fcmp fast oge&quot;,
                    =&gt; .fcmp_oge,
                    .@&quot;fcmp ogt&quot;,
                    .@&quot;fcmp fast ogt&quot;,
                    =&gt; .fcmp_ogt,
                    .@&quot;fcmp ole&quot;,
                    .@&quot;fcmp fast ole&quot;,
                    =&gt; .fcmp_ole,
                    .@&quot;fcmp olt&quot;,
                    .@&quot;fcmp fast olt&quot;,
                    =&gt; .fcmp_olt,
                    .@&quot;fcmp one&quot;,
                    .@&quot;fcmp fast one&quot;,
                    =&gt; .fcmp_one,
                    .@&quot;fcmp ord&quot;,
                    .@&quot;fcmp fast ord&quot;,
                    =&gt; .fcmp_ord,
                    .@&quot;fcmp true&quot;,
                    .@&quot;fcmp fast true&quot;,
                    =&gt; .fcmp_true,
                    .@&quot;fcmp ueq&quot;,
                    .@&quot;fcmp fast ueq&quot;,
                    =&gt; .fcmp_ueq,
                    .@&quot;fcmp uge&quot;,
                    .@&quot;fcmp fast uge&quot;,
                    =&gt; .fcmp_uge,
                    .@&quot;fcmp ugt&quot;,
                    .@&quot;fcmp fast ugt&quot;,
                    =&gt; .fcmp_ugt,
                    .@&quot;fcmp ule&quot;,
                    .@&quot;fcmp fast ule&quot;,
                    =&gt; .fcmp_ule,
                    .@&quot;fcmp ult&quot;,
                    .@&quot;fcmp fast ult&quot;,
                    =&gt; .fcmp_ult,
                    .@&quot;fcmp une&quot;,
                    .@&quot;fcmp fast une&quot;,
                    =&gt; .fcmp_une,
                    .@&quot;fcmp uno&quot;,
                    .@&quot;fcmp fast uno&quot;,
                    =&gt; .fcmp_uno,
                    .@&quot;icmp eq&quot; =&gt; .icmp_eq,
                    .@&quot;icmp ne&quot; =&gt; .icmp_ne,
                    .@&quot;icmp sge&quot; =&gt; .icmp_sge,
                    .@&quot;icmp sgt&quot; =&gt; .icmp_sgt,
                    .@&quot;icmp sle&quot; =&gt; .icmp_sle,
                    .@&quot;icmp slt&quot; =&gt; .icmp_slt,
                    .@&quot;icmp uge&quot; =&gt; .icmp_uge,
                    .@&quot;icmp ugt&quot; =&gt; .icmp_ugt,
                    .@&quot;icmp ule&quot; =&gt; .icmp_ule,
                    .@&quot;icmp ult&quot; =&gt; .icmp_ult,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                };
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
            none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>),
            _,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">name</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, function: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>) <a href="std.zig.llvm.Builder.String.html">String</a> {
                <span class="tok-kw">return</span> function.names[<span class="tok-builtin">@intFromEnum</span>(self)];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueIndex</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, function: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> function.value_indices[<span class="tok-builtin">@intFromEnum</span>(self)];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toValue</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(self));
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isTerminatorWip</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, wip: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (wip.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(self)]) {
                    .br,
                    .br_cond,
                    .indirectbr,
                    .ret,
                    .@&quot;ret void&quot;,
                    .@&quot;switch&quot;,
                    .@&quot;unreachable&quot;,
                    =&gt; <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hasResultWip</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, wip: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <span class="tok-type">bool</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (wip.instructions.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(self)]) {
                    .br,
                    .br_cond,
                    .fence,
                    .indirectbr,
                    .ret,
                    .@&quot;ret void&quot;,
                    .store,
                    .@&quot;store atomic&quot;,
                    .@&quot;switch&quot;,
                    .@&quot;unreachable&quot;,
                    .block,
                    =&gt; <span class="tok-null">false</span>,
                    .call,
                    .@&quot;call fast&quot;,
                    .@&quot;musttail call&quot;,
                    .@&quot;musttail call fast&quot;,
                    .@&quot;notail call&quot;,
                    .@&quot;notail call fast&quot;,
                    .@&quot;tail call&quot;,
                    .@&quot;tail call fast&quot;,
                    =&gt; self.typeOfWip(wip) != .<span class="tok-type">void</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">true</span>,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOfWip</span>(self: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, wip: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
                <span class="tok-kw">const</span> instruction = wip.instructions.get(<span class="tok-builtin">@intFromEnum</span>(self));
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (instruction.tag) {
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .@&quot;add nuw nsw&quot;,
                    .@&quot;and&quot;,
                    .ashr,
                    .@&quot;ashr exact&quot;,
                    .fadd,
                    .@&quot;fadd fast&quot;,
                    .fdiv,
                    .@&quot;fdiv fast&quot;,
                    .fmul,
                    .@&quot;fmul fast&quot;,
                    .frem,
                    .@&quot;frem fast&quot;,
                    .fsub,
                    .@&quot;fsub fast&quot;,
                    .lshr,
                    .@&quot;lshr exact&quot;,
                    .mul,
                    .@&quot;mul nsw&quot;,
                    .@&quot;mul nuw&quot;,
                    .@&quot;mul nuw nsw&quot;,
                    .@&quot;or&quot;,
                    .sdiv,
                    .@&quot;sdiv exact&quot;,
                    .shl,
                    .@&quot;shl nsw&quot;,
                    .@&quot;shl nuw&quot;,
                    .@&quot;shl nuw nsw&quot;,
                    .srem,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .@&quot;sub nuw nsw&quot;,
                    .udiv,
                    .@&quot;udiv exact&quot;,
                    .urem,
                    .xor,
                    =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data).lhs.typeOfWip(wip),
                    .addrspacecast,
                    .bitcast,
                    .fpext,
                    .fptosi,
                    .fptoui,
                    .fptrunc,
                    .inttoptr,
                    .ptrtoint,
                    .sext,
                    .sitofp,
                    .trunc,
                    .uitofp,
                    .zext,
                    =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, instruction.data).<span class="tok-type">type</span>,
                    .alloca,
                    .@&quot;alloca inalloca&quot;,
                    =&gt; wip.builder.ptrTypeAssumeCapacity(
                        wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, instruction.data).info.addr_space,
                    ),
                    .arg =&gt; wip.function.typeOf(wip.builder)
                        .functionParameters(wip.builder)[instruction.data],
                    .atomicrmw =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, instruction.data).val.typeOfWip(wip),
                    .block =&gt; .label,
                    .br,
                    .br_cond,
                    .fence,
                    .indirectbr,
                    .ret,
                    .@&quot;ret void&quot;,
                    .store,
                    .@&quot;store atomic&quot;,
                    .@&quot;switch&quot;,
                    .@&quot;unreachable&quot;,
                    =&gt; .none,
                    .call,
                    .@&quot;call fast&quot;,
                    .@&quot;musttail call&quot;,
                    .@&quot;musttail call fast&quot;,
                    .@&quot;notail call&quot;,
                    .@&quot;notail call fast&quot;,
                    .@&quot;tail call&quot;,
                    .@&quot;tail call fast&quot;,
                    =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, instruction.data).ty.functionReturn(wip.builder),
                    .cmpxchg,
                    .@&quot;cmpxchg weak&quot;,
                    =&gt; wip.builder.structTypeAssumeCapacity(.normal, &amp;.{
                        wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, instruction.data).cmp.typeOfWip(wip),
                        .<span class="tok-type">i1</span>,
                    }),
                    .extractelement =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, instruction.data)
                        .val.typeOfWip(wip).childType(wip.builder),
                    .extractvalue =&gt; {
                        <span class="tok-kw">var</span> extra = wip.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, wip);
                        <span class="tok-kw">return</span> extra.data.val.typeOfWip(wip).childTypeAt(indices, wip.builder);
                    },
                    .@&quot;fcmp false&quot;,
                    .@&quot;fcmp fast false&quot;,
                    .@&quot;fcmp fast oeq&quot;,
                    .@&quot;fcmp fast oge&quot;,
                    .@&quot;fcmp fast ogt&quot;,
                    .@&quot;fcmp fast ole&quot;,
                    .@&quot;fcmp fast olt&quot;,
                    .@&quot;fcmp fast one&quot;,
                    .@&quot;fcmp fast ord&quot;,
                    .@&quot;fcmp fast true&quot;,
                    .@&quot;fcmp fast ueq&quot;,
                    .@&quot;fcmp fast uge&quot;,
                    .@&quot;fcmp fast ugt&quot;,
                    .@&quot;fcmp fast ule&quot;,
                    .@&quot;fcmp fast ult&quot;,
                    .@&quot;fcmp fast une&quot;,
                    .@&quot;fcmp fast uno&quot;,
                    .@&quot;fcmp oeq&quot;,
                    .@&quot;fcmp oge&quot;,
                    .@&quot;fcmp ogt&quot;,
                    .@&quot;fcmp ole&quot;,
                    .@&quot;fcmp olt&quot;,
                    .@&quot;fcmp one&quot;,
                    .@&quot;fcmp ord&quot;,
                    .@&quot;fcmp true&quot;,
                    .@&quot;fcmp ueq&quot;,
                    .@&quot;fcmp uge&quot;,
                    .@&quot;fcmp ugt&quot;,
                    .@&quot;fcmp ule&quot;,
                    .@&quot;fcmp ult&quot;,
                    .@&quot;fcmp une&quot;,
                    .@&quot;fcmp uno&quot;,
                    .@&quot;icmp eq&quot;,
                    .@&quot;icmp ne&quot;,
                    .@&quot;icmp sge&quot;,
                    .@&quot;icmp sgt&quot;,
                    .@&quot;icmp sle&quot;,
                    .@&quot;icmp slt&quot;,
                    .@&quot;icmp uge&quot;,
                    .@&quot;icmp ugt&quot;,
                    .@&quot;icmp ule&quot;,
                    .@&quot;icmp ult&quot;,
                    =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data).lhs.typeOfWip(wip)
                        .changeScalarAssumeCapacity(.<span class="tok-type">i1</span>, wip.builder),
                    .fneg,
                    .@&quot;fneg fast&quot;,
                    =&gt; <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Value.html">Value</a>, <span class="tok-builtin">@enumFromInt</span>(instruction.data)).typeOfWip(wip),
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = wip.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, wip);
                        <span class="tok-kw">const</span> base_ty = extra.data.base.typeOfWip(wip);
                        <span class="tok-kw">if</span> (!base_ty.isVector(wip.builder)) <span class="tok-kw">for</span> (indices) |index| {
                            <span class="tok-kw">const</span> index_ty = index.typeOfWip(wip);
                            <span class="tok-kw">if</span> (!index_ty.isVector(wip.builder)) <span class="tok-kw">continue</span>;
                            <span class="tok-kw">return</span> index_ty.changeScalarAssumeCapacity(base_ty, wip.builder);
                        };
                        <span class="tok-kw">return</span> base_ty;
                    },
                    .insertelement =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, instruction.data).val.typeOfWip(wip),
                    .insertvalue =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, instruction.data).val.typeOfWip(wip),
                    .load,
                    .@&quot;load atomic&quot;,
                    =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, instruction.data).<span class="tok-type">type</span>,
                    .phi,
                    .@&quot;phi fast&quot;,
                    =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data).<span class="tok-type">type</span>,
                    .select,
                    .@&quot;select fast&quot;,
                    =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, instruction.data).lhs.typeOfWip(wip),
                    .shufflevector =&gt; {
                        <span class="tok-kw">const</span> extra = wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, instruction.data);
                        <span class="tok-kw">return</span> extra.lhs.typeOfWip(wip).changeLengthAssumeCapacity(
                            extra.mask.typeOfWip(wip).vectorLen(wip.builder),
                            wip.builder,
                        );
                    },
                    .va_arg =&gt; wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, instruction.data).<span class="tok-type">type</span>,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(
                self: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,
                function_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
                builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
            ) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
                <span class="tok-kw">const</span> function = function_index.ptrConst(builder);
                <span class="tok-kw">const</span> instruction = function.instructions.get(<span class="tok-builtin">@intFromEnum</span>(self));
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (instruction.tag) {
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .@&quot;add nuw nsw&quot;,
                    .@&quot;and&quot;,
                    .ashr,
                    .@&quot;ashr exact&quot;,
                    .fadd,
                    .@&quot;fadd fast&quot;,
                    .fdiv,
                    .@&quot;fdiv fast&quot;,
                    .fmul,
                    .@&quot;fmul fast&quot;,
                    .frem,
                    .@&quot;frem fast&quot;,
                    .fsub,
                    .@&quot;fsub fast&quot;,
                    .lshr,
                    .@&quot;lshr exact&quot;,
                    .mul,
                    .@&quot;mul nsw&quot;,
                    .@&quot;mul nuw&quot;,
                    .@&quot;mul nuw nsw&quot;,
                    .@&quot;or&quot;,
                    .sdiv,
                    .@&quot;sdiv exact&quot;,
                    .shl,
                    .@&quot;shl nsw&quot;,
                    .@&quot;shl nuw&quot;,
                    .@&quot;shl nuw nsw&quot;,
                    .srem,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .@&quot;sub nuw nsw&quot;,
                    .udiv,
                    .@&quot;udiv exact&quot;,
                    .urem,
                    .xor,
                    =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data).lhs.typeOf(function_index, builder),
                    .addrspacecast,
                    .bitcast,
                    .fpext,
                    .fptosi,
                    .fptoui,
                    .fptrunc,
                    .inttoptr,
                    .ptrtoint,
                    .sext,
                    .sitofp,
                    .trunc,
                    .uitofp,
                    .zext,
                    =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, instruction.data).<span class="tok-type">type</span>,
                    .alloca,
                    .@&quot;alloca inalloca&quot;,
                    =&gt; builder.ptrTypeAssumeCapacity(
                        function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, instruction.data).info.addr_space,
                    ),
                    .arg =&gt; function.global.typeOf(builder)
                        .functionParameters(builder)[instruction.data],
                    .atomicrmw =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, instruction.data)
                        .val.typeOf(function_index, builder),
                    .block =&gt; .label,
                    .br,
                    .br_cond,
                    .fence,
                    .indirectbr,
                    .ret,
                    .@&quot;ret void&quot;,
                    .store,
                    .@&quot;store atomic&quot;,
                    .@&quot;switch&quot;,
                    .@&quot;unreachable&quot;,
                    =&gt; .none,
                    .call,
                    .@&quot;call fast&quot;,
                    .@&quot;musttail call&quot;,
                    .@&quot;musttail call fast&quot;,
                    .@&quot;notail call&quot;,
                    .@&quot;notail call fast&quot;,
                    .@&quot;tail call&quot;,
                    .@&quot;tail call fast&quot;,
                    =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, instruction.data).ty.functionReturn(builder),
                    .cmpxchg,
                    .@&quot;cmpxchg weak&quot;,
                    =&gt; builder.structTypeAssumeCapacity(.normal, &amp;.{
                        function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, instruction.data)
                            .cmp.typeOf(function_index, builder),
                        .<span class="tok-type">i1</span>,
                    }),
                    .extractelement =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, instruction.data)
                        .val.typeOf(function_index, builder).childType(builder),
                    .extractvalue =&gt; {
                        <span class="tok-kw">var</span> extra = function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, function);
                        <span class="tok-kw">return</span> extra.data.val.typeOf(function_index, builder)
                            .childTypeAt(indices, builder);
                    },
                    .@&quot;fcmp false&quot;,
                    .@&quot;fcmp fast false&quot;,
                    .@&quot;fcmp fast oeq&quot;,
                    .@&quot;fcmp fast oge&quot;,
                    .@&quot;fcmp fast ogt&quot;,
                    .@&quot;fcmp fast ole&quot;,
                    .@&quot;fcmp fast olt&quot;,
                    .@&quot;fcmp fast one&quot;,
                    .@&quot;fcmp fast ord&quot;,
                    .@&quot;fcmp fast true&quot;,
                    .@&quot;fcmp fast ueq&quot;,
                    .@&quot;fcmp fast uge&quot;,
                    .@&quot;fcmp fast ugt&quot;,
                    .@&quot;fcmp fast ule&quot;,
                    .@&quot;fcmp fast ult&quot;,
                    .@&quot;fcmp fast une&quot;,
                    .@&quot;fcmp fast uno&quot;,
                    .@&quot;fcmp oeq&quot;,
                    .@&quot;fcmp oge&quot;,
                    .@&quot;fcmp ogt&quot;,
                    .@&quot;fcmp ole&quot;,
                    .@&quot;fcmp olt&quot;,
                    .@&quot;fcmp one&quot;,
                    .@&quot;fcmp ord&quot;,
                    .@&quot;fcmp true&quot;,
                    .@&quot;fcmp ueq&quot;,
                    .@&quot;fcmp uge&quot;,
                    .@&quot;fcmp ugt&quot;,
                    .@&quot;fcmp ule&quot;,
                    .@&quot;fcmp ult&quot;,
                    .@&quot;fcmp une&quot;,
                    .@&quot;fcmp uno&quot;,
                    .@&quot;icmp eq&quot;,
                    .@&quot;icmp ne&quot;,
                    .@&quot;icmp sge&quot;,
                    .@&quot;icmp sgt&quot;,
                    .@&quot;icmp sle&quot;,
                    .@&quot;icmp slt&quot;,
                    .@&quot;icmp uge&quot;,
                    .@&quot;icmp ugt&quot;,
                    .@&quot;icmp ule&quot;,
                    .@&quot;icmp ult&quot;,
                    =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data).lhs.typeOf(function_index, builder)
                        .changeScalarAssumeCapacity(.<span class="tok-type">i1</span>, builder),
                    .fneg,
                    .@&quot;fneg fast&quot;,
                    =&gt; <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Value.html">Value</a>, <span class="tok-builtin">@enumFromInt</span>(instruction.data)).typeOf(function_index, builder),
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, function);
                        <span class="tok-kw">const</span> base_ty = extra.data.base.typeOf(function_index, builder);
                        <span class="tok-kw">if</span> (!base_ty.isVector(builder)) <span class="tok-kw">for</span> (indices) |index| {
                            <span class="tok-kw">const</span> index_ty = index.typeOf(function_index, builder);
                            <span class="tok-kw">if</span> (!index_ty.isVector(builder)) <span class="tok-kw">continue</span>;
                            <span class="tok-kw">return</span> index_ty.changeScalarAssumeCapacity(base_ty, builder);
                        };
                        <span class="tok-kw">return</span> base_ty;
                    },
                    .insertelement =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, instruction.data)
                        .val.typeOf(function_index, builder),
                    .insertvalue =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, instruction.data)
                        .val.typeOf(function_index, builder),
                    .load,
                    .@&quot;load atomic&quot;,
                    =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, instruction.data).<span class="tok-type">type</span>,
                    .phi,
                    .@&quot;phi fast&quot;,
                    =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data).<span class="tok-type">type</span>,
                    .select,
                    .@&quot;select fast&quot;,
                    =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, instruction.data).lhs.typeOf(function_index, builder),
                    .shufflevector =&gt; {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, instruction.data);
                        <span class="tok-kw">return</span> extra.lhs.typeOf(function_index, builder).changeLengthAssumeCapacity(
                            extra.mask.typeOf(function_index, builder).vectorLen(builder),
                            builder,
                        );
                    },
                    .va_arg =&gt; function.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, instruction.data).<span class="tok-type">type</span>,
                };
            }

            <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
                instruction: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,
                function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
                builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
            };
            <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
                data: <a href="std.zig.llvm.Builder.Function.Instruction.Index.FormatData.html">FormatData</a>,
                <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
                writer: <span class="tok-kw">anytype</span>,
            ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
                <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;, %&quot;</span>)) |_|
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid format string: '&quot;</span> ++ fmt_str ++ <span class="tok-str">&quot;'&quot;</span>);
                <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">','</span>) != <span class="tok-null">null</span>) {
                    <span class="tok-kw">if</span> (data.instruction == .none) <span class="tok-kw">return</span>;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">','</span>);
                }
                <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">' '</span>) != <span class="tok-null">null</span>) {
                    <span class="tok-kw">if</span> (data.instruction == .none) <span class="tok-kw">return</span>;
                    <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">' '</span>);
                }
                <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">'%'</span>) != <span class="tok-null">null</span>) <span class="tok-kw">try</span> writer.print(
                    <span class="tok-str">&quot;{%} &quot;</span>,
                    .{data.instruction.typeOf(data.function, data.builder).fmt(data.builder)},
                );
                <a href="std.debug.html#std.debug.assert">assert</a>(data.instruction != .none);
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;%{}&quot;</span>, .{
                    data.instruction.name(data.function.ptrConst(data.builder)).fmt(data.builder),
                });
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(
                self: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,
                function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
                builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
            ) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Function.Instruction.Index.html#std.zig.llvm.Builder.Function.Instruction.Index.format">format</a>) {
                <span class="tok-kw">return</span> .{ .data = .{ .instruction = self, .function = function, .builder = builder } };
            }
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExtraIndex = <span class="tok-type">u32</span>;

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BrCond = <span class="tok-kw">struct</span> {
            cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            then: <a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
            @&quot;else&quot;: <a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
            weights: <a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Weights = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {<span class="tok-comment">
                // We can do this as metadata indices 0 and 1 are reserved.
                </span>none = <span class="tok-number">0</span>,
                unpredictable = <span class="tok-number">1</span>,
                <span class="tok-comment">/// These values should be converted to `Metadata` to be used</span>
                <span class="tok-comment">/// in a `prof` annotation providing branch weights.</span>
                _,
            };
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Switch = <span class="tok-kw">struct</span> {
            val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            default: <a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
            cases_len: <span class="tok-type">u32</span>,
            weights: <a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,<span class="tok-comment">
            //case_vals: [cases_len]Constant,
            //case_blocks: [cases_len]Block.Index,
        </span>};

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> IndirectBr = <span class="tok-kw">struct</span> {
            addr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            targets_len: <span class="tok-type">u32</span>,<span class="tok-comment">
            //targets: [targets_len]Block.Index,
        </span>};

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Binary = <span class="tok-kw">struct</span> {
            lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExtractElement = <span class="tok-kw">struct</span> {
            val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            index: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InsertElement = <span class="tok-kw">struct</span> {
            val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            index: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ShuffleVector = <span class="tok-kw">struct</span> {
            lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            mask: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExtractValue = <span class="tok-kw">struct</span> {
            val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            indices_len: <span class="tok-type">u32</span>,<span class="tok-comment">
            //indices: [indices_len]u32,
        </span>};

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InsertValue = <span class="tok-kw">struct</span> {
            val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            indices_len: <span class="tok-type">u32</span>,<span class="tok-comment">
            //indices: [indices_len]u32,
        </span>};

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Alloca = <span class="tok-kw">struct</span> {
            <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
            len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            info: <a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> { normal, inalloca };
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Info = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
                alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
                _: <span class="tok-type">u2</span> = <span class="tok-null">undefined</span>,
            };
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Load = <span class="tok-kw">struct</span> {
            info: <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
            <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
            ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Store = <span class="tok-kw">struct</span> {
            info: <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
            val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CmpXchg = <span class="tok-kw">struct</span> {
            info: <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
            ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            cmp: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            new: <a href="std.zig.llvm.Builder.Value.html">Value</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> { strong, weak };
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicRmw = <span class="tok-kw">struct</span> {
            info: <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
            ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Operation = <span class="tok-kw">enum</span>(<span class="tok-type">u5</span>) {
                xchg = <span class="tok-number">0</span>,
                add = <span class="tok-number">1</span>,
                sub = <span class="tok-number">2</span>,
                @&quot;and&quot; = <span class="tok-number">3</span>,
                nand = <span class="tok-number">4</span>,
                @&quot;or&quot; = <span class="tok-number">5</span>,
                xor = <span class="tok-number">6</span>,
                max = <span class="tok-number">7</span>,
                min = <span class="tok-number">8</span>,
                umax = <span class="tok-number">9</span>,
                umin = <span class="tok-number">10</span>,
                fadd = <span class="tok-number">11</span>,
                fsub = <span class="tok-number">12</span>,
                fmax = <span class="tok-number">13</span>,
                fmin = <span class="tok-number">14</span>,
                none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u5</span>),
            };
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetElementPtr = <span class="tok-kw">struct</span> {
            <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
            base: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            indices_len: <span class="tok-type">u32</span>,<span class="tok-comment">
            //indices: [indices_len]Value,

            </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>;
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cast = <span class="tok-kw">struct</span> {
            val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Signedness = <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>.<a href="std.zig.llvm.Builder.Constant.Cast.Signedness.html">Signedness</a>;
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Phi = <span class="tok-kw">struct</span> {
            <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,<span class="tok-comment">
            //incoming_vals: [block.incoming]Value,
            //incoming_blocks: [block.incoming]Block.Index,
        </span>};

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Select = <span class="tok-kw">struct</span> {
            cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Call = <span class="tok-kw">struct</span> {
            info: <a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
            attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
            ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
            callee: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            args_len: <span class="tok-type">u32</span>,<span class="tok-comment">
            //args: [args_len]Value,

            </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> {
                normal,
                fast,
                musttail,
                musttail_fast,
                notail,
                notail_fast,
                tail,
                tail_fast,
            };
            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Info = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
                call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>,
                has_op_bundle_cold: <span class="tok-type">bool</span>,
                _: <span class="tok-type">u21</span> = <span class="tok-null">undefined</span>,
            };
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> VaArg = <span class="tok-kw">struct</span> {
            list: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.Function.html">Function</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        gpa.free(self.extra);
        gpa.free(self.debug_values);
        self.debug_locations.deinit(gpa);
        gpa.free(self.value_indices[<span class="tok-number">0</span>..self.instructions.len]);
        gpa.free(self.names[<span class="tok-number">0</span>..self.instructions.len]);
        self.instructions.deinit(gpa);
        gpa.free(self.blocks);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arg</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>, index: <span class="tok-type">u32</span>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> argument = self.instructions.get(index);
        <a href="std.debug.html#std.debug.assert">assert</a>(argument.tag == .arg);
        <a href="std.debug.html#std.debug.assert">assert</a>(argument.data == index);

        <span class="tok-kw">const</span> argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(index);
        <span class="tok-kw">return</span> argument_index.toValue();
    }

    <span class="tok-kw">const</span> ExtraDataTrail = <span class="tok-kw">struct</span> {
        index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">nextMut</span>(self: *<a href="std.zig.llvm.Builder.Function.ExtraDataTrail.html">ExtraDataTrail</a>, len: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>, function: *<a href="std.zig.llvm.Builder.Function.html">Function</a>) []Item {
            <span class="tok-kw">const</span> items: []Item = <span class="tok-builtin">@ptrCast</span>(function.extra[self.index..][<span class="tok-number">0</span>..len]);
            self.index += <span class="tok-builtin">@intCast</span>(len);
            <span class="tok-kw">return</span> items;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(
            self: *<a href="std.zig.llvm.Builder.Function.ExtraDataTrail.html">ExtraDataTrail</a>,
            len: <span class="tok-type">u32</span>,
            <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>,
            function: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>,
        ) []<span class="tok-kw">const</span> Item {
            <span class="tok-kw">const</span> items: []<span class="tok-kw">const</span> Item = <span class="tok-builtin">@ptrCast</span>(function.extra[self.index..][<span class="tok-number">0</span>..len]);
            self.index += <span class="tok-builtin">@intCast</span>(len);
            <span class="tok-kw">return</span> items;
        }
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">extraDataTrail</span>(
        self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>,
        <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
        index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>,
    ) <span class="tok-kw">struct</span> { data: T, trail: <a href="std.zig.llvm.Builder.Function.ExtraDataTrail.html">ExtraDataTrail</a> } {
        <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields, self.extra[index..][<span class="tok-number">0</span>..fields.len]) |field, value|
            <span class="tok-builtin">@field</span>(result, field.name) = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                <span class="tok-type">u32</span> =&gt; value,
                <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
                <a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
                <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
                =&gt; <span class="tok-builtin">@enumFromInt</span>(value),
                <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
                =&gt; <span class="tok-builtin">@bitCast</span>(value),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
            };
        <span class="tok-kw">return</span> .{
            .data = result,
            .trail = .{ .index = index + <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a>, <span class="tok-builtin">@intCast</span>(fields.len)) },
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">extraData</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>) T {
        <span class="tok-kw">return</span> self.extraDataTrail(T, index).data;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> DebugLocation = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    no_location: <span class="tok-type">void</span>,
    location: <a href="std.zig.llvm.Builder.DebugLocation.Location.html">Location</a>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Location = <span class="tok-kw">struct</span> {
        line: <span class="tok-type">u32</span>,
        column: <span class="tok-type">u32</span>,
        scope: <a href="std.zig.llvm.Builder.html">Builder</a>.<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        inlined_at: <a href="std.zig.llvm.Builder.html">Builder</a>.<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toMetadata</span>(self: <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            .no_location =&gt; .none,
            .location =&gt; |location| <span class="tok-kw">try</span> builder.debugLocation(
                location.line,
                location.column,
                location.scope,
                location.inlined_at,
            ),
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> WipFunction = <span class="tok-kw">struct</span> {
    builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    prev_debug_location: <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>,
    debug_location: <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>,
    cursor: <a href="std.zig.llvm.Builder.WipFunction.Cursor.html">Cursor</a>,
    blocks: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>),
    instructions: <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>),
    names: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>),
    strip: <span class="tok-type">bool</span>,
    debug_locations: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>),
    debug_values: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <span class="tok-type">void</span>),
    extra: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u32</span>),

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cursor = <span class="tok-kw">struct</span> { block: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, instruction: <span class="tok-type">u32</span> = <span class="tok-number">0</span> };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Block = <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.String.html">String</a>,
        incoming: <span class="tok-type">u32</span>,
        branches: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,
        instructions: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>),

        <span class="tok-kw">const</span> Index = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
            entry,
            _,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptr</span>(self: <a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) *<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a> {
                <span class="tok-kw">return</span> &amp;wip.blocks.items[<span class="tok-builtin">@intFromEnum</span>(self)];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrConst</span>(self: <a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, wip: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a> {
                <span class="tok-kw">return</span> &amp;wip.blocks.items[<span class="tok-builtin">@intFromEnum</span>(self)];
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toInst</span>(self: <a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, function: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>) <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
                <span class="tok-kw">return</span> function.blocks[<span class="tok-builtin">@intFromEnum</span>(self)].instruction;
            }
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Instruction = <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>;

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(builder: *<a href="std.zig.llvm.Builder.html">Builder</a>, options: <span class="tok-kw">struct</span> {
        function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
        strip: <span class="tok-type">bool</span>,
    }) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a> {
        <span class="tok-kw">var</span> self: <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a> = .{
            .builder = builder,
            .function = options.function,
            .prev_debug_location = .no_location,
            .debug_location = .no_location,
            .cursor = <span class="tok-null">undefined</span>,
            .blocks = .{},
            .instructions = .{},
            .names = .{},
            .strip = options.strip,
            .debug_locations = .{},
            .debug_values = .{},
            .extra = .{},
        };
        <span class="tok-kw">errdefer</span> self.deinit();

        <span class="tok-kw">const</span> params_len = options.function.typeOf(self.builder).functionParameters(self.builder).len;
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(params_len, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> self.instructions.ensureUnusedCapacity(self.builder.gpa, params_len);
        <span class="tok-kw">if</span> (!self.strip) {
            <span class="tok-kw">try</span> self.names.ensureUnusedCapacity(self.builder.gpa, params_len);
        }
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
            self.instructions.appendAssumeCapacity(.{ .tag = .arg, .data = <span class="tok-builtin">@intCast</span>(param_index) });
            <span class="tok-kw">if</span> (!self.strip) {
                self.names.appendAssumeCapacity(.empty);<span class="tok-comment"> // TODO: param names
            </span>}
        }

        <span class="tok-kw">return</span> self;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arg</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, index: <span class="tok-type">u32</span>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> argument = self.instructions.get(index);
        <a href="std.debug.html#std.debug.assert">assert</a>(argument.tag == .arg);
        <a href="std.debug.html#std.debug.assert">assert</a>(argument.data == index);

        <span class="tok-kw">const</span> argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(index);
        <span class="tok-kw">return</span> argument_index.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">block</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, incoming: <span class="tok-type">u32</span>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.blocks.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);

        <span class="tok-kw">const</span> index: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.blocks.items.len);
        <span class="tok-kw">const</span> final_name = <span class="tok-kw">if</span> (self.strip) .empty <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.builder.string(name);
        self.blocks.appendAssumeCapacity(.{
            .name = final_name,
            .incoming = incoming,
            .instructions = .{},
        });
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ret</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self) == self.function.typeOf(self.builder).functionReturn(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .ret, .data = <span class="tok-builtin">@intFromEnum</span>(val) });
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">retVoid</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .@&quot;ret void&quot;, .data = <span class="tok-null">undefined</span> });
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">br</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, dest: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .br, .data = <span class="tok-builtin">@intFromEnum</span>(dest) });
        dest.ptr(self).branches += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">brCond</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        then: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
        @&quot;else&quot;: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
        weights: <span class="tok-kw">enum</span> { none, unpredictable, then_likely, else_likely },
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(cond.typeOfWip(self) == .<span class="tok-type">i1</span>);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = .br_cond,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>{
                .cond = cond,
                .then = then,
                .@&quot;else&quot; = @&quot;else&quot;,
                .weights = <span class="tok-kw">switch</span> (weights) {
                    .none =&gt; .none,
                    .unpredictable =&gt; .unpredictable,
                    .then_likely, .else_likely =&gt; w: {
                        <span class="tok-kw">const</span> branch_weights_str = <span class="tok-kw">try</span> self.builder.metadataString(<span class="tok-str">&quot;branch_weights&quot;</span>);
                        <span class="tok-kw">const</span> unlikely_const = <span class="tok-kw">try</span> self.builder.metadataConstant(<span class="tok-kw">try</span> self.builder.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">1</span>));
                        <span class="tok-kw">const</span> likely_const = <span class="tok-kw">try</span> self.builder.metadataConstant(<span class="tok-kw">try</span> self.builder.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">2000</span>));
                        <span class="tok-kw">const</span> weight_vals: [<span class="tok-number">2</span>]<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> = <span class="tok-kw">switch</span> (weights) {
                            .none, .unpredictable =&gt; <span class="tok-kw">unreachable</span>,
                            .then_likely =&gt; .{ likely_const, unlikely_const },
                            .else_likely =&gt; .{ unlikely_const, likely_const },
                        };
                        <span class="tok-kw">const</span> tuple = <span class="tok-kw">try</span> self.builder.strTuple(branch_weights_str, &amp;weight_vals);
                        <span class="tok-kw">break</span> :w <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(tuple));
                    },
                },
            }),
        });
        then.ptr(self).branches += <span class="tok-number">1</span>;
        @&quot;else&quot;.ptr(self).branches += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WipSwitch = <span class="tok-kw">struct</span> {
        index: <span class="tok-type">u32</span>,
        instruction: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addCase</span>(
            self: *<a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">WipSwitch</a>,
            val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
            dest: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
            wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> instruction = wip.instructions.get(<span class="tok-builtin">@intFromEnum</span>(self.instruction));
            <span class="tok-kw">var</span> extra = wip.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
            <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOf(wip.builder) == extra.data.val.typeOfWip(wip));
            extra.trail.nextMut(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, wip)[self.index] = val;
            extra.trail.nextMut(extra.data.cases_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, wip)[self.index] = dest;
            self.index += <span class="tok-number">1</span>;
            dest.ptr(wip).branches += <span class="tok-number">1</span>;
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(self: <a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">WipSwitch</a>, wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> instruction = wip.instructions.get(<span class="tok-builtin">@intFromEnum</span>(self.instruction));
            <span class="tok-kw">const</span> extra = wip.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.index == extra.cases_len);
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;switch&quot;</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        default: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
        cases_len: <span class="tok-type">u32</span>,
        weights: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipSwitch.html">WipSwitch</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, cases_len * <span class="tok-number">2</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = .@&quot;switch&quot;,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>{
                .val = val,
                .default = default,
                .cases_len = cases_len,
                .weights = weights,
            }),
        });
        _ = self.extra.addManyAsSliceAssumeCapacity(cases_len * <span class="tok-number">2</span>);
        default.ptr(self).branches += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> .{ .index = <span class="tok-number">0</span>, .instruction = instruction };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">indirectbr</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        addr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        targets: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, targets.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = .indirectbr,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>{
                .addr = addr,
                .targets_len = <span class="tok-builtin">@intCast</span>(targets.len),
            }),
        });
        _ = self.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(targets));
        <span class="tok-kw">for</span> (targets) |target| target.ptr(self).branches += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;unreachable&quot;</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{ .tag = .@&quot;unreachable&quot;, .data = <span class="tok-null">undefined</span> });
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">un</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .fneg,
            .@&quot;fneg fast&quot;,
            =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).scalarType(self.builder).isFloatingPoint()),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{ .tag = tag, .data = <span class="tok-builtin">@intFromEnum</span>(val) });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">not</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> ty = val.typeOfWip(self);
        <span class="tok-kw">const</span> all_ones = <span class="tok-kw">try</span> self.builder.splatValue(
            ty,
            <span class="tok-kw">try</span> self.builder.intConst(ty.scalarType(self.builder), -<span class="tok-number">1</span>),
        );
        <span class="tok-kw">return</span> self.bin(.xor, val, all_ones, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">neg</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, val: <a href="std.zig.llvm.Builder.Value.html">Value</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.bin(.sub, <span class="tok-kw">try</span> self.builder.zeroInitValue(val.typeOfWip(self)), val, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bin</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .add,
            .@&quot;add nsw&quot;,
            .@&quot;add nuw&quot;,
            .@&quot;and&quot;,
            .ashr,
            .@&quot;ashr exact&quot;,
            .fadd,
            .@&quot;fadd fast&quot;,
            .fdiv,
            .@&quot;fdiv fast&quot;,
            .fmul,
            .@&quot;fmul fast&quot;,
            .frem,
            .@&quot;frem fast&quot;,
            .fsub,
            .@&quot;fsub fast&quot;,
            .lshr,
            .@&quot;lshr exact&quot;,
            .mul,
            .@&quot;mul nsw&quot;,
            .@&quot;mul nuw&quot;,
            .@&quot;or&quot;,
            .sdiv,
            .@&quot;sdiv exact&quot;,
            .shl,
            .@&quot;shl nsw&quot;,
            .@&quot;shl nuw&quot;,
            .srem,
            .sub,
            .@&quot;sub nsw&quot;,
            .@&quot;sub nuw&quot;,
            .udiv,
            .@&quot;udiv exact&quot;,
            .urem,
            .xor,
            =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self)),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>{ .lhs = lhs, .rhs = rhs }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractElement</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        index: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).isVector(self.builder));
        <a href="std.debug.html#std.debug.assert">assert</a>(index.typeOfWip(self).isInteger(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .extractelement,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>{
                .val = val,
                .index = index,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertElement</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        index: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).scalarType(self.builder) == elem.typeOfWip(self));
        <a href="std.debug.html#std.debug.assert">assert</a>(index.typeOfWip(self).isInteger(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .insertelement,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>{
                .val = val,
                .elem = elem,
                .index = index,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shuffleVector</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        mask: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self).isVector(self.builder));
        <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self));
        <a href="std.debug.html#std.debug.assert">assert</a>(mask.typeOfWip(self).scalarType(self.builder).isInteger(self.builder));
        _ = <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .shufflevector,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>{
                .lhs = lhs,
                .rhs = rhs,
                .mask = mask,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatVector</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> scalar_ty = <span class="tok-kw">try</span> ty.changeLength(<span class="tok-number">1</span>, self.builder);
        <span class="tok-kw">const</span> mask_ty = <span class="tok-kw">try</span> ty.changeScalar(.<span class="tok-type">i32</span>, self.builder);
        <span class="tok-kw">const</span> poison = <span class="tok-kw">try</span> self.builder.poisonValue(scalar_ty);
        <span class="tok-kw">const</span> mask = <span class="tok-kw">try</span> self.builder.splatValue(mask_ty, .@&quot;0&quot;);
        <span class="tok-kw">const</span> scalar = <span class="tok-kw">try</span> self.insertElement(poison, elem, .@&quot;0&quot;, name);
        <span class="tok-kw">return</span> self.shuffleVector(scalar, poison, mask, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">extractValue</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(indices.len &gt; <span class="tok-number">0</span>);
        _ = val.typeOfWip(self).childTypeAt(indices, self.builder);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, indices.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .extractvalue,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>{
                .val = val,
                .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
            }),
        });
        self.extra.appendSliceAssumeCapacity(indices);
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">insertValue</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        elem: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        indices: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(indices.len &gt; <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(self).childTypeAt(indices, self.builder) == elem.typeOfWip(self));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, indices.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .insertvalue,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>{
                .val = val,
                .elem = elem,
                .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
            }),
        });
        self.extra.appendSliceAssumeCapacity(indices);
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">buildAggregate</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        elems: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ty.aggregateLen(self.builder) == elems.len);
        <span class="tok-kw">var</span> cur = <span class="tok-kw">try</span> self.builder.poisonValue(ty);
        <span class="tok-kw">for</span> (elems, <span class="tok-number">0</span>..) |elem, index|
            cur = <span class="tok-kw">try</span> self.insertValue(cur, elem, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-builtin">@intCast</span>(index)}, name);
        <span class="tok-kw">return</span> cur;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">alloca</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Kind.html">Kind</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(len == .none <span class="tok-kw">or</span> len.typeOfWip(self).isInteger(self.builder));
        _ = <span class="tok-kw">try</span> self.builder.ptrType(addr_space);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; .alloca,
                .inalloca =&gt; .@&quot;alloca inalloca&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>{
                .<span class="tok-type">type</span> = ty,
                .len = <span class="tok-kw">switch</span> (len) {
                    .none =&gt; .@&quot;1&quot;,
                    <span class="tok-kw">else</span> =&gt; len,
                },
                .info = .{ .alignment = alignment, .addr_space = addr_space },
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">load</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.loadAtomic(access_kind, ty, ptr, .system, .none, alignment, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">loadAtomic</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = <span class="tok-kw">switch</span> (ordering) {
                .none =&gt; .load,
                <span class="tok-kw">else</span> =&gt; .@&quot;load atomic&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>{
                .info = .{
                    .access_kind = access_kind,
                    .sync_scope = <span class="tok-kw">switch</span> (ordering) {
                        .none =&gt; .system,
                        <span class="tok-kw">else</span> =&gt; sync_scope,
                    },
                    .success_ordering = ordering,
                    .alignment = alignment,
                },
                .<span class="tok-type">type</span> = ty,
                .ptr = ptr,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">store</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">return</span> self.storeAtomic(kind, val, ptr, .system, .none, alignment);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">storeAtomic</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = <span class="tok-kw">switch</span> (ordering) {
                .none =&gt; .store,
                <span class="tok-kw">else</span> =&gt; .@&quot;store atomic&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>{
                .info = .{
                    .access_kind = access_kind,
                    .sync_scope = <span class="tok-kw">switch</span> (ordering) {
                        .none =&gt; .system,
                        <span class="tok-kw">else</span> =&gt; sync_scope,
                    },
                    .success_ordering = ordering,
                    .alignment = alignment,
                },
                .val = val,
                .ptr = ptr,
            }),
        });
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fence</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ordering != .none);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-null">null</span>, .{
            .tag = .fence,
            .data = <span class="tok-builtin">@bitCast</span>(<a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>{
                .sync_scope = sync_scope,
                .success_ordering = ordering,
            }),
        });
        <span class="tok-kw">return</span> instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cmpxchg</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.Kind.html">Kind</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        cmp: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        new: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        success_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        failure_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
        <span class="tok-kw">const</span> ty = cmp.typeOfWip(self);
        <a href="std.debug.html#std.debug.assert">assert</a>(ty == new.typeOfWip(self));
        <a href="std.debug.html#std.debug.assert">assert</a>(success_ordering != .none);
        <a href="std.debug.html#std.debug.assert">assert</a>(failure_ordering != .none);

        _ = <span class="tok-kw">try</span> self.builder.structType(.normal, &amp;.{ ty, .<span class="tok-type">i1</span> });
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = <span class="tok-kw">switch</span> (kind) {
                .strong =&gt; .cmpxchg,
                .weak =&gt; .@&quot;cmpxchg weak&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>{
                .info = .{
                    .access_kind = access_kind,
                    .sync_scope = sync_scope,
                    .success_ordering = success_ordering,
                    .failure_ordering = failure_ordering,
                    .alignment = alignment,
                },
                .ptr = ptr,
                .cmp = cmp,
                .new = new,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">atomicrmw</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        operation: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.Operation.html">Operation</a>,
        ptr: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ptr.typeOfWip(self).isPointer(self.builder));
        <a href="std.debug.html#std.debug.assert">assert</a>(ordering != .none);

        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .atomicrmw,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>{
                .info = .{
                    .access_kind = access_kind,
                    .atomic_rmw_operation = operation,
                    .sync_scope = sync_scope,
                    .success_ordering = ordering,
                    .alignment = alignment,
                },
                .ptr = ptr,
                .val = val,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gep</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        base: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> base_ty = base.typeOfWip(self);
        <span class="tok-kw">const</span> base_is_vector = base_ty.isVector(self.builder);

        <span class="tok-kw">const</span> VectorInfo = <span class="tok-kw">struct</span> {
            kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a>,
            len: <span class="tok-type">u32</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(vector_ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-builtin">@This</span>() {
                <span class="tok-kw">return</span> .{ .kind = vector_ty.vectorKind(builder), .len = vector_ty.vectorLen(builder) };
            }
        };
        <span class="tok-kw">var</span> vector_info: ?VectorInfo =
            <span class="tok-kw">if</span> (base_is_vector) VectorInfo.init(base_ty, self.builder) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
        <span class="tok-kw">for</span> (indices) |index| {
            <span class="tok-kw">const</span> index_ty = index.typeOfWip(self);
            <span class="tok-kw">switch</span> (index_ty.tag(self.builder)) {
                .integer =&gt; {},
                .vector, .scalable_vector =&gt; {
                    <span class="tok-kw">const</span> index_info = VectorInfo.init(index_ty, self.builder);
                    <span class="tok-kw">if</span> (vector_info) |info|
                        <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(info, index_info))
                    <span class="tok-kw">else</span>
                        vector_info = index_info;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            }
        }
        <span class="tok-kw">if</span> (!base_is_vector) <span class="tok-kw">if</span> (vector_info) |info| <span class="tok-kw">switch</span> (info.kind) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |vector_kind| _ = <span class="tok-kw">try</span> self.builder.vectorType(
                vector_kind,
                info.len,
                base_ty,
            ),
        };

        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, indices.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; .getelementptr,
                .inbounds =&gt; .@&quot;getelementptr inbounds&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>{
                .<span class="tok-type">type</span> = ty,
                .base = base,
                .indices_len = <span class="tok-builtin">@intCast</span>(indices.len),
            }),
        });
        self.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(indices));
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepStruct</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        base: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        index: <span class="tok-type">usize</span>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <a href="std.debug.html#std.debug.assert">assert</a>(ty.isStruct(self.builder));
        <span class="tok-kw">return</span> self.gep(.inbounds, ty, base, &amp;.{ .@&quot;0&quot;, <span class="tok-kw">try</span> self.builder.intValue(.<span class="tok-type">i32</span>, index) }, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">conv</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        signedness: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>.<a href="std.zig.llvm.Builder.Constant.Cast.Signedness.html">Signedness</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> val_ty = val.typeOfWip(self);
        <span class="tok-kw">if</span> (val_ty == ty) <span class="tok-kw">return</span> val;
        <span class="tok-kw">return</span> self.cast(self.builder.convTag(signedness, val_ty, ty), val, ty, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cast</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .addrspacecast,
            .bitcast,
            .fpext,
            .fptosi,
            .fptoui,
            .fptrunc,
            .inttoptr,
            .ptrtoint,
            .sext,
            .sitofp,
            .trunc,
            .uitofp,
            .zext,
            =&gt; {},
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">if</span> (val.typeOfWip(self) == ty) <span class="tok-kw">return</span> val;
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>{
                .val = val,
                .<span class="tok-type">type</span> = ty,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">icmp</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        cond: <a href="std.zig.llvm.Builder.IntegerCondition.html">IntegerCondition</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.cmpTag(<span class="tok-kw">switch</span> (cond) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |tag| <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, <span class="tok-str">&quot;icmp &quot;</span> ++ <span class="tok-builtin">@tagName</span>(tag)),
        }, lhs, rhs, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fcmp</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
        cond: <a href="std.zig.llvm.Builder.FloatCondition.html">FloatCondition</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.cmpTag(<span class="tok-kw">switch</span> (fast) {
            <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |fast_tag| <span class="tok-kw">switch</span> (cond) {
                <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |cond_tag| <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>, <span class="tok-str">&quot;fcmp &quot;</span> ++ <span class="tok-kw">switch</span> (fast_tag) {
                    .normal =&gt; <span class="tok-str">&quot;&quot;</span>,
                    .fast =&gt; <span class="tok-str">&quot;fast &quot;</span>,
                } ++ <span class="tok-builtin">@tagName</span>(cond_tag)),
            },
        }, lhs, rhs, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> WipPhi = <span class="tok-kw">struct</span> {
        block: <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
        instruction: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toValue</span>(self: <a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
            <span class="tok-kw">return</span> self.instruction.toValue();
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(
            self: <a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a>,
            vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            blocks: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
            wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> incoming_len = self.block.ptrConst(wip).incoming;
            <a href="std.debug.html#std.debug.assert">assert</a>(vals.len == incoming_len <span class="tok-kw">and</span> blocks.len == incoming_len);
            <span class="tok-kw">const</span> instruction = wip.instructions.get(<span class="tok-builtin">@intFromEnum</span>(self.instruction));
            <span class="tok-kw">var</span> extra = wip.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data);
            <span class="tok-kw">for</span> (vals) |val| <a href="std.debug.html#std.debug.assert">assert</a>(val.typeOfWip(wip) == extra.data.<span class="tok-type">type</span>);
            <span class="tok-builtin">@memcpy</span>(extra.trail.nextMut(incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, wip), vals);
            <span class="tok-builtin">@memcpy</span>(extra.trail.nextMut(incoming_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, wip), blocks);
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">phi</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a> {
        <span class="tok-kw">return</span> self.phiTag(.phi, ty, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">phiFast</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a> {
        <span class="tok-kw">return</span> self.phiTag(.@&quot;phi fast&quot;, ty, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">select</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
        cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.selectTag(<span class="tok-kw">switch</span> (fast) {
            .normal =&gt; .select,
            .fast =&gt; .@&quot;select fast&quot;,
        }, cond, lhs, rhs, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">call</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Kind.html">Kind</a>,
        call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>,
        function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        callee: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> self.callInner(kind, call_conv, function_attributes, ty, callee, args, name, <span class="tok-null">false</span>);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">callInner</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        kind: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Kind.html">Kind</a>,
        call_conv: <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>,
        function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        callee: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        has_op_bundle_cold: <span class="tok-type">bool</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> ret_ty = ty.functionReturn(self.builder);
        <a href="std.debug.html#std.debug.assert">assert</a>(ty.isFunction(self.builder));
        <a href="std.debug.html#std.debug.assert">assert</a>(callee.typeOfWip(self).isPointer(self.builder));
        <span class="tok-kw">const</span> params = ty.functionParameters(self.builder);
        <span class="tok-kw">for</span> (params, args[<span class="tok-number">0</span>..params.len]) |param, arg_val| <a href="std.debug.html#std.debug.assert">assert</a>(param == arg_val.typeOfWip(self));

        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, args.len);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(<span class="tok-kw">switch</span> (ret_ty) {
            .<span class="tok-type">void</span> =&gt; <span class="tok-null">null</span>,
            <span class="tok-kw">else</span> =&gt; name,
        }, .{
            .tag = <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; .call,
                .fast =&gt; .@&quot;call fast&quot;,
                .musttail =&gt; .@&quot;musttail call&quot;,
                .musttail_fast =&gt; .@&quot;musttail call fast&quot;,
                .notail =&gt; .@&quot;notail call&quot;,
                .notail_fast =&gt; .@&quot;notail call fast&quot;,
                .tail =&gt; .@&quot;tail call&quot;,
                .tail_fast =&gt; .@&quot;tail call fast&quot;,
            },
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>{
                .info = .{
                    .call_conv = call_conv,
                    .has_op_bundle_cold = has_op_bundle_cold,
                },
                .attributes = function_attributes,
                .ty = ty,
                .callee = callee,
                .args_len = <span class="tok-builtin">@intCast</span>(args.len),
            }),
        });
        self.extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(args));
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callAsm</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>,
        assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
        constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,
        args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> callee = <span class="tok-kw">try</span> self.builder.asmValue(ty, kind, assembly, constraints);
        <span class="tok-kw">return</span> self.call(.normal, <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>, function_attributes, ty, callee, args, name);
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callIntrinsic</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        fast: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>,
        function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
        id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>,
        overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        args: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> intrinsic = <span class="tok-kw">try</span> self.builder.getIntrinsic(id, overload);
        <span class="tok-kw">return</span> self.call(
            fast.toCallKind(),
            <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>,
            function_attributes,
            intrinsic.typeOf(self.builder),
            intrinsic.toValue(self.builder),
            args,
            name,
        );
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callIntrinsicAssumeCold</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">const</span> intrinsic = <span class="tok-kw">try</span> self.builder.getIntrinsic(.assume, &amp;.{});
        <span class="tok-kw">return</span> self.callInner(
            .normal,
            <a href="std.zig.llvm.Builder.CallConv.html">CallConv</a>.<a href="std.zig.llvm.Builder.CallConv.html#std.zig.llvm.Builder.CallConv.default">default</a>,
            .none,
            intrinsic.typeOf(self.builder),
            intrinsic.toValue(self.builder),
            &amp;.{<span class="tok-kw">try</span> self.builder.intValue(.<span class="tok-type">i1</span>, <span class="tok-number">1</span>)},
            <span class="tok-str">&quot;&quot;</span>,
            <span class="tok-null">true</span>,
        );
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMemCpy</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        dst: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        src: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        src_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        @&quot;inline&quot;: <span class="tok-type">bool</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">var</span> dst_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = dst_align })};
        <span class="tok-kw">var</span> src_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = src_align })};
        <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> self.callIntrinsic(
            .normal,
            <span class="tok-kw">try</span> self.builder.fnAttrs(&amp;.{
                .none,
                .none,
                <span class="tok-kw">try</span> self.builder.attrs(&amp;dst_attrs),
                <span class="tok-kw">try</span> self.builder.attrs(&amp;src_attrs),
            }),
            <span class="tok-kw">if</span> (@&quot;inline&quot;) .@&quot;memcpy.inline&quot; <span class="tok-kw">else</span> .memcpy,
            &amp;.{ dst.typeOfWip(self), src.typeOfWip(self), len.typeOfWip(self) },
            &amp;.{ dst, src, len, <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">false</span>,
                .@&quot;volatile&quot; =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">true</span>,
            } },
            <span class="tok-null">undefined</span>,
        );
        <span class="tok-kw">return</span> value.unwrap().instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">callMemSet</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        dst: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        dst_align: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
        val: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        len: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        @&quot;inline&quot;: <span class="tok-type">bool</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">var</span> dst_attrs = [_]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>{<span class="tok-kw">try</span> self.builder.attr(.{ .@&quot;align&quot; = dst_align })};
        <span class="tok-kw">const</span> value = <span class="tok-kw">try</span> self.callIntrinsic(
            .normal,
            <span class="tok-kw">try</span> self.builder.fnAttrs(&amp;.{ .none, .none, <span class="tok-kw">try</span> self.builder.attrs(&amp;dst_attrs) }),
            <span class="tok-kw">if</span> (@&quot;inline&quot;) .@&quot;memset.inline&quot; <span class="tok-kw">else</span> .memset,
            &amp;.{ dst.typeOfWip(self), len.typeOfWip(self) },
            &amp;.{ dst, val, len, <span class="tok-kw">switch</span> (kind) {
                .normal =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">false</span>,
                .@&quot;volatile&quot; =&gt; <a href="std.zig.llvm.Builder.Value.html">Value</a>.<span class="tok-null">true</span>,
            } },
            <span class="tok-null">undefined</span>,
        );
        <span class="tok-kw">return</span> value.unwrap().instruction;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vaArg</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, list: <a href="std.zig.llvm.Builder.Value.html">Value</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = .va_arg,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>{
                .list = list,
                .<span class="tok-type">type</span> = ty,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugValue</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
        <span class="tok-kw">if</span> (self.strip) <span class="tok-kw">return</span> .none;
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (value.unwrap()) {
            .instruction =&gt; |instr_index| blk: {
                <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.debug_values.getOrPut(self.builder.gpa, instr_index);

                <span class="tok-kw">const</span> metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> = <span class="tok-builtin">@enumFromInt</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a> + gop.index);
                <span class="tok-kw">if</span> (!gop.found_existing) gop.key_ptr.* = instr_index;

                <span class="tok-kw">break</span> :blk metadata;
            },
            .constant =&gt; |constant| <span class="tok-kw">try</span> self.builder.metadataConstant(constant),
            .metadata =&gt; |metadata| metadata,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> gpa = self.builder.gpa;
        <span class="tok-kw">const</span> function = self.function.ptr(self.builder);
        <span class="tok-kw">const</span> params_len = self.function.typeOf(self.builder).functionParameters(self.builder).len;
        <span class="tok-kw">const</span> final_instructions_len = self.blocks.items.len + self.instructions.len;

        <span class="tok-kw">const</span> blocks = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>, self.blocks.items.len);
        <span class="tok-kw">errdefer</span> gpa.free(blocks);

        <span class="tok-kw">const</span> instructions: <span class="tok-kw">struct</span> {
            items: []<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

            <span class="tok-kw">fn</span> <span class="tok-fn">map</span>(instructions: <span class="tok-builtin">@This</span>(), val: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
                <span class="tok-kw">if</span> (val == .none) <span class="tok-kw">return</span> .none;
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (val.unwrap()) {
                    .instruction =&gt; |instruction| instructions.items[
                        <span class="tok-builtin">@intFromEnum</span>(instruction)
                    ].toValue(),
                    .constant =&gt; |constant| constant.toValue(),
                    .metadata =&gt; |metadata| metadata.toValue(),
                };
            }
        } = .{ .items = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, self.instructions.len) };
        <span class="tok-kw">defer</span> gpa.free(instructions.items);

        <span class="tok-kw">const</span> names = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.String.html">String</a>, final_instructions_len);
        <span class="tok-kw">errdefer</span> gpa.free(names);

        <span class="tok-kw">const</span> value_indices = <span class="tok-kw">try</span> gpa.alloc(<span class="tok-type">u32</span>, final_instructions_len);
        <span class="tok-kw">errdefer</span> gpa.free(value_indices);

        <span class="tok-kw">var</span> debug_locations: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMapUnmanaged">AutoHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>) = .empty;
        <span class="tok-kw">errdefer</span> debug_locations.deinit(gpa);
        <span class="tok-kw">try</span> debug_locations.ensureUnusedCapacity(gpa, <span class="tok-builtin">@intCast</span>(self.debug_locations.count()));

        <span class="tok-kw">const</span> debug_values = <span class="tok-kw">try</span> gpa.alloc(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>, self.debug_values.count());
        <span class="tok-kw">errdefer</span> gpa.free(debug_values);

        <span class="tok-kw">var</span> wip_extra: <span class="tok-kw">struct</span> {
            index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> = <span class="tok-number">0</span>,
            items: []<span class="tok-type">u32</span>,

            <span class="tok-kw">fn</span> <span class="tok-fn">addExtra</span>(wip_extra: *<span class="tok-builtin">@This</span>(), extra: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> {
                <span class="tok-kw">const</span> result = wip_extra.index;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields) |field| {
                    <span class="tok-kw">const</span> value = <span class="tok-builtin">@field</span>(extra, field.name);
                    wip_extra.items[wip_extra.index] = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                        <span class="tok-type">u32</span> =&gt; value,
                        <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                        <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
                        <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
                        <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
                        <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                        <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                        <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
                        =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
                        <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
                        <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,
                        <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
                        =&gt; <span class="tok-builtin">@bitCast</span>(value),
                        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
                    };
                    wip_extra.index += <span class="tok-number">1</span>;
                }
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">appendSlice</span>(wip_extra: *<span class="tok-builtin">@This</span>(), slice: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
                <span class="tok-kw">if</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(slice)).pointer.child == <a href="std.zig.llvm.Builder.Value.html">Value</a>)
                    <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;use appendMappedValues&quot;</span>);
                <span class="tok-kw">const</span> data: []<span class="tok-kw">const</span> <span class="tok-type">u32</span> = <span class="tok-builtin">@ptrCast</span>(slice);
                <span class="tok-builtin">@memcpy</span>(wip_extra.items[wip_extra.index..][<span class="tok-number">0</span>..data.len], data);
                wip_extra.index += <span class="tok-builtin">@intCast</span>(data.len);
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">appendMappedValues</span>(wip_extra: *<span class="tok-builtin">@This</span>(), vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
                <span class="tok-kw">for</span> (wip_extra.items[wip_extra.index..][<span class="tok-number">0</span>..vals.len], vals) |*extra, val|
                    extra.* = <span class="tok-builtin">@intFromEnum</span>(ctx.map(val));
                wip_extra.index += <span class="tok-builtin">@intCast</span>(vals.len);
            }

            <span class="tok-kw">fn</span> <span class="tok-fn">finish</span>(wip_extra: *<span class="tok-kw">const</span> <span class="tok-builtin">@This</span>()) []<span class="tok-kw">const</span> <span class="tok-type">u32</span> {
                <a href="std.debug.html#std.debug.assert">assert</a>(wip_extra.index == wip_extra.items.len);
                <span class="tok-kw">return</span> wip_extra.items;
            }
        } = .{ .items = <span class="tok-kw">try</span> gpa.alloc(<span class="tok-type">u32</span>, self.extra.items.len) };
        <span class="tok-kw">errdefer</span> gpa.free(wip_extra.items);

        gpa.free(function.blocks);
        function.blocks = &amp;.{};
        gpa.free(function.names[<span class="tok-number">0</span>..function.instructions.len]);
        function.debug_locations.deinit(gpa);
        function.debug_locations = .{};
        gpa.free(function.debug_values);
        function.debug_values = &amp;.{};
        gpa.free(function.extra);
        function.extra = &amp;.{};

        function.instructions.shrinkRetainingCapacity(<span class="tok-number">0</span>);
        <span class="tok-kw">try</span> function.instructions.setCapacity(gpa, final_instructions_len);
        <span class="tok-kw">errdefer</span> function.instructions.shrinkRetainingCapacity(<span class="tok-number">0</span>);

        {
            <span class="tok-kw">var</span> final_instruction_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
                instructions.items[param_index] = final_instruction_index;
                final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
            }
            <span class="tok-kw">for</span> (blocks, self.blocks.items) |*final_block, current_block| {
                <a href="std.debug.html#std.debug.assert">assert</a>(current_block.incoming == current_block.branches);
                final_block.instruction = final_instruction_index;
                final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
                <span class="tok-kw">for</span> (current_block.instructions.items) |instruction| {
                    instructions.items[<span class="tok-builtin">@intFromEnum</span>(instruction)] = final_instruction_index;
                    final_instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(final_instruction_index) + <span class="tok-number">1</span>);
                }
            }
        }

        <span class="tok-kw">var</span> wip_name: <span class="tok-kw">struct</span> {
            next_name: <a href="std.zig.llvm.Builder.String.html">String</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
            next_unique_name: <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.String.html">String</a>),
            builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,

            <span class="tok-kw">fn</span> <span class="tok-fn">map</span>(wip_name: *<span class="tok-builtin">@This</span>(), name: <a href="std.zig.llvm.Builder.String.html">String</a>, sep: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
                <span class="tok-kw">switch</span> (name) {
                    .none =&gt; <span class="tok-kw">return</span> .none,
                    .empty =&gt; {
                        <a href="std.debug.html#std.debug.assert">assert</a>(wip_name.next_name != .none);
                        <span class="tok-kw">defer</span> wip_name.next_name = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(wip_name.next_name) + <span class="tok-number">1</span>);
                        <span class="tok-kw">return</span> wip_name.next_name;
                    },
                    _ =&gt; {
                        <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
                        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> wip_name.next_unique_name.getOrPut(name);
                        <span class="tok-kw">if</span> (!gop.found_existing) {
                            gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
                            <span class="tok-kw">return</span> name;
                        }

                        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
                            gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(gop.value_ptr.*) + <span class="tok-number">1</span>);
                            <span class="tok-kw">const</span> unique_name = <span class="tok-kw">try</span> wip_name.builder.fmt(<span class="tok-str">&quot;{r}{s}{r}&quot;</span>, .{
                                name.fmt(wip_name.builder),
                                sep,
                                gop.value_ptr.fmt(wip_name.builder),
                            });
                            <span class="tok-kw">const</span> unique_gop = <span class="tok-kw">try</span> wip_name.next_unique_name.getOrPut(unique_name);
                            <span class="tok-kw">if</span> (!unique_gop.found_existing) {
                                unique_gop.value_ptr.* = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>);
                                <span class="tok-kw">return</span> unique_name;
                            }
                        }
                    },
                }
            }
        } = .{
            .next_unique_name = <a href="std.html">std</a>.<a href="std.hash_map.html#std.hash_map.AutoHashMap">AutoHashMap</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.String.html">String</a>).init(gpa),
            .builder = self.builder,
        };
        <span class="tok-kw">defer</span> wip_name.next_unique_name.deinit();

        <span class="tok-kw">var</span> value_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |param_index| {
            <span class="tok-kw">const</span> old_argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(param_index);
            <span class="tok-kw">const</span> new_argument_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
            <span class="tok-kw">const</span> argument = self.instructions.get(<span class="tok-builtin">@intFromEnum</span>(old_argument_index));
            <a href="std.debug.html#std.debug.assert">assert</a>(argument.tag == .arg);
            <a href="std.debug.html#std.debug.assert">assert</a>(argument.data == param_index);
            value_indices[function.instructions.len] = value_index;
            value_index += <span class="tok-number">1</span>;
            function.instructions.appendAssumeCapacity(argument);
            names[<span class="tok-builtin">@intFromEnum</span>(new_argument_index)] = <span class="tok-kw">try</span> wip_name.map(
                <span class="tok-kw">if</span> (self.strip) .empty <span class="tok-kw">else</span> self.names.items[<span class="tok-builtin">@intFromEnum</span>(old_argument_index)],
                <span class="tok-str">&quot;.&quot;</span>,
            );
            <span class="tok-kw">if</span> (self.debug_locations.get(old_argument_index)) |location| {
                debug_locations.putAssumeCapacity(new_argument_index, location);
            }
            <span class="tok-kw">if</span> (self.debug_values.getIndex(old_argument_index)) |index| {
                debug_values[index] = new_argument_index;
            }
        }
        <span class="tok-kw">for</span> (self.blocks.items) |current_block| {
            <span class="tok-kw">const</span> new_block_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
            value_indices[function.instructions.len] = value_index;
            function.instructions.appendAssumeCapacity(.{
                .tag = .block,
                .data = current_block.incoming,
            });
            names[<span class="tok-builtin">@intFromEnum</span>(new_block_index)] = <span class="tok-kw">try</span> wip_name.map(current_block.name, <span class="tok-str">&quot;&quot;</span>);
            <span class="tok-kw">for</span> (current_block.instructions.items) |old_instruction_index| {
                <span class="tok-kw">const</span> new_instruction_index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function.instructions.len);
                <span class="tok-kw">var</span> instruction = self.instructions.get(<span class="tok-builtin">@intFromEnum</span>(old_instruction_index));
                <span class="tok-kw">switch</span> (instruction.tag) {
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .@&quot;add nuw nsw&quot;,
                    .@&quot;and&quot;,
                    .ashr,
                    .@&quot;ashr exact&quot;,
                    .fadd,
                    .@&quot;fadd fast&quot;,
                    .@&quot;fcmp false&quot;,
                    .@&quot;fcmp fast false&quot;,
                    .@&quot;fcmp fast oeq&quot;,
                    .@&quot;fcmp fast oge&quot;,
                    .@&quot;fcmp fast ogt&quot;,
                    .@&quot;fcmp fast ole&quot;,
                    .@&quot;fcmp fast olt&quot;,
                    .@&quot;fcmp fast one&quot;,
                    .@&quot;fcmp fast ord&quot;,
                    .@&quot;fcmp fast true&quot;,
                    .@&quot;fcmp fast ueq&quot;,
                    .@&quot;fcmp fast uge&quot;,
                    .@&quot;fcmp fast ugt&quot;,
                    .@&quot;fcmp fast ule&quot;,
                    .@&quot;fcmp fast ult&quot;,
                    .@&quot;fcmp fast une&quot;,
                    .@&quot;fcmp fast uno&quot;,
                    .@&quot;fcmp oeq&quot;,
                    .@&quot;fcmp oge&quot;,
                    .@&quot;fcmp ogt&quot;,
                    .@&quot;fcmp ole&quot;,
                    .@&quot;fcmp olt&quot;,
                    .@&quot;fcmp one&quot;,
                    .@&quot;fcmp ord&quot;,
                    .@&quot;fcmp true&quot;,
                    .@&quot;fcmp ueq&quot;,
                    .@&quot;fcmp uge&quot;,
                    .@&quot;fcmp ugt&quot;,
                    .@&quot;fcmp ule&quot;,
                    .@&quot;fcmp ult&quot;,
                    .@&quot;fcmp une&quot;,
                    .@&quot;fcmp uno&quot;,
                    .fdiv,
                    .@&quot;fdiv fast&quot;,
                    .fmul,
                    .@&quot;fmul fast&quot;,
                    .frem,
                    .@&quot;frem fast&quot;,
                    .fsub,
                    .@&quot;fsub fast&quot;,
                    .@&quot;icmp eq&quot;,
                    .@&quot;icmp ne&quot;,
                    .@&quot;icmp sge&quot;,
                    .@&quot;icmp sgt&quot;,
                    .@&quot;icmp sle&quot;,
                    .@&quot;icmp slt&quot;,
                    .@&quot;icmp uge&quot;,
                    .@&quot;icmp ugt&quot;,
                    .@&quot;icmp ule&quot;,
                    .@&quot;icmp ult&quot;,
                    .lshr,
                    .@&quot;lshr exact&quot;,
                    .mul,
                    .@&quot;mul nsw&quot;,
                    .@&quot;mul nuw&quot;,
                    .@&quot;mul nuw nsw&quot;,
                    .@&quot;or&quot;,
                    .sdiv,
                    .@&quot;sdiv exact&quot;,
                    .shl,
                    .@&quot;shl nsw&quot;,
                    .@&quot;shl nuw&quot;,
                    .@&quot;shl nuw nsw&quot;,
                    .srem,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .@&quot;sub nuw nsw&quot;,
                    .udiv,
                    .@&quot;udiv exact&quot;,
                    .urem,
                    .xor,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>{
                            .lhs = instructions.map(extra.lhs),
                            .rhs = instructions.map(extra.rhs),
                        });
                    },
                    .addrspacecast,
                    .bitcast,
                    .fpext,
                    .fptosi,
                    .fptoui,
                    .fptrunc,
                    .inttoptr,
                    .ptrtoint,
                    .sext,
                    .sitofp,
                    .trunc,
                    .uitofp,
                    .zext,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>{
                            .val = instructions.map(extra.val),
                            .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                        });
                    },
                    .alloca,
                    .@&quot;alloca inalloca&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>{
                            .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                            .len = instructions.map(extra.len),
                            .info = extra.info,
                        });
                    },
                    .arg,
                    .block,
                    =&gt; <span class="tok-kw">unreachable</span>,
                    .atomicrmw =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>{
                            .info = extra.info,
                            .ptr = instructions.map(extra.ptr),
                            .val = instructions.map(extra.val),
                        });
                    },
                    .br,
                    .fence,
                    .@&quot;ret void&quot;,
                    .@&quot;unreachable&quot;,
                    =&gt; {},
                    .br_cond =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>{
                            .cond = instructions.map(extra.cond),
                            .then = extra.then,
                            .@&quot;else&quot; = extra.@&quot;else&quot;,
                            .weights = extra.weights,
                        });
                    },
                    .call,
                    .@&quot;call fast&quot;,
                    .@&quot;musttail call&quot;,
                    .@&quot;musttail call fast&quot;,
                    .@&quot;notail call&quot;,
                    .@&quot;notail call fast&quot;,
                    .@&quot;tail call&quot;,
                    .@&quot;tail call fast&quot;,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, instruction.data);
                        <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>{
                            .info = extra.data.info,
                            .attributes = extra.data.attributes,
                            .ty = extra.data.ty,
                            .callee = instructions.map(extra.data.callee),
                            .args_len = extra.data.args_len,
                        });
                        wip_extra.appendMappedValues(args, instructions);
                    },
                    .cmpxchg,
                    .@&quot;cmpxchg weak&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>{
                            .info = extra.info,
                            .ptr = instructions.map(extra.ptr),
                            .cmp = instructions.map(extra.cmp),
                            .new = instructions.map(extra.new),
                        });
                    },
                    .extractelement =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>{
                            .val = instructions.map(extra.val),
                            .index = instructions.map(extra.index),
                        });
                    },
                    .extractvalue =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>{
                            .val = instructions.map(extra.data.val),
                            .indices_len = extra.data.indices_len,
                        });
                        wip_extra.appendSlice(indices);
                    },
                    .fneg,
                    .@&quot;fneg fast&quot;,
                    .ret,
                    =&gt; instruction.data = <span class="tok-builtin">@intFromEnum</span>(instructions.map(<span class="tok-builtin">@enumFromInt</span>(instruction.data))),
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>{
                            .<span class="tok-type">type</span> = extra.data.<span class="tok-type">type</span>,
                            .base = instructions.map(extra.data.base),
                            .indices_len = extra.data.indices_len,
                        });
                        wip_extra.appendMappedValues(indices, instructions);
                    },
                    .indirectbr =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, instruction.data);
                        <span class="tok-kw">const</span> targets = extra.trail.next(extra.data.targets_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>{
                            .addr = instructions.map(extra.data.addr),
                            .targets_len = extra.data.targets_len,
                        });
                        wip_extra.appendSlice(targets);
                    },
                    .insertelement =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>{
                            .val = instructions.map(extra.val),
                            .elem = instructions.map(extra.elem),
                            .index = instructions.map(extra.index),
                        });
                    },
                    .insertvalue =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>{
                            .val = instructions.map(extra.data.val),
                            .elem = instructions.map(extra.data.elem),
                            .indices_len = extra.data.indices_len,
                        });
                        wip_extra.appendSlice(indices);
                    },
                    .load,
                    .@&quot;load atomic&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>{
                            .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                            .ptr = instructions.map(extra.ptr),
                            .info = extra.info,
                        });
                    },
                    .phi,
                    .@&quot;phi fast&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> incoming_len = current_block.incoming;
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data);
                        <span class="tok-kw">const</span> incoming_vals = extra.trail.next(incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, self);
                        <span class="tok-kw">const</span> incoming_blocks = extra.trail.next(incoming_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>{
                            .<span class="tok-type">type</span> = extra.data.<span class="tok-type">type</span>,
                        });
                        wip_extra.appendMappedValues(incoming_vals, instructions);
                        wip_extra.appendSlice(incoming_blocks);
                    },
                    .select,
                    .@&quot;select fast&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>{
                            .cond = instructions.map(extra.cond),
                            .lhs = instructions.map(extra.lhs),
                            .rhs = instructions.map(extra.rhs),
                        });
                    },
                    .shufflevector =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>{
                            .lhs = instructions.map(extra.lhs),
                            .rhs = instructions.map(extra.rhs),
                            .mask = instructions.map(extra.mask),
                        });
                    },
                    .store,
                    .@&quot;store atomic&quot;,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>{
                            .val = instructions.map(extra.val),
                            .ptr = instructions.map(extra.ptr),
                            .info = extra.info,
                        });
                    },
                    .@&quot;switch&quot; =&gt; {
                        <span class="tok-kw">var</span> extra = self.extraDataTrail(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
                        <span class="tok-kw">const</span> case_vals = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, self);
                        <span class="tok-kw">const</span> case_blocks = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, self);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>{
                            .val = instructions.map(extra.data.val),
                            .default = extra.data.default,
                            .cases_len = extra.data.cases_len,
                            .weights = extra.data.weights,
                        });
                        wip_extra.appendSlice(case_vals);
                        wip_extra.appendSlice(case_blocks);
                    },
                    .va_arg =&gt; {
                        <span class="tok-kw">const</span> extra = self.extraData(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, instruction.data);
                        instruction.data = wip_extra.addExtra(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>{
                            .list = instructions.map(extra.list),
                            .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                        });
                    },
                }
                function.instructions.appendAssumeCapacity(instruction);
                names[<span class="tok-builtin">@intFromEnum</span>(new_instruction_index)] = <span class="tok-kw">try</span> wip_name.map(<span class="tok-kw">if</span> (self.strip)
                    <span class="tok-kw">if</span> (old_instruction_index.hasResultWip(self)) .empty <span class="tok-kw">else</span> .none
                <span class="tok-kw">else</span>
                    self.names.items[<span class="tok-builtin">@intFromEnum</span>(old_instruction_index)], <span class="tok-str">&quot;.&quot;</span>);

                <span class="tok-kw">if</span> (self.debug_locations.get(old_instruction_index)) |location| {
                    debug_locations.putAssumeCapacity(new_instruction_index, location);
                }

                <span class="tok-kw">if</span> (self.debug_values.getIndex(old_instruction_index)) |index| {
                    debug_values[index] = new_instruction_index;
                }

                value_indices[<span class="tok-builtin">@intFromEnum</span>(new_instruction_index)] = value_index;
                <span class="tok-kw">if</span> (old_instruction_index.hasResultWip(self)) value_index += <span class="tok-number">1</span>;
            }
        }

        <a href="std.debug.html#std.debug.assert">assert</a>(function.instructions.len == final_instructions_len);
        function.extra = wip_extra.finish();
        function.blocks = blocks;
        function.names = names.ptr;
        function.value_indices = value_indices.ptr;
        function.strip = self.strip;
        function.debug_locations = debug_locations;
        function.debug_values = debug_values;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <span class="tok-type">void</span> {
        self.extra.deinit(self.builder.gpa);
        self.debug_values.deinit(self.builder.gpa);
        self.debug_locations.deinit(self.builder.gpa);
        self.names.deinit(self.builder.gpa);
        self.instructions.deinit(self.builder.gpa);
        <span class="tok-kw">for</span> (self.blocks.items) |*b| b.instructions.deinit(self.builder.gpa);
        self.blocks.deinit(self.builder.gpa);
        self.* = <span class="tok-null">undefined</span>;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">cmpTag</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .@&quot;fcmp false&quot;,
            .@&quot;fcmp fast false&quot;,
            .@&quot;fcmp fast oeq&quot;,
            .@&quot;fcmp fast oge&quot;,
            .@&quot;fcmp fast ogt&quot;,
            .@&quot;fcmp fast ole&quot;,
            .@&quot;fcmp fast olt&quot;,
            .@&quot;fcmp fast one&quot;,
            .@&quot;fcmp fast ord&quot;,
            .@&quot;fcmp fast true&quot;,
            .@&quot;fcmp fast ueq&quot;,
            .@&quot;fcmp fast uge&quot;,
            .@&quot;fcmp fast ugt&quot;,
            .@&quot;fcmp fast ule&quot;,
            .@&quot;fcmp fast ult&quot;,
            .@&quot;fcmp fast une&quot;,
            .@&quot;fcmp fast uno&quot;,
            .@&quot;fcmp oeq&quot;,
            .@&quot;fcmp oge&quot;,
            .@&quot;fcmp ogt&quot;,
            .@&quot;fcmp ole&quot;,
            .@&quot;fcmp olt&quot;,
            .@&quot;fcmp one&quot;,
            .@&quot;fcmp ord&quot;,
            .@&quot;fcmp true&quot;,
            .@&quot;fcmp ueq&quot;,
            .@&quot;fcmp uge&quot;,
            .@&quot;fcmp ugt&quot;,
            .@&quot;fcmp ule&quot;,
            .@&quot;fcmp ult&quot;,
            .@&quot;fcmp une&quot;,
            .@&quot;fcmp uno&quot;,
            .@&quot;icmp eq&quot;,
            .@&quot;icmp ne&quot;,
            .@&quot;icmp sge&quot;,
            .@&quot;icmp sgt&quot;,
            .@&quot;icmp sle&quot;,
            .@&quot;icmp slt&quot;,
            .@&quot;icmp uge&quot;,
            .@&quot;icmp ugt&quot;,
            .@&quot;icmp ule&quot;,
            .@&quot;icmp ult&quot;,
            =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self)),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        _ = <span class="tok-kw">try</span> lhs.typeOfWip(self).changeScalar(.<span class="tok-type">i1</span>, self.builder);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>{
                .lhs = lhs,
                .rhs = rhs,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">phiTag</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.WipFunction.WipPhi.html">WipPhi</a> {
        <span class="tok-kw">switch</span> (tag) {
            .phi, .@&quot;phi fast&quot; =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> ty.isSized(self.builder)),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">const</span> incoming = self.cursor.block.ptrConst(self).incoming;
        <a href="std.debug.html#std.debug.assert">assert</a>(incoming &gt; <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, incoming * <span class="tok-number">2</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>{ .<span class="tok-type">type</span> = ty }),
        });
        _ = self.extra.addManyAsSliceAssumeCapacity(incoming * <span class="tok-number">2</span>);
        <span class="tok-kw">return</span> .{ .block = self.cursor.block, .instruction = instruction };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">selectTag</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        tag: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a>,
        cond: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        lhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        rhs: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">switch</span> (tag) {
            .select, .@&quot;select fast&quot; =&gt; {
                <a href="std.debug.html#std.debug.assert">assert</a>(cond.typeOfWip(self).scalarType(self.builder) == .<span class="tok-type">i1</span>);
                <a href="std.debug.html#std.debug.assert">assert</a>(lhs.typeOfWip(self) == rhs.typeOfWip(self));
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
        <span class="tok-kw">try</span> self.ensureUnusedExtraCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, <span class="tok-number">0</span>);
        <span class="tok-kw">const</span> instruction = <span class="tok-kw">try</span> self.addInst(name, .{
            .tag = tag,
            .data = self.addExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>{
                .cond = cond,
                .lhs = lhs,
                .rhs = rhs,
            }),
        });
        <span class="tok-kw">return</span> instruction.toValue();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedExtraCapacity</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        count: <span class="tok-type">usize</span>,
        <span class="tok-kw">comptime</span> Extra: <span class="tok-type">type</span>,
        trail_len: <span class="tok-type">usize</span>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> self.extra.ensureUnusedCapacity(
            self.builder.gpa,
            count * (<span class="tok-builtin">@typeInfo</span>(Extra).@&quot;struct&quot;.fields.len + trail_len),
        );
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addInst</span>(
        self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        instruction: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>,
    ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> {
        <span class="tok-kw">const</span> block_instructions = &amp;self.cursor.block.ptr(self).instructions;
        <span class="tok-kw">try</span> self.instructions.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">if</span> (!self.strip) {
            <span class="tok-kw">try</span> self.names.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);
            <span class="tok-kw">try</span> self.debug_locations.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);
        }
        <span class="tok-kw">try</span> block_instructions.ensureUnusedCapacity(self.builder.gpa, <span class="tok-number">1</span>);
        <span class="tok-kw">const</span> final_name = <span class="tok-kw">if</span> (name) |n|
            <span class="tok-kw">if</span> (self.strip) .empty <span class="tok-kw">else</span> <span class="tok-kw">try</span> self.builder.string(n)
        <span class="tok-kw">else</span>
            .none;

        <span class="tok-kw">const</span> index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.instructions.len);
        self.instructions.appendAssumeCapacity(instruction);
        <span class="tok-kw">if</span> (!self.strip) {
            self.names.appendAssumeCapacity(final_name);
            <span class="tok-kw">if</span> (block_instructions.items.len == <span class="tok-number">0</span> <span class="tok-kw">or</span>
                !<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(self.debug_location, self.prev_debug_location))
            {
                self.debug_locations.putAssumeCapacity(index, self.debug_location);
                self.prev_debug_location = self.debug_location;
            }
        }
        block_instructions.insertAssumeCapacity(self.cursor.instruction, index);
        self.cursor.instruction += <span class="tok-number">1</span>;
        <span class="tok-kw">return</span> index;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">addExtraAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, extra: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> {
        <span class="tok-kw">const</span> result: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a> = <span class="tok-builtin">@intCast</span>(self.extra.items.len);
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields) |field| {
            <span class="tok-kw">const</span> value = <span class="tok-builtin">@field</span>(extra, field.name);
            self.extra.appendAssumeCapacity(<span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                <span class="tok-type">u32</span> =&gt; value,
                <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
                <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
                <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
                =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
                <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
                =&gt; <span class="tok-builtin">@bitCast</span>(value),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
            });
        }
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-kw">const</span> ExtraDataTrail = <span class="tok-kw">struct</span> {
        index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>,

        <span class="tok-kw">fn</span> <span class="tok-fn">nextMut</span>(self: *<a href="std.zig.llvm.Builder.WipFunction.ExtraDataTrail.html">ExtraDataTrail</a>, len: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>, wip: *<a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) []Item {
            <span class="tok-kw">const</span> items: []Item = <span class="tok-builtin">@ptrCast</span>(wip.extra.items[self.index..][<span class="tok-number">0</span>..len]);
            self.index += <span class="tok-builtin">@intCast</span>(len);
            <span class="tok-kw">return</span> items;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(
            self: *<a href="std.zig.llvm.Builder.WipFunction.ExtraDataTrail.html">ExtraDataTrail</a>,
            len: <span class="tok-type">u32</span>,
            <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>,
            wip: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        ) []<span class="tok-kw">const</span> Item {
            <span class="tok-kw">const</span> items: []<span class="tok-kw">const</span> Item = <span class="tok-builtin">@ptrCast</span>(wip.extra.items[self.index..][<span class="tok-number">0</span>..len]);
            self.index += <span class="tok-builtin">@intCast</span>(len);
            <span class="tok-kw">return</span> items;
        }
    };

    <span class="tok-kw">fn</span> <span class="tok-fn">extraDataTrail</span>(
        self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>,
        <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
        index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>,
    ) <span class="tok-kw">struct</span> { data: T, trail: <a href="std.zig.llvm.Builder.WipFunction.ExtraDataTrail.html">ExtraDataTrail</a> } {
        <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
        <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields, self.extra.items[index..][<span class="tok-number">0</span>..fields.len]) |field, value|
            <span class="tok-builtin">@field</span>(result, field.name) = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
                <span class="tok-type">u32</span> =&gt; value,
                <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a>,
                <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
                <a href="std.zig.llvm.Builder.WipFunction.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>,
                <a href="std.zig.llvm.Builder.Type.html">Type</a>,
                <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.Weights.html">Weights</a>,
                =&gt; <span class="tok-builtin">@enumFromInt</span>(value),
                <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.Info.html">Info</a>,
                <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Info.html">Info</a>,
                =&gt; <span class="tok-builtin">@bitCast</span>(value),
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
            };
        <span class="tok-kw">return</span> .{
            .data = result,
            .trail = .{ .index = index + <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a>, <span class="tok-builtin">@intCast</span>(fields.len)) },
        };
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">extraData</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, index: <a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html#std.zig.llvm.Builder.Function.Instruction.ExtraIndex">ExtraIndex</a>) T {
        <span class="tok-kw">return</span> self.extraDataTrail(T, index).data;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FloatCondition = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
    oeq = <span class="tok-number">1</span>,
    ogt = <span class="tok-number">2</span>,
    oge = <span class="tok-number">3</span>,
    olt = <span class="tok-number">4</span>,
    ole = <span class="tok-number">5</span>,
    one = <span class="tok-number">6</span>,
    ord = <span class="tok-number">7</span>,
    uno = <span class="tok-number">8</span>,
    ueq = <span class="tok-number">9</span>,
    ugt = <span class="tok-number">10</span>,
    uge = <span class="tok-number">11</span>,
    ult = <span class="tok-number">12</span>,
    ule = <span class="tok-number">13</span>,
    une = <span class="tok-number">14</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> IntegerCondition = <span class="tok-kw">enum</span>(<span class="tok-type">u6</span>) {
    eq = <span class="tok-number">32</span>,
    ne = <span class="tok-number">33</span>,
    ugt = <span class="tok-number">34</span>,
    uge = <span class="tok-number">35</span>,
    ult = <span class="tok-number">36</span>,
    ule = <span class="tok-number">37</span>,
    sgt = <span class="tok-number">38</span>,
    sge = <span class="tok-number">39</span>,
    slt = <span class="tok-number">40</span>,
    sle = <span class="tok-number">41</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MemoryAccessKind = <span class="tok-kw">enum</span>(<span class="tok-type">u1</span>) {
    normal,
    @&quot;volatile&quot;,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a>,
        <span class="tok-kw">comptime</span> prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self != .normal) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ prefix, <span class="tok-builtin">@tagName</span>(self) });
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SyncScope = <span class="tok-kw">enum</span>(<span class="tok-type">u1</span>) {
    singlethread,
    system,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
        <span class="tok-kw">comptime</span> prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self != .system) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\{s}syncscope(&quot;{s}&quot;)</span>
        , .{ prefix, <span class="tok-builtin">@tagName</span>(self) });
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicOrdering = <span class="tok-kw">enum</span>(<span class="tok-type">u3</span>) {
    none = <span class="tok-number">0</span>,
    unordered = <span class="tok-number">1</span>,
    monotonic = <span class="tok-number">2</span>,
    acquire = <span class="tok-number">3</span>,
    release = <span class="tok-number">4</span>,
    acq_rel = <span class="tok-number">5</span>,
    seq_cst = <span class="tok-number">6</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        self: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
        <span class="tok-kw">comptime</span> prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (self != .none) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}{s}&quot;</span>, .{ prefix, <span class="tok-builtin">@tagName</span>(self) });
    }
};

<span class="tok-kw">const</span> MemoryAccessInfo = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
    access_kind: <a href="std.zig.llvm.Builder.MemoryAccessKind.html">MemoryAccessKind</a> = .normal,
    atomic_rmw_operation: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.Operation.html">Operation</a> = .none,
    sync_scope: <a href="std.zig.llvm.Builder.SyncScope.html">SyncScope</a>,
    success_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a>,
    failure_ordering: <a href="std.zig.llvm.Builder.AtomicOrdering.html">AtomicOrdering</a> = .none,
    alignment: <a href="std.zig.llvm.Builder.Alignment.html">Alignment</a> = .default,
    _: <span class="tok-type">u13</span> = <span class="tok-null">undefined</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FastMath = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u8</span>) {
    unsafe_algebra: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,<span class="tok-comment"> // Legacy
    </span>nnan: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    ninf: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    nsz: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    arcp: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    contract: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    afn: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
    reassoc: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> fast = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>{
        .nnan = <span class="tok-null">true</span>,
        .ninf = <span class="tok-null">true</span>,
        .nsz = <span class="tok-null">true</span>,
        .arcp = <span class="tok-null">true</span>,
        .contract = <span class="tok-null">true</span>,
        .afn = <span class="tok-null">true</span>,
        .reassoc = <span class="tok-null">true</span>,
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FastMathKind = <span class="tok-kw">enum</span> {
    normal,
    fast,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toCallKind</span>(self: <a href="std.zig.llvm.Builder.FastMathKind.html">FastMathKind</a>) <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.Kind.html">Kind</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            .normal =&gt; .normal,
            .fast =&gt; .fast,
        };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Constant = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    <span class="tok-null">false</span>,
    <span class="tok-null">true</span>,
    @&quot;0&quot;,
    @&quot;1&quot;,
    none,
    no_init = (<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">30</span>) - <span class="tok-number">1</span>,
    _,

    <span class="tok-kw">const</span> first_global: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">29</span>);

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span>(<span class="tok-type">u7</span>) {
        positive_integer,
        negative_integer,
        half,
        bfloat,
        float,
        double,
        fp128,
        x86_fp80,
        ppc_fp128,
        <span class="tok-null">null</span>,
        none,
        structure,
        packed_structure,
        array,
        <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.string">string</a>,
        vector,
        splat,
        zeroinitializer,
        undef,
        poison,
        blockaddress,
        dso_local_equivalent,
        no_cfi,
        trunc,
        ptrtoint,
        inttoptr,
        bitcast,
        addrspacecast,
        getelementptr,
        @&quot;getelementptr inbounds&quot;,
        add,
        @&quot;add nsw&quot;,
        @&quot;add nuw&quot;,
        sub,
        @&quot;sub nsw&quot;,
        @&quot;sub nuw&quot;,
        shl,
        xor,
        @&quot;asm&quot;,
        @&quot;asm sideeffect&quot;,
        @&quot;asm alignstack&quot;,
        @&quot;asm sideeffect alignstack&quot;,
        @&quot;asm inteldialect&quot;,
        @&quot;asm sideeffect inteldialect&quot;,
        @&quot;asm alignstack inteldialect&quot;,
        @&quot;asm sideeffect alignstack inteldialect&quot;,
        @&quot;asm unwind&quot;,
        @&quot;asm sideeffect unwind&quot;,
        @&quot;asm alignstack unwind&quot;,
        @&quot;asm sideeffect alignstack unwind&quot;,
        @&quot;asm inteldialect unwind&quot;,
        @&quot;asm sideeffect inteldialect unwind&quot;,
        @&quot;asm alignstack inteldialect unwind&quot;,
        @&quot;asm sideeffect alignstack inteldialect unwind&quot;,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBinaryOpcode</span>(self: <a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>) <a href="std.zig.llvm.Builder.BinaryOpcode.html">BinaryOpcode</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
                .add,
                .@&quot;add nsw&quot;,
                .@&quot;add nuw&quot;,
                =&gt; .add,
                .sub,
                .@&quot;sub nsw&quot;,
                .@&quot;sub nuw&quot;,
                =&gt; .sub,
                .shl =&gt; .shl,
                .xor =&gt; .xor,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toCastOpcode</span>(self: <a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>) <a href="std.zig.llvm.Builder.CastOpcode.html">CastOpcode</a> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
                .trunc =&gt; .trunc,
                .ptrtoint =&gt; .ptrtoint,
                .inttoptr =&gt; .inttoptr,
                .bitcast =&gt; .bitcast,
                .addrspacecast =&gt; .addrspacecast,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {
        tag: <a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>,
        data: <a href="std.zig.llvm.Builder.Constant.Item.html#std.zig.llvm.Builder.Constant.Item.ExtraIndex">ExtraIndex</a>,

        <span class="tok-kw">const</span> ExtraIndex = <span class="tok-type">u32</span>;
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Integer = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u64</span>) {
        <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        limbs_len: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> limbs = <span class="tok-builtin">@divExact</span>(<span class="tok-builtin">@bitSizeOf</span>(<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>), <span class="tok-builtin">@bitSizeOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Double = <span class="tok-kw">struct</span> {
        lo: <span class="tok-type">u32</span>,
        hi: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fp80 = <span class="tok-kw">struct</span> {
        lo_lo: <span class="tok-type">u32</span>,
        lo_hi: <span class="tok-type">u32</span>,
        hi: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fp128 = <span class="tok-kw">struct</span> {
        lo_lo: <span class="tok-type">u32</span>,
        lo_hi: <span class="tok-type">u32</span>,
        hi_lo: <span class="tok-type">u32</span>,
        hi_hi: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Aggregate = <span class="tok-kw">struct</span> {
        <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,<span class="tok-comment">
        //fields: [type.aggregateLen(builder)]Constant,
    </span>};

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Splat = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        value: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BlockAddress = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
        block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Cast = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
        <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Signedness = <span class="tok-kw">enum</span> { unsigned, signed, unneeded };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetElementPtr = <span class="tok-kw">struct</span> {
        <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
        info: <a href="std.zig.llvm.Builder.Constant.GetElementPtr.Info.html">Info</a>,<span class="tok-comment">
        //indices: [info.indices_len]Constant,

        </span><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Kind = <span class="tok-kw">enum</span> { normal, inbounds };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> InRangeIndex = <span class="tok-kw">enum</span>(<span class="tok-type">u16</span>) { none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u16</span>), _ };
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Info = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) { indices_len: <span class="tok-type">u16</span>, inrange: <a href="std.zig.llvm.Builder.Constant.GetElementPtr.InRangeIndex.html">InRangeIndex</a> };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Binary = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
        rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Assembly = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
        constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Info = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
            sideeffect: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            alignstack: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            inteldialect: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            unwind: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(self: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        constant: <span class="tok-type">u30</span>,
        global: <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>,
    } {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(self) &lt; <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html#std.zig.llvm.Builder.Constant.first_global">first_global</a>))
            .{ .constant = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(self)) }
        <span class="tok-kw">else</span>
            .{ .global = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(self) - <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html#std.zig.llvm.Builder.Constant.first_global">first_global</a>)) };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toValue</span>(self: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<a href="std.zig.llvm.Builder.Value.html">Value</a>.<a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_constant">first_constant</a> + <span class="tok-builtin">@intFromEnum</span>(self));
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(self: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">switch</span> (self.unwrap()) {
            .constant =&gt; |constant| {
                <span class="tok-kw">const</span> item = builder.constant_items.get(constant);
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
                    .positive_integer,
                    .negative_integer,
                    =&gt; <span class="tok-builtin">@as</span>(
                        *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>,
                        <span class="tok-builtin">@ptrCast</span>(builder.constant_limbs.items[item.data..][<span class="tok-number">0</span>..<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a>]),
                    ).<span class="tok-type">type</span>,
                    .half =&gt; .half,
                    .bfloat =&gt; .bfloat,
                    .float =&gt; .float,
                    .double =&gt; .double,
                    .fp128 =&gt; .fp128,
                    .x86_fp80 =&gt; .x86_fp80,
                    .ppc_fp128 =&gt; .ppc_fp128,
                    .<span class="tok-null">null</span>,
                    .none,
                    .zeroinitializer,
                    .undef,
                    .poison,
                    =&gt; <span class="tok-builtin">@enumFromInt</span>(item.data),
                    .structure,
                    .packed_structure,
                    .array,
                    .vector,
                    =&gt; builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, item.data).<span class="tok-type">type</span>,
                    .splat =&gt; builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>, item.data).<span class="tok-type">type</span>,
                    .string =&gt; builder.arrayTypeAssumeCapacity(
                        <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.String.html">String</a>, <span class="tok-builtin">@enumFromInt</span>(item.data)).slice(builder).?.len,
                        .<span class="tok-type">i8</span>,
                    ),
                    .blockaddress =&gt; builder.ptrTypeAssumeCapacity(
                        builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>, item.data)
                            .function.ptrConst(builder).global.ptrConst(builder).addr_space,
                    ),
                    .dso_local_equivalent,
                    .no_cfi,
                    =&gt; builder.ptrTypeAssumeCapacity(<span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, <span class="tok-builtin">@enumFromInt</span>(item.data))
                        .ptrConst(builder).global.ptrConst(builder).addr_space),
                    .trunc,
                    .ptrtoint,
                    .inttoptr,
                    .bitcast,
                    .addrspacecast,
                    =&gt; builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, item.data).<span class="tok-type">type</span>,
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = builder.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>, item.data);
                        <span class="tok-kw">const</span> indices =
                            extra.trail.next(extra.data.info.indices_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, builder);
                        <span class="tok-kw">const</span> base_ty = extra.data.base.typeOf(builder);
                        <span class="tok-kw">if</span> (!base_ty.isVector(builder)) <span class="tok-kw">for</span> (indices) |index| {
                            <span class="tok-kw">const</span> index_ty = index.typeOf(builder);
                            <span class="tok-kw">if</span> (!index_ty.isVector(builder)) <span class="tok-kw">continue</span>;
                            <span class="tok-kw">return</span> index_ty.changeScalarAssumeCapacity(base_ty, builder);
                        };
                        <span class="tok-kw">return</span> base_ty;
                    },
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .shl,
                    .xor,
                    =&gt; builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, item.data).lhs.typeOf(builder),
                    .@&quot;asm&quot;,
                    .@&quot;asm sideeffect&quot;,
                    .@&quot;asm alignstack&quot;,
                    .@&quot;asm sideeffect alignstack&quot;,
                    .@&quot;asm inteldialect&quot;,
                    .@&quot;asm sideeffect inteldialect&quot;,
                    .@&quot;asm alignstack inteldialect&quot;,
                    .@&quot;asm sideeffect alignstack inteldialect&quot;,
                    .@&quot;asm unwind&quot;,
                    .@&quot;asm sideeffect unwind&quot;,
                    .@&quot;asm alignstack unwind&quot;,
                    .@&quot;asm sideeffect alignstack unwind&quot;,
                    .@&quot;asm inteldialect unwind&quot;,
                    .@&quot;asm sideeffect inteldialect unwind&quot;,
                    .@&quot;asm alignstack inteldialect unwind&quot;,
                    .@&quot;asm sideeffect alignstack inteldialect unwind&quot;,
                    =&gt; .ptr,
                };
            },
            .global =&gt; |global| <span class="tok-kw">return</span> builder.ptrTypeAssumeCapacity(
                global.ptrConst(builder).addr_space,
            ),
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isZeroInit</span>(self: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">switch</span> (self.unwrap()) {
            .constant =&gt; |constant| {
                <span class="tok-kw">const</span> item = builder.constant_items.get(constant);
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (item.tag) {
                    .positive_integer =&gt; {
                        <span class="tok-kw">const</span> extra: *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a> =
                            <span class="tok-builtin">@ptrCast</span>(builder.constant_limbs.items[item.data..][<span class="tok-number">0</span>..<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a>]);
                        <span class="tok-kw">const</span> limbs = builder.constant_limbs
                            .items[item.data + <a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> ..][<span class="tok-number">0</span>..extra.limbs_len];
                        <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>, limbs, &amp;.{<span class="tok-number">0</span>});
                    },
                    .half, .bfloat, .float =&gt; item.data == <span class="tok-number">0</span>,
                    .double =&gt; {
                        <span class="tok-kw">const</span> extra = builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Double.html">Double</a>, item.data);
                        <span class="tok-kw">return</span> extra.lo == <span class="tok-number">0</span> <span class="tok-kw">and</span> extra.hi == <span class="tok-number">0</span>;
                    },
                    .fp128, .ppc_fp128 =&gt; {
                        <span class="tok-kw">const</span> extra = builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, item.data);
                        <span class="tok-kw">return</span> extra.lo_lo == <span class="tok-number">0</span> <span class="tok-kw">and</span> extra.lo_hi == <span class="tok-number">0</span> <span class="tok-kw">and</span>
                            extra.hi_lo == <span class="tok-number">0</span> <span class="tok-kw">and</span> extra.hi_hi == <span class="tok-number">0</span>;
                    },
                    .x86_fp80 =&gt; {
                        <span class="tok-kw">const</span> extra = builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp80.html">Fp80</a>, item.data);
                        <span class="tok-kw">return</span> extra.lo_lo == <span class="tok-number">0</span> <span class="tok-kw">and</span> extra.lo_hi == <span class="tok-number">0</span> <span class="tok-kw">and</span> extra.hi == <span class="tok-number">0</span>;
                    },
                    .vector =&gt; {
                        <span class="tok-kw">var</span> extra = builder.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, item.data);
                        <span class="tok-kw">const</span> len: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(extra.data.<span class="tok-type">type</span>.aggregateLen(builder));
                        <span class="tok-kw">const</span> vals = extra.trail.next(len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, builder);
                        <span class="tok-kw">for</span> (vals) |val| <span class="tok-kw">if</span> (!val.isZeroInit(builder)) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
                        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                    },
                    .<span class="tok-null">null</span>, .zeroinitializer =&gt; <span class="tok-null">true</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
                };
            },
            .global =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
        }
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getBase</span>(self: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
        <span class="tok-kw">var</span> cur = self;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) <span class="tok-kw">switch</span> (cur.unwrap()) {
            .constant =&gt; |constant| {
                <span class="tok-kw">const</span> item = builder.constant_items.get(constant);
                <span class="tok-kw">switch</span> (item.tag) {
                    .ptrtoint,
                    .inttoptr,
                    .bitcast,
                    =&gt; cur = builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, item.data).val,
                    .getelementptr =&gt; cur = builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>, item.data).base,
                    .add =&gt; {
                        <span class="tok-kw">const</span> extra = builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, item.data);
                        <span class="tok-kw">const</span> lhs_base = extra.lhs.getBase(builder);
                        <span class="tok-kw">const</span> rhs_base = extra.rhs.getBase(builder);
                        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (lhs_base != .none <span class="tok-kw">and</span> rhs_base != .none)
                            .none
                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (lhs_base != .none) lhs_base <span class="tok-kw">else</span> rhs_base;
                    },
                    .sub =&gt; {
                        <span class="tok-kw">const</span> extra = builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, item.data);
                        <span class="tok-kw">if</span> (extra.rhs.getBase(builder) != .none) <span class="tok-kw">return</span> .none;
                        cur = extra.lhs;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> .none,
                }
            },
            .global =&gt; |global| <span class="tok-kw">switch</span> (global.ptrConst(builder).kind) {
                .alias =&gt; |alias| cur = alias.ptrConst(builder).aliasee,
                .variable, .function =&gt; <span class="tok-kw">return</span> global,
                .replaced =&gt; <span class="tok-kw">unreachable</span>,
            },
        };
    }

    <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
        constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
        builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    };
    <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        data: <a href="std.zig.llvm.Builder.Constant.FormatData.html">FormatData</a>,
        <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfNone">indexOfNone</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">&quot;, %&quot;</span>)) |_|
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;invalid format string: '&quot;</span> ++ fmt_str ++ <span class="tok-str">&quot;'&quot;</span>);
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">','</span>) != <span class="tok-null">null</span>) {
            <span class="tok-kw">if</span> (data.constant == .no_init) <span class="tok-kw">return</span>;
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">','</span>);
        }
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">' '</span>) != <span class="tok-null">null</span>) {
            <span class="tok-kw">if</span> (data.constant == .no_init) <span class="tok-kw">return</span>;
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">' '</span>);
        }
        <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.indexOfScalar">indexOfScalar</a>(<span class="tok-type">u8</span>, fmt_str, <span class="tok-str">'%'</span>) != <span class="tok-null">null</span>)
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%} &quot;</span>, .{data.constant.typeOf(data.builder).fmt(data.builder)});
        <a href="std.debug.html#std.debug.assert">assert</a>(data.constant != .no_init);
        <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.enums.html">enums</a>.<a href="std.enums.html#std.enums.tagName">tagName</a>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>, data.constant)) |name| <span class="tok-kw">return</span> writer.writeAll(name);
        <span class="tok-kw">switch</span> (data.constant.unwrap()) {
            .constant =&gt; |constant| {
                <span class="tok-kw">const</span> item = data.builder.constant_items.get(constant);
                <span class="tok-kw">switch</span> (item.tag) {
                    .positive_integer,
                    .negative_integer,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra: *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a> =
                            <span class="tok-builtin">@ptrCast</span>(data.builder.constant_limbs.items[item.data..][<span class="tok-number">0</span>..<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a>]);
                        <span class="tok-kw">const</span> limbs = data.builder.constant_limbs
                            .items[item.data + <a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> ..][<span class="tok-number">0</span>..extra.limbs_len];
                        <span class="tok-kw">const</span> bigint: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a> = .{
                            .limbs = limbs,
                            .positive = <span class="tok-kw">switch</span> (tag) {
                                .positive_integer =&gt; <span class="tok-null">true</span>,
                                .negative_integer =&gt; <span class="tok-null">false</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> ExpectedContents = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
                            <span class="tok-kw">const</span> expected_limbs = <span class="tok-builtin">@divExact</span>(<span class="tok-number">512</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                            string: [
                                (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>{
                                    .limbs = &amp;([<span class="tok-number">1</span>]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>{
                                        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>),
                                    } ** <a href="std.zig.llvm.Builder.Constant.html#std.zig.llvm.Builder.Constant.format.expected_limbs">expected_limbs</a>),
                                    .positive = <span class="tok-null">false</span>,
                                }).sizeInBaseUpperBound(<span class="tok-number">10</span>)
                            ]<span class="tok-type">u8</span>,
                            limbs: [
                                <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcToStringLimbsBufferLen">calcToStringLimbsBufferLen</a>(<a href="std.zig.llvm.Builder.Constant.html#std.zig.llvm.Builder.Constant.format.expected_limbs">expected_limbs</a>, <span class="tok-number">10</span>)
                            ]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
                        };
                        <span class="tok-kw">var</span> stack <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(ExpectedContents)) =
                            <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-builtin">@sizeOf</span>(ExpectedContents), data.builder.gpa);
                        <span class="tok-kw">const</span> allocator = stack.get();
                        <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> bigint.toStringAlloc(allocator, <span class="tok-number">10</span>, <span class="tok-null">undefined</span>);
                        <span class="tok-kw">defer</span> allocator.free(str);
                        <span class="tok-kw">try</span> writer.writeAll(str);
                    },
                    .half,
                    .bfloat,
                    =&gt; |tag| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{c}{X:0&gt;4}&quot;</span>, .{ <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-kw">switch</span> (tag) {
                        .half =&gt; <span class="tok-str">'H'</span>,
                        .bfloat =&gt; <span class="tok-str">'R'</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    }), item.data &gt;&gt; <span class="tok-kw">switch</span> (tag) {
                        .half =&gt; <span class="tok-number">0</span>,
                        .bfloat =&gt; <span class="tok-number">16</span>,
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    } }),
                    .float =&gt; {
                        <span class="tok-kw">const</span> Float = <span class="tok-kw">struct</span> {
                            <span class="tok-kw">fn</span> <span class="tok-fn">Repr</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
                                <span class="tok-kw">return</span> <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(std.meta.Int(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(T))) {
                                    mantissa: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatMantissaBits">floatMantissaBits</a>(T)),
                                    exponent: <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.Int">Int</a>(.unsigned, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatExponentBits">floatExponentBits</a>(T)),
                                    sign: <span class="tok-type">u1</span>,
                                };
                            }
                        };
                        <span class="tok-kw">const</span> Mantissa64 = <span class="tok-builtin">@FieldType</span>(Float.Repr(<span class="tok-type">f64</span>), <span class="tok-str">&quot;mantissa&quot;</span>);
                        <span class="tok-kw">const</span> Exponent32 = <span class="tok-builtin">@FieldType</span>(Float.Repr(<span class="tok-type">f32</span>), <span class="tok-str">&quot;exponent&quot;</span>);
                        <span class="tok-kw">const</span> Exponent64 = <span class="tok-builtin">@FieldType</span>(Float.Repr(<span class="tok-type">f64</span>), <span class="tok-str">&quot;exponent&quot;</span>);

                        <span class="tok-kw">const</span> repr: Float.Repr(<span class="tok-type">f32</span>) = <span class="tok-builtin">@bitCast</span>(item.data);
                        <span class="tok-kw">const</span> denormal_shift = <span class="tok-kw">switch</span> (repr.exponent) {
                            <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(Exponent32) =&gt; <span class="tok-builtin">@as</span>(
                                <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(Mantissa64),
                                <span class="tok-builtin">@clz</span>(repr.mantissa),
                            ) + <span class="tok-number">1</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-number">0</span>,
                        };
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{X:0&gt;16}&quot;</span>, .{<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(Float.Repr(<span class="tok-type">f64</span>){
                            .mantissa = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.shl">shl</a>(
                                Mantissa64,
                                repr.mantissa,
                                <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatMantissaBits">floatMantissaBits</a>(<span class="tok-type">f64</span>) - <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatMantissaBits">floatMantissaBits</a>(<span class="tok-type">f32</span>) +
                                    denormal_shift,
                            ),
                            .exponent = <span class="tok-kw">switch</span> (repr.exponent) {
                                <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(Exponent32) =&gt; <span class="tok-kw">if</span> (repr.mantissa &gt; <span class="tok-number">0</span>)
                                    <span class="tok-builtin">@as</span>(Exponent64, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatExponentMin">floatExponentMin</a>(<span class="tok-type">f32</span>) +
                                        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatExponentMax">floatExponentMax</a>(<span class="tok-type">f64</span>)) - denormal_shift
                                <span class="tok-kw">else</span>
                                    <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.minInt">minInt</a>(Exponent64),
                                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@as</span>(Exponent64, repr.exponent) +
                                    (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatExponentMax">floatExponentMax</a>(<span class="tok-type">f64</span>) - <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.floatExponentMax">floatExponentMax</a>(<span class="tok-type">f32</span>)),
                                <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(Exponent32) =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(Exponent64),
                            },
                            .sign = repr.sign,
                        }))});
                    },
                    .double =&gt; {
                        <span class="tok-kw">const</span> extra = data.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Double.html">Double</a>, item.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{X:0&gt;8}{X:0&gt;8}&quot;</span>, .{ extra.hi, extra.lo });
                    },
                    .fp128,
                    .ppc_fp128,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = data.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, item.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0x{c}{X:0&gt;8}{X:0&gt;8}{X:0&gt;8}{X:0&gt;8}&quot;</span>, .{
                            <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-kw">switch</span> (tag) {
                                .fp128 =&gt; <span class="tok-str">'L'</span>,
                                .ppc_fp128 =&gt; <span class="tok-str">'M'</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            }),
                            extra.lo_hi,
                            extra.lo_lo,
                            extra.hi_hi,
                            extra.hi_lo,
                        });
                    },
                    .x86_fp80 =&gt; {
                        <span class="tok-kw">const</span> extra = data.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Fp80.html">Fp80</a>, item.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;0xK{X:0&gt;4}{X:0&gt;8}{X:0&gt;8}&quot;</span>, .{
                            extra.hi, extra.lo_hi, extra.lo_lo,
                        });
                    },
                    .<span class="tok-null">null</span>,
                    .none,
                    .zeroinitializer,
                    .undef,
                    .poison,
                    =&gt; |tag| <span class="tok-kw">try</span> writer.writeAll(<span class="tok-builtin">@tagName</span>(tag)),
                    .structure,
                    .packed_structure,
                    .array,
                    .vector,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = data.builder.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, item.data);
                        <span class="tok-kw">const</span> len: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(extra.data.<span class="tok-type">type</span>.aggregateLen(data.builder));
                        <span class="tok-kw">const</span> vals = extra.trail.next(len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, data.builder);
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-kw">switch</span> (tag) {
                            .structure =&gt; <span class="tok-str">&quot;{ &quot;</span>,
                            .packed_structure =&gt; <span class="tok-str">&quot;&lt;{ &quot;</span>,
                            .array =&gt; <span class="tok-str">&quot;[&quot;</span>,
                            .vector =&gt; <span class="tok-str">&quot;&lt;&quot;</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        });
                        <span class="tok-kw">for</span> (vals, <span class="tok-number">0</span>..) |val, index| {
                            <span class="tok-kw">if</span> (index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%}&quot;</span>, .{val.fmt(data.builder)});
                        }
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-kw">switch</span> (tag) {
                            .structure =&gt; <span class="tok-str">&quot; }&quot;</span>,
                            .packed_structure =&gt; <span class="tok-str">&quot; }&gt;&quot;</span>,
                            .array =&gt; <span class="tok-str">&quot;]&quot;</span>,
                            .vector =&gt; <span class="tok-str">&quot;&gt;&quot;</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        });
                    },
                    .splat =&gt; {
                        <span class="tok-kw">const</span> extra = data.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>, item.data);
                        <span class="tok-kw">const</span> len = extra.<span class="tok-type">type</span>.vectorLen(data.builder);
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'&lt;'</span>);
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..len) |index| {
                            <span class="tok-kw">if</span> (index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%}&quot;</span>, .{extra.value.fmt(data.builder)});
                        }
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'&gt;'</span>);
                    },
                    .string =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;c{\&quot;}&quot;</span>, .{
                        <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.String.html">String</a>, <span class="tok-builtin">@enumFromInt</span>(item.data)).fmt(data.builder),
                    }),
                    .blockaddress =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = data.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>, item.data);
                        <span class="tok-kw">const</span> function = extra.function.ptrConst(data.builder);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}({}, {})&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            function.global.fmt(data.builder),
                            extra.block.toInst(function).fmt(extra.function, data.builder),
                        });
                    },
                    .dso_local_equivalent,
                    .no_cfi,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(item.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s} {}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            function.ptrConst(data.builder).global.fmt(data.builder),
                        });
                    },
                    .trunc,
                    .ptrtoint,
                    .inttoptr,
                    .bitcast,
                    .addrspacecast,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = data.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, item.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s} ({%} to {%})&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.val.fmt(data.builder),
                            extra.<span class="tok-type">type</span>.fmt(data.builder),
                        });
                    },
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = data.builder.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>, item.data);
                        <span class="tok-kw">const</span> indices =
                            extra.trail.next(extra.data.info.indices_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, data.builder);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s} ({%}, {%}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.<span class="tok-type">type</span>.fmt(data.builder),
                            extra.data.base.fmt(data.builder),
                        });
                        <span class="tok-kw">for</span> (indices) |index| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {%}&quot;</span>, .{index.fmt(data.builder)});
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
                    },
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .shl,
                    .xor,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = data.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, item.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s} ({%}, {%})&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.lhs.fmt(data.builder),
                            extra.rhs.fmt(data.builder),
                        });
                    },
                    .@&quot;asm&quot;,
                    .@&quot;asm sideeffect&quot;,
                    .@&quot;asm alignstack&quot;,
                    .@&quot;asm sideeffect alignstack&quot;,
                    .@&quot;asm inteldialect&quot;,
                    .@&quot;asm sideeffect inteldialect&quot;,
                    .@&quot;asm alignstack inteldialect&quot;,
                    .@&quot;asm sideeffect alignstack inteldialect&quot;,
                    .@&quot;asm unwind&quot;,
                    .@&quot;asm sideeffect unwind&quot;,
                    .@&quot;asm alignstack unwind&quot;,
                    .@&quot;asm sideeffect alignstack unwind&quot;,
                    .@&quot;asm inteldialect unwind&quot;,
                    .@&quot;asm sideeffect inteldialect unwind&quot;,
                    .@&quot;asm alignstack inteldialect unwind&quot;,
                    .@&quot;asm sideeffect alignstack inteldialect unwind&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = data.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>, item.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s} {\&quot;}, {\&quot;}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.assembly.fmt(data.builder),
                            extra.constraints.fmt(data.builder),
                        });
                    },
                }
            },
            .global =&gt; |global| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}&quot;</span>, .{global.fmt(data.builder)}),
        }
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Constant.html#std.zig.llvm.Builder.Constant.format">format</a>) {
        <span class="tok-kw">return</span> .{ .data = .{ .constant = self, .builder = builder } };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Value = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    none = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u31</span>),
    <span class="tok-null">false</span> = <a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_constant">first_constant</a> + <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<span class="tok-null">false</span>),
    <span class="tok-null">true</span> = <a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_constant">first_constant</a> + <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<span class="tok-null">true</span>),
    @&quot;0&quot; = <a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_constant">first_constant</a> + <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="#"0"">@&quot;0&quot;</a>),
    @&quot;1&quot; = <a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_constant">first_constant</a> + <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="#"1"">@&quot;1&quot;</a>),
    _,

    <span class="tok-kw">const</span> first_constant = <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">30</span>;
    <span class="tok-kw">const</span> first_metadata = <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">31</span>;

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(self: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        instruction: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,
        constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
        metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    } {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(self) &lt; <a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_constant">first_constant</a>)
            .{ .instruction = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(self)) }
        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(self) &lt; <a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_metadata">first_metadata</a>)
            .{ .constant = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(self) - <a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_constant">first_constant</a>) }
        <span class="tok-kw">else</span>
            .{ .metadata = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(self) - <a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_metadata">first_metadata</a>) };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOfWip</span>(self: <a href="std.zig.llvm.Builder.Value.html">Value</a>, wip: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.WipFunction.html">WipFunction</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.unwrap()) {
            .instruction =&gt; |instruction| instruction.typeOfWip(wip),
            .constant =&gt; |constant| constant.typeOf(wip.builder),
            .metadata =&gt; .metadata,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">typeOf</span>(self: <a href="std.zig.llvm.Builder.Value.html">Value</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.unwrap()) {
            .instruction =&gt; |instruction| instruction.typeOf(function, builder),
            .constant =&gt; |constant| constant.typeOf(builder),
            .metadata =&gt; .metadata,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toConst</span>(self: <a href="std.zig.llvm.Builder.Value.html">Value</a>) ?<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.unwrap()) {
            .instruction, .metadata =&gt; <span class="tok-null">null</span>,
            .constant =&gt; |constant| constant,
        };
    }

    <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
        value: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
        function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
        builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    };
    <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        data: <a href="std.zig.llvm.Builder.Value.FormatData.html">FormatData</a>,
        <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        fmt_opts: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (data.value.unwrap()) {
            .instruction =&gt; |instruction| <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html#std.zig.llvm.Builder.Function.Instruction.Index.format">format</a>(.{
                .instruction = instruction,
                .function = data.function,
                .builder = data.builder,
            }, fmt_str, fmt_opts, writer),
            .constant =&gt; |constant| <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.html#std.zig.llvm.Builder.Constant.format">format</a>(.{
                .constant = constant,
                .builder = data.builder,
            }, fmt_str, fmt_opts, writer),
            .metadata =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.Value.html">Value</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.format">format</a>) {
        <span class="tok-kw">return</span> .{ .data = .{ .value = self, .function = function, .builder = builder } };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MetadataString = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    none = <span class="tok-number">0</span>,
    _,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(self: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-kw">const</span> index = <span class="tok-builtin">@intFromEnum</span>(self);
        <span class="tok-kw">const</span> start = builder.metadata_string_indices.items[index];
        <span class="tok-kw">const</span> end = builder.metadata_string_indices.items[index + <span class="tok-number">1</span>];
        <span class="tok-kw">return</span> builder.metadata_string_bytes.items[start..end];
    }

    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <a href="std.zig.llvm.Builder.MetadataString.Adapter.html">Adapter</a>, key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, key));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <a href="std.zig.llvm.Builder.MetadataString.Adapter.html">Adapter</a>, lhs_key: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> rhs_metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> = <span class="tok-builtin">@enumFromInt</span>(rhs_index);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, lhs_key, rhs_metadata_string.slice(ctx.builder));
        }
    };

    <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
        metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    };
    <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
        data: <a href="std.zig.llvm.Builder.MetadataString.FormatData.html">FormatData</a>,
        <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
        writer: <span class="tok-kw">anytype</span>,
    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
        <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printEscapedString">printEscapedString</a>(data.metadata_string.slice(data.builder), .always_quote, writer);
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.MetadataString.html#std.zig.llvm.Builder.MetadataString.format">format</a>) {
        <span class="tok-kw">return</span> .{ .data = .{ .metadata_string = self, .builder = builder } };
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Metadata = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    none = <span class="tok-number">0</span>,
    empty_tuple = <span class="tok-number">1</span>,
    _,

    <span class="tok-kw">const</span> first_forward_reference = <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">29</span>;
    <span class="tok-kw">const</span> first_local_metadata = <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">30</span>;

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tag = <span class="tok-kw">enum</span>(<span class="tok-type">u6</span>) {
        none,
        file,
        compile_unit,
        @&quot;compile_unit optimized&quot;,
        subprogram,
        @&quot;subprogram local&quot;,
        @&quot;subprogram definition&quot;,
        @&quot;subprogram local definition&quot;,
        @&quot;subprogram optimized&quot;,
        @&quot;subprogram optimized local&quot;,
        @&quot;subprogram optimized definition&quot;,
        @&quot;subprogram optimized local definition&quot;,
        lexical_block,
        location,
        basic_bool_type,
        basic_unsigned_type,
        basic_signed_type,
        basic_float_type,
        composite_struct_type,
        composite_union_type,
        composite_enumeration_type,
        composite_array_type,
        composite_vector_type,
        derived_pointer_type,
        derived_member_type,
        subroutine_type,
        enumerator_unsigned,
        enumerator_signed_positive,
        enumerator_signed_negative,
        subrange,
        tuple,
        str_tuple,
        module_flag,
        expression,
        local_var,
        parameter,
        global_var,
        @&quot;global_var local&quot;,
        global_var_expression,
        constant,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isInline</span>(tag: <a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (tag) {
                .none,
                .expression,
                .constant,
                =&gt; <span class="tok-null">true</span>,
                .file,
                .compile_unit,
                .@&quot;compile_unit optimized&quot;,
                .subprogram,
                .@&quot;subprogram local&quot;,
                .@&quot;subprogram definition&quot;,
                .@&quot;subprogram local definition&quot;,
                .@&quot;subprogram optimized&quot;,
                .@&quot;subprogram optimized local&quot;,
                .@&quot;subprogram optimized definition&quot;,
                .@&quot;subprogram optimized local definition&quot;,
                .lexical_block,
                .location,
                .basic_bool_type,
                .basic_unsigned_type,
                .basic_signed_type,
                .basic_float_type,
                .composite_struct_type,
                .composite_union_type,
                .composite_enumeration_type,
                .composite_array_type,
                .composite_vector_type,
                .derived_pointer_type,
                .derived_member_type,
                .subroutine_type,
                .enumerator_unsigned,
                .enumerator_signed_positive,
                .enumerator_signed_negative,
                .subrange,
                .tuple,
                .str_tuple,
                .module_flag,
                .local_var,
                .parameter,
                .global_var,
                .@&quot;global_var local&quot;,
                .global_var_expression,
                =&gt; <span class="tok-null">false</span>,
            };
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isInline</span>(self: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> builder.metadata_items.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(self)].isInline();
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unwrap</span>(self: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
        <span class="tok-kw">var</span> metadata = self;
        <span class="tok-kw">while</span> (<span class="tok-builtin">@intFromEnum</span>(metadata) &gt;= <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_forward_reference">first_forward_reference</a> <span class="tok-kw">and</span>
            <span class="tok-builtin">@intFromEnum</span>(metadata) &lt; <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a>)
        {
            <span class="tok-kw">const</span> index = <span class="tok-builtin">@intFromEnum</span>(metadata) - <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_forward_reference">first_forward_reference</a>;
            metadata = builder.metadata_forward_references.items[index];
            <a href="std.debug.html#std.debug.assert">assert</a>(metadata != .none);
        }
        <span class="tok-kw">return</span> metadata;
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Item = <span class="tok-kw">struct</span> {
        tag: <a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>,
        data: <a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a>,

        <span class="tok-kw">const</span> ExtraIndex = <span class="tok-type">u32</span>;
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DIFlags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
        Visibility: <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) { Zero, Private, Protected, Public } = .Zero,
        FwdDecl: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        AppleBlock: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        ReservedBit4: <span class="tok-type">u1</span> = <span class="tok-number">0</span>,
        Virtual: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        Artificial: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        Explicit: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        Prototyped: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        ObjcClassComplete: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        ObjectPointer: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        Vector: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        StaticMember: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        LValueReference: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        RValueReference: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        ExportSymbols: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        Inheritance: <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
            Zero,
            SingleInheritance,
            MultipleInheritance,
            VirtualInheritance,
        } = .Zero,
        IntroducedVirtual: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        BitField: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        NoReturn: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        ReservedBit21: <span class="tok-type">u1</span> = <span class="tok-number">0</span>,
        TypePassbyValue: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        TypePassbyReference: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        EnumClass: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        Thunk: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        NonTrivial: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        BigEndian: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        LittleEndian: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        AllCallsDescribed: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
        Unused: <span class="tok-type">u2</span> = <span class="tok-number">0</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
            self: <a href="std.zig.llvm.Builder.Metadata.DIFlags.html">DIFlags</a>,
            <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
            writer: <span class="tok-kw">anytype</span>,
        ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> need_pipe = <span class="tok-null">false</span>;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Metadata.DIFlags.html">DIFlags</a>).@&quot;struct&quot;.fields) |field| {
                <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(field.<span class="tok-type">type</span>)) {
                    .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(self, field.name)) {
                        <span class="tok-kw">if</span> (need_pipe) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; | &quot;</span>) <span class="tok-kw">else</span> need_pipe = <span class="tok-null">true</span>;
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;DIFlag{s}&quot;</span>, .{field.name});
                    },
                    .@&quot;enum&quot; =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(self, field.name) != .Zero) {
                        <span class="tok-kw">if</span> (need_pipe) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; | &quot;</span>) <span class="tok-kw">else</span> need_pipe = <span class="tok-null">true</span>;
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;DIFlag{s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(<span class="tok-builtin">@field</span>(self, field.name))});
                    },
                    .int =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@field</span>(self, field.name) == <span class="tok-number">0</span>),
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++
                        <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
                }
            }
            <span class="tok-kw">if</span> (!need_pipe) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'0'</span>);
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> File = <span class="tok-kw">struct</span> {
        filename: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        directory: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompileUnit = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
            optimized: <span class="tok-type">bool</span>,
        };

        file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Subprogram = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
            di_flags: <a href="std.zig.llvm.Builder.Metadata.DIFlags.html">DIFlags</a>,
            sp_flags: <a href="std.zig.llvm.Builder.Metadata.Subprogram.DISPFlags.html">DISPFlags</a>,
        };

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DISPFlags = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) {
            Virtuality: <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) { Zero, Virtual, PureVirtual } = .Zero,
            LocalToUnit: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            Definition: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            Optimized: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            Pure: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            Elemental: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            Recursive: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            MainSubprogram: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            Deleted: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            ReservedBit10: <span class="tok-type">u1</span> = <span class="tok-number">0</span>,
            ObjCDirect: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,
            Unused: <span class="tok-type">u20</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
                self: <a href="std.zig.llvm.Builder.Metadata.Subprogram.DISPFlags.html">DISPFlags</a>,
                <span class="tok-kw">comptime</span> _: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                _: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
                writer: <span class="tok-kw">anytype</span>,
            ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
                <span class="tok-kw">var</span> need_pipe = <span class="tok-null">false</span>;
                <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Metadata.Subprogram.DISPFlags.html">DISPFlags</a>).@&quot;struct&quot;.fields) |field| {
                    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(field.<span class="tok-type">type</span>)) {
                        .<span class="tok-type">bool</span> =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(self, field.name)) {
                            <span class="tok-kw">if</span> (need_pipe) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; | &quot;</span>) <span class="tok-kw">else</span> need_pipe = <span class="tok-null">true</span>;
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;DISPFlag{s}&quot;</span>, .{field.name});
                        },
                        .@&quot;enum&quot; =&gt; <span class="tok-kw">if</span> (<span class="tok-builtin">@field</span>(self, field.name) != .Zero) {
                            <span class="tok-kw">if</span> (need_pipe) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; | &quot;</span>) <span class="tok-kw">else</span> need_pipe = <span class="tok-null">true</span>;
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;DISPFlag{s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(<span class="tok-builtin">@field</span>(self, field.name))});
                        },
                        .int =&gt; <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@field</span>(self, field.name) == <span class="tok-number">0</span>),
                        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++
                            <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
                    }
                }
                <span class="tok-kw">if</span> (!need_pipe) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'0'</span>);
            }
        };

        file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        line: <span class="tok-type">u32</span>,
        scope_line: <span class="tok-type">u32</span>,
        ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        di_flags: <a href="std.zig.llvm.Builder.Metadata.DIFlags.html">DIFlags</a>,
        compile_unit: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LexicalBlock = <span class="tok-kw">struct</span> {
        scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        line: <span class="tok-type">u32</span>,
        column: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Location = <span class="tok-kw">struct</span> {
        line: <span class="tok-type">u32</span>,
        column: <span class="tok-type">u32</span>,
        scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        inlined_at: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> BasicType = <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        size_in_bits_lo: <span class="tok-type">u32</span>,
        size_in_bits_hi: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitSize</span>(self: <a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>) <span class="tok-type">u64</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, self.size_in_bits_hi) &lt;&lt; <span class="tok-number">32</span> | self.size_in_bits_lo;
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompositeType = <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        line: <span class="tok-type">u32</span>,
        underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        size_in_bits_lo: <span class="tok-type">u32</span>,
        size_in_bits_hi: <span class="tok-type">u32</span>,
        align_in_bits_lo: <span class="tok-type">u32</span>,
        align_in_bits_hi: <span class="tok-type">u32</span>,
        fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitSize</span>(self: <a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>) <span class="tok-type">u64</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, self.size_in_bits_hi) &lt;&lt; <span class="tok-number">32</span> | self.size_in_bits_lo;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAlign</span>(self: <a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>) <span class="tok-type">u64</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, self.align_in_bits_hi) &lt;&lt; <span class="tok-number">32</span> | self.align_in_bits_lo;
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DerivedType = <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        line: <span class="tok-type">u32</span>,
        underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        size_in_bits_lo: <span class="tok-type">u32</span>,
        size_in_bits_hi: <span class="tok-type">u32</span>,
        align_in_bits_lo: <span class="tok-type">u32</span>,
        align_in_bits_hi: <span class="tok-type">u32</span>,
        offset_in_bits_lo: <span class="tok-type">u32</span>,
        offset_in_bits_hi: <span class="tok-type">u32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitSize</span>(self: <a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>) <span class="tok-type">u64</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, self.size_in_bits_hi) &lt;&lt; <span class="tok-number">32</span> | self.size_in_bits_lo;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitAlign</span>(self: <a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>) <span class="tok-type">u64</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, self.align_in_bits_hi) &lt;&lt; <span class="tok-number">32</span> | self.align_in_bits_lo;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bitOffset</span>(self: <a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>) <span class="tok-type">u64</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, self.offset_in_bits_hi) &lt;&lt; <span class="tok-number">32</span> | self.offset_in_bits_lo;
        }
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> SubroutineType = <span class="tok-kw">struct</span> {
        types_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Enumerator = <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        bit_width: <span class="tok-type">u32</span>,
        limbs_index: <span class="tok-type">u32</span>,
        limbs_len: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Subrange = <span class="tok-kw">struct</span> {
        lower_bound: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        count: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Expression = <span class="tok-kw">struct</span> {
        elements_len: <span class="tok-type">u32</span>,<span class="tok-comment">

        // elements: [elements_len]u32
    </span>};

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Tuple = <span class="tok-kw">struct</span> {
        elements_len: <span class="tok-type">u32</span>,<span class="tok-comment">

        // elements: [elements_len]Metadata
    </span>};

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StrTuple = <span class="tok-kw">struct</span> {
        str: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        elements_len: <span class="tok-type">u32</span>,<span class="tok-comment">

        // elements: [elements_len]Metadata
    </span>};

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ModuleFlag = <span class="tok-kw">struct</span> {
        behavior: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        constant: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> LocalVar = <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        line: <span class="tok-type">u32</span>,
        ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Parameter = <span class="tok-kw">struct</span> {
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        line: <span class="tok-type">u32</span>,
        ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        arg_no: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GlobalVar = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Options = <span class="tok-kw">struct</span> {
            local: <span class="tok-type">bool</span>,
        };

        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        line: <span class="tok-type">u32</span>,
        ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        variable: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GlobalVarExpression = <span class="tok-kw">struct</span> {
        variable: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
        expression: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toValue</span>(self: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.zig.llvm.Builder.Value.html">Value</a> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<a href="std.zig.llvm.Builder.Value.html">Value</a>.<a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.first_metadata">first_metadata</a> + <span class="tok-builtin">@intFromEnum</span>(self));
    }

    <span class="tok-kw">const</span> Formatter = <span class="tok-kw">struct</span> {
        builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
        need_comma: <span class="tok-type">bool</span>,
        map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
            debug_location: <a href="std.zig.llvm.Builder.DebugLocation.html">DebugLocation</a>.<a href="std.zig.llvm.Builder.DebugLocation.Location.html">Location</a>,
        }, <span class="tok-type">void</span>) = .{},

        <span class="tok-kw">const</span> FormatData = <span class="tok-kw">struct</span> {
            formatter: *<a href="std.zig.llvm.Builder.Metadata.Formatter.html">Formatter</a>,
            prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>,
            node: <a href="std.zig.llvm.Builder.Metadata.Formatter.FormatData.Node.html">Node</a>,

            <span class="tok-kw">const</span> Node = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
                none,
                @&quot;inline&quot;: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
                index: <span class="tok-type">u32</span>,

                local_value: <a href="std.zig.llvm.Builder.Metadata.Formatter.FormatData.Node.ValueData.html">ValueData</a>,
                local_metadata: <a href="std.zig.llvm.Builder.Metadata.Formatter.FormatData.Node.ValueData.html">ValueData</a>,
                local_inline: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
                local_index: <span class="tok-type">u32</span>,

                string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
                <span class="tok-type">bool</span>: <span class="tok-type">bool</span>,
                <span class="tok-type">u32</span>: <span class="tok-type">u32</span>,
                <span class="tok-type">u64</span>: <span class="tok-type">u64</span>,
                di_flags: <a href="std.zig.llvm.Builder.Metadata.DIFlags.html">DIFlags</a>,
                sp_flags: <a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.DISPFlags.html">DISPFlags</a>,
                raw: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,

                <span class="tok-kw">const</span> ValueData = <span class="tok-kw">struct</span> {
                    value: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
                    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
                };
            };
        };
        <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(
            data: <a href="std.zig.llvm.Builder.Metadata.Formatter.FormatData.html">FormatData</a>,
            <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            fmt_opts: <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.FormatOptions.html">FormatOptions</a>,
            writer: <span class="tok-kw">anytype</span>,
        ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (data.node == .none) <span class="tok-kw">return</span>;

            <span class="tok-kw">const</span> is_specialized = fmt_str.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> fmt_str[<span class="tok-number">0</span>] == <span class="tok-str">'S'</span>;
            <span class="tok-kw">const</span> recurse_fmt_str = <span class="tok-kw">if</span> (is_specialized) fmt_str[<span class="tok-number">1</span>..] <span class="tok-kw">else</span> fmt_str;

            <span class="tok-kw">if</span> (data.formatter.need_comma) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
            <span class="tok-kw">defer</span> data.formatter.need_comma = <span class="tok-null">true</span>;
            <span class="tok-kw">try</span> writer.writeAll(data.prefix);

            <span class="tok-kw">const</span> builder = data.formatter.builder;
            <span class="tok-kw">switch</span> (data.node) {
                .none =&gt; <span class="tok-kw">unreachable</span>,
                .@&quot;inline&quot; =&gt; |node| {
                    <span class="tok-kw">const</span> needed_comma = data.formatter.need_comma;
                    <span class="tok-kw">defer</span> data.formatter.need_comma = needed_comma;
                    data.formatter.need_comma = <span class="tok-null">false</span>;

                    <span class="tok-kw">const</span> item = builder.metadata_items.get(<span class="tok-builtin">@intFromEnum</span>(node));
                    <span class="tok-kw">switch</span> (item.tag) {
                        .expression =&gt; {
                            <span class="tok-kw">var</span> extra = builder.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.Expression.html">Expression</a>, item.data);
                            <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <span class="tok-type">u32</span>, builder);
                            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;!DIExpression(&quot;</span>);
                            <span class="tok-kw">for</span> (elements) |element| <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.Metadata.Formatter.html#std.zig.llvm.Builder.Metadata.Formatter.format">format</a>(.{
                                .formatter = data.formatter,
                                .node = .{ .<span class="tok-type">u64</span> = element },
                            }, <span class="tok-str">&quot;%&quot;</span>, fmt_opts, writer);
                            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
                        },
                        .constant =&gt; <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.html#std.zig.llvm.Builder.Constant.format">format</a>(.{
                            .constant = <span class="tok-builtin">@enumFromInt</span>(item.data),
                            .builder = builder,
                        }, recurse_fmt_str, fmt_opts, writer),
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                    }
                },
                .index =&gt; |node| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;!{d}&quot;</span>, .{node}),
                <span class="tok-kw">inline</span> .local_value, .local_metadata =&gt; |node, tag| <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.Value.html">Value</a>.<a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.format">format</a>(.{
                    .value = node.value,
                    .function = node.function,
                    .builder = builder,
                }, <span class="tok-kw">switch</span> (tag) {
                    .local_value =&gt; recurse_fmt_str,
                    .local_metadata =&gt; <span class="tok-str">&quot;%&quot;</span>,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                }, fmt_opts, writer),
                <span class="tok-kw">inline</span> .local_inline, .local_index =&gt; |node, tag| {
                    <span class="tok-kw">if</span> (<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, recurse_fmt_str, <span class="tok-str">&quot;%&quot;</span>))
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%} &quot;</span>, .{<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="#">metadata</a>.<a href="#">fmt</a>(builder)});
                    <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.Metadata.Formatter.html#std.zig.llvm.Builder.Metadata.Formatter.format">format</a>(.{
                        .formatter = data.formatter,
                        .node = <span class="tok-builtin">@unionInit</span>(<a href="std.zig.llvm.Builder.Metadata.Formatter.FormatData.html">FormatData</a>.<a href="std.zig.llvm.Builder.Metadata.Formatter.FormatData.Node.html">Node</a>, <span class="tok-builtin">@tagName</span>(tag)[<span class="tok-str">&quot;local_&quot;</span>.len..], node),
                    }, <span class="tok-str">&quot;%&quot;</span>, fmt_opts, writer);
                },
                .string =&gt; |node| <span class="tok-kw">try</span> writer.print((<span class="tok-kw">if</span> (is_specialized) <span class="tok-str">&quot;&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;!&quot;</span>) ++ <span class="tok-str">&quot;{}&quot;</span>, .{
                    node.fmt(builder),
                }),
                <span class="tok-kw">inline</span> .<span class="tok-type">bool</span>,
                .<span class="tok-type">u32</span>,
                .<span class="tok-type">u64</span>,
                .di_flags,
                .sp_flags,
                =&gt; |node| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}&quot;</span>, .{node}),
                .raw =&gt; |node| <span class="tok-kw">try</span> writer.writeAll(node),
            }
        }
        <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(formatter: *<a href="std.zig.llvm.Builder.Metadata.Formatter.html">Formatter</a>, prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, node: <span class="tok-kw">anytype</span>) <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(node)) {
            <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> =&gt; <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">error</span>{},
        }!<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Metadata.Formatter.html#std.zig.llvm.Builder.Metadata.Formatter.format">format</a>) {
            <span class="tok-kw">const</span> Node = <span class="tok-builtin">@TypeOf</span>(node);
            <span class="tok-kw">const</span> MaybeNode = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Node)) {
                .optional =&gt; Node,
                .<span class="tok-null">null</span> =&gt; ?<span class="tok-type">noreturn</span>,
                <span class="tok-kw">else</span> =&gt; ?Node,
            };
            <span class="tok-kw">const</span> Some = <span class="tok-builtin">@typeInfo</span>(MaybeNode).optional.child;
            <span class="tok-kw">return</span> .{ .data = .{
                .formatter = formatter,
                .prefix = prefix,
                .node = <span class="tok-kw">if</span> (<span class="tok-builtin">@as</span>(MaybeNode, node)) |some| <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Some)) {
                    .@&quot;enum&quot; =&gt; |enum_info| <span class="tok-kw">switch</span> (Some) {
                        <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> =&gt; <span class="tok-kw">switch</span> (some) {
                            .none =&gt; .none,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> formatter.refUnwrapped(some.unwrap(formatter.builder)),
                        },
                        <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> =&gt; .{ .string = some },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">if</span> (enum_info.is_exhaustive)
                            .{ .raw = <span class="tok-builtin">@tagName</span>(some) }
                        <span class="tok-kw">else</span>
                            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown type to format: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Node)),
                    },
                    .enum_literal =&gt; .{ .raw = <span class="tok-builtin">@tagName</span>(some) },
                    .<span class="tok-type">bool</span> =&gt; .{ .<span class="tok-type">bool</span> = some },
                    .@&quot;struct&quot; =&gt; <span class="tok-kw">switch</span> (Some) {
                        <a href="std.zig.llvm.Builder.Metadata.DIFlags.html">DIFlags</a> =&gt; .{ .di_flags = some },
                        <a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.DISPFlags.html">DISPFlags</a> =&gt; .{ .sp_flags = some },
                        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown type to format: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Node)),
                    },
                    .int, .<span class="tok-type">comptime_int</span> =&gt; .{ .<span class="tok-type">u64</span> = some },
                    .pointer =&gt; .{ .raw = some },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unknown type to format: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Node)),
                } <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(Node)) {
                    .optional, .<span class="tok-null">null</span> =&gt; .none,
                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                },
            } };
        }
        <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmtLocal</span>(
            formatter: *<a href="std.zig.llvm.Builder.Metadata.Formatter.html">Formatter</a>,
            prefix: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
            value: <a href="std.zig.llvm.Builder.Value.html">Value</a>,
            function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
        ) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Metadata.Formatter.html#std.zig.llvm.Builder.Metadata.Formatter.format">format</a>) {
            <span class="tok-kw">return</span> .{ .data = .{
                .formatter = formatter,
                .prefix = prefix,
                .node = <span class="tok-kw">switch</span> (value.unwrap()) {
                    .instruction, .constant =&gt; .{ .local_value = .{
                        .value = value,
                        .function = function,
                    } },
                    .metadata =&gt; |metadata| <span class="tok-kw">if</span> (value == .none) .none <span class="tok-kw">else</span> node: {
                        <span class="tok-kw">const</span> unwrapped = metadata.unwrap(formatter.builder);
                        <span class="tok-kw">break</span> :node <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(unwrapped) &gt;= <a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a>)
                            .{ .local_metadata = .{
                                .value = function.ptrConst(formatter.builder).debug_values[
                                    <span class="tok-builtin">@intFromEnum</span>(unwrapped) - <a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a>
                                ].toValue(),
                                .function = function,
                            } }
                        <span class="tok-kw">else</span> <span class="tok-kw">switch</span> (<span class="tok-kw">try</span> formatter.refUnwrapped(unwrapped)) {
                            .@&quot;inline&quot; =&gt; |node| .{ .local_inline = node },
                            .index =&gt; |node| .{ .local_index = node },
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        };
                    },
                },
            } };
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">refUnwrapped</span>(formatter: *<a href="std.zig.llvm.Builder.Metadata.Formatter.html">Formatter</a>, node: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.Formatter.FormatData.html">FormatData</a>.<a href="std.zig.llvm.Builder.Metadata.Formatter.FormatData.Node.html">Node</a> {
            <a href="std.debug.html#std.debug.assert">assert</a>(node != .none);
            <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@intFromEnum</span>(node) &lt; <a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_forward_reference">first_forward_reference</a>);
            <span class="tok-kw">const</span> builder = formatter.builder;
            <span class="tok-kw">const</span> unwrapped_metadata = node.unwrap(builder);
            <span class="tok-kw">const</span> tag = formatter.builder.metadata_items.items(.tag)[<span class="tok-builtin">@intFromEnum</span>(unwrapped_metadata)];
            <span class="tok-kw">switch</span> (tag) {
                .none =&gt; <span class="tok-kw">unreachable</span>,
                .expression, .constant =&gt; <span class="tok-kw">return</span> .{ .@&quot;inline&quot; = unwrapped_metadata },
                <span class="tok-kw">else</span> =&gt; {
                    <a href="std.debug.html#std.debug.assert">assert</a>(!tag.isInline());
                    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> formatter.map.getOrPut(builder.gpa, .{ .metadata = unwrapped_metadata });
                    <span class="tok-kw">return</span> .{ .index = <span class="tok-builtin">@intCast</span>(gop.index) };
                },
            }
        }

        <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">specialized</span>(
            formatter: *<a href="std.zig.llvm.Builder.Metadata.Formatter.html">Formatter</a>,
            distinct: <span class="tok-kw">enum</span> { @&quot;!&quot;, @&quot;distinct !&quot; },
            node: <span class="tok-kw">enum</span> {
                DIFile,
                DICompileUnit,
                DISubprogram,
                DILexicalBlock,
                DILocation,
                DIBasicType,
                DICompositeType,
                DIDerivedType,
                DISubroutineType,
                DIEnumerator,
                DISubrange,
                DILocalVariable,
                DIGlobalVariable,
                DIGlobalVariableExpression,
            },
            nodes: <span class="tok-kw">anytype</span>,
            writer: <span class="tok-kw">anytype</span>,
        ) !<span class="tok-type">void</span> {
            <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>;
            <span class="tok-kw">const</span> names = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fieldNames">fieldNames</a>(<span class="tok-builtin">@TypeOf</span>(nodes));
            <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> fields: [<span class="tok-number">2</span> + names.len]<a href="std.html">std</a>.<a href="std.builtin.html">builtin</a>.<a href="std.builtin.Type.html">Type</a>.<a href="std.builtin.Type.StructField.html">StructField</a> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields[<span class="tok-number">0</span>..<span class="tok-number">2</span>], .{ <span class="tok-str">&quot;distinct&quot;</span>, <span class="tok-str">&quot;node&quot;</span> }) |*field, name| {
                fmt_str = fmt_str ++ <span class="tok-str">&quot;{[&quot;</span> ++ name ++ <span class="tok-str">&quot;]s}&quot;</span>;
                field.* = .{
                    .name = name,
                    .<span class="tok-type">type</span> = []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                    .default_value_ptr = <span class="tok-null">null</span>,
                    .is_comptime = <span class="tok-null">false</span>,
                    .alignment = <span class="tok-number">0</span>,
                };
            }
            fmt_str = fmt_str ++ <span class="tok-str">&quot;(&quot;</span>;
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields[<span class="tok-number">2</span>..], names) |*field, name| {
                fmt_str = fmt_str ++ <span class="tok-str">&quot;{[&quot;</span> ++ name ++ <span class="tok-str">&quot;]S}&quot;</span>;
                field.* = .{
                    .name = name,
                    .<span class="tok-type">type</span> = <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.Formatter">Formatter</a>(<a href="std.zig.llvm.Builder.Metadata.Formatter.html#std.zig.llvm.Builder.Metadata.Formatter.format">format</a>),
                    .default_value_ptr = <span class="tok-null">null</span>,
                    .is_comptime = <span class="tok-null">false</span>,
                    .alignment = <span class="tok-number">0</span>,
                };
            }
            fmt_str = fmt_str ++ <span class="tok-str">&quot;)\n&quot;</span>;

            <span class="tok-kw">var</span> fmt_args: <span class="tok-builtin">@Type</span>(.{ .@&quot;struct&quot; = .{
                .layout = .auto,
                .fields = &amp;fields,
                .decls = &amp;.{},
                .is_tuple = <span class="tok-null">false</span>,
            } }) = <span class="tok-null">undefined</span>;
            fmt_args.distinct = <span class="tok-builtin">@tagName</span>(distinct);
            fmt_args.node = <span class="tok-builtin">@tagName</span>(node);
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (names) |name| <span class="tok-builtin">@field</span>(fmt_args, name) = <span class="tok-kw">try</span> formatter.fmt(
                name ++ <span class="tok-str">&quot;: &quot;</span>,
                <span class="tok-builtin">@field</span>(nodes, name),
            );
            <span class="tok-kw">try</span> writer.print(fmt_str, fmt_args);
        }
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(options: <a href="std.zig.llvm.Builder.Options.html">Options</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.html">Builder</a> {
    <span class="tok-kw">var</span> self: <a href="std.zig.llvm.Builder.html">Builder</a> = .{
        .gpa = options.allocator,
        .strip = options.strip,

        .source_filename = .none,
        .data_layout = .none,
        .target_triple = .none,
        .module_asm = .{},

        .string_map = .{},
        .string_indices = .{},
        .string_bytes = .{},

        .types = .{},
        .next_unnamed_type = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
        .next_unique_type_id = .{},
        .type_map = .{},
        .type_items = .{},
        .type_extra = .{},

        .attributes = .{},
        .attributes_map = .{},
        .attributes_indices = .{},
        .attributes_extra = .{},

        .function_attributes_set = .{},

        .globals = .{},
        .next_unnamed_global = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
        .next_replaced_global = .none,
        .next_unique_global_id = .{},
        .aliases = .{},
        .variables = .{},
        .functions = .{},

        .strtab_string_map = .{},
        .strtab_string_indices = .{},
        .strtab_string_bytes = .{},

        .constant_map = .{},
        .constant_items = .{},
        .constant_extra = .{},
        .constant_limbs = .{},

        .metadata_map = .{},
        .metadata_items = .{},
        .metadata_extra = .{},
        .metadata_limbs = .{},
        .metadata_forward_references = .{},
        .metadata_named = .{},
        .metadata_string_map = .{},
        .metadata_string_indices = .{},
        .metadata_string_bytes = .{},
    };
    <span class="tok-kw">errdefer</span> self.deinit();

    <span class="tok-kw">try</span> self.string_indices.append(self.gpa, <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.string(<span class="tok-str">&quot;&quot;</span>) == .empty);

    <span class="tok-kw">try</span> self.strtab_string_indices.append(self.gpa, <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.strtabString(<span class="tok-str">&quot;&quot;</span>) == .empty);

    <span class="tok-kw">if</span> (options.name.len &gt; <span class="tok-number">0</span>) self.source_filename = <span class="tok-kw">try</span> self.string(options.name);

    <span class="tok-kw">if</span> (options.triple.len &gt; <span class="tok-number">0</span>) {
        self.target_triple = <span class="tok-kw">try</span> self.string(options.triple);
    }

    {
        <span class="tok-kw">const</span> static_len = <span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>).@&quot;enum&quot;.fields.len - <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> self.type_map.ensureTotalCapacity(self.gpa, static_len);
        <span class="tok-kw">try</span> self.type_items.ensureTotalCapacity(self.gpa, static_len);
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Simple.html">Simple</a>).@&quot;enum&quot;.fields) |simple_field| {
            <span class="tok-kw">const</span> result = self.getOrPutTypeNoExtraAssumeCapacity(
                .{ .tag = .simple, .data = simple_field.value },
            );
            <a href="std.debug.html#std.debug.assert">assert</a>(result.new <span class="tok-kw">and</span> result.<span class="tok-type">type</span> == <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, simple_field.name));
        }
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{ <span class="tok-number">1</span>, <span class="tok-number">8</span>, <span class="tok-number">16</span>, <span class="tok-number">29</span>, <span class="tok-number">32</span>, <span class="tok-number">64</span>, <span class="tok-number">80</span>, <span class="tok-number">128</span> }) |bits|
            <a href="std.debug.html#std.debug.assert">assert</a>(self.intTypeAssumeCapacity(bits) ==
                <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;i{d}&quot;</span>, .{bits})));
        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (.{ <span class="tok-number">0</span>, <span class="tok-number">4</span> }) |addr_space_index| {
            <span class="tok-kw">const</span> addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a> = <span class="tok-builtin">@enumFromInt</span>(addr_space_index);
            <a href="std.debug.html#std.debug.assert">assert</a>(self.ptrTypeAssumeCapacity(addr_space) ==
                <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.comptimePrint">comptimePrint</a>(<span class="tok-str">&quot;ptr{ }&quot;</span>, .{addr_space})));
        }
    }

    {
        <span class="tok-kw">try</span> self.attributes_indices.append(self.gpa, <span class="tok-number">0</span>);
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.attrs(&amp;.{}) == .none);
        <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.fnAttrs(&amp;.{}) == .none);
    }

    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.intConst(.<span class="tok-type">i1</span>, <span class="tok-number">0</span>) == .<span class="tok-null">false</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.intConst(.<span class="tok-type">i1</span>, <span class="tok-number">1</span>) == .<span class="tok-null">true</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">0</span>) == .@&quot;0&quot;);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.intConst(.<span class="tok-type">i32</span>, <span class="tok-number">1</span>) == .@&quot;1&quot;);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.noneConst(.token) == .none);

    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.metadataNone() == .none);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.metadataTuple(&amp;.{}) == .empty_tuple);

    <span class="tok-kw">try</span> self.metadata_string_indices.append(self.gpa, <span class="tok-number">0</span>);
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-kw">try</span> self.metadataString(<span class="tok-str">&quot;&quot;</span>) == .none);

    <span class="tok-kw">return</span> self;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
    self.module_asm.clearAndFree(self.gpa);

    self.string_map.clearAndFree(self.gpa);
    self.string_indices.clearAndFree(self.gpa);
    self.string_bytes.clearAndFree(self.gpa);

    self.types.clearAndFree(self.gpa);
    self.next_unique_type_id.clearAndFree(self.gpa);
    self.type_map.clearAndFree(self.gpa);
    self.type_items.clearAndFree(self.gpa);
    self.type_extra.clearAndFree(self.gpa);

    self.attributes.clearAndFree(self.gpa);
    self.attributes_map.clearAndFree(self.gpa);
    self.attributes_indices.clearAndFree(self.gpa);
    self.attributes_extra.clearAndFree(self.gpa);

    self.function_attributes_set.clearAndFree(self.gpa);

    self.globals.clearAndFree(self.gpa);
    self.next_unique_global_id.clearAndFree(self.gpa);
    self.aliases.clearAndFree(self.gpa);
    self.variables.clearAndFree(self.gpa);
    <span class="tok-kw">for</span> (self.functions.items) |*function| function.deinit(self.gpa);
    self.functions.clearAndFree(self.gpa);

    self.strtab_string_map.clearAndFree(self.gpa);
    self.strtab_string_indices.clearAndFree(self.gpa);
    self.strtab_string_bytes.clearAndFree(self.gpa);

    self.constant_map.clearAndFree(self.gpa);
    self.constant_items.shrinkAndFree(self.gpa, <span class="tok-number">0</span>);
    self.constant_extra.clearAndFree(self.gpa);
    self.constant_limbs.clearAndFree(self.gpa);

    self.metadata_map.clearAndFree(self.gpa);
    self.metadata_items.shrinkAndFree(self.gpa, <span class="tok-number">0</span>);
    self.metadata_extra.clearAndFree(self.gpa);
    self.metadata_limbs.clearAndFree(self.gpa);
    self.metadata_forward_references.clearAndFree(self.gpa);
    self.metadata_named.clearAndFree(self.gpa);

    self.metadata_string_map.clearAndFree(self.gpa);
    self.metadata_string_indices.clearAndFree(self.gpa);
    self.metadata_string_bytes.clearAndFree(self.gpa);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
    self.module_asm.deinit(self.gpa);

    self.string_map.deinit(self.gpa);
    self.string_indices.deinit(self.gpa);
    self.string_bytes.deinit(self.gpa);

    self.types.deinit(self.gpa);
    self.next_unique_type_id.deinit(self.gpa);
    self.type_map.deinit(self.gpa);
    self.type_items.deinit(self.gpa);
    self.type_extra.deinit(self.gpa);

    self.attributes.deinit(self.gpa);
    self.attributes_map.deinit(self.gpa);
    self.attributes_indices.deinit(self.gpa);
    self.attributes_extra.deinit(self.gpa);

    self.function_attributes_set.deinit(self.gpa);

    self.globals.deinit(self.gpa);
    self.next_unique_global_id.deinit(self.gpa);
    self.aliases.deinit(self.gpa);
    self.variables.deinit(self.gpa);
    <span class="tok-kw">for</span> (self.functions.items) |*function| function.deinit(self.gpa);
    self.functions.deinit(self.gpa);

    self.strtab_string_map.deinit(self.gpa);
    self.strtab_string_indices.deinit(self.gpa);
    self.strtab_string_bytes.deinit(self.gpa);

    self.constant_map.deinit(self.gpa);
    self.constant_items.deinit(self.gpa);
    self.constant_extra.deinit(self.gpa);
    self.constant_limbs.deinit(self.gpa);

    self.metadata_map.deinit(self.gpa);
    self.metadata_items.deinit(self.gpa);
    self.metadata_extra.deinit(self.gpa);
    self.metadata_limbs.deinit(self.gpa);
    self.metadata_forward_references.deinit(self.gpa);
    self.metadata_named.deinit(self.gpa);

    self.metadata_string_map.deinit(self.gpa);
    self.metadata_string_indices.deinit(self.gpa);
    self.metadata_string_bytes.deinit(self.gpa);

    self.* = <span class="tok-null">undefined</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).Writer {
    self.module_asm.clearRetainingCapacity();
    <span class="tok-kw">return</span> self.appendModuleAsm();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">appendModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u8</span>).Writer {
    <span class="tok-kw">return</span> self.module_asm.writer(self.gpa);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">finishModuleAsm</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (self.module_asm.getLastOrNull()) |last| <span class="tok-kw">if</span> (last != <span class="tok-str">'\n'</span>)
        <span class="tok-kw">try</span> self.module_asm.append(self.gpa, <span class="tok-str">'\n'</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">string</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">try</span> self.string_bytes.ensureUnusedCapacity(self.gpa, bytes.len);
    <span class="tok-kw">try</span> self.string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> gop = self.string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        self.string_bytes.appendSliceAssumeCapacity(bytes);
        self.string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.html#std.zig.llvm.Builder.String.fromIndex">fromIndex</a>(gop.index);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringNull</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">return</span> self.string(bytes[<span class="tok-number">0</span> .. bytes.len + <span class="tok-number">1</span>]);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringIfExists</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.html#std.zig.llvm.Builder.String.fromIndex">fromIndex</a>(
        self.string_map.getIndexAdapted(bytes, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>{ .builder = self }) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">try</span> self.string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.string_bytes.ensureUnusedCapacity(self.gpa, <span class="tok-builtin">@intCast</span>(<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(fmt_str, fmt_args)));
    <span class="tok-kw">try</span> self.string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.fmtAssumeCapacity(fmt_str, fmt_args);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.String.html">String</a> {
    self.string_bytes.writer(<span class="tok-null">undefined</span>).print(fmt_str, fmt_args) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> self.trailingStringAssumeCapacity();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">try</span> self.string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.trailingStringAssumeCapacity();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.String.html">String</a> {
    <span class="tok-kw">const</span> start = self.string_indices.getLast();
    <span class="tok-kw">const</span> bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = self.string_bytes.items[start..];
    <span class="tok-kw">const</span> gop = self.string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (gop.found_existing) {
        self.string_bytes.shrinkRetainingCapacity(start);
    } <span class="tok-kw">else</span> {
        self.string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.html#std.zig.llvm.Builder.String.fromIndex">fromIndex</a>(gop.index);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ret: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    params: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Type.Function.Kind.html">Kind</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, params.len);
    <span class="tok-kw">switch</span> (kind) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |comptime_kind| <span class="tok-kw">return</span> self.fnTypeAssumeCapacity(ret, params, comptime_kind),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bits: <span class="tok-type">u24</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.intTypeAssumeCapacity(bits);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ptrType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.ptrTypeAssumeCapacity(addr_space);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a>,
    len: <span class="tok-type">u32</span>,
    child: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">switch</span> (kind) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |comptime_kind| <span class="tok-kw">return</span> self.vectorTypeAssumeCapacity(comptime_kind, len, child),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, len: <span class="tok-type">u64</span>, child: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">comptime</span> <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@sizeOf</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>) &gt;= <span class="tok-builtin">@sizeOf</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>));
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.arrayTypeAssumeCapacity(len, child);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>.<a href="std.zig.llvm.Builder.Type.Structure.Kind.html">Kind</a>,
    fields: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, fields.len);
    <span class="tok-kw">switch</span> (kind) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |comptime_kind| <span class="tok-kw">return</span> self.structTypeAssumeCapacity(comptime_kind, fields),
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">opaqueType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">try</span> self.string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (name.slice(self)) |id| {
        <span class="tok-kw">const</span> count: <span class="tok-type">usize</span> = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(<span class="tok-str">&quot;{d}&quot;</span>, .{<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>)});
        <span class="tok-kw">try</span> self.string_bytes.ensureUnusedCapacity(self.gpa, id.len + count);
    }
    <span class="tok-kw">try</span> self.string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.types.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.next_unique_type_id.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.opaqueTypeAssumeCapacity(name);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">namedTypeSetBody</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    named_type: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    body_type: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> named_item = self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(named_type)];
    self.type_extra.items[named_item.data + <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fieldIndex">fieldIndex</a>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, <span class="tok-str">&quot;body&quot;</span>).?] =
        <span class="tok-builtin">@intFromEnum</span>(body_type);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attr</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, attribute: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a> {
    <span class="tok-kw">try</span> self.attributes.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> gop = self.attributes.getOrPutAssumeCapacity(attribute.toStorage());
    <span class="tok-kw">if</span> (!gop.found_existing) gop.value_ptr.* = {};
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">attrs</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, attributes: []<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
    <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.html#std.sort.heap">heap</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, attributes, self, <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, lhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>, rhs: <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> lhs_kind = lhs.getKind(builder);
            <span class="tok-kw">const</span> rhs_kind = rhs.getKind(builder);
            <a href="std.debug.html#std.debug.assert">assert</a>(lhs_kind != rhs_kind);
            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(lhs_kind) &lt; <span class="tok-builtin">@intFromEnum</span>(rhs_kind);
        }
    }.lessThan);
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">try</span> self.attrGeneric(<span class="tok-builtin">@ptrCast</span>(attributes)));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fnAttrs</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, fn_attributes: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> {
    <span class="tok-kw">try</span> self.function_attributes_set.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> function_attributes: <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">try</span> self.attrGeneric(<span class="tok-builtin">@ptrCast</span>(
        fn_attributes[<span class="tok-number">0</span>..<span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.lastIndexOfNone">lastIndexOfNone</a>(<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>, fn_attributes, &amp;.{.none})) |last|
            last + <span class="tok-number">1</span>
        <span class="tok-kw">else</span>
            <span class="tok-number">0</span>],
    )));

    _ = self.function_attributes_set.getOrPutAssumeCapacity(function_attributes);
    <span class="tok-kw">return</span> function_attributes;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addGlobal</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, global: <a href="std.zig.llvm.Builder.Global.html">Global</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedGlobalCapacity(name);
    <span class="tok-kw">return</span> self.addGlobalAssumeCapacity(name, global);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addGlobalAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>, global: <a href="std.zig.llvm.Builder.Global.html">Global</a>) <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
    _ = self.ptrTypeAssumeCapacity(global.addr_space);
    <span class="tok-kw">var</span> id = name;
    <span class="tok-kw">if</span> (name == .empty) {
        id = self.next_unnamed_global;
        <a href="std.debug.html#std.debug.assert">assert</a>(id != self.next_replaced_global);
        self.next_unnamed_global = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(id) + <span class="tok-number">1</span>);
    }
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> global_gop = self.globals.getOrPutAssumeCapacity(id);
        <span class="tok-kw">if</span> (!global_gop.found_existing) {
            global_gop.value_ptr.* = global;
            <span class="tok-kw">const</span> global_index: <a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(global_gop.index);
            global_index.updateDsoLocal(self);
            <span class="tok-kw">return</span> global_index;
        }

        <span class="tok-kw">const</span> unique_gop = self.next_unique_global_id.getOrPutAssumeCapacity(name);
        <span class="tok-kw">if</span> (!unique_gop.found_existing) unique_gop.value_ptr.* = <span class="tok-number">2</span>;
        id = self.strtabStringFmtAssumeCapacity(<span class="tok-str">&quot;{s}.{d}&quot;</span>, .{ name.slice(self).?, unique_gop.value_ptr.* });
        unique_gop.value_ptr.* += <span class="tok-number">1</span>;
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGlobal</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) ?<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(self.globals.getIndex(name) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAlias</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
    aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedGlobalCapacity(name);
    <span class="tok-kw">try</span> self.aliases.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addAliasAssumeCapacity(name, ty, addr_space, aliasee);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addAliasAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
    aliasee: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a> {
    <span class="tok-kw">const</span> alias_index: <a href="std.zig.llvm.Builder.Alias.html">Alias</a>.<a href="std.zig.llvm.Builder.Alias.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.aliases.items.len);
    self.aliases.appendAssumeCapacity(.{ .global = self.addGlobalAssumeCapacity(name, .{
        .addr_space = addr_space,
        .<span class="tok-type">type</span> = ty,
        .kind = .{ .alias = alias_index },
    }), .aliasee = aliasee });
    <span class="tok-kw">return</span> alias_index;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addVariable</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedGlobalCapacity(name);
    <span class="tok-kw">try</span> self.variables.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addVariableAssumeCapacity(ty, name, addr_space);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addVariableAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
) <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a> {
    <span class="tok-kw">const</span> variable_index: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.variables.items.len);
    self.variables.appendAssumeCapacity(.{ .global = self.addGlobalAssumeCapacity(name, .{
        .addr_space = addr_space,
        .<span class="tok-type">type</span> = ty,
        .kind = .{ .variable = variable_index },
    }) });
    <span class="tok-kw">return</span> variable_index;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFunction</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedGlobalCapacity(name);
    <span class="tok-kw">try</span> self.functions.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.addFunctionAssumeCapacity(ty, name, addr_space);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">addFunctionAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>,
    addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>,
) <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ty.isFunction(self));
    <span class="tok-kw">const</span> function_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(self.functions.items.len);
    self.functions.appendAssumeCapacity(.{
        .global = self.addGlobalAssumeCapacity(name, .{
            .addr_space = addr_space,
            .<span class="tok-type">type</span> = ty,
            .kind = .{ .function = function_index },
        }),
        .strip = <span class="tok-null">undefined</span>,
    });
    <span class="tok-kw">return</span> function_index;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIntrinsic</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    id: <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>,
    overload: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> {
    <span class="tok-kw">const</span> ExpectedContents = <span class="tok-kw">extern</span> <span class="tok-kw">union</span> {
        attrs: <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
            params: [<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.expected_args_len">expected_args_len</a>]<a href="std.zig.llvm.Builder.Type.html">Type</a>,
            fn_attrs: [<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.expected_args_len">expected_args_len</a>]<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>,
            attrs: [<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.expected_attrs_len">expected_attrs_len</a>]<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>,
            fields: [<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.expected_fields_len">expected_fields_len</a>]<a href="std.zig.llvm.Builder.Type.html">Type</a>,
        },
    };
    <span class="tok-kw">var</span> stack <span class="tok-kw">align</span>(<span class="tok-builtin">@max</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.StackFallbackAllocator">StackFallbackAllocator</a>(<span class="tok-number">0</span>)), <span class="tok-builtin">@alignOf</span>(ExpectedContents))) =
        <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-builtin">@sizeOf</span>(ExpectedContents), self.gpa);
    <span class="tok-kw">const</span> allocator = stack.get();

    <span class="tok-kw">const</span> name = name: {
        <span class="tok-kw">const</span> writer = self.strtab_string_bytes.writer(self.gpa);
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;llvm.{s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(id)});
        <span class="tok-kw">for</span> (overload) |ty| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;.{m}&quot;</span>, .{ty.fmt(self)});
        <span class="tok-kw">break</span> :name <span class="tok-kw">try</span> self.trailingStrtabString();
    };
    <span class="tok-kw">if</span> (self.getGlobal(name)) |global| <span class="tok-kw">return</span> global.ptrConst(self).kind.function;

    <span class="tok-kw">const</span> signature = <a href="std.zig.llvm.Builder.Intrinsic.html">Intrinsic</a>.<a href="std.zig.llvm.Builder.Intrinsic.html#std.zig.llvm.Builder.Intrinsic.signatures">signatures</a>.<a href="#">get</a>(id);
    <span class="tok-kw">const</span> param_types = <span class="tok-kw">try</span> allocator.alloc(<a href="std.zig.llvm.Builder.Type.html">Type</a>, signature.params.len);
    <span class="tok-kw">defer</span> allocator.free(param_types);
    <span class="tok-kw">const</span> function_attributes = <span class="tok-kw">try</span> allocator.alloc(
        <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>,
        <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + (signature.params.len - signature.ret_len),
    );
    <span class="tok-kw">defer</span> allocator.free(function_attributes);

    <span class="tok-kw">var</span> attributes: <span class="tok-kw">struct</span> {
        builder: *<a href="std.zig.llvm.Builder.html">Builder</a>,
        list: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>),

        <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(state: *<span class="tok-builtin">@This</span>()) <span class="tok-type">void</span> {
            state.list.deinit();
            state.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(state: *<span class="tok-builtin">@This</span>(), attributes: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a> {
            <span class="tok-kw">try</span> state.list.resize(attributes.len);
            <span class="tok-kw">for</span> (state.list.items, attributes) |*item, attribute|
                item.* = <span class="tok-kw">try</span> state.builder.attr(attribute);
            <span class="tok-kw">return</span> state.builder.attrs(state.list.items);
        }
    } = .{ .builder = self, .list = <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayList">ArrayList</a>(<a href="std.zig.llvm.Builder.Attribute.html">Attribute</a>.<a href="std.zig.llvm.Builder.Attribute.Index.html">Index</a>).init(allocator) };
    <span class="tok-kw">defer</span> attributes.deinit();

    <span class="tok-kw">var</span> overload_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    function_attributes[<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.function_index">function_index</a>] = <span class="tok-kw">try</span> attributes.get(signature.attrs);
    function_attributes[<a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.return_index">return_index</a>] = .none;<span class="tok-comment"> // needed for void return
    </span><span class="tok-kw">for</span> (<span class="tok-number">0</span>.., param_types, signature.params) |param_index, *param_type, signature_param| {
        <span class="tok-kw">switch</span> (signature_param.kind) {
            .<span class="tok-type">type</span> =&gt; |ty| param_type.* = ty,
            .overloaded =&gt; {
                param_type.* = overload[overload_index];
                overload_index += <span class="tok-number">1</span>;
            },
            .matches, .matches_scalar, .matches_changed_scalar =&gt; {},
        }
        function_attributes[
            <span class="tok-kw">if</span> (param_index &lt; signature.ret_len)
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.return_index">return_index</a>
            <span class="tok-kw">else</span>
                <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a>.<a href="std.zig.llvm.Builder.FunctionAttributes.html#std.zig.llvm.Builder.FunctionAttributes.params_index">params_index</a> + (param_index - signature.ret_len)
        ] = <span class="tok-kw">try</span> attributes.get(signature_param.attrs);
    }
    <a href="std.debug.html#std.debug.assert">assert</a>(overload_index == overload.len);
    <span class="tok-kw">for</span> (param_types, signature.params) |*param_type, signature_param| {
        param_type.* = <span class="tok-kw">switch</span> (signature_param.kind) {
            .<span class="tok-type">type</span>, .overloaded =&gt; <span class="tok-kw">continue</span>,
            .matches =&gt; |param_index| param_types[param_index],
            .matches_scalar =&gt; |param_index| param_types[param_index].scalarType(self),
            .matches_changed_scalar =&gt; |info| <span class="tok-kw">try</span> param_types[info.index]
                .changeScalar(info.scalar, self),
        };
    }

    <span class="tok-kw">const</span> function_index = <span class="tok-kw">try</span> self.addFunction(<span class="tok-kw">try</span> self.fnType(<span class="tok-kw">switch</span> (signature.ret_len) {
        <span class="tok-number">0</span> =&gt; .<span class="tok-type">void</span>,
        <span class="tok-number">1</span> =&gt; param_types[<span class="tok-number">0</span>],
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> self.structType(.normal, param_types[<span class="tok-number">0</span>..signature.ret_len]),
    }, param_types[signature.ret_len..], .normal), name, .default);
    function_index.ptr(self).attributes = <span class="tok-kw">try</span> self.fnAttrs(function_attributes);
    <span class="tok-kw">return</span> function_index;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> int_value = <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value))) {
        .int, .<span class="tok-type">comptime_int</span> =&gt; value,
        .@&quot;enum&quot; =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;intConst expected an integral value, got &quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value))),
    };
    <span class="tok-kw">var</span> limbs: [
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(int_value))) {
            .int =&gt; |info| <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(info.bits),
            .<span class="tok-type">comptime_int</span> =&gt; <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(int_value),
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    ]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> self.bigIntConst(ty, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(&amp;limbs, int_value).toConst());
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">intValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.intConst(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigIntConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.constant_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.constant_items.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.constant_limbs.ensureUnusedCapacity(self.gpa, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> + value.limbs.len);
    <span class="tok-kw">return</span> self.bigIntConstAssumeCapacity(ty, value);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bigIntValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.bigIntConst(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fpConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, <span class="tok-kw">comptime</span> val: <span class="tok-type">comptime_float</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (ty) {
        .half =&gt; <span class="tok-kw">try</span> self.halfConst(val),
        .bfloat =&gt; <span class="tok-kw">try</span> self.bfloatConst(val),
        .float =&gt; <span class="tok-kw">try</span> self.floatConst(val),
        .double =&gt; <span class="tok-kw">try</span> self.doubleConst(val),
        .fp128 =&gt; <span class="tok-kw">try</span> self.fp128Const(val),
        .x86_fp80 =&gt; <span class="tok-kw">try</span> self.x86_fp80Const(val),
        .ppc_fp128 =&gt; <span class="tok-kw">try</span> self.ppc_fp128Const(.{ val, -<span class="tok-number">0.0</span> }),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fpValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, <span class="tok-kw">comptime</span> value: <span class="tok-type">comptime_float</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.fpConst(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (ty) {
        .half =&gt; <span class="tok-kw">try</span> self.halfConst(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f16</span>)),
        .bfloat =&gt; <span class="tok-kw">try</span> self.bfloatConst(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f32</span>)),
        .float =&gt; <span class="tok-kw">try</span> self.floatConst(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f32</span>)),
        .double =&gt; <span class="tok-kw">try</span> self.doubleConst(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f64</span>)),
        .fp128 =&gt; <span class="tok-kw">try</span> self.fp128Const(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f128</span>)),
        .x86_fp80 =&gt; <span class="tok-kw">try</span> self.x86_fp80Const(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f80</span>)),
        .ppc_fp128 =&gt; <span class="tok-kw">try</span> self.ppc_fp128Const(.{<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.float.html#std.math.float.nan">nan</a>(<span class="tok-type">f64</span>)} ** <span class="tok-number">2</span>),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nanValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.nanConst(ty)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">halfConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f16</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.halfConstAssumeCapacity(val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">halfValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f16</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.halfConst(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bfloatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.bfloatConstAssumeCapacity(val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">bfloatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.bfloatConst(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.floatConstAssumeCapacity(val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">floatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.floatConst(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doubleConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Double.html">Double</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.doubleConstAssumeCapacity(val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">doubleValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.doubleConst(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fp128Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f128</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.fp128ConstAssumeCapacity(val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fp128Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f128</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.fp128Const(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">x86_fp80Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f80</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp80.html">Fp80</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.x86_fp80ConstAssumeCapacity(val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">x86_fp80Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: <span class="tok-type">f80</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.x86_fp80Const(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppc_fp128Const</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.ppc_fp128ConstAssumeCapacity(val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ppc_fp128Value</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, value: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.ppc_fp128Const(ty, value)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.nullConstAssumeCapacity(ty);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nullValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.nullConst(ty)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noneConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.noneConstAssumeCapacity(ty);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noneValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.noneConst(ty)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, vals.len);
    <span class="tok-kw">return</span> self.structConstAssumeCapacity(ty, vals);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">structValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.structConst(ty, vals)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, vals.len);
    <span class="tok-kw">return</span> self.arrayConstAssumeCapacity(ty, vals);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">arrayValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.arrayConst(ty, vals)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.stringConstAssumeCapacity(val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">stringValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.stringConst(val)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, vals.len);
    <span class="tok-kw">return</span> self.vectorConstAssumeCapacity(ty, vals);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">vectorValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.vectorConst(ty, vals)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.splatConstAssumeCapacity(ty, val);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splatValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.splatConst(ty, val)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInitConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.constant_limbs.ensureUnusedCapacity(
        self.gpa,
        <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> + <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(<span class="tok-number">0</span>),
    );
    <span class="tok-kw">return</span> self.zeroInitConstAssumeCapacity(ty);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">zeroInitValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.zeroInitConst(ty)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">undefConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.undefConstAssumeCapacity(ty);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">undefValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.undefConst(ty)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poisonConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.poisonConstAssumeCapacity(ty);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">poisonValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.poisonConst(ty)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">blockAddrConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.blockAddrConstAssumeCapacity(function, block);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">blockAddrValue</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.blockAddrConst(function, block)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dsoLocalEquivalentConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.dsoLocalEquivalentConstAssumeCapacity(function);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dsoLocalEquivalentValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.dsoLocalEquivalentConst(function)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noCfiConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.noCfiConstAssumeCapacity(function);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">noCfiValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.noCfiConst(function)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.convConstAssumeCapacity(val, ty);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convValue</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.convConst(val, ty)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castConst</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.castConstAssumeCapacity(tag, val, ty);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">castValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.castConst(tag, val, ty)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    inrange: ?<span class="tok-type">u16</span>,
    indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedTypeCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>, indices.len);
    <span class="tok-kw">return</span> self.gepConstAssumeCapacity(kind, ty, base, inrange, indices);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">gepValue</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    inrange: ?<span class="tok-type">u16</span>,
    indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.gepConst(kind, ty, base, inrange, indices)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>,
    lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.binConstAssumeCapacity(tag, lhs, rhs);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">binValue</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.binConst(tag, lhs, rhs)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmConst</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>,
    assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
    constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">try</span> self.ensureUnusedConstantCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.asmConstAssumeCapacity(ty, info, assembly, constraints);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">asmValue</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>,
    assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
    constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Value.html">Value</a> {
    <span class="tok-kw">return</span> (<span class="tok-kw">try</span> self.asmConst(ty, info, assembly, constraints)).toValue();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-type">void</span> {
    self.print(<a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.getStdErr">getStdErr</a>().writer()) <span class="tok-kw">catch</span> {};
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printToFile</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> file = <a href="std.html">std</a>.<a href="std.fs.html">fs</a>.<a href="std.fs.html#std.fs.cwd">cwd</a>().createFile(path, .{}) <span class="tok-kw">catch</span> |err| {
        <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.log">log</a>.<a href="#">err</a>(<span class="tok-str">&quot;failed printing LLVM module to \&quot;{s}\&quot;: {s}&quot;</span>, .{ path, <span class="tok-builtin">@errorName</span>(err) });
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    };
    <span class="tok-kw">defer</span> file.close();
    self.print(file.writer()) <span class="tok-kw">catch</span> |err| {
        <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.log">log</a>.<a href="#">err</a>(<span class="tok-str">&quot;failed printing LLVM module to \&quot;{s}\&quot;: {s}&quot;</span>, .{ path, <span class="tok-builtin">@errorName</span>(err) });
        <span class="tok-kw">return</span> <span class="tok-null">false</span>;
    };
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, writer: <span class="tok-kw">anytype</span>) (<span class="tok-builtin">@TypeOf</span>(writer).Error || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>)!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> bw = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.buffered_writer.html#std.io.buffered_writer.bufferedWriter">bufferedWriter</a>(writer);
    <span class="tok-kw">try</span> self.printUnbuffered(bw.writer());
    <span class="tok-kw">try</span> bw.flush();
}

<span class="tok-kw">fn</span> <span class="tok-fn">WriterWithErrors</span>(<span class="tok-kw">comptime</span> BackingWriter: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> ExtraErrors: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        backing_writer: BackingWriter,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = BackingWriter.Error || ExtraErrors;
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Writer = <a href="std.html">std</a>.<a href="std.io.html">io</a>.<a href="std.io.html#std.io.GenericWriter">Writer</a>(*<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.WriterWithErrors">Self</a>, <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.WriterWithErrors.Error">Error</a>, <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.WriterWithErrors.write">write</a>);

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">writer</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.WriterWithErrors">Self</a>) <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.WriterWithErrors.Writer">Writer</a> {
            <span class="tok-kw">return</span> .{ .context = self };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.WriterWithErrors">Self</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.WriterWithErrors.Error">Error</a>!<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.backing_writer.write(bytes);
        }
    };
}
<span class="tok-kw">fn</span> <span class="tok-fn">writerWithErrors</span>(
    backing_writer: <span class="tok-kw">anytype</span>,
    <span class="tok-kw">comptime</span> ExtraErrors: <span class="tok-type">type</span>,
) <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.WriterWithErrors">WriterWithErrors</a>(<span class="tok-builtin">@TypeOf</span>(backing_writer), ExtraErrors) {
    <span class="tok-kw">return</span> .{ .backing_writer = backing_writer };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printUnbuffered</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    backing_writer: <span class="tok-kw">anytype</span>,
) (<span class="tok-builtin">@TypeOf</span>(backing_writer).Error || <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>)!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> writer_with_errors = <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.writerWithErrors">writerWithErrors</a>(backing_writer, <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>);
    <span class="tok-kw">const</span> writer = writer_with_errors.writer();

    <span class="tok-kw">var</span> need_newline = <span class="tok-null">false</span>;
    <span class="tok-kw">var</span> metadata_formatter: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Formatter.html">Formatter</a> = .{ .builder = self, .need_comma = <span class="tok-null">undefined</span> };
    <span class="tok-kw">defer</span> metadata_formatter.map.deinit(self.gpa);

    <span class="tok-kw">if</span> (self.source_filename != .none <span class="tok-kw">or</span> self.data_layout != .none <span class="tok-kw">or</span> self.target_triple != .none) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">if</span> (self.source_filename != .none) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\; ModuleID = '{s}'</span>
            <span class="tok-str">\\source_filename = {&quot;}</span>
            <span class="tok-str">\\</span>
        , .{ self.source_filename.slice(self).?, self.source_filename.fmt(self) });
        <span class="tok-kw">if</span> (self.data_layout != .none) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\target datalayout = {&quot;}</span>
            <span class="tok-str">\\</span>
        , .{self.data_layout.fmt(self)});
        <span class="tok-kw">if</span> (self.target_triple != .none) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\target triple = {&quot;}</span>
            <span class="tok-str">\\</span>
        , .{self.target_triple.fmt(self)});
    }

    <span class="tok-kw">if</span> (self.module_asm.items.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">var</span> line_it = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.tokenizeScalar">tokenizeScalar</a>(<span class="tok-type">u8</span>, self.module_asm.items, <span class="tok-str">'\n'</span>);
        <span class="tok-kw">while</span> (line_it.next()) |line| {
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;module asm &quot;</span>);
            <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printEscapedString">printEscapedString</a>(line, .always_quote, writer);
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
        }
    }

    <span class="tok-kw">if</span> (self.types.count() &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (self.types.keys(), self.types.values()) |id, ty| <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\%{} = type {}</span>
            <span class="tok-str">\\</span>
        , .{ id.fmt(self), ty.fmt(self) });
    }

    <span class="tok-kw">if</span> (self.variables.items.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (self.variables.items) |variable| {
            <span class="tok-kw">if</span> (variable.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;
            <span class="tok-kw">const</span> global = variable.global.ptrConst(self);
            metadata_formatter.need_comma = <span class="tok-null">true</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\{} ={}{}{}{}{ }{}{ }{} {s} {%}{ }{, }{}</span>
                <span class="tok-str">\\</span>
            , .{
                variable.global.fmt(self),
                <a href="std.zig.llvm.Builder.Linkage.html">Linkage</a>.<a href="std.zig.llvm.Builder.Linkage.html#std.zig.llvm.Builder.Linkage.fmtOptional">fmtOptional</a>(<span class="tok-kw">if</span> (global.linkage == .external <span class="tok-kw">and</span>
                    variable.init != .no_init) <span class="tok-null">null</span> <span class="tok-kw">else</span> global.linkage),
                global.preemption,
                global.visibility,
                global.dll_storage_class,
                variable.thread_local,
                global.unnamed_addr,
                global.addr_space,
                global.externally_initialized,
                <span class="tok-builtin">@tagName</span>(variable.mutability),
                global.<span class="tok-type">type</span>.fmt(self),
                variable.init.fmt(self),
                variable.alignment,
                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;!dbg &quot;</span>, global.dbg),
            });
        }
    }

    <span class="tok-kw">if</span> (self.aliases.items.len &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (self.aliases.items) |alias| {
            <span class="tok-kw">if</span> (alias.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;
            <span class="tok-kw">const</span> global = alias.global.ptrConst(self);
            metadata_formatter.need_comma = <span class="tok-null">true</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\{} ={}{}{}{}{ }{} alias {%}, {%}{}</span>
                <span class="tok-str">\\</span>
            , .{
                alias.global.fmt(self),
                global.linkage,
                global.preemption,
                global.visibility,
                global.dll_storage_class,
                alias.thread_local,
                global.unnamed_addr,
                global.<span class="tok-type">type</span>.fmt(self),
                alias.aliasee.fmt(self),
                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;!dbg &quot;</span>, global.dbg),
            });
        }
    }

    <span class="tok-kw">var</span> attribute_groups: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>, <span class="tok-type">void</span>) = .empty;
    <span class="tok-kw">defer</span> attribute_groups.deinit(self.gpa);

    <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., self.functions.items) |function_i, function| {
        <span class="tok-kw">if</span> (function.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">const</span> function_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(function_i);
        <span class="tok-kw">const</span> global = function.global.ptrConst(self);
        <span class="tok-kw">const</span> params_len = global.<span class="tok-type">type</span>.functionParameters(self).len;
        <span class="tok-kw">const</span> function_attributes = function.attributes.func(self);
        <span class="tok-kw">if</span> (function_attributes != .none) <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\; Function Attrs:{}</span>
            <span class="tok-str">\\</span>
        , .{function_attributes.fmt(self)});
        <span class="tok-kw">try</span> writer.print(
            <span class="tok-str">\\{s}{}{}{}{}{}{&quot;} {%} {}(</span>
        , .{
            <span class="tok-kw">if</span> (function.instructions.len &gt; <span class="tok-number">0</span>) <span class="tok-str">&quot;define&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;declare&quot;</span>,
            global.linkage,
            global.preemption,
            global.visibility,
            global.dll_storage_class,
            function.call_conv,
            function.attributes.ret(self).fmt(self),
            global.<span class="tok-type">type</span>.functionReturn(self).fmt(self),
            function.global.fmt(self),
        });
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..params_len) |arg| {
            <span class="tok-kw">if</span> (arg &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\{%}{&quot;}</span>
            , .{
                global.<span class="tok-type">type</span>.functionParameters(self)[arg].fmt(self),
                function.attributes.param(arg, self).fmt(self),
            });
            <span class="tok-kw">if</span> (function.instructions.len &gt; <span class="tok-number">0</span>)
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; {}&quot;</span>, .{function.arg(<span class="tok-builtin">@intCast</span>(arg)).fmt(function_index, self)})
            <span class="tok-kw">else</span>
                <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; %{d}&quot;</span>, .{arg});
        }
        <span class="tok-kw">switch</span> (global.<span class="tok-type">type</span>.functionKind(self)) {
            .normal =&gt; {},
            .vararg =&gt; {
                <span class="tok-kw">if</span> (params_len &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;...&quot;</span>);
            },
        }
        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;){}{ }&quot;</span>, .{ global.unnamed_addr, global.addr_space });
        <span class="tok-kw">if</span> (function_attributes != .none) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; #{d}&quot;</span>, .{
            (<span class="tok-kw">try</span> attribute_groups.getOrPutValue(self.gpa, function_attributes, {})).index,
        });
        {
            metadata_formatter.need_comma = <span class="tok-null">false</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{ }{}&quot;</span>, .{
                function.alignment,
                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot; !dbg &quot;</span>, global.dbg),
            });
        }
        <span class="tok-kw">if</span> (function.instructions.len &gt; <span class="tok-number">0</span>) {
            <span class="tok-kw">var</span> block_incoming_len: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; {\n&quot;</span>);
            <span class="tok-kw">var</span> maybe_dbg_index: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
            <span class="tok-kw">for</span> (params_len..function.instructions.len) |instruction_i| {
                <span class="tok-kw">const</span> instruction_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(instruction_i);
                <span class="tok-kw">const</span> instruction = function.instructions.get(<span class="tok-builtin">@intFromEnum</span>(instruction_index));
                <span class="tok-kw">if</span> (function.debug_locations.get(instruction_index)) |debug_location| <span class="tok-kw">switch</span> (debug_location) {
                    .no_location =&gt; maybe_dbg_index = <span class="tok-null">null</span>,
                    .location =&gt; |location| {
                        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> metadata_formatter.map.getOrPut(self.gpa, .{
                            .debug_location = location,
                        });
                        maybe_dbg_index = <span class="tok-builtin">@intCast</span>(gop.index);
                    },
                };
                <span class="tok-kw">switch</span> (instruction.tag) {
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .@&quot;add nuw nsw&quot;,
                    .@&quot;and&quot;,
                    .ashr,
                    .@&quot;ashr exact&quot;,
                    .fadd,
                    .@&quot;fadd fast&quot;,
                    .@&quot;fcmp false&quot;,
                    .@&quot;fcmp fast false&quot;,
                    .@&quot;fcmp fast oeq&quot;,
                    .@&quot;fcmp fast oge&quot;,
                    .@&quot;fcmp fast ogt&quot;,
                    .@&quot;fcmp fast ole&quot;,
                    .@&quot;fcmp fast olt&quot;,
                    .@&quot;fcmp fast one&quot;,
                    .@&quot;fcmp fast ord&quot;,
                    .@&quot;fcmp fast true&quot;,
                    .@&quot;fcmp fast ueq&quot;,
                    .@&quot;fcmp fast uge&quot;,
                    .@&quot;fcmp fast ugt&quot;,
                    .@&quot;fcmp fast ule&quot;,
                    .@&quot;fcmp fast ult&quot;,
                    .@&quot;fcmp fast une&quot;,
                    .@&quot;fcmp fast uno&quot;,
                    .@&quot;fcmp oeq&quot;,
                    .@&quot;fcmp oge&quot;,
                    .@&quot;fcmp ogt&quot;,
                    .@&quot;fcmp ole&quot;,
                    .@&quot;fcmp olt&quot;,
                    .@&quot;fcmp one&quot;,
                    .@&quot;fcmp ord&quot;,
                    .@&quot;fcmp true&quot;,
                    .@&quot;fcmp ueq&quot;,
                    .@&quot;fcmp uge&quot;,
                    .@&quot;fcmp ugt&quot;,
                    .@&quot;fcmp ule&quot;,
                    .@&quot;fcmp ult&quot;,
                    .@&quot;fcmp une&quot;,
                    .@&quot;fcmp uno&quot;,
                    .fdiv,
                    .@&quot;fdiv fast&quot;,
                    .fmul,
                    .@&quot;fmul fast&quot;,
                    .frem,
                    .@&quot;frem fast&quot;,
                    .fsub,
                    .@&quot;fsub fast&quot;,
                    .@&quot;icmp eq&quot;,
                    .@&quot;icmp ne&quot;,
                    .@&quot;icmp sge&quot;,
                    .@&quot;icmp sgt&quot;,
                    .@&quot;icmp sle&quot;,
                    .@&quot;icmp slt&quot;,
                    .@&quot;icmp uge&quot;,
                    .@&quot;icmp ugt&quot;,
                    .@&quot;icmp ule&quot;,
                    .@&quot;icmp ult&quot;,
                    .lshr,
                    .@&quot;lshr exact&quot;,
                    .mul,
                    .@&quot;mul nsw&quot;,
                    .@&quot;mul nuw&quot;,
                    .@&quot;mul nuw nsw&quot;,
                    .@&quot;or&quot;,
                    .sdiv,
                    .@&quot;sdiv exact&quot;,
                    .srem,
                    .shl,
                    .@&quot;shl nsw&quot;,
                    .@&quot;shl nuw&quot;,
                    .@&quot;shl nuw nsw&quot;,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .@&quot;sub nuw nsw&quot;,
                    .udiv,
                    .@&quot;udiv exact&quot;,
                    .urem,
                    .xor,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.lhs.fmt(function_index, self),
                            extra.rhs.fmt(function_index, self),
                        });
                    },
                    .addrspacecast,
                    .bitcast,
                    .fpext,
                    .fptosi,
                    .fptoui,
                    .fptrunc,
                    .inttoptr,
                    .ptrtoint,
                    .sext,
                    .sitofp,
                    .trunc,
                    .uitofp,
                    .zext,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%} to {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.val.fmt(function_index, self),
                            extra.<span class="tok-type">type</span>.fmt(self),
                        });
                    },
                    .alloca,
                    .@&quot;alloca inalloca&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}{,%}{, }{, }&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.<span class="tok-type">type</span>.fmt(self),
                            <a href="std.zig.llvm.Builder.Value.html">Value</a>.<a href="std.zig.llvm.Builder.Value.html#std.zig.llvm.Builder.Value.fmt">fmt</a>(<span class="tok-kw">switch</span> (extra.len) {
                                .@&quot;1&quot; =&gt; .none,
                                <span class="tok-kw">else</span> =&gt; extra.len,
                            }, function_index, self),
                            extra.info.alignment,
                            extra.info.addr_space,
                        });
                    },
                    .arg =&gt; <span class="tok-kw">unreachable</span>,
                    .atomicrmw =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s}{ } {s} {%}, {%}{ }{ }{, }&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.info.access_kind,
                            <span class="tok-builtin">@tagName</span>(extra.info.atomic_rmw_operation),
                            extra.ptr.fmt(function_index, self),
                            extra.val.fmt(function_index, self),
                            extra.info.sync_scope,
                            extra.info.success_ordering,
                            extra.info.alignment,
                        });
                    },
                    .block =&gt; {
                        block_incoming_len = instruction.data;
                        <span class="tok-kw">const</span> name = instruction_index.name(&amp;function);
                        <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(instruction_index) &gt; params_len)
                            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}:\n&quot;</span>, .{name.fmt(self)});
                        <span class="tok-kw">continue</span>;
                    },
                    .br =&gt; |tag| {
                        <span class="tok-kw">const</span> target: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s} {%}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag), target.toInst(&amp;function).fmt(function_index, self),
                        });
                    },
                    .br_cond =&gt; {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  br {%}, {%}, {%}&quot;</span>, .{
                            extra.cond.fmt(function_index, self),
                            extra.then.toInst(&amp;function).fmt(function_index, self),
                            extra.@&quot;else&quot;.toInst(&amp;function).fmt(function_index, self),
                        });
                        metadata_formatter.need_comma = <span class="tok-null">true</span>;
                        <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
                        <span class="tok-kw">switch</span> (extra.weights) {
                            .none =&gt; {},
                            .unpredictable =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;!unpredictable !{}&quot;</span>),
                            _ =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}&quot;</span>, .{
                                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;!prof &quot;</span>, <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(extra.weights)))),
                            }),
                        }
                    },
                    .call,
                    .@&quot;call fast&quot;,
                    .@&quot;musttail call&quot;,
                    .@&quot;musttail call fast&quot;,
                    .@&quot;notail call&quot;,
                    .@&quot;notail call fast&quot;,
                    .@&quot;tail call&quot;,
                    .@&quot;tail call fast&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra =
                            function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, instruction.data);
                        <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;  &quot;</span>);
                        <span class="tok-kw">const</span> ret_ty = extra.data.ty.functionReturn(self);
                        <span class="tok-kw">switch</span> (ret_ty) {
                            .<span class="tok-type">void</span> =&gt; {},
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;%{} = &quot;</span>, .{
                                instruction_index.name(&amp;function).fmt(self),
                            }),
                            .none =&gt; <span class="tok-kw">unreachable</span>,
                        }
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}{}{}{} {%} {}(&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.info.call_conv,
                            extra.data.attributes.ret(self).fmt(self),
                            extra.data.callee.typeOf(function_index, self).pointerAddrSpace(self),
                            <span class="tok-kw">switch</span> (extra.data.ty.functionKind(self)) {
                                .normal =&gt; ret_ty,
                                .vararg =&gt; extra.data.ty,
                            }.fmt(self),
                            extra.data.callee.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., args) |arg_index, arg| {
                            <span class="tok-kw">if</span> (arg_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            metadata_formatter.need_comma = <span class="tok-null">false</span>;
                            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%}{}{}&quot;</span>, .{
                                arg.typeOf(function_index, self).fmt(self),
                                extra.data.attributes.param(arg_index, self).fmt(self),
                                <span class="tok-kw">try</span> metadata_formatter.fmtLocal(<span class="tok-str">&quot; &quot;</span>, arg, function_index),
                            });
                        }
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">')'</span>);
                        <span class="tok-kw">if</span> (extra.data.info.has_op_bundle_cold) {
                            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; [ \&quot;cold\&quot;() ]&quot;</span>);
                        }
                        <span class="tok-kw">const</span> call_function_attributes = extra.data.attributes.func(self);
                        <span class="tok-kw">if</span> (call_function_attributes != .none) <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot; #{d}&quot;</span>, .{
                            (<span class="tok-kw">try</span> attribute_groups.getOrPutValue(
                                self.gpa,
                                call_function_attributes,
                                {},
                            )).index,
                        });
                    },
                    .cmpxchg,
                    .@&quot;cmpxchg weak&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s}{ } {%}, {%}, {%}{ }{ }{ }{, }&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.info.access_kind,
                            extra.ptr.fmt(function_index, self),
                            extra.cmp.fmt(function_index, self),
                            extra.new.fmt(function_index, self),
                            extra.info.sync_scope,
                            extra.info.success_ordering,
                            extra.info.failure_ordering,
                            extra.info.alignment,
                        });
                    },
                    .extractelement =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.val.fmt(function_index, self),
                            extra.index.fmt(function_index, self),
                        });
                    },
                    .extractvalue =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = function.extraDataTrail(
                            <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>,
                            instruction.data,
                        );
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.val.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (indices) |index| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {d}&quot;</span>, .{index});
                    },
                    .fence =&gt; |tag| {
                        <span class="tok-kw">const</span> info: <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a> = <span class="tok-builtin">@bitCast</span>(instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s}{ }{ }&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            info.sync_scope,
                            info.success_ordering,
                        });
                    },
                    .fneg,
                    .@&quot;fneg fast&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> val: <a href="std.zig.llvm.Builder.Value.html">Value</a> = <span class="tok-builtin">@enumFromInt</span>(instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            val.fmt(function_index, self),
                        });
                    },
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = function.extraDataTrail(
                            <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>,
                            instruction.data,
                        );
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.<span class="tok-type">type</span>.fmt(self),
                            extra.data.base.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (indices) |index| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {%}&quot;</span>, .{
                            index.fmt(function_index, self),
                        });
                    },
                    .indirectbr =&gt; |tag| {
                        <span class="tok-kw">var</span> extra =
                            function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, instruction.data);
                        <span class="tok-kw">const</span> targets =
                            extra.trail.next(extra.data.targets_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s} {%}, [&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.addr.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., targets) |target_index, target| {
                            <span class="tok-kw">if</span> (target_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{%}&quot;</span>, .{
                                target.toInst(&amp;function).fmt(function_index, self),
                            });
                        }
                        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">']'</span>);
                    },
                    .insertelement =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.val.fmt(function_index, self),
                            extra.elem.fmt(function_index, self),
                            extra.index.fmt(function_index, self),
                        });
                    },
                    .insertvalue =&gt; |tag| {
                        <span class="tok-kw">var</span> extra =
                            function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, instruction.data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.val.fmt(function_index, self),
                            extra.data.elem.fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (indices) |index| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, {d}&quot;</span>, .{index});
                    },
                    .load,
                    .@&quot;load atomic&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s}{ } {%}, {%}{ }{ }{, }&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.info.access_kind,
                            extra.<span class="tok-type">type</span>.fmt(self),
                            extra.ptr.fmt(function_index, self),
                            extra.info.sync_scope,
                            extra.info.success_ordering,
                            extra.info.alignment,
                        });
                    },
                    .phi,
                    .@&quot;phi fast&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, instruction.data);
                        <span class="tok-kw">const</span> vals = extra.trail.next(block_incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;function);
                        <span class="tok-kw">const</span> blocks =
                            extra.trail.next(block_incoming_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%} &quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            vals[<span class="tok-number">0</span>].typeOf(function_index, self).fmt(self),
                        });
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., vals, blocks) |incoming_index, incoming_val, incoming_block| {
                            <span class="tok-kw">if</span> (incoming_index &gt; <span class="tok-number">0</span>) <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;, &quot;</span>);
                            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;[ {}, {} ]&quot;</span>, .{
                                incoming_val.fmt(function_index, self),
                                incoming_block.toInst(&amp;function).fmt(function_index, self),
                            });
                        }
                    },
                    .ret =&gt; |tag| {
                        <span class="tok-kw">const</span> val: <a href="std.zig.llvm.Builder.Value.html">Value</a> = <span class="tok-builtin">@enumFromInt</span>(instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s} {%}&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            val.fmt(function_index, self),
                        });
                    },
                    .@&quot;ret void&quot;,
                    .@&quot;unreachable&quot;,
                    =&gt; |tag| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s}&quot;</span>, .{<span class="tok-builtin">@tagName</span>(tag)}),
                    .select,
                    .@&quot;select fast&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.cond.fmt(function_index, self),
                            extra.lhs.fmt(function_index, self),
                            extra.rhs.fmt(function_index, self),
                        });
                    },
                    .shufflevector =&gt; |tag| {
                        <span class="tok-kw">const</span> extra =
                            function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.lhs.fmt(function_index, self),
                            extra.rhs.fmt(function_index, self),
                            extra.mask.fmt(function_index, self),
                        });
                    },
                    .store,
                    .@&quot;store atomic&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s}{ } {%}, {%}{ }{ }{, }&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.info.access_kind,
                            extra.val.fmt(function_index, self),
                            extra.ptr.fmt(function_index, self),
                            extra.info.sync_scope,
                            extra.info.success_ordering,
                            extra.info.alignment,
                        });
                    },
                    .@&quot;switch&quot; =&gt; |tag| {
                        <span class="tok-kw">var</span> extra =
                            function.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, instruction.data);
                        <span class="tok-kw">const</span> vals = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, &amp;function);
                        <span class="tok-kw">const</span> blocks =
                            extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;function);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  {s} {%}, {%} [\n&quot;</span>, .{
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.data.val.fmt(function_index, self),
                            extra.data.default.toInst(&amp;function).fmt(function_index, self),
                        });
                        <span class="tok-kw">for</span> (vals, blocks) |case_val, case_block| <span class="tok-kw">try</span> writer.print(
                            <span class="tok-str">&quot;    {%}, {%}\n&quot;</span>,
                            .{
                                case_val.fmt(self),
                                case_block.toInst(&amp;function).fmt(function_index, self),
                            },
                        );
                        <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;  ]&quot;</span>);
                        metadata_formatter.need_comma = <span class="tok-null">true</span>;
                        <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
                        <span class="tok-kw">switch</span> (extra.data.weights) {
                            .none =&gt; {},
                            .unpredictable =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;!unpredictable !{}&quot;</span>),
                            _ =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}&quot;</span>, .{
                                <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;!prof &quot;</span>, <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(extra.data.weights)))),
                            }),
                        }
                    },
                    .va_arg =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = function.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, instruction.data);
                        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;  %{} = {s} {%}, {%}&quot;</span>, .{
                            instruction_index.name(&amp;function).fmt(self),
                            <span class="tok-builtin">@tagName</span>(tag),
                            extra.list.fmt(function_index, self),
                            extra.<span class="tok-type">type</span>.fmt(self),
                        });
                    },
                }

                <span class="tok-kw">if</span> (maybe_dbg_index) |dbg_index| {
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;, !dbg !{}&quot;</span>, .{dbg_index});
                }
                <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
            }
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'}'</span>);
        }
        <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>);
    }

    <span class="tok-kw">if</span> (attribute_groups.count() &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (<span class="tok-number">0</span>.., attribute_groups.keys()) |attribute_group_index, attribute_group|
            <span class="tok-kw">try</span> writer.print(
                <span class="tok-str">\\attributes #{d} = {{{#&quot;} }}</span>
                <span class="tok-str">\\</span>
            , .{ attribute_group_index, attribute_group.fmt(self) });
    }

    <span class="tok-kw">if</span> (self.metadata_named.count() &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">for</span> (self.metadata_named.keys(), self.metadata_named.values()) |name, data| {
            <span class="tok-kw">const</span> elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> =
                <span class="tok-builtin">@ptrCast</span>(self.metadata_extra.items[data.index..][<span class="tok-number">0</span>..data.len]);
            <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'!'</span>);
            <span class="tok-kw">try</span> <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printEscapedString">printEscapedString</a>(name.slice(self), .quote_unless_valid_identifier, writer);
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot; = !{&quot;</span>);
            metadata_formatter.need_comma = <span class="tok-null">false</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;
            <span class="tok-kw">for</span> (elements) |element| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{}&quot;</span>, .{<span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, element)});
            <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;}\n&quot;</span>);
        }
    }

    <span class="tok-kw">if</span> (metadata_formatter.map.count() &gt; <span class="tok-number">0</span>) {
        <span class="tok-kw">if</span> (need_newline) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'\n'</span>) <span class="tok-kw">else</span> need_newline = <span class="tok-null">true</span>;
        <span class="tok-kw">var</span> metadata_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (metadata_index &lt; metadata_formatter.map.count()) : (metadata_index += <span class="tok-number">1</span>) {
            <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">10_000</span>);
            <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;!{} = &quot;</span>, .{metadata_index});
            metadata_formatter.need_comma = <span class="tok-null">false</span>;
            <span class="tok-kw">defer</span> metadata_formatter.need_comma = <span class="tok-null">undefined</span>;

            <span class="tok-kw">const</span> key = metadata_formatter.map.keys()[metadata_index];
            <span class="tok-kw">const</span> metadata_item = <span class="tok-kw">switch</span> (key) {
                .debug_location =&gt; |location| {
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DILocation, .{
                        .line = location.line,
                        .column = location.column,
                        .scope = location.scope,
                        .inlinedAt = location.inlined_at,
                        .isImplicitCode = <span class="tok-null">false</span>,
                    }, writer);
                    <span class="tok-kw">continue</span>;
                },
                .metadata =&gt; |metadata| self.metadata_items.get(<span class="tok-builtin">@intFromEnum</span>(metadata)),
            };

            <span class="tok-kw">switch</span> (metadata_item.tag) {
                .none, .expression, .constant =&gt; <span class="tok-kw">unreachable</span>,
                .file =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.File.html">File</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIFile, .{
                        .filename = extra.filename,
                        .directory = extra.directory,
                        .checksumkind = <span class="tok-null">null</span>,
                        .checksum = <span class="tok-null">null</span>,
                        .source = <span class="tok-null">null</span>,
                    }, writer);
                },
                .compile_unit,
                .@&quot;compile_unit optimized&quot;,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;distinct !&quot;, .DICompileUnit, .{
                        .language = .DW_LANG_C99,
                        .file = extra.file,
                        .producer = extra.producer,
                        .isOptimized = <span class="tok-kw">switch</span> (kind) {
                            .compile_unit =&gt; <span class="tok-null">false</span>,
                            .@&quot;compile_unit optimized&quot; =&gt; <span class="tok-null">true</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                        .flags = <span class="tok-null">null</span>,
                        .runtimeVersion = <span class="tok-number">0</span>,
                        .splitDebugFilename = <span class="tok-null">null</span>,
                        .emissionKind = .FullDebug,
                        .enums = extra.enums,
                        .retainedTypes = <span class="tok-null">null</span>,
                        .globals = extra.globals,
                        .imports = <span class="tok-null">null</span>,
                        .macros = <span class="tok-null">null</span>,
                        .dwoId = <span class="tok-null">null</span>,
                        .splitDebugInlining = <span class="tok-null">false</span>,
                        .debugInfoForProfiling = <span class="tok-null">null</span>,
                        .nameTableKind = <span class="tok-null">null</span>,
                        .rangesBaseAddress = <span class="tok-null">null</span>,
                        .sysroot = <span class="tok-null">null</span>,
                        .sdk = <span class="tok-null">null</span>,
                    }, writer);
                },
                .subprogram,
                .@&quot;subprogram local&quot;,
                .@&quot;subprogram definition&quot;,
                .@&quot;subprogram local definition&quot;,
                .@&quot;subprogram optimized&quot;,
                .@&quot;subprogram optimized local&quot;,
                .@&quot;subprogram optimized definition&quot;,
                .@&quot;subprogram optimized local definition&quot;,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;distinct !&quot;, .DISubprogram, .{
                        .name = extra.name,
                        .linkageName = extra.linkage_name,
                        .scope = extra.file,
                        .file = extra.file,
                        .line = extra.line,
                        .<span class="tok-type">type</span> = extra.ty,
                        .scopeLine = extra.scope_line,
                        .containingType = <span class="tok-null">null</span>,
                        .virtualIndex = <span class="tok-null">null</span>,
                        .thisAdjustment = <span class="tok-null">null</span>,
                        .flags = extra.di_flags,
                        .spFlags = <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.DISPFlags.html">DISPFlags</a>, <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(
                            <span class="tok-builtin">@intFromEnum</span>(kind) - <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">subprogram</a>),
                        ))) &lt;&lt; <span class="tok-number">2</span>)),
                        .unit = extra.compile_unit,
                        .templateParams = <span class="tok-null">null</span>,
                        .declaration = <span class="tok-null">null</span>,
                        .retainedNodes = <span class="tok-null">null</span>,
                        .thrownTypes = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                        .targetFuncName = <span class="tok-null">null</span>,
                    }, writer);
                },
                .lexical_block =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LexicalBlock.html">LexicalBlock</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;distinct !&quot;, .DILexicalBlock, .{
                        .scope = extra.scope,
                        .file = extra.file,
                        .line = extra.line,
                        .column = extra.column,
                    }, writer);
                },
                .location =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Location.html">Location</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DILocation, .{
                        .line = extra.line,
                        .column = extra.column,
                        .scope = extra.scope,
                        .inlinedAt = extra.inlined_at,
                        .isImplicitCode = <span class="tok-null">false</span>,
                    }, writer);
                },
                .basic_bool_type,
                .basic_unsigned_type,
                .basic_signed_type,
                .basic_float_type,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIBasicType, .{
                        .tag = <span class="tok-null">null</span>,
                        .name = <span class="tok-kw">switch</span> (extra.name) {
                            .none =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; extra.name,
                        },
                        .size = extra.bitSize(),
                        .@&quot;align&quot; = <span class="tok-null">null</span>,
                        .encoding = <span class="tok-builtin">@as</span>(<span class="tok-kw">enum</span> {
                            DW_ATE_boolean,
                            DW_ATE_unsigned,
                            DW_ATE_signed,
                            DW_ATE_float,
                        }, <span class="tok-kw">switch</span> (kind) {
                            .basic_bool_type =&gt; .DW_ATE_boolean,
                            .basic_unsigned_type =&gt; .DW_ATE_unsigned,
                            .basic_signed_type =&gt; .DW_ATE_signed,
                            .basic_float_type =&gt; .DW_ATE_float,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }),
                        .flags = <span class="tok-null">null</span>,
                    }, writer);
                },
                .composite_struct_type,
                .composite_union_type,
                .composite_enumeration_type,
                .composite_array_type,
                .composite_vector_type,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DICompositeType, .{
                        .tag = <span class="tok-builtin">@as</span>(<span class="tok-kw">enum</span> {
                            DW_TAG_structure_type,
                            DW_TAG_union_type,
                            DW_TAG_enumeration_type,
                            DW_TAG_array_type,
                        }, <span class="tok-kw">switch</span> (kind) {
                            .composite_struct_type =&gt; .DW_TAG_structure_type,
                            .composite_union_type =&gt; .DW_TAG_union_type,
                            .composite_enumeration_type =&gt; .DW_TAG_enumeration_type,
                            .composite_array_type, .composite_vector_type =&gt; .DW_TAG_array_type,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }),
                        .name = <span class="tok-kw">switch</span> (extra.name) {
                            .none =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; extra.name,
                        },
                        .scope = extra.scope,
                        .file = <span class="tok-null">null</span>,
                        .line = <span class="tok-null">null</span>,
                        .baseType = extra.underlying_type,
                        .size = extra.bitSize(),
                        .@&quot;align&quot; = extra.bitAlign(),
                        .offset = <span class="tok-null">null</span>,
                        .flags = <span class="tok-null">null</span>,
                        .elements = extra.fields_tuple,
                        .runtimeLang = <span class="tok-null">null</span>,
                        .vtableHolder = <span class="tok-null">null</span>,
                        .templateParams = <span class="tok-null">null</span>,
                        .identifier = <span class="tok-null">null</span>,
                        .discriminator = <span class="tok-null">null</span>,
                        .dataLocation = <span class="tok-null">null</span>,
                        .associated = <span class="tok-null">null</span>,
                        .allocated = <span class="tok-null">null</span>,
                        .rank = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .derived_pointer_type,
                .derived_member_type,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIDerivedType, .{
                        .tag = <span class="tok-builtin">@as</span>(<span class="tok-kw">enum</span> {
                            DW_TAG_pointer_type,
                            DW_TAG_member,
                        }, <span class="tok-kw">switch</span> (kind) {
                            .derived_pointer_type =&gt; .DW_TAG_pointer_type,
                            .derived_member_type =&gt; .DW_TAG_member,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }),
                        .name = <span class="tok-kw">switch</span> (extra.name) {
                            .none =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; extra.name,
                        },
                        .scope = extra.scope,
                        .file = <span class="tok-null">null</span>,
                        .line = <span class="tok-null">null</span>,
                        .baseType = extra.underlying_type,
                        .size = extra.bitSize(),
                        .@&quot;align&quot; = extra.bitAlign(),
                        .offset = <span class="tok-kw">switch</span> (extra.bitOffset()) {
                            <span class="tok-number">0</span> =&gt; <span class="tok-null">null</span>,
                            <span class="tok-kw">else</span> =&gt; |bit_offset| bit_offset,
                        },
                        .flags = <span class="tok-null">null</span>,
                        .extraData = <span class="tok-null">null</span>,
                        .dwarfAddressSpace = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .subroutine_type =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.SubroutineType.html">SubroutineType</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DISubroutineType, .{
                        .flags = <span class="tok-null">null</span>,
                        .cc = <span class="tok-null">null</span>,
                        .types = extra.types_tuple,
                    }, writer);
                },
                .enumerator_unsigned,
                .enumerator_signed_positive,
                .enumerator_signed_negative,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Enumerator.html">Enumerator</a>, metadata_item.data);

                    <span class="tok-kw">const</span> ExpectedContents = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
                        <span class="tok-kw">const</span> expected_limbs = <span class="tok-builtin">@divExact</span>(<span class="tok-number">512</span>, <span class="tok-builtin">@bitSizeOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>));
                        string: [
                            (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>{
                                .limbs = &amp;([<span class="tok-number">1</span>]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>{
                                    <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>),
                                } ** <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printUnbuffered.expected_limbs">expected_limbs</a>),
                                .positive = <span class="tok-null">false</span>,
                            }).sizeInBaseUpperBound(<span class="tok-number">10</span>)
                        ]<span class="tok-type">u8</span>,
                        limbs: [
                            <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcToStringLimbsBufferLen">calcToStringLimbsBufferLen</a>(<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.printUnbuffered.expected_limbs">expected_limbs</a>, <span class="tok-number">10</span>)
                        ]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>,
                    };
                    <span class="tok-kw">var</span> stack <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(ExpectedContents)) =
                        <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-builtin">@sizeOf</span>(ExpectedContents), self.gpa);
                    <span class="tok-kw">const</span> allocator = stack.get();

                    <span class="tok-kw">const</span> limbs = self.metadata_limbs.items[extra.limbs_index..][<span class="tok-number">0</span>..extra.limbs_len];
                    <span class="tok-kw">const</span> bigint: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a> = .{
                        .limbs = limbs,
                        .positive = <span class="tok-kw">switch</span> (kind) {
                            .enumerator_unsigned,
                            .enumerator_signed_positive,
                            =&gt; <span class="tok-null">true</span>,
                            .enumerator_signed_negative =&gt; <span class="tok-null">false</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                    };
                    <span class="tok-kw">const</span> str = <span class="tok-kw">try</span> bigint.toStringAlloc(allocator, <span class="tok-number">10</span>, <span class="tok-null">undefined</span>);
                    <span class="tok-kw">defer</span> allocator.free(str);

                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIEnumerator, .{
                        .name = extra.name,
                        .value = str,
                        .isUnsigned = <span class="tok-kw">switch</span> (kind) {
                            .enumerator_unsigned =&gt; <span class="tok-null">true</span>,
                            .enumerator_signed_positive,
                            .enumerator_signed_negative,
                            =&gt; <span class="tok-null">false</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                    }, writer);
                },
                .subrange =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subrange.html">Subrange</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DISubrange, .{
                        .count = extra.count,
                        .lowerBound = extra.lower_bound,
                        .upperBound = <span class="tok-null">null</span>,
                        .stride = <span class="tok-null">null</span>,
                    }, writer);
                },
                .tuple =&gt; {
                    <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tuple.html">Tuple</a>, metadata_item.data);
                    <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, self);
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;!{&quot;</span>);
                    <span class="tok-kw">for</span> (elements) |element| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{[element]%}&quot;</span>, .{
                        .element = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, element),
                    });
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;}\n&quot;</span>);
                },
                .str_tuple =&gt; {
                    <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.StrTuple.html">StrTuple</a>, metadata_item.data);
                    <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, self);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;!{{{[str]%}&quot;</span>, .{
                        .str = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, extra.data.str),
                    });
                    <span class="tok-kw">for</span> (elements) |element| <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{[element]%}&quot;</span>, .{
                        .element = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, element),
                    });
                    <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;}\n&quot;</span>);
                },
                .module_flag =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.ModuleFlag.html">ModuleFlag</a>, metadata_item.data);
                    <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;!{{{[behavior]%}{[name]%}{[constant]%}}}\n&quot;</span>, .{
                        .behavior = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, extra.behavior),
                        .name = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, extra.name),
                        .constant = <span class="tok-kw">try</span> metadata_formatter.fmt(<span class="tok-str">&quot;&quot;</span>, extra.constant),
                    });
                },
                .local_var =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LocalVar.html">LocalVar</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DILocalVariable, .{
                        .name = extra.name,
                        .arg = <span class="tok-null">null</span>,
                        .scope = extra.scope,
                        .file = extra.file,
                        .line = extra.line,
                        .<span class="tok-type">type</span> = extra.ty,
                        .flags = <span class="tok-null">null</span>,
                        .@&quot;align&quot; = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .parameter =&gt; {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Parameter.html">Parameter</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DILocalVariable, .{
                        .name = extra.name,
                        .arg = extra.arg_no,
                        .scope = extra.scope,
                        .file = extra.file,
                        .line = extra.line,
                        .<span class="tok-type">type</span> = extra.ty,
                        .flags = <span class="tok-null">null</span>,
                        .@&quot;align&quot; = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .global_var,
                .@&quot;global_var local&quot;,
                =&gt; |kind| {
                    <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;distinct !&quot;, .DIGlobalVariable, .{
                        .name = extra.name,
                        .linkageName = extra.linkage_name,
                        .scope = extra.scope,
                        .file = extra.file,
                        .line = extra.line,
                        .<span class="tok-type">type</span> = extra.ty,
                        .isLocal = <span class="tok-kw">switch</span> (kind) {
                            .global_var =&gt; <span class="tok-null">false</span>,
                            .@&quot;global_var local&quot; =&gt; <span class="tok-null">true</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        },
                        .isDefinition = <span class="tok-null">true</span>,
                        .declaration = <span class="tok-null">null</span>,
                        .templateParams = <span class="tok-null">null</span>,
                        .@&quot;align&quot; = <span class="tok-null">null</span>,
                        .annotations = <span class="tok-null">null</span>,
                    }, writer);
                },
                .global_var_expression =&gt; {
                    <span class="tok-kw">const</span> extra =
                        self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVarExpression.html">GlobalVarExpression</a>, metadata_item.data);
                    <span class="tok-kw">try</span> metadata_formatter.specialized(.@&quot;!&quot;, .DIGlobalVariableExpression, .{
                        .@&quot;var&quot; = extra.variable,
                        .expr = extra.expression,
                    }, writer);
                },
            }
        }
    }
}

<span class="tok-kw">const</span> NoExtra = <span class="tok-kw">struct</span> {};

<span class="tok-kw">fn</span> <span class="tok-fn">isValidIdentifier</span>(id: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">for</span> (id, <span class="tok-number">0</span>..) |byte, index| <span class="tok-kw">switch</span> (byte) {
        <span class="tok-str">'</code></pre></details></div></span>, <span class="tok-str">'-'</span>, <span class="tok-str">'.'</span>, <span class="tok-str">'A'</span>...<span class="tok-str">'Z'</span>, <span class="tok-str">'_'</span>, <span class="tok-str">'a'</span>...<span class="tok-str">'z'</span> =&gt; {},
        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; <span class="tok-kw">if</span> (index == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-null">false</span>,
    };
    <span class="tok-kw">return</span> <span class="tok-null">true</span>;
}

<span class="tok-kw">const</span> QuoteBehavior = <span class="tok-kw">enum</span> { always_quote, quote_unless_valid_identifier };
<span class="tok-kw">fn</span> <span class="tok-fn">printEscapedString</span>(
    slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    quotes: <a href="std.zig.llvm.Builder.QuoteBehavior.html">QuoteBehavior</a>,
    writer: <span class="tok-kw">anytype</span>,
) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> need_quotes = <span class="tok-kw">switch</span> (quotes) {
        .always_quote =&gt; <span class="tok-null">true</span>,
        .quote_unless_valid_identifier =&gt; !<a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.isValidIdentifier">isValidIdentifier</a>(slice),
    };
    <span class="tok-kw">if</span> (need_quotes) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'&quot;'</span>);
    <span class="tok-kw">for</span> (slice) |byte| <span class="tok-kw">switch</span> (byte) {
        <span class="tok-str">'\\'</span> =&gt; <span class="tok-kw">try</span> writer.writeAll(<span class="tok-str">&quot;\\\\&quot;</span>),
        <span class="tok-str">' '</span>...<span class="tok-str">'&quot;'</span> - <span class="tok-number">1</span>, <span class="tok-str">'&quot;'</span> + <span class="tok-number">1</span>...<span class="tok-str">'\\'</span> - <span class="tok-number">1</span>, <span class="tok-str">'\\'</span> + <span class="tok-number">1</span>...<span class="tok-str">'~'</span> =&gt; <span class="tok-kw">try</span> writer.writeByte(byte),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;\\{X:0&gt;2}&quot;</span>, .{byte}),
    };
    <span class="tok-kw">if</span> (need_quotes) <span class="tok-kw">try</span> writer.writeByte(<span class="tok-str">'&quot;'</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedGlobalCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.strtab_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (name.slice(self)) |id| {
        <span class="tok-kw">const</span> count: <span class="tok-type">usize</span> = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(<span class="tok-str">&quot;{d}&quot;</span>, .{<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.maxInt">maxInt</a>(<span class="tok-type">u32</span>)});
        <span class="tok-kw">try</span> self.strtab_string_bytes.ensureUnusedCapacity(self.gpa, id.len + count);
    }
    <span class="tok-kw">try</span> self.strtab_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.globals.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.next_unique_global_id.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">fnTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ret: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    params: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Type.Function.Kind.html">Kind</a>,
) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">const</span> tag: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (kind) {
        .normal =&gt; .function,
        .vararg =&gt; .vararg_function,
    };
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> { ret: <a href="std.zig.llvm.Builder.Type.html">Type</a>, params: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a> };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(tag)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.ret));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key.params));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> rhs_data = ctx.builder.type_items.items[rhs_index];
            <span class="tok-kw">if</span> (rhs_data.tag != tag) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">var</span> rhs_extra = ctx.builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, rhs_data.data);
            <span class="tok-kw">const</span> rhs_params = rhs_extra.trail.next(rhs_extra.data.params_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, ctx.builder);
            <span class="tok-kw">return</span> lhs_key.ret == rhs_extra.data.ret <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, lhs_key.params, rhs_params);
        }
    };
    <span class="tok-kw">const</span> gop = self.type_map.getOrPutAssumeCapacityAdapted(
        Key{ .ret = ret, .params = params },
        Adapter{ .builder = self },
    );
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.type_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addTypeExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>{
                .ret = ret,
                .params_len = <span class="tok-builtin">@intCast</span>(params.len),
            }),
        });
        self.type_extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(params));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">intTypeAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bits: <span class="tok-type">u24</span>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(bits &gt; <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> result = self.getOrPutTypeNoExtraAssumeCapacity(.{ .tag = .integer, .data = bits });
    <span class="tok-kw">return</span> result.<span class="tok-type">type</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">ptrTypeAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, addr_space: <a href="std.zig.llvm.Builder.AddrSpace.html">AddrSpace</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">const</span> result = self.getOrPutTypeNoExtraAssumeCapacity(
        .{ .tag = .pointer, .data = <span class="tok-builtin">@intFromEnum</span>(addr_space) },
    );
    <span class="tok-kw">return</span> result.<span class="tok-type">type</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">vectorTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a>,
    len: <span class="tok-type">u32</span>,
    child: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(child.isFloatingPoint() <span class="tok-kw">or</span> child.isInteger(self) <span class="tok-kw">or</span> child.isPointer(self));
    <span class="tok-kw">const</span> tag: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (kind) {
        .normal =&gt; .vector,
        .scalable =&gt; .scalable_vector,
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(tag)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> rhs_data = ctx.builder.type_items.items[rhs_index];
            <span class="tok-kw">return</span> rhs_data.tag == tag <span class="tok-kw">and</span>
                <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key, ctx.builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, rhs_data.data));
        }
    };
    <span class="tok-kw">const</span> data = <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>{ .len = len, .child = child };
    <span class="tok-kw">const</span> gop = self.type_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.type_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addTypeExtraAssumeCapacity(data),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">arrayTypeAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, len: <span class="tok-type">u64</span>, child: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.cast">cast</a>(<span class="tok-type">u32</span>, len)) |small_len| {
        <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                    <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a>.<a href="#">small_array</a>)),
                    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
                ));
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
                <span class="tok-kw">const</span> rhs_data = ctx.builder.type_items.items[rhs_index];
                <span class="tok-kw">return</span> rhs_data.tag == .small_array <span class="tok-kw">and</span>
                    <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key, ctx.builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>, rhs_data.data));
            }
        };
        <span class="tok-kw">const</span> data = <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>{ .len = small_len, .child = child };
        <span class="tok-kw">const</span> gop = self.type_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
        <span class="tok-kw">if</span> (!gop.found_existing) {
            gop.key_ptr.* = {};
            gop.value_ptr.* = {};
            self.type_items.appendAssumeCapacity(.{
                .tag = .small_array,
                .data = self.addTypeExtraAssumeCapacity(data),
            });
        }
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                    <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a>.<a href="#">array</a>)),
                    <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
                ));
            }
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
                <span class="tok-kw">const</span> rhs_data = ctx.builder.type_items.items[rhs_index];
                <span class="tok-kw">return</span> rhs_data.tag == .array <span class="tok-kw">and</span>
                    <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key, ctx.builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>, rhs_data.data));
            }
        };
        <span class="tok-kw">const</span> data = <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>{
            .len_lo = <span class="tok-builtin">@truncate</span>(len),
            .len_hi = <span class="tok-builtin">@intCast</span>(len &gt;&gt; <span class="tok-number">32</span>),
            .child = child,
        };
        <span class="tok-kw">const</span> gop = self.type_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
        <span class="tok-kw">if</span> (!gop.found_existing) {
            gop.key_ptr.* = {};
            gop.value_ptr.* = {};
            self.type_items.appendAssumeCapacity(.{
                .tag = .array,
                .data = self.addTypeExtraAssumeCapacity(data),
            });
        }
        <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">structTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>.<a href="std.zig.llvm.Builder.Type.Structure.Kind.html">Kind</a>,
    fields: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">const</span> tag: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (kind) {
        .normal =&gt; .structure,
        .@&quot;packed&quot; =&gt; .packed_structure,
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(tag)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Type.html">Type</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> rhs_data = ctx.builder.type_items.items[rhs_index];
            <span class="tok-kw">if</span> (rhs_data.tag != tag) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">var</span> rhs_extra = ctx.builder.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, rhs_data.data);
            <span class="tok-kw">const</span> rhs_fields = rhs_extra.trail.next(rhs_extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, ctx.builder);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<a href="std.zig.llvm.Builder.Type.html">Type</a>, lhs_key, rhs_fields);
        }
    };
    <span class="tok-kw">const</span> gop = self.type_map.getOrPutAssumeCapacityAdapted(fields, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.type_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addTypeExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>{
                .fields_len = <span class="tok-builtin">@intCast</span>(fields.len),
            }),
        });
        self.type_extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(fields));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">opaqueTypeAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.zig.llvm.Builder.Type.html">Type</a> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.String.html">String</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a>.<a href="#">named_structure</a>)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.String.html">String</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> rhs_data = ctx.builder.type_items.items[rhs_index];
            <span class="tok-kw">return</span> rhs_data.tag == .named_structure <span class="tok-kw">and</span>
                lhs_key == ctx.builder.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, rhs_data.data).id;
        }
    };
    <span class="tok-kw">var</span> id = name;
    <span class="tok-kw">if</span> (name == .empty) {
        id = self.next_unnamed_type;
        <a href="std.debug.html#std.debug.assert">assert</a>(id != .none);
        self.next_unnamed_type = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(id) + <span class="tok-number">1</span>);
    } <span class="tok-kw">else</span> <a href="std.debug.html#std.debug.assert">assert</a>(!name.isAnon());
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">const</span> type_gop = self.types.getOrPutAssumeCapacity(id);
        <span class="tok-kw">if</span> (!type_gop.found_existing) {
            <span class="tok-kw">const</span> gop = self.type_map.getOrPutAssumeCapacityAdapted(id, Adapter{ .builder = self });
            <a href="std.debug.html#std.debug.assert">assert</a>(!gop.found_existing);
            gop.key_ptr.* = {};
            gop.value_ptr.* = {};
            self.type_items.appendAssumeCapacity(.{
                .tag = .named_structure,
                .data = self.addTypeExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>{
                    .id = id,
                    .body = .none,
                }),
            });
            <span class="tok-kw">const</span> result: <a href="std.zig.llvm.Builder.Type.html">Type</a> = <span class="tok-builtin">@enumFromInt</span>(gop.index);
            type_gop.value_ptr.* = result;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-kw">const</span> unique_gop = self.next_unique_type_id.getOrPutAssumeCapacity(name);
        <span class="tok-kw">if</span> (!unique_gop.found_existing) unique_gop.value_ptr.* = <span class="tok-number">2</span>;
        id = self.fmtAssumeCapacity(<span class="tok-str">&quot;{s}.{d}&quot;</span>, .{ name.slice(self).?, unique_gop.value_ptr.* });
        unique_gop.value_ptr.* += <span class="tok-number">1</span>;
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedTypeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    count: <span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> Extra: <span class="tok-type">type</span>,
    trail_len: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.type_map.ensureUnusedCapacity(self.gpa, count);
    <span class="tok-kw">try</span> self.type_items.ensureUnusedCapacity(self.gpa, count);
    <span class="tok-kw">try</span> self.type_extra.ensureUnusedCapacity(
        self.gpa,
        count * (<span class="tok-builtin">@typeInfo</span>(Extra).@&quot;struct&quot;.fields.len + trail_len),
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">getOrPutTypeNoExtraAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, item: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>) <span class="tok-kw">struct</span> { new: <span class="tok-type">bool</span>, <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a> } {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Tag.html">Tag</a>.<a href="#">simple</a>)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> lhs_bits: <span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(lhs_key);
            <span class="tok-kw">const</span> rhs_bits: <span class="tok-type">u32</span> = <span class="tok-builtin">@bitCast</span>(ctx.builder.type_items.items[rhs_index]);
            <span class="tok-kw">return</span> lhs_bits == rhs_bits;
        }
    };
    <span class="tok-kw">const</span> gop = self.type_map.getOrPutAssumeCapacityAdapted(item, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.type_items.appendAssumeCapacity(item);
    }
    <span class="tok-kw">return</span> .{ .new = !gop.found_existing, .<span class="tok-type">type</span> = <span class="tok-builtin">@enumFromInt</span>(gop.index) };
}

<span class="tok-kw">fn</span> <span class="tok-fn">addTypeExtraAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, extra: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a> {
    <span class="tok-kw">const</span> result: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a> = <span class="tok-builtin">@intCast</span>(self.type_extra.items.len);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields) |field| {
        <span class="tok-kw">const</span> value = <span class="tok-builtin">@field</span>(extra, field.name);
        self.type_extra.appendAssumeCapacity(<span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
            <span class="tok-type">u32</span> =&gt; value,
            <a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.Type.html">Type</a> =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ field.name ++ <span class="tok-str">&quot;: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
        });
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">const</span> TypeExtraDataTrail = <span class="tok-kw">struct</span> {
    index: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">nextMut</span>(self: *<a href="std.zig.llvm.Builder.TypeExtraDataTrail.html">TypeExtraDataTrail</a>, len: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) []Item {
        <span class="tok-kw">const</span> items: []Item = <span class="tok-builtin">@ptrCast</span>(builder.type_extra.items[self.index..][<span class="tok-number">0</span>..len]);
        self.index += <span class="tok-builtin">@intCast</span>(len);
        <span class="tok-kw">return</span> items;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(
        self: *<a href="std.zig.llvm.Builder.TypeExtraDataTrail.html">TypeExtraDataTrail</a>,
        len: <span class="tok-type">u32</span>,
        <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    ) []<span class="tok-kw">const</span> Item {
        <span class="tok-kw">const</span> items: []<span class="tok-kw">const</span> Item = <span class="tok-builtin">@ptrCast</span>(builder.type_extra.items[self.index..][<span class="tok-number">0</span>..len]);
        self.index += <span class="tok-builtin">@intCast</span>(len);
        <span class="tok-kw">return</span> items;
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">typeExtraDataTrail</span>(
    self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    index: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a>,
) <span class="tok-kw">struct</span> { data: T, trail: <a href="std.zig.llvm.Builder.TypeExtraDataTrail.html">TypeExtraDataTrail</a> } {
    <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields, self.type_extra.items[index..][<span class="tok-number">0</span>..fields.len]) |field, value|
        <span class="tok-builtin">@field</span>(result, field.name) = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
            <span class="tok-type">u32</span> =&gt; value,
            <a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.Type.html">Type</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(value),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
        };
    <span class="tok-kw">return</span> .{
        .data = result,
        .trail = .{ .index = index + <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a>, <span class="tok-builtin">@intCast</span>(fields.len)) },
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeExtraData</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, index: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Type.Item.html#std.zig.llvm.Builder.Type.Item.ExtraIndex">ExtraIndex</a>) T {
    <span class="tok-kw">return</span> self.typeExtraDataTrail(T, index).data;
}

<span class="tok-kw">fn</span> <span class="tok-fn">attrGeneric</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, data: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">u32</span> {
    <span class="tok-kw">try</span> self.attributes_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.attributes_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.attributes_extra.ensureUnusedCapacity(self.gpa, data.len);

    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">1</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key)));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> start = ctx.builder.attributes_indices.items[rhs_index];
            <span class="tok-kw">const</span> end = ctx.builder.attributes_indices.items[rhs_index + <span class="tok-number">1</span>];
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u32</span>, lhs_key, ctx.builder.attributes_extra.items[start..end]);
        }
    };
    <span class="tok-kw">const</span> gop = self.attributes_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        self.attributes_extra.appendSliceAssumeCapacity(data);
        self.attributes_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.attributes_extra.items.len));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bigIntConstAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> type_item = self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(ty)];
    <a href="std.debug.html#std.debug.assert">assert</a>(type_item.tag == .integer);
    <span class="tok-kw">const</span> bits = type_item.data;

    <span class="tok-kw">const</span> ExpectedContents = [<span class="tok-number">64</span> / <span class="tok-builtin">@sizeOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>;
    <span class="tok-kw">var</span> stack <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(ExpectedContents)) =
        <a href="std.html">std</a>.<a href="std.heap.html">heap</a>.<a href="std.heap.html#std.heap.stackFallback">stackFallback</a>(<span class="tok-builtin">@sizeOf</span>(ExpectedContents), self.gpa);
    <span class="tok-kw">const</span> allocator = stack.get();

    <span class="tok-kw">var</span> limbs: []<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a> = &amp;.{};
    <span class="tok-kw">defer</span> allocator.free(limbs);
    <span class="tok-kw">const</span> canonical_value = <span class="tok-kw">if</span> (value.fitsInTwosComp(.signed, bits)) value <span class="tok-kw">else</span> canon: {
        <a href="std.debug.html#std.debug.assert">assert</a>(value.fitsInTwosComp(.unsigned, bits));
        limbs = <span class="tok-kw">try</span> allocator.alloc(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>, <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcTwosCompLimbCount">calcTwosCompLimbCount</a>(bits));
        <span class="tok-kw">var</span> temp_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(limbs, <span class="tok-number">0</span>);
        temp_value.truncate(value, .signed, bits);
        <span class="tok-kw">break</span> :canon temp_value.toConst();
    };
    <a href="std.debug.html#std.debug.assert">assert</a>(canonical_value.fitsInTwosComp(.signed, bits));

    <span class="tok-kw">const</span> ExtraPtr = *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>;
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> { tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>, limbs: []<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a> };
    <span class="tok-kw">const</span> tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (canonical_value.positive) {
        <span class="tok-null">true</span> =&gt; .positive_integer,
        <span class="tok-null">false</span> =&gt; .negative_integer,
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.<span class="tok-type">type</span>));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key.limbs));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (lhs_key.tag != ctx.builder.constant_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra: ExtraPtr =
                <span class="tok-builtin">@ptrCast</span>(ctx.builder.constant_limbs.items[rhs_data..][<span class="tok-number">0</span>..<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a>]);
            <span class="tok-kw">const</span> rhs_limbs = ctx.builder.constant_limbs
                .items[rhs_data + <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> ..][<span class="tok-number">0</span>..rhs_extra.limbs_len];
            <span class="tok-kw">return</span> lhs_key.<span class="tok-type">type</span> == rhs_extra.<span class="tok-type">type</span> <span class="tok-kw">and</span>
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>, lhs_key.limbs, rhs_limbs);
        }
    };

    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(
        Key{ .tag = tag, .<span class="tok-type">type</span> = ty, .limbs = canonical_value.limbs },
        Adapter{ .builder = self },
    );
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = <span class="tok-builtin">@intCast</span>(self.constant_limbs.items.len),
        });
        <span class="tok-kw">const</span> extra: ExtraPtr =
            <span class="tok-builtin">@ptrCast</span>(self.constant_limbs.addManyAsArrayAssumeCapacity(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a>));
        extra.* = .{ .<span class="tok-type">type</span> = ty, .limbs_len = <span class="tok-builtin">@intCast</span>(canonical_value.limbs.len) };
        self.constant_limbs.appendSliceAssumeCapacity(canonical_value.limbs);
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">halfConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f16</span>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .half, .data = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@bitCast</span>(val)) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bfloatConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f32</span>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(<span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(val)))) == <span class="tok-number">0</span>);
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .bfloat, .data = <span class="tok-builtin">@bitCast</span>(val) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">floatConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f32</span>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .float, .data = <span class="tok-builtin">@bitCast</span>(val) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">doubleConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f64</span>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <span class="tok-type">f64</span>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>.<a href="#">double</a>)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <span class="tok-type">f64</span>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (ctx.builder.constant_items.items(.tag)[rhs_index] != .double) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Double.html">Double</a>, rhs_data);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(lhs_key)) == <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, rhs_extra.hi) &lt;&lt; <span class="tok-number">32</span> | rhs_extra.lo;
        }
    };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(val, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = .double,
            .data = self.addConstantExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Double.html">Double</a>{
                .lo = <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(val))),
                .hi = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(val)) &gt;&gt; <span class="tok-number">32</span>),
            }),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">fp128ConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f128</span>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <span class="tok-type">f128</span>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>.<a href="#">fp128</a>)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <span class="tok-type">f128</span>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (ctx.builder.constant_items.items(.tag)[rhs_index] != .fp128) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, rhs_data);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-builtin">@bitCast</span>(lhs_key)) == <span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, rhs_extra.hi_hi) &lt;&lt; <span class="tok-number">96</span> |
                <span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, rhs_extra.hi_lo) &lt;&lt; <span class="tok-number">64</span> | <span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, rhs_extra.lo_hi) &lt;&lt; <span class="tok-number">32</span> | rhs_extra.lo_lo;
        }
    };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(val, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = .fp128,
            .data = self.addConstantExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>{
                .lo_lo = <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-builtin">@bitCast</span>(val))),
                .lo_hi = <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-builtin">@bitCast</span>(val)) &gt;&gt; <span class="tok-number">32</span>),
                .hi_lo = <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-builtin">@bitCast</span>(val)) &gt;&gt; <span class="tok-number">64</span>),
                .hi_hi = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u128</span>, <span class="tok-builtin">@bitCast</span>(val)) &gt;&gt; <span class="tok-number">96</span>),
            }),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">x86_fp80ConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <span class="tok-type">f80</span>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <span class="tok-type">f80</span>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>.<a href="#">x86_fp80</a>)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key)[<span class="tok-number">0</span>..<span class="tok-number">10</span>],
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <span class="tok-type">f80</span>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (ctx.builder.constant_items.items(.tag)[rhs_index] != .x86_fp80) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp80.html">Fp80</a>, rhs_data);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u80</span>, <span class="tok-builtin">@bitCast</span>(lhs_key)) == <span class="tok-builtin">@as</span>(<span class="tok-type">u80</span>, rhs_extra.hi) &lt;&lt; <span class="tok-number">64</span> |
                <span class="tok-builtin">@as</span>(<span class="tok-type">u80</span>, rhs_extra.lo_hi) &lt;&lt; <span class="tok-number">32</span> | rhs_extra.lo_lo;
        }
    };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(val, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = .x86_fp80,
            .data = self.addConstantExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp80.html">Fp80</a>{
                .lo_lo = <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u80</span>, <span class="tok-builtin">@bitCast</span>(val))),
                .lo_hi = <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u80</span>, <span class="tok-builtin">@bitCast</span>(val)) &gt;&gt; <span class="tok-number">32</span>),
                .hi = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u80</span>, <span class="tok-builtin">@bitCast</span>(val)) &gt;&gt; <span class="tok-number">64</span>),
            }),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ppc_fp128ConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>.<a href="#">ppc_fp128</a>)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: [<span class="tok-number">2</span>]<span class="tok-type">f64</span>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (ctx.builder.constant_items.items(.tag)[rhs_index] != .ppc_fp128) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, rhs_data);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(lhs_key[<span class="tok-number">0</span>])) == <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, rhs_extra.lo_hi) &lt;&lt; <span class="tok-number">32</span> | rhs_extra.lo_lo <span class="tok-kw">and</span>
                <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(lhs_key[<span class="tok-number">1</span>])) == <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, rhs_extra.hi_hi) &lt;&lt; <span class="tok-number">32</span> | rhs_extra.hi_lo;
        }
    };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(val, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = .ppc_fp128,
            .data = self.addConstantExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>{
                .lo_lo = <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(val[<span class="tok-number">0</span>]))),
                .lo_hi = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(val[<span class="tok-number">0</span>])) &gt;&gt; <span class="tok-number">32</span>),
                .hi_lo = <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(val[<span class="tok-number">1</span>]))),
                .hi_hi = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, <span class="tok-builtin">@bitCast</span>(val[<span class="tok-number">1</span>])) &gt;&gt; <span class="tok-number">32</span>),
            }),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">nullConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(ty)].tag == .pointer);
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .<span class="tok-null">null</span>, .data = <span class="tok-builtin">@intFromEnum</span>(ty) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">noneConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ty == .token);
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .none, .data = <span class="tok-builtin">@intFromEnum</span>(ty) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">structConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> type_item = self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(ty)];
    <span class="tok-kw">var</span> extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, <span class="tok-kw">switch</span> (type_item.tag) {
        .structure, .packed_structure =&gt; type_item.data,
        .named_structure =&gt; data: {
            <span class="tok-kw">const</span> body_ty = self.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, type_item.data).body;
            <span class="tok-kw">const</span> body_item = self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(body_ty)];
            <span class="tok-kw">switch</span> (body_item.tag) {
                .structure, .packed_structure =&gt; <span class="tok-kw">break</span> :data body_item.data,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            }
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    });
    <span class="tok-kw">const</span> fields = extra.trail.next(extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self);
    <span class="tok-kw">for</span> (fields, vals) |field, val| <a href="std.debug.html#std.debug.assert">assert</a>(field == val.typeOf(self));

    <span class="tok-kw">for</span> (vals) |val| {
        <span class="tok-kw">if</span> (!val.isZeroInit(self)) <span class="tok-kw">break</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> self.zeroInitConstAssumeCapacity(ty);

    <span class="tok-kw">const</span> tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (ty.unnamedTag(self)) {
        .structure =&gt; .structure,
        .packed_structure =&gt; .packed_structure,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
    <span class="tok-kw">const</span> result = self.getOrPutConstantAggregateAssumeCapacity(tag, ty, vals);
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">arrayConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> type_item = self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(ty)];
    <span class="tok-kw">const</span> type_extra: <span class="tok-kw">struct</span> { len: <span class="tok-type">u64</span>, child: <a href="std.zig.llvm.Builder.Type.html">Type</a> } = <span class="tok-kw">switch</span> (type_item.tag) {
        <span class="tok-kw">inline</span> .small_array, .array =&gt; |kind| extra: {
            <span class="tok-kw">const</span> extra = self.typeExtraData(<span class="tok-kw">switch</span> (kind) {
                .small_array =&gt; <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>,
                .array =&gt; <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Array.html">Array</a>,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            }, type_item.data);
            <span class="tok-kw">break</span> :extra .{ .len = extra.length(), .child = extra.child };
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
    <a href="std.debug.html#std.debug.assert">assert</a>(type_extra.len == vals.len);
    <span class="tok-kw">for</span> (vals) |val| <a href="std.debug.html#std.debug.assert">assert</a>(type_extra.child == val.typeOf(self));

    <span class="tok-kw">for</span> (vals) |val| {
        <span class="tok-kw">if</span> (!val.isZeroInit(self)) <span class="tok-kw">break</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> self.zeroInitConstAssumeCapacity(ty);

    <span class="tok-kw">const</span> result = self.getOrPutConstantAggregateAssumeCapacity(.array, ty, vals);
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">stringConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, val: <a href="std.zig.llvm.Builder.String.html">String</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> slice = val.slice(self).?;
    <span class="tok-kw">const</span> ty = self.arrayTypeAssumeCapacity(slice.len, .<span class="tok-type">i8</span>);
    <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.allEqual">allEqual</a>(<span class="tok-type">u8</span>, slice, <span class="tok-number">0</span>)) <span class="tok-kw">return</span> self.zeroInitConstAssumeCapacity(ty);
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .string, .data = <span class="tok-builtin">@intFromEnum</span>(val) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">vectorConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ty.isVector(self));
    <a href="std.debug.html#std.debug.assert">assert</a>(ty.vectorLen(self) == vals.len);
    <span class="tok-kw">for</span> (vals) |val| <a href="std.debug.html#std.debug.assert">assert</a>(ty.childType(self) == val.typeOf(self));

    <span class="tok-kw">for</span> (vals[<span class="tok-number">1</span>..]) |val| {
        <span class="tok-kw">if</span> (vals[<span class="tok-number">0</span>] != val) <span class="tok-kw">break</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> self.splatConstAssumeCapacity(ty, vals[<span class="tok-number">0</span>]);
    <span class="tok-kw">for</span> (vals) |val| {
        <span class="tok-kw">if</span> (!val.isZeroInit(self)) <span class="tok-kw">break</span>;
    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> self.zeroInitConstAssumeCapacity(ty);

    <span class="tok-kw">const</span> result = self.getOrPutConstantAggregateAssumeCapacity(.vector, ty, vals);
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">splatConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ty.scalarType(self) == val.typeOf(self));

    <span class="tok-kw">if</span> (!ty.isVector(self)) <span class="tok-kw">return</span> val;
    <span class="tok-kw">if</span> (val.isZeroInit(self)) <span class="tok-kw">return</span> self.zeroInitConstAssumeCapacity(ty);

    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>.<a href="#">splat</a>)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (ctx.builder.constant_items.items(.tag)[rhs_index] != .splat) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>, rhs_data);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key, rhs_extra);
        }
    };
    <span class="tok-kw">const</span> data = <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>{ .<span class="tok-type">type</span> = ty, .value = val };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = .splat,
            .data = self.addConstantExtraAssumeCapacity(data),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">zeroInitConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">switch</span> (ty) {
        <span class="tok-kw">inline</span> .half,
        .bfloat,
        .float,
        .double,
        .fp128,
        .x86_fp80,
        =&gt; |tag| <span class="tok-kw">return</span> <span class="tok-builtin">@field</span>(<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-builtin">@tagName</span>(tag) ++ <span class="tok-str">&quot;ConstAssumeCapacity&quot;</span>)(self, <span class="tok-number">0.0</span>),
        .ppc_fp128 =&gt; <span class="tok-kw">return</span> self.ppc_fp128ConstAssumeCapacity(.{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span> }),
        .token =&gt; <span class="tok-kw">return</span> .none,
        .<span class="tok-type">i1</span> =&gt; <span class="tok-kw">return</span> .<span class="tok-null">false</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">switch</span> (self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(ty)].tag) {
            .simple,
            .function,
            .vararg_function,
            =&gt; <span class="tok-kw">unreachable</span>,
            .integer =&gt; {
                <span class="tok-kw">var</span> limbs: [<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.html#std.math.big.int.calcLimbLen">calcLimbLen</a>(<span class="tok-number">0</span>)]<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">const</span> bigint = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Mutable.html">Mutable</a>.<a href="std.math.big.int.Mutable.html#std.math.big.int.Mutable.init">init</a>(&amp;limbs, <span class="tok-number">0</span>);
                <span class="tok-kw">return</span> self.bigIntConstAssumeCapacity(ty, bigint.toConst()) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
            },
            .pointer =&gt; <span class="tok-kw">return</span> self.nullConstAssumeCapacity(ty),
            .target,
            .vector,
            .scalable_vector,
            .small_array,
            .array,
            .structure,
            .packed_structure,
            .named_structure,
            =&gt; {},
        },
    }
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .zeroinitializer, .data = <span class="tok-builtin">@intFromEnum</span>(ty) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">undefConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">switch</span> (self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(ty)].tag) {
        .simple =&gt; <span class="tok-kw">switch</span> (ty) {
            .<span class="tok-type">void</span>, .label =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; {},
        },
        .function, .vararg_function =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .undef, .data = <span class="tok-builtin">@intFromEnum</span>(ty) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">poisonConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">switch</span> (self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(ty)].tag) {
        .simple =&gt; <span class="tok-kw">switch</span> (ty) {
            .<span class="tok-type">void</span>, .label =&gt; <span class="tok-kw">unreachable</span>,
            <span class="tok-kw">else</span> =&gt; {},
        },
        .function, .vararg_function =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-kw">else</span> =&gt; {},
    }
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .poison, .data = <span class="tok-builtin">@intFromEnum</span>(ty) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">blockAddrConstAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>,
    block: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>,
) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>.<a href="#">blockaddress</a>)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (ctx.builder.constant_items.items(.tag)[rhs_index] != .blockaddress) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>, rhs_data);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key, rhs_extra);
        }
    };
    <span class="tok-kw">const</span> data = <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>{ .function = function, .block = block };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = .blockaddress,
            .data = self.addConstantExtraAssumeCapacity(data),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">dsoLocalEquivalentConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .dso_local_equivalent, .data = <span class="tok-builtin">@intFromEnum</span>(function) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">noCfiConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> result = self.getOrPutConstantNoExtraAssumeCapacity(
        .{ .tag = .no_cfi, .data = <span class="tok-builtin">@intFromEnum</span>(function) },
    );
    <span class="tok-kw">return</span> result.constant;
}

<span class="tok-kw">fn</span> <span class="tok-fn">convTag</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    signedness: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>.<a href="std.zig.llvm.Builder.Constant.Cast.Signedness.html">Signedness</a>,
    val_ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Tag.html">Tag</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(val_ty != ty);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (val_ty.scalarTag(self)) {
        .simple =&gt; <span class="tok-kw">switch</span> (ty.scalarTag(self)) {
            .simple =&gt; <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(val_ty.scalarBits(self), ty.scalarBits(self))) {
                .lt =&gt; .fpext,
                .eq =&gt; <span class="tok-kw">unreachable</span>,
                .gt =&gt; .fptrunc,
            },
            .integer =&gt; <span class="tok-kw">switch</span> (signedness) {
                .unsigned =&gt; .fptoui,
                .signed =&gt; .fptosi,
                .unneeded =&gt; <span class="tok-kw">unreachable</span>,
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        },
        .integer =&gt; <span class="tok-kw">switch</span> (ty.scalarTag(self)) {
            .simple =&gt; <span class="tok-kw">switch</span> (signedness) {
                .unsigned =&gt; .uitofp,
                .signed =&gt; .sitofp,
                .unneeded =&gt; <span class="tok-kw">unreachable</span>,
            },
            .integer =&gt; <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(val_ty.scalarBits(self), ty.scalarBits(self))) {
                .lt =&gt; <span class="tok-kw">switch</span> (signedness) {
                    .unsigned =&gt; .zext,
                    .signed =&gt; .sext,
                    .unneeded =&gt; <span class="tok-kw">unreachable</span>,
                },
                .eq =&gt; <span class="tok-kw">unreachable</span>,
                .gt =&gt; .trunc,
            },
            .pointer =&gt; .inttoptr,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        },
        .pointer =&gt; <span class="tok-kw">switch</span> (ty.scalarTag(self)) {
            .integer =&gt; .ptrtoint,
            .pointer =&gt; .addrspacecast,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">convConstTag</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    val_ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(val_ty != ty);
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (val_ty.scalarTag(self)) {
        .integer =&gt; <span class="tok-kw">switch</span> (ty.scalarTag(self)) {
            .integer =&gt; <span class="tok-kw">switch</span> (<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.order">order</a>(val_ty.scalarBits(self), ty.scalarBits(self))) {
                .gt =&gt; .trunc,
                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
            },
            .pointer =&gt; .inttoptr,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        },
        .pointer =&gt; <span class="tok-kw">switch</span> (ty.scalarTag(self)) {
            .integer =&gt; .ptrtoint,
            .pointer =&gt; .addrspacecast,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        },
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">convConstAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> val_ty = val.typeOf(self);
    <span class="tok-kw">if</span> (val_ty == ty) <span class="tok-kw">return</span> val;
    <span class="tok-kw">return</span> self.castConstAssumeCapacity(self.convConstTag(val_ty, ty), val, ty);
}

<span class="tok-kw">fn</span> <span class="tok-fn">castConstAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, val: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> { tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, cast: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a> };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.cast),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (lhs_key.tag != ctx.builder.constant_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, rhs_data);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key.cast, rhs_extra);
        }
    };
    <span class="tok-kw">const</span> data = Key{ .tag = tag, .cast = .{ .val = val, .<span class="tok-type">type</span> = ty } };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addConstantExtraAssumeCapacity(data.cast),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">gepConstAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> kind: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Kind.html">Kind</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    inrange: ?<span class="tok-type">u16</span>,
    indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">const</span> tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a> = <span class="tok-kw">switch</span> (kind) {
        .normal =&gt; .getelementptr,
        .inbounds =&gt; .@&quot;getelementptr inbounds&quot;,
    };
    <span class="tok-kw">const</span> base_ty = base.typeOf(self);
    <span class="tok-kw">const</span> base_is_vector = base_ty.isVector(self);

    <span class="tok-kw">const</span> VectorInfo = <span class="tok-kw">struct</span> {
        kind: <a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Vector.html">Vector</a>.<a href="std.zig.llvm.Builder.Type.Vector.Kind.html">Kind</a>,
        len: <span class="tok-type">u32</span>,

        <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(vector_ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>, builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>) <span class="tok-builtin">@This</span>() {
            <span class="tok-kw">return</span> .{ .kind = vector_ty.vectorKind(builder), .len = vector_ty.vectorLen(builder) };
        }
    };
    <span class="tok-kw">var</span> vector_info: ?VectorInfo = <span class="tok-kw">if</span> (base_is_vector) VectorInfo.init(base_ty, self) <span class="tok-kw">else</span> <span class="tok-null">null</span>;
    <span class="tok-kw">for</span> (indices) |index| {
        <span class="tok-kw">const</span> index_ty = index.typeOf(self);
        <span class="tok-kw">switch</span> (index_ty.tag(self)) {
            .integer =&gt; {},
            .vector, .scalable_vector =&gt; {
                <span class="tok-kw">const</span> index_info = VectorInfo.init(index_ty, self);
                <span class="tok-kw">if</span> (vector_info) |info|
                    <a href="std.debug.html#std.debug.assert">assert</a>(<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(info, index_info))
                <span class="tok-kw">else</span>
                    vector_info = index_info;
            },
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
    <span class="tok-kw">if</span> (!base_is_vector) <span class="tok-kw">if</span> (vector_info) |info| <span class="tok-kw">switch</span> (info.kind) {
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |vector_kind| _ = self.vectorTypeAssumeCapacity(vector_kind, info.len, base_ty),
    };

    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> {
        <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
        base: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
        inrange: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.InRangeIndex.html">InRangeIndex</a>,
        indices: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(tag)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.<span class="tok-type">type</span>));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.base));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.inrange));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key.indices));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (ctx.builder.constant_items.items(.tag)[rhs_index] != tag) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">var</span> rhs_extra = ctx.builder.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>, rhs_data);
            <span class="tok-kw">const</span> rhs_indices =
                rhs_extra.trail.next(rhs_extra.data.info.indices_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ctx.builder);
            <span class="tok-kw">return</span> lhs_key.<span class="tok-type">type</span> == rhs_extra.data.<span class="tok-type">type</span> <span class="tok-kw">and</span> lhs_key.base == rhs_extra.data.base <span class="tok-kw">and</span>
                lhs_key.inrange == rhs_extra.data.info.inrange <span class="tok-kw">and</span>
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>, lhs_key.indices, rhs_indices);
        }
    };
    <span class="tok-kw">const</span> data = Key{
        .<span class="tok-type">type</span> = ty,
        .base = base,
        .inrange = <span class="tok-kw">if</span> (inrange) |index| <span class="tok-builtin">@enumFromInt</span>(index) <span class="tok-kw">else</span> .none,
        .indices = indices,
    };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addConstantExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>{
                .<span class="tok-type">type</span> = ty,
                .base = base,
                .info = .{ .indices_len = <span class="tok-builtin">@intCast</span>(indices.len), .inrange = data.inrange },
            }),
        });
        self.constant_extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(indices));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">binConstAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>,
    lhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
    rhs: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <span class="tok-kw">switch</span> (tag) {
        .add,
        .@&quot;add nsw&quot;,
        .@&quot;add nuw&quot;,
        .sub,
        .@&quot;sub nsw&quot;,
        .@&quot;sub nuw&quot;,
        .shl,
        .xor,
        =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> { tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, extra: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a> };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.extra),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (lhs_key.tag != ctx.builder.constant_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, rhs_data);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key.extra, rhs_extra);
        }
    };
    <span class="tok-kw">const</span> data = Key{ .tag = tag, .extra = .{ .lhs = lhs, .rhs = rhs } };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addConstantExtraAssumeCapacity(data.extra),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">asmConstAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    info: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.Info.html">Info</a>,
    assembly: <a href="std.zig.llvm.Builder.String.html">String</a>,
    constraints: <a href="std.zig.llvm.Builder.String.html">String</a>,
) <a href="std.zig.llvm.Builder.Constant.html">Constant</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(ty.functionKind(self) == .normal);

    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> { tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, extra: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a> };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.extra),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (lhs_key.tag != ctx.builder.constant_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>, rhs_data);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key.extra, rhs_extra);
        }
    };

    <span class="tok-kw">const</span> data = Key{
        .tag = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>.<a href="#"asm"">@&quot;asm&quot;</a>) + <span class="tok-builtin">@as</span>(<span class="tok-type">u4</span>, <span class="tok-builtin">@bitCast</span>(info))),
        .extra = .{ .<span class="tok-type">type</span> = ty, .assembly = assembly, .constraints = constraints },
    };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(data, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = data.tag,
            .data = self.addConstantExtraAssumeCapacity(data.extra),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedConstantCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    count: <span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> Extra: <span class="tok-type">type</span>,
    trail_len: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.constant_map.ensureUnusedCapacity(self.gpa, count);
    <span class="tok-kw">try</span> self.constant_items.ensureUnusedCapacity(self.gpa, count);
    <span class="tok-kw">try</span> self.constant_extra.ensureUnusedCapacity(
        self.gpa,
        count * (<span class="tok-builtin">@typeInfo</span>(Extra).@&quot;struct&quot;.fields.len + trail_len),
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">getOrPutConstantNoExtraAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    item: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>,
) <span class="tok-kw">struct</span> { new: <span class="tok-type">bool</span>, constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> } {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.data),
            ));
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key, ctx.builder.constant_items.get(rhs_index));
        }
    };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(item, Adapter{ .builder = self });
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(item);
    }
    <span class="tok-kw">return</span> .{ .new = !gop.found_existing, .constant = <span class="tok-builtin">@enumFromInt</span>(gop.index) };
}

<span class="tok-kw">fn</span> <span class="tok-fn">getOrPutConstantAggregateAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>,
    ty: <a href="std.zig.llvm.Builder.Type.html">Type</a>,
    vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a>,
) <span class="tok-kw">struct</span> { new: <span class="tok-type">bool</span>, constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> } {
    <span class="tok-kw">switch</span> (tag) {
        .structure, .packed_structure, .array, .vector =&gt; {},
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> { tag: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Tag.html">Tag</a>, <span class="tok-type">type</span>: <a href="std.zig.llvm.Builder.Type.html">Type</a>, vals: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Constant.html">Constant</a> };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.<span class="tok-type">type</span>));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key.vals));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (lhs_key.tag != ctx.builder.constant_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.constant_items.items(.data)[rhs_index];
            <span class="tok-kw">var</span> rhs_extra = ctx.builder.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, rhs_data);
            <span class="tok-kw">if</span> (lhs_key.<span class="tok-type">type</span> != rhs_extra.data.<span class="tok-type">type</span>) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_vals = rhs_extra.trail.next(<span class="tok-builtin">@intCast</span>(lhs_key.vals.len), <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, ctx.builder);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>, lhs_key.vals, rhs_vals);
        }
    };
    <span class="tok-kw">const</span> gop = self.constant_map.getOrPutAssumeCapacityAdapted(
        Key{ .tag = tag, .<span class="tok-type">type</span> = ty, .vals = vals },
        Adapter{ .builder = self },
    );
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.constant_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addConstantExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>{ .<span class="tok-type">type</span> = ty }),
        });
        self.constant_extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(vals));
    }
    <span class="tok-kw">return</span> .{ .new = !gop.found_existing, .constant = <span class="tok-builtin">@enumFromInt</span>(gop.index) };
}

<span class="tok-kw">fn</span> <span class="tok-fn">addConstantExtraAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, extra: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Constant.Item.html#std.zig.llvm.Builder.Constant.Item.ExtraIndex">ExtraIndex</a> {
    <span class="tok-kw">const</span> result: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Constant.Item.html#std.zig.llvm.Builder.Constant.Item.ExtraIndex">ExtraIndex</a> = <span class="tok-builtin">@intCast</span>(self.constant_extra.items.len);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields) |field| {
        <span class="tok-kw">const</span> value = <span class="tok-builtin">@field</span>(extra, field.name);
        self.constant_extra.appendAssumeCapacity(<span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
            <span class="tok-type">u32</span> =&gt; value,
            <a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
            <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Info.html">Info</a> =&gt; <span class="tok-builtin">@bitCast</span>(value),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
        });
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">const</span> ConstantExtraDataTrail = <span class="tok-kw">struct</span> {
    index: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Constant.Item.html#std.zig.llvm.Builder.Constant.Item.ExtraIndex">ExtraIndex</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">nextMut</span>(self: *<a href="std.zig.llvm.Builder.ConstantExtraDataTrail.html">ConstantExtraDataTrail</a>, len: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) []Item {
        <span class="tok-kw">const</span> items: []Item = <span class="tok-builtin">@ptrCast</span>(builder.constant_extra.items[self.index..][<span class="tok-number">0</span>..len]);
        self.index += <span class="tok-builtin">@intCast</span>(len);
        <span class="tok-kw">return</span> items;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(
        self: *<a href="std.zig.llvm.Builder.ConstantExtraDataTrail.html">ConstantExtraDataTrail</a>,
        len: <span class="tok-type">u32</span>,
        <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    ) []<span class="tok-kw">const</span> Item {
        <span class="tok-kw">const</span> items: []<span class="tok-kw">const</span> Item = <span class="tok-builtin">@ptrCast</span>(builder.constant_extra.items[self.index..][<span class="tok-number">0</span>..len]);
        self.index += <span class="tok-builtin">@intCast</span>(len);
        <span class="tok-kw">return</span> items;
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">constantExtraDataTrail</span>(
    self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    index: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Constant.Item.html#std.zig.llvm.Builder.Constant.Item.ExtraIndex">ExtraIndex</a>,
) <span class="tok-kw">struct</span> { data: T, trail: <a href="std.zig.llvm.Builder.ConstantExtraDataTrail.html">ConstantExtraDataTrail</a> } {
    <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields, self.constant_extra.items[index..][<span class="tok-number">0</span>..fields.len]) |field, value|
        <span class="tok-builtin">@field</span>(result, field.name) = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
            <span class="tok-type">u32</span> =&gt; value,
            <a href="std.zig.llvm.Builder.String.html">String</a>, <a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a>, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(value),
            <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.Info.html">Info</a> =&gt; <span class="tok-builtin">@bitCast</span>(value),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
        };
    <span class="tok-kw">return</span> .{
        .data = result,
        .trail = .{ .index = index + <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Constant.Item.html#std.zig.llvm.Builder.Constant.Item.ExtraIndex">ExtraIndex</a>, <span class="tok-builtin">@intCast</span>(fields.len)) },
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">constantExtraData</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, index: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Constant.Item.html#std.zig.llvm.Builder.Constant.Item.ExtraIndex">ExtraIndex</a>) T {
    <span class="tok-kw">return</span> self.constantExtraDataTrail(T, index).data;
}

<span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedMetadataCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    count: <span class="tok-type">usize</span>,
    <span class="tok-kw">comptime</span> Extra: <span class="tok-type">type</span>,
    trail_len: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.metadata_map.ensureUnusedCapacity(self.gpa, count);
    <span class="tok-kw">try</span> self.metadata_items.ensureUnusedCapacity(self.gpa, count);
    <span class="tok-kw">try</span> self.metadata_extra.ensureUnusedCapacity(
        self.gpa,
        count * (<span class="tok-builtin">@typeInfo</span>(Extra).@&quot;struct&quot;.fields.len + trail_len),
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">addMetadataExtraAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, extra: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a> {
    <span class="tok-kw">const</span> result: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a> = <span class="tok-builtin">@intCast</span>(self.metadata_extra.items.len);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(extra)).@&quot;struct&quot;.fields) |field| {
        <span class="tok-kw">const</span> value = <span class="tok-builtin">@field</span>(extra, field.name);
        self.metadata_extra.appendAssumeCapacity(<span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
            <span class="tok-type">u32</span> =&gt; value,
            <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, <a href="std.zig.llvm.Builder.Value.html">Value</a> =&gt; <span class="tok-builtin">@intFromEnum</span>(value),
            <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DIFlags.html">DIFlags</a> =&gt; <span class="tok-builtin">@bitCast</span>(value),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
        });
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">const</span> MetadataExtraDataTrail = <span class="tok-kw">struct</span> {
    index: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a>,

    <span class="tok-kw">fn</span> <span class="tok-fn">nextMut</span>(self: *<a href="std.zig.llvm.Builder.MetadataExtraDataTrail.html">MetadataExtraDataTrail</a>, len: <span class="tok-type">u32</span>, <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>, builder: *<a href="std.zig.llvm.Builder.html">Builder</a>) []Item {
        <span class="tok-kw">const</span> items: []Item = <span class="tok-builtin">@ptrCast</span>(builder.metadata_extra.items[self.index..][<span class="tok-number">0</span>..len]);
        self.index += <span class="tok-builtin">@intCast</span>(len);
        <span class="tok-kw">return</span> items;
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(
        self: *<a href="std.zig.llvm.Builder.MetadataExtraDataTrail.html">MetadataExtraDataTrail</a>,
        len: <span class="tok-type">u32</span>,
        <span class="tok-kw">comptime</span> Item: <span class="tok-type">type</span>,
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    ) []<span class="tok-kw">const</span> Item {
        <span class="tok-kw">const</span> items: []<span class="tok-kw">const</span> Item = <span class="tok-builtin">@ptrCast</span>(builder.metadata_extra.items[self.index..][<span class="tok-number">0</span>..len]);
        self.index += <span class="tok-builtin">@intCast</span>(len);
        <span class="tok-kw">return</span> items;
    }
};

<span class="tok-kw">fn</span> <span class="tok-fn">metadataExtraDataTrail</span>(
    self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
    <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>,
    index: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a>,
) <span class="tok-kw">struct</span> { data: T, trail: <a href="std.zig.llvm.Builder.MetadataExtraDataTrail.html">MetadataExtraDataTrail</a> } {
    <span class="tok-kw">var</span> result: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (fields, self.metadata_extra.items[index..][<span class="tok-number">0</span>..fields.len]) |field, value|
        <span class="tok-builtin">@field</span>(result, field.name) = <span class="tok-kw">switch</span> (field.<span class="tok-type">type</span>) {
            <span class="tok-type">u32</span> =&gt; value,
            <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>, <a href="std.zig.llvm.Builder.Value.html">Value</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(value),
            <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DIFlags.html">DIFlags</a> =&gt; <span class="tok-builtin">@bitCast</span>(value),
            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad field type: &quot;</span> ++ <span class="tok-builtin">@typeName</span>(field.<span class="tok-type">type</span>)),
        };
    <span class="tok-kw">return</span> .{
        .data = result,
        .trail = .{ .index = index + <span class="tok-builtin">@as</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a>, <span class="tok-builtin">@intCast</span>(fields.len)) },
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">metadataExtraData</span>(self: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, index: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html">Item</a>.<a href="std.zig.llvm.Builder.Metadata.Item.html#std.zig.llvm.Builder.Metadata.Item.ExtraIndex">ExtraIndex</a>) T {
    <span class="tok-kw">return</span> self.metadataExtraDataTrail(T, index).data;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">try</span> self.metadata_string_bytes.ensureUnusedCapacity(self.gpa, bytes.len);
    <span class="tok-kw">try</span> self.metadata_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.metadata_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);

    <span class="tok-kw">const</span> gop = self.metadata_string_map.getOrPutAssumeCapacityAdapted(
        bytes,
        <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>.<a href="std.zig.llvm.Builder.MetadataString.Adapter.html">Adapter</a>{ .builder = self },
    );
    <span class="tok-kw">if</span> (!gop.found_existing) {
        self.metadata_string_bytes.appendSliceAssumeCapacity(bytes);
        self.metadata_string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.metadata_string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFromStrtabString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, str: <a href="std.zig.llvm.Builder.StrtabString.html">StrtabString</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">if</span> (str == .none <span class="tok-kw">or</span> str == .empty) <span class="tok-kw">return</span> <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>.<a href="#">none</a>;
    <span class="tok-kw">return</span> <span class="tok-kw">try</span> self.metadataString(str.slice(self).?);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFmt</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">try</span> self.metadata_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.metadata_string_bytes.ensureUnusedCapacity(self.gpa, <span class="tok-builtin">@intCast</span>(<a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.count">count</a>(fmt_str, fmt_args)));
    <span class="tok-kw">try</span> self.metadata_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.metadataStringFmtAssumeCapacity(fmt_str, fmt_args);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataStringFmtAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, <span class="tok-kw">comptime</span> fmt_str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, fmt_args: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    self.metadata_string_bytes.writer(<span class="tok-null">undefined</span>).print(fmt_str, fmt_args) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> self.trailingMetadataStringAssumeCapacity();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingMetadataString</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">try</span> self.metadata_string_indices.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> self.metadata_string_map.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.trailingMetadataStringAssumeCapacity();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trailingMetadataStringAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> {
    <span class="tok-kw">const</span> start = self.metadata_string_indices.getLast();
    <span class="tok-kw">const</span> bytes: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = self.metadata_string_bytes.items[start..];
    <span class="tok-kw">const</span> gop = self.metadata_string_map.getOrPutAssumeCapacityAdapted(bytes, <a href="std.zig.llvm.Builder.String.html">String</a>.<a href="std.zig.llvm.Builder.String.Adapter.html">Adapter</a>{ .builder = self });
    <span class="tok-kw">if</span> (gop.found_existing) {
        self.metadata_string_bytes.shrinkRetainingCapacity(start);
    } <span class="tok-kw">else</span> {
        self.metadata_string_indices.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(self.metadata_string_bytes.items.len));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataNamed</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, operands: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.metadata_extra.ensureUnusedCapacity(self.gpa, operands.len);
    <span class="tok-kw">try</span> self.metadata_named.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    self.metadataNamedAssumeCapacity(name, operands);
}

<span class="tok-kw">fn</span> <span class="tok-fn">metadataNone</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.metadataNoneAssumeCapacity();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugFile</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    filename: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    directory: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.File.html">File</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugFileAssumeCapacity(filename, directory);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugCompileUnit</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.Options.html">Options</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugCompileUnitAssumeCapacity(file, producer, enums, globals, options);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubprogram</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    line: <span class="tok-type">u32</span>,
    scope_line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.Options.html">Options</a>,
    compile_unit: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugSubprogramAssumeCapacity(
        file,
        name,
        linkage_name,
        line,
        scope_line,
        ty,
        options,
        compile_unit,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLexicalBlock</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, column: <span class="tok-type">u32</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LexicalBlock.html">LexicalBlock</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugLexicalBlockAssumeCapacity(scope, file, line, column);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLocation</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, line: <span class="tok-type">u32</span>, column: <span class="tok-type">u32</span>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, inlined_at: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Location.html">Location</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugLocationAssumeCapacity(line, column, scope, inlined_at);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugBoolType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugBoolTypeAssumeCapacity(name, size_in_bits);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugUnsignedType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugUnsignedTypeAssumeCapacity(name, size_in_bits);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSignedType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugSignedTypeAssumeCapacity(name, size_in_bits);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugFloatType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugFloatTypeAssumeCapacity(name, size_in_bits);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugForwardReference</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.metadata_forward_references.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span>);
    <span class="tok-kw">return</span> self.debugForwardReferenceAssumeCapacity();
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugStructType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugStructTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugUnionType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugUnionTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugEnumerationType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugEnumerationTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugArrayType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugArrayTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugVectorType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugVectorTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugPointerType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    offset_in_bits: <span class="tok-type">u64</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugPointerTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        offset_in_bits,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugMemberType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    offset_in_bits: <span class="tok-type">u64</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugMemberTypeAssumeCapacity(
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        offset_in_bits,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubroutineType</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    types_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.SubroutineType.html">SubroutineType</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugSubroutineTypeAssumeCapacity(types_tuple);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugEnumerator</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    unsigned: <span class="tok-type">bool</span>,
    bit_width: <span class="tok-type">u32</span>,
    value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!(unsigned <span class="tok-kw">and</span> !value.positive));
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Enumerator.html">Enumerator</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> self.metadata_limbs.ensureUnusedCapacity(self.gpa, value.limbs.len);
    <span class="tok-kw">return</span> self.debugEnumeratorAssumeCapacity(name, unsigned, bit_width, value);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugSubrange</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    lower_bound: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    count: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subrange.html">Subrange</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugSubrangeAssumeCapacity(lower_bound, count);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugExpression</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    elements: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Expression.html">Expression</a>, elements.len);
    <span class="tok-kw">return</span> self.debugExpressionAssumeCapacity(elements);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataTuple</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tuple.html">Tuple</a>, elements.len);
    <span class="tok-kw">return</span> self.metadataTupleAssumeCapacity(elements);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">strTuple</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    str: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.StrTuple.html">StrTuple</a>, elements.len);
    <span class="tok-kw">return</span> self.strTupleAssumeCapacity(str, elements);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataModuleFlag</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    behavior: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    constant: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.ModuleFlag.html">ModuleFlag</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.metadataModuleFlagAssumeCapacity(behavior, name, constant);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugLocalVar</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LocalVar.html">LocalVar</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugLocalVarAssumeCapacity(name, file, scope, line, ty);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugParameter</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    arg_no: <span class="tok-type">u32</span>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Parameter.html">Parameter</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugParameterAssumeCapacity(name, file, scope, line, ty, arg_no);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugGlobalVar</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    variable: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.Options.html">Options</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugGlobalVarAssumeCapacity(
        name,
        linkage_name,
        file,
        scope,
        line,
        ty,
        variable,
        options,
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugGlobalVarExpression</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    variable: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    expression: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVarExpression.html">GlobalVarExpression</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.debugGlobalVarExpressionAssumeCapacity(variable, expression);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataConstant</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, value: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">try</span> self.ensureUnusedMetadataCapacity(<span class="tok-number">1</span>, <a href="std.zig.llvm.Builder.NoExtra.html">NoExtra</a>, <span class="tok-number">0</span>);
    <span class="tok-kw">return</span> self.metadataConstantAssumeCapacity(value);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugForwardReferenceSetType</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, fwd_ref: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(
        <span class="tok-builtin">@intFromEnum</span>(fwd_ref) &gt;= <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_forward_reference">first_forward_reference</a> <span class="tok-kw">and</span>
            <span class="tok-builtin">@intFromEnum</span>(fwd_ref) &lt;= <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a>,
    );
    <span class="tok-kw">const</span> index = <span class="tok-builtin">@intFromEnum</span>(fwd_ref) - <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_forward_reference">first_forward_reference</a>;
    self.metadata_forward_references.items[index] = ty;
}

<span class="tok-kw">fn</span> <span class="tok-fn">metadataSimpleAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>, value: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> {
        tag: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>,
        value: <span class="tok-builtin">@TypeOf</span>(value),
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)));
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.fields">fields</a>(<span class="tok-builtin">@TypeOf</span>(value))) |field| {
                hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;<span class="tok-builtin">@field</span>(key.value, field.name)));
            }
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (lhs_key.tag != ctx.builder.metadata_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.metadata_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.metadataExtraData(<span class="tok-builtin">@TypeOf</span>(value), rhs_data);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(lhs_key.value, rhs_extra);
        }
    };

    <span class="tok-kw">const</span> gop = self.metadata_map.getOrPutAssumeCapacityAdapted(
        Key{ .tag = tag, .value = value },
        Adapter{ .builder = self },
    );

    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.metadata_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addMetadataExtraAssumeCapacity(value),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">metadataDistinctAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, tag: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>, value: <span class="tok-kw">anytype</span>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> { tag: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>, index: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(
                <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)),
                <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.index),
            ));
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(_: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(lhs_key.index) == rhs_index;
        }
    };

    <span class="tok-kw">const</span> gop = self.metadata_map.getOrPutAssumeCapacityAdapted(
        Key{ .tag = tag, .index = <span class="tok-builtin">@enumFromInt</span>(self.metadata_map.count()) },
        Adapter{},
    );

    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.metadata_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addMetadataExtraAssumeCapacity(value),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">metadataNamedAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, operands: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <span class="tok-type">void</span> {
    <a href="std.debug.html#std.debug.assert">assert</a>(name != .none);
    <span class="tok-kw">const</span> extra_index: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(self.metadata_extra.items.len);
    self.metadata_extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(operands));

    <span class="tok-kw">const</span> gop = self.metadata_named.getOrPutAssumeCapacity(name);
    gop.value_ptr.* = .{
        .index = extra_index,
        .len = <span class="tok-builtin">@intCast</span>(operands.len),
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">metadataNoneAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.none, .{});
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugFileAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    filename: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    directory: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.file, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.File.html">File</a>{
        .filename = filename,
        .directory = directory,
    });
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">debugCompileUnitAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    producer: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    enums: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    globals: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.Options.html">Options</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataDistinctAssumeCapacity(
        <span class="tok-kw">if</span> (options.optimized) .@&quot;compile_unit optimized&quot; <span class="tok-kw">else</span> .compile_unit,
        <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>{
            .file = file,
            .producer = producer,
            .enums = enums,
            .globals = globals,
        },
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugSubprogramAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    line: <span class="tok-type">u32</span>,
    scope_line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.Options.html">Options</a>,
    compile_unit: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">const</span> tag: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a> = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">subprogram</a>) +
        <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@truncate</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(options.sp_flags)) &gt;&gt; <span class="tok-number">2</span>)));
    <span class="tok-kw">return</span> self.metadataDistinctAssumeCapacity(tag, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>{
        .file = file,
        .name = name,
        .linkage_name = linkage_name,
        .line = line,
        .scope_line = scope_line,
        .ty = ty,
        .di_flags = options.di_flags,
        .compile_unit = compile_unit,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugLexicalBlockAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, line: <span class="tok-type">u32</span>, column: <span class="tok-type">u32</span>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.lexical_block, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LexicalBlock.html">LexicalBlock</a>{
        .scope = scope,
        .file = file,
        .line = line,
        .column = column,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugLocationAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, line: <span class="tok-type">u32</span>, column: <span class="tok-type">u32</span>, scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, inlined_at: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.location, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Location.html">Location</a>{
        .line = line,
        .column = column,
        .scope = scope,
        .inlined_at = inlined_at,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugBoolTypeAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.basic_bool_type, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>{
        .name = name,
        .size_in_bits_lo = <span class="tok-builtin">@truncate</span>(size_in_bits),
        .size_in_bits_hi = <span class="tok-builtin">@truncate</span>(size_in_bits &gt;&gt; <span class="tok-number">32</span>),
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugUnsignedTypeAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.basic_unsigned_type, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>{
        .name = name,
        .size_in_bits_lo = <span class="tok-builtin">@truncate</span>(size_in_bits),
        .size_in_bits_hi = <span class="tok-builtin">@truncate</span>(size_in_bits &gt;&gt; <span class="tok-number">32</span>),
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugSignedTypeAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.basic_signed_type, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>{
        .name = name,
        .size_in_bits_lo = <span class="tok-builtin">@truncate</span>(size_in_bits),
        .size_in_bits_hi = <span class="tok-builtin">@truncate</span>(size_in_bits &gt;&gt; <span class="tok-number">32</span>),
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugFloatTypeAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>, size_in_bits: <span class="tok-type">u64</span>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.basic_float_type, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>{
        .name = name,
        .size_in_bits_lo = <span class="tok-builtin">@truncate</span>(size_in_bits),
        .size_in_bits_hi = <span class="tok-builtin">@truncate</span>(size_in_bits &gt;&gt; <span class="tok-number">32</span>),
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugForwardReferenceAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">const</span> index = <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_forward_reference">first_forward_reference</a> + self.metadata_forward_references.items.len;
    self.metadata_forward_references.appendAssumeCapacity(.none);
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugStructTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.debugCompositeTypeAssumeCapacity(
        .composite_struct_type,
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugUnionTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.debugCompositeTypeAssumeCapacity(
        .composite_union_type,
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugEnumerationTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.debugCompositeTypeAssumeCapacity(
        .composite_enumeration_type,
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugArrayTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.debugCompositeTypeAssumeCapacity(
        .composite_array_type,
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugVectorTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.debugCompositeTypeAssumeCapacity(
        .composite_vector_type,
        name,
        file,
        scope,
        line,
        underlying_type,
        size_in_bits,
        align_in_bits,
        fields_tuple,
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugCompositeTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    tag: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    fields_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(tag, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>{
        .name = name,
        .file = file,
        .scope = scope,
        .line = line,
        .underlying_type = underlying_type,
        .size_in_bits_lo = <span class="tok-builtin">@truncate</span>(size_in_bits),
        .size_in_bits_hi = <span class="tok-builtin">@truncate</span>(size_in_bits &gt;&gt; <span class="tok-number">32</span>),
        .align_in_bits_lo = <span class="tok-builtin">@truncate</span>(align_in_bits),
        .align_in_bits_hi = <span class="tok-builtin">@truncate</span>(align_in_bits &gt;&gt; <span class="tok-number">32</span>),
        .fields_tuple = fields_tuple,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugPointerTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    offset_in_bits: <span class="tok-type">u64</span>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.derived_pointer_type, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>{
        .name = name,
        .file = file,
        .scope = scope,
        .line = line,
        .underlying_type = underlying_type,
        .size_in_bits_lo = <span class="tok-builtin">@truncate</span>(size_in_bits),
        .size_in_bits_hi = <span class="tok-builtin">@truncate</span>(size_in_bits &gt;&gt; <span class="tok-number">32</span>),
        .align_in_bits_lo = <span class="tok-builtin">@truncate</span>(align_in_bits),
        .align_in_bits_hi = <span class="tok-builtin">@truncate</span>(align_in_bits &gt;&gt; <span class="tok-number">32</span>),
        .offset_in_bits_lo = <span class="tok-builtin">@truncate</span>(offset_in_bits),
        .offset_in_bits_hi = <span class="tok-builtin">@truncate</span>(offset_in_bits &gt;&gt; <span class="tok-number">32</span>),
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugMemberTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    underlying_type: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    size_in_bits: <span class="tok-type">u64</span>,
    align_in_bits: <span class="tok-type">u64</span>,
    offset_in_bits: <span class="tok-type">u64</span>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.derived_member_type, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>{
        .name = name,
        .file = file,
        .scope = scope,
        .line = line,
        .underlying_type = underlying_type,
        .size_in_bits_lo = <span class="tok-builtin">@truncate</span>(size_in_bits),
        .size_in_bits_hi = <span class="tok-builtin">@truncate</span>(size_in_bits &gt;&gt; <span class="tok-number">32</span>),
        .align_in_bits_lo = <span class="tok-builtin">@truncate</span>(align_in_bits),
        .align_in_bits_hi = <span class="tok-builtin">@truncate</span>(align_in_bits &gt;&gt; <span class="tok-number">32</span>),
        .offset_in_bits_lo = <span class="tok-builtin">@truncate</span>(offset_in_bits),
        .offset_in_bits_hi = <span class="tok-builtin">@truncate</span>(offset_in_bits &gt;&gt; <span class="tok-number">32</span>),
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugSubroutineTypeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    types_tuple: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.subroutine_type, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.SubroutineType.html">SubroutineType</a>{
        .types_tuple = types_tuple,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugEnumeratorAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    unsigned: <span class="tok-type">bool</span>,
    bit_width: <span class="tok-type">u32</span>,
    value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> {
        tag: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>,
        name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        bit_width: <span class="tok-type">u32</span>,
        value: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>,
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(key.tag)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.name));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key.bit_width));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key.value.limbs));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (lhs_key.tag != ctx.builder.metadata_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.metadata_items.items(.data)[rhs_index];
            <span class="tok-kw">const</span> rhs_extra = ctx.builder.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Enumerator.html">Enumerator</a>, rhs_data);
            <span class="tok-kw">const</span> limbs = ctx.builder.metadata_limbs
                .items[rhs_extra.limbs_index..][<span class="tok-number">0</span>..rhs_extra.limbs_len];
            <span class="tok-kw">const</span> rhs_value = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a>{
                .limbs = limbs,
                .positive = lhs_key.value.positive,
            };
            <span class="tok-kw">return</span> lhs_key.name == rhs_extra.name <span class="tok-kw">and</span>
                lhs_key.bit_width == rhs_extra.bit_width <span class="tok-kw">and</span>
                lhs_key.value.eql(rhs_value);
        }
    };

    <span class="tok-kw">const</span> tag: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a> = <span class="tok-kw">if</span> (unsigned)
        .enumerator_unsigned
    <span class="tok-kw">else</span> <span class="tok-kw">if</span> (value.positive)
        .enumerator_signed_positive
    <span class="tok-kw">else</span>
        .enumerator_signed_negative;

    <a href="std.debug.html#std.debug.assert">assert</a>(!(tag == .enumerator_unsigned <span class="tok-kw">and</span> !value.positive));

    <span class="tok-kw">const</span> gop = self.metadata_map.getOrPutAssumeCapacityAdapted(
        Key{
            .tag = tag,
            .name = name,
            .bit_width = bit_width,
            .value = value,
        },
        Adapter{ .builder = self },
    );

    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.metadata_items.appendAssumeCapacity(.{
            .tag = tag,
            .data = self.addMetadataExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Enumerator.html">Enumerator</a>{
                .name = name,
                .bit_width = bit_width,
                .limbs_index = <span class="tok-builtin">@intCast</span>(self.metadata_limbs.items.len),
                .limbs_len = <span class="tok-builtin">@intCast</span>(value.limbs.len),
            }),
        });
        self.metadata_limbs.appendSliceAssumeCapacity(value.limbs);
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugSubrangeAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    lower_bound: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    count: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.subrange, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subrange.html">Subrange</a>{
        .lower_bound = lower_bound,
        .count = count,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugExpressionAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    elements: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> {
        elements: []<span class="tok-kw">const</span> <span class="tok-type">u32</span>,
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">expression</a>)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key.elements));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">expression</a> != ctx.builder.metadata_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.metadata_items.items(.data)[rhs_index];
            <span class="tok-kw">var</span> rhs_extra = ctx.builder.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Expression.html">Expression</a>, rhs_data);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(
                <span class="tok-type">u32</span>,
                lhs_key.elements,
                rhs_extra.trail.next(rhs_extra.data.elements_len, <span class="tok-type">u32</span>, ctx.builder),
            );
        }
    };

    <span class="tok-kw">const</span> gop = self.metadata_map.getOrPutAssumeCapacityAdapted(
        Key{ .elements = elements },
        Adapter{ .builder = self },
    );

    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.metadata_items.appendAssumeCapacity(.{
            .tag = .expression,
            .data = self.addMetadataExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Expression.html">Expression</a>{
                .elements_len = <span class="tok-builtin">@intCast</span>(elements.len),
            }),
        });
        self.metadata_extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(elements));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">metadataTupleAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> {
        elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">tuple</a>)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key.elements));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">tuple</a> != ctx.builder.metadata_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.metadata_items.items(.data)[rhs_index];
            <span class="tok-kw">var</span> rhs_extra = ctx.builder.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tuple.html">Tuple</a>, rhs_data);
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(
                <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
                lhs_key.elements,
                rhs_extra.trail.next(rhs_extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ctx.builder),
            );
        }
    };

    <span class="tok-kw">const</span> gop = self.metadata_map.getOrPutAssumeCapacityAdapted(
        Key{ .elements = elements },
        Adapter{ .builder = self },
    );

    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.metadata_items.appendAssumeCapacity(.{
            .tag = .tuple,
            .data = self.addMetadataExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tuple.html">Tuple</a>{
                .elements_len = <span class="tok-builtin">@intCast</span>(elements.len),
            }),
        });
        self.metadata_extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(elements));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">strTupleAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    str: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">const</span> Key = <span class="tok-kw">struct</span> {
        str: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
        elements: []<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    };
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: Key) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">tuple</a>)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(key.elements));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: Key, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (.str_tuple != ctx.builder.metadata_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data = ctx.builder.metadata_items.items(.data)[rhs_index];
            <span class="tok-kw">var</span> rhs_extra = ctx.builder.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.StrTuple.html">StrTuple</a>, rhs_data);
            <span class="tok-kw">return</span> rhs_extra.data.str == lhs_key.str <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(
                <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
                lhs_key.elements,
                rhs_extra.trail.next(rhs_extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, ctx.builder),
            );
        }
    };

    <span class="tok-kw">const</span> gop = self.metadata_map.getOrPutAssumeCapacityAdapted(
        Key{ .str = str, .elements = elements },
        Adapter{ .builder = self },
    );

    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.metadata_items.appendAssumeCapacity(.{
            .tag = .str_tuple,
            .data = self.addMetadataExtraAssumeCapacity(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.StrTuple.html">StrTuple</a>{
                .str = str,
                .elements_len = <span class="tok-builtin">@intCast</span>(elements.len),
            }),
        });
        self.metadata_extra.appendSliceAssumeCapacity(<span class="tok-builtin">@ptrCast</span>(elements));
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">fn</span> <span class="tok-fn">metadataModuleFlagAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    behavior: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    constant: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.module_flag, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.ModuleFlag.html">ModuleFlag</a>{
        .behavior = behavior,
        .name = name,
        .constant = constant,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugLocalVarAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.local_var, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LocalVar.html">LocalVar</a>{
        .name = name,
        .file = file,
        .scope = scope,
        .line = line,
        .ty = ty,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugParameterAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    arg_no: <span class="tok-type">u32</span>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.parameter, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Parameter.html">Parameter</a>{
        .name = name,
        .file = file,
        .scope = scope,
        .line = line,
        .ty = ty,
        .arg_no = arg_no,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugGlobalVarAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    linkage_name: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>,
    file: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    scope: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    line: <span class="tok-type">u32</span>,
    ty: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    variable: <a href="std.zig.llvm.Builder.Variable.html">Variable</a>.<a href="std.zig.llvm.Builder.Variable.Index.html">Index</a>,
    options: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.Options.html">Options</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataDistinctAssumeCapacity(
        <span class="tok-kw">if</span> (options.local) .@&quot;global_var local&quot; <span class="tok-kw">else</span> .global_var,
        <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>{
            .name = name,
            .linkage_name = linkage_name,
            .file = file,
            .scope = scope,
            .line = line,
            .ty = ty,
            .variable = variable,
        },
    );
}

<span class="tok-kw">fn</span> <span class="tok-fn">debugGlobalVarExpressionAssumeCapacity</span>(
    self: *<a href="std.zig.llvm.Builder.html">Builder</a>,
    variable: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
    expression: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>,
) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <a href="std.debug.html#std.debug.assert">assert</a>(!self.strip);
    <span class="tok-kw">return</span> self.metadataSimpleAssumeCapacity(.global_var_expression, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVarExpression.html">GlobalVarExpression</a>{
        .variable = variable,
        .expression = expression,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">metadataConstantAssumeCapacity</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> {
    <span class="tok-kw">const</span> Adapter = <span class="tok-kw">struct</span> {
        builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(_: <span class="tok-builtin">@This</span>(), key: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span> {
            <span class="tok-kw">var</span> hasher = <span class="tok-kw">comptime</span> <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.html#std.hash.uint32">uint32</a>(<span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">constant</a>)));
            hasher.update(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key));
            <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: <span class="tok-builtin">@This</span>(), lhs_key: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, _: <span class="tok-type">void</span>, rhs_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">constant</a> != ctx.builder.metadata_items.items(.tag)[rhs_index]) <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            <span class="tok-kw">const</span> rhs_data: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> = <span class="tok-builtin">@enumFromInt</span>(ctx.builder.metadata_items.items(.data)[rhs_index]);
            <span class="tok-kw">return</span> rhs_data == lhs_key;
        }
    };

    <span class="tok-kw">const</span> gop = self.metadata_map.getOrPutAssumeCapacityAdapted(
        constant,
        Adapter{ .builder = self },
    );

    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = {};
        gop.value_ptr.* = {};
        self.metadata_items.appendAssumeCapacity(.{
            .tag = .constant,
            .data = <span class="tok-builtin">@intFromEnum</span>(constant),
        });
    }
    <span class="tok-kw">return</span> <span class="tok-builtin">@enumFromInt</span>(gop.index);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Producer = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    version: <a href="std.html">std</a>.<a href="std.SemanticVersion.html">SemanticVersion</a>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toBitcode</span>(self: *<a href="std.zig.llvm.Builder.html">Builder</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, producer: <a href="std.zig.llvm.Builder.Producer.html">Producer</a>) <a href="std.zig.llvm.bitcode_writer.html">bitcode_writer</a>.<a href="std.zig.llvm.bitcode_writer.html#std.zig.llvm.bitcode_writer.Error">Error</a>![]<span class="tok-kw">const</span> <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> BitcodeWriter = <a href="std.zig.llvm.bitcode_writer.html">bitcode_writer</a>.<a href="std.zig.llvm.bitcode_writer.html#std.zig.llvm.bitcode_writer.BitcodeWriter">BitcodeWriter</a>(&amp;.{ <a href="std.zig.llvm.Builder.Type.html">Type</a>, <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> });
    <span class="tok-kw">var</span> bitcode = BitcodeWriter.init(allocator, .{
        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, self.type_items.items.len),
        <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, <span class="tok-number">1</span> + self.function_attributes_set.count()),
    });
    <span class="tok-kw">errdefer</span> bitcode.deinit();<span class="tok-comment">

    // Write LLVM IR magic
    </span><span class="tok-kw">try</span> bitcode.writeBits(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.html#std.zig.llvm.ir.MAGIC">MAGIC</a>, <span class="tok-number">32</span>);

    <span class="tok-kw">var</span> record: <a href="std.html">std</a>.<a href="std.array_list.html#std.array_list.ArrayListUnmanaged">ArrayListUnmanaged</a>(<span class="tok-type">u64</span>) = .empty;
    <span class="tok-kw">defer</span> record.deinit(self.gpa);<span class="tok-comment">

    // IDENTIFICATION_BLOCK
    </span>{
        <span class="tok-kw">const</span> Identification = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Identification.html">Identification</a>;
        <span class="tok-kw">var</span> identification_block = <span class="tok-kw">try</span> bitcode.enterTopBlock(Identification);

        <span class="tok-kw">const</span> producer_str = <span class="tok-kw">try</span> <a href="std.html">std</a>.<a href="std.fmt.html">fmt</a>.<a href="std.fmt.html#std.fmt.allocPrint">allocPrint</a>(self.gpa, <span class="tok-str">&quot;{s} {d}.{d}.{d}&quot;</span>, .{
            producer.name,
            producer.version.major,
            producer.version.minor,
            producer.version.patch,
        });
        <span class="tok-kw">defer</span> self.gpa.free(producer_str);

        <span class="tok-kw">try</span> identification_block.writeAbbrev(Identification.Version{ .string = producer_str });
        <span class="tok-kw">try</span> identification_block.writeAbbrev(Identification.Epoch{ .epoch = <span class="tok-number">0</span> });

        <span class="tok-kw">try</span> identification_block.end();
    }<span class="tok-comment">

    // MODULE_BLOCK
    </span>{
        <span class="tok-kw">const</span> Module = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Module.html">Module</a>;
        <span class="tok-kw">var</span> module_block = <span class="tok-kw">try</span> bitcode.enterTopBlock(Module);

        <span class="tok-kw">try</span> module_block.writeAbbrev(Module.Version{});

        <span class="tok-kw">if</span> (self.target_triple.slice(self)) |triple| {
            <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                .code = <span class="tok-number">2</span>,
                .string = triple,
            });
        }

        <span class="tok-kw">if</span> (self.data_layout.slice(self)) |data_layout| {
            <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                .code = <span class="tok-number">3</span>,
                .string = data_layout,
            });
        }

        <span class="tok-kw">if</span> (self.source_filename.slice(self)) |source_filename| {
            <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                .code = <span class="tok-number">16</span>,
                .string = source_filename,
            });
        }

        <span class="tok-kw">if</span> (self.module_asm.items.len != <span class="tok-number">0</span>) {
            <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                .code = <span class="tok-number">4</span>,
                .string = self.module_asm.items,
            });
        }<span class="tok-comment">

        // TYPE_BLOCK
        </span>{
            <span class="tok-kw">var</span> type_block = <span class="tok-kw">try</span> module_block.enterSubBlock(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>, <span class="tok-null">true</span>);

            <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.NumEntry.html">NumEntry</a>{ .num = <span class="tok-builtin">@intCast</span>(self.type_items.items.len) });

            <span class="tok-kw">for</span> (self.type_items.items, <span class="tok-number">0</span>..) |item, i| {
                <span class="tok-kw">const</span> ty: <a href="std.zig.llvm.Builder.Type.html">Type</a> = <span class="tok-builtin">@enumFromInt</span>(i);

                <span class="tok-kw">switch</span> (item.tag) {
                    .simple =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Simple.html">Simple</a>{ .code = <span class="tok-builtin">@truncate</span>(item.data) }),
                    .integer =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Integer.html">Integer</a>{ .width = item.data }),
                    .structure,
                    .packed_structure,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> is_packed = <span class="tok-kw">switch</span> (kind) {
                            .structure =&gt; <span class="tok-null">false</span>,
                            .packed_structure =&gt; <span class="tok-null">true</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        };
                        <span class="tok-kw">var</span> extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, item.data);
                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.StructAnon.html">StructAnon</a>{
                            .is_packed = is_packed,
                            .types = extra.trail.next(extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self),
                        });
                    },
                    .named_structure =&gt; {
                        <span class="tok-kw">const</span> extra = self.typeExtraData(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.NamedStructure.html">NamedStructure</a>, item.data);
                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.StructName.html">StructName</a>{
                            .string = extra.id.slice(self).?,
                        });

                        <span class="tok-kw">switch</span> (extra.body) {
                            .none =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Opaque.html">Opaque</a>{}),
                            <span class="tok-kw">else</span> =&gt; {
                                <span class="tok-kw">const</span> real_struct = self.type_items.items[<span class="tok-builtin">@intFromEnum</span>(extra.body)];
                                <span class="tok-kw">const</span> is_packed: <span class="tok-type">bool</span> = <span class="tok-kw">switch</span> (real_struct.tag) {
                                    .structure =&gt; <span class="tok-null">false</span>,
                                    .packed_structure =&gt; <span class="tok-null">true</span>,
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                };

                                <span class="tok-kw">var</span> real_extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Structure.html">Structure</a>, real_struct.data);
                                <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.StructNamed.html">StructNamed</a>{
                                    .is_packed = is_packed,
                                    .types = real_extra.trail.next(real_extra.data.fields_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self),
                                });
                            },
                        }
                    },
                    .array,
                    .small_array,
                    =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Array.html">Array</a>{
                        .len = ty.aggregateLen(self),
                        .child = ty.childType(self),
                    }),
                    .vector,
                    .scalable_vector,
                    =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Vector.html">Vector</a>{
                        .len = ty.aggregateLen(self),
                        .child = ty.childType(self),
                    }),
                    .pointer =&gt; <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Pointer.html">Pointer</a>{
                        .addr_space = ty.pointerAddrSpace(self),
                    }),
                    .target =&gt; {
                        <span class="tok-kw">var</span> extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Target.html">Target</a>, item.data);
                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.StructName.html">StructName</a>{
                            .string = extra.data.name.slice(self).?,
                        });

                        <span class="tok-kw">const</span> types = extra.trail.next(extra.data.types_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self);
                        <span class="tok-kw">const</span> ints = extra.trail.next(extra.data.ints_len, <span class="tok-type">u32</span>, self);

                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Target.html">Target</a>{
                            .num_types = extra.data.types_len,
                            .types = types,
                            .ints = ints,
                        });
                    },
                    .function, .vararg_function =&gt; |kind| {
                        <span class="tok-kw">const</span> is_vararg = <span class="tok-kw">switch</span> (kind) {
                            .function =&gt; <span class="tok-null">false</span>,
                            .vararg_function =&gt; <span class="tok-null">true</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        };
                        <span class="tok-kw">var</span> extra = self.typeExtraDataTrail(<a href="std.zig.llvm.Builder.Type.html">Type</a>.<a href="std.zig.llvm.Builder.Type.Function.html">Function</a>, item.data);
                        <span class="tok-kw">try</span> type_block.writeAbbrev(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Type.html">Type</a>.<a href="std.zig.llvm.ir.Type.Function.html">Function</a>{
                            .is_vararg = is_vararg,
                            .return_type = extra.data.ret,
                            .param_types = extra.trail.next(extra.data.params_len, <a href="std.zig.llvm.Builder.Type.html">Type</a>, self),
                        });
                    },
                }
            }

            <span class="tok-kw">try</span> type_block.end();
        }

        <span class="tok-kw">var</span> attributes_set: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-kw">struct</span> {
            attributes: <a href="std.zig.llvm.Builder.Attributes.html">Attributes</a>,
            index: <span class="tok-type">u32</span>,
        }, <span class="tok-type">void</span>) = .{};
        <span class="tok-kw">defer</span> attributes_set.deinit(self.gpa);<span class="tok-comment">

        // PARAMATTR_GROUP_BLOCK
        </span>{
            <span class="tok-kw">const</span> ParamattrGroup = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.ParamattrGroup.html">ParamattrGroup</a>;

            <span class="tok-kw">var</span> paramattr_group_block = <span class="tok-kw">try</span> module_block.enterSubBlock(ParamattrGroup, <span class="tok-null">true</span>);

            <span class="tok-kw">for</span> (self.function_attributes_set.keys()) |func_attributes| {
                <span class="tok-kw">for</span> (func_attributes.slice(self), <span class="tok-number">0</span>..) |attributes, i| {
                    <span class="tok-kw">const</span> attributes_slice = attributes.slice(self);
                    <span class="tok-kw">if</span> (attributes_slice.len == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

                    <span class="tok-kw">const</span> attr_gop = <span class="tok-kw">try</span> attributes_set.getOrPut(self.gpa, .{
                        .attributes = attributes,
                        .index = <span class="tok-builtin">@intCast</span>(i),
                    });

                    <span class="tok-kw">if</span> (attr_gop.found_existing) <span class="tok-kw">continue</span>;

                    record.clearRetainingCapacity();
                    <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">2</span>);

                    record.appendAssumeCapacity(attr_gop.index);
                    record.appendAssumeCapacity(<span class="tok-kw">switch</span> (i) {
                        <span class="tok-number">0</span> =&gt; <span class="tok-number">0xffffffff</span>,
                        <span class="tok-kw">else</span> =&gt; i - <span class="tok-number">1</span>,
                    });

                    <span class="tok-kw">for</span> (attributes_slice) |attr_index| {
                        <span class="tok-kw">const</span> kind = attr_index.getKind(self);
                        <span class="tok-kw">switch</span> (attr_index.toAttribute(self)) {
                            .zeroext,
                            .signext,
                            .inreg,
                            .@&quot;noalias&quot;,
                            .nocapture,
                            .nofree,
                            .nest,
                            .returned,
                            .nonnull,
                            .swiftself,
                            .swiftasync,
                            .swifterror,
                            .immarg,
                            .noundef,
                            .allocalign,
                            .allocptr,
                            .readnone,
                            .readonly,
                            .writeonly,
                            .alwaysinline,
                            .builtin,
                            .cold,
                            .convergent,
                            .disable_sanitizer_information,
                            .fn_ret_thunk_extern,
                            .hot,
                            .inlinehint,
                            .jumptable,
                            .minsize,
                            .naked,
                            .nobuiltin,
                            .nocallback,
                            .noduplicate,
                            .noimplicitfloat,
                            .@&quot;noinline&quot;,
                            .nomerge,
                            .nonlazybind,
                            .noprofile,
                            .skipprofile,
                            .noredzone,
                            .<span class="tok-type">noreturn</span>,
                            .norecurse,
                            .willreturn,
                            .nosync,
                            .nounwind,
                            .nosanitize_bounds,
                            .nosanitize_coverage,
                            .null_pointer_is_valid,
                            .optforfuzzing,
                            .optnone,
                            .optsize,
                            .returns_twice,
                            .safestack,
                            .sanitize_address,
                            .sanitize_memory,
                            .sanitize_thread,
                            .sanitize_hwaddress,
                            .sanitize_memtag,
                            .speculative_load_hardening,
                            .speculatable,
                            .ssp,
                            .sspstrong,
                            .sspreq,
                            .strictfp,
                            .nocf_check,
                            .shadowcallstack,
                            .mustprogress,
                            .no_sanitize_address,
                            .no_sanitize_hwaddress,
                            .sanitize_address_dyninit,
                            =&gt; {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">2</span>);
                                record.appendAssumeCapacity(<span class="tok-number">0</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                            },
                            .byval,
                            .byref,
                            .preallocated,
                            .inalloca,
                            .sret,
                            .elementtype,
                            =&gt; |ty| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">6</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(ty));
                            },
                            .@&quot;align&quot;,
                            .alignstack,
                            =&gt; |alignment| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(alignment.toByteUnits() <span class="tok-kw">orelse</span> <span class="tok-number">0</span>);
                            },
                            .dereferenceable,
                            .dereferenceable_or_null,
                            =&gt; |size| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(size);
                            },
                            .nofpclass =&gt; |fpclass| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(fpclass)));
                            },
                            .allockind =&gt; |allockind| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(allockind)));
                            },

                            .allocsize =&gt; |allocsize| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@bitCast</span>(allocsize.toLlvm()));
                            },
                            .memory =&gt; |memory| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(memory)));
                            },
                            .uwtable =&gt; |uwtable| <span class="tok-kw">if</span> (uwtable != .none) {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(uwtable));
                            },
                            .vscale_range =&gt; |vscale_range| {
                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span>);
                                record.appendAssumeCapacity(<span class="tok-number">1</span>);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(kind));
                                record.appendAssumeCapacity(<span class="tok-builtin">@bitCast</span>(vscale_range.toLlvm()));
                            },
                            .string =&gt; |string_attr| {
                                <span class="tok-kw">const</span> string_attr_kind_slice = string_attr.kind.slice(self).?;
                                <span class="tok-kw">const</span> string_attr_value_slice = <span class="tok-kw">if</span> (string_attr.value != .none)
                                    string_attr.value.slice(self).?
                                <span class="tok-kw">else</span>
                                    <span class="tok-null">null</span>;

                                <span class="tok-kw">try</span> record.ensureUnusedCapacity(
                                    self.gpa,
                                    <span class="tok-number">2</span> + string_attr_kind_slice.len + <span class="tok-kw">if</span> (string_attr_value_slice) |slice| slice.len + <span class="tok-number">1</span> <span class="tok-kw">else</span> <span class="tok-number">0</span>,
                                );
                                record.appendAssumeCapacity(<span class="tok-kw">if</span> (string_attr.value == .none) <span class="tok-number">3</span> <span class="tok-kw">else</span> <span class="tok-number">4</span>);
                                <span class="tok-kw">for</span> (string_attr.kind.slice(self).?) |c| {
                                    record.appendAssumeCapacity(c);
                                }
                                record.appendAssumeCapacity(<span class="tok-number">0</span>);
                                <span class="tok-kw">if</span> (string_attr_value_slice) |slice| {
                                    <span class="tok-kw">for</span> (slice) |c| {
                                        record.appendAssumeCapacity(c);
                                    }
                                    record.appendAssumeCapacity(<span class="tok-number">0</span>);
                                }
                            },
                            .none =&gt; <span class="tok-kw">unreachable</span>,
                        }
                    }

                    <span class="tok-kw">try</span> paramattr_group_block.writeUnabbrev(<span class="tok-number">3</span>, record.items);
                }
            }

            <span class="tok-kw">try</span> paramattr_group_block.end();
        }<span class="tok-comment">

        // PARAMATTR_BLOCK
        </span>{
            <span class="tok-kw">const</span> Paramattr = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Paramattr.html">Paramattr</a>;
            <span class="tok-kw">var</span> paramattr_block = <span class="tok-kw">try</span> module_block.enterSubBlock(Paramattr, <span class="tok-null">true</span>);

            <span class="tok-kw">for</span> (self.function_attributes_set.keys()) |func_attributes| {
                <span class="tok-kw">const</span> func_attributes_slice = func_attributes.slice(self);
                record.clearRetainingCapacity();
                <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, func_attributes_slice.len);
                <span class="tok-kw">for</span> (func_attributes_slice, <span class="tok-number">0</span>..) |attributes, i| {
                    <span class="tok-kw">const</span> attributes_slice = attributes.slice(self);
                    <span class="tok-kw">if</span> (attributes_slice.len == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

                    <span class="tok-kw">const</span> group_index = attributes_set.getIndex(.{
                        .attributes = attributes,
                        .index = <span class="tok-builtin">@intCast</span>(i),
                    }).?;
                    record.appendAssumeCapacity(<span class="tok-builtin">@intCast</span>(group_index));
                }

                <span class="tok-kw">try</span> paramattr_block.writeAbbrev(Paramattr.Entry{ .group_indices = record.items });
            }

            <span class="tok-kw">try</span> paramattr_block.end();
        }

        <span class="tok-kw">var</span> globals: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, <span class="tok-type">void</span>) = .empty;
        <span class="tok-kw">defer</span> globals.deinit(self.gpa);
        <span class="tok-kw">try</span> globals.ensureUnusedCapacity(
            self.gpa,
            self.variables.items.len +
                self.functions.items.len +
                self.aliases.items.len,
        );

        <span class="tok-kw">for</span> (self.variables.items) |variable| {
            <span class="tok-kw">if</span> (variable.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

            globals.putAssumeCapacity(variable.global, {});
        }

        <span class="tok-kw">for</span> (self.functions.items) |function| {
            <span class="tok-kw">if</span> (function.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

            globals.putAssumeCapacity(function.global, {});
        }

        <span class="tok-kw">for</span> (self.aliases.items) |alias| {
            <span class="tok-kw">if</span> (alias.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

            globals.putAssumeCapacity(alias.global, {});
        }

        <span class="tok-kw">const</span> ConstantAdapter = <span class="tok-kw">struct</span> {
            <span class="tok-kw">const</span> ConstantAdapter = <span class="tok-builtin">@This</span>();
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
            globals: *<span class="tok-kw">const</span> <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.Global.html">Global</a>.<a href="std.zig.llvm.Builder.Global.Index.html">Index</a>, <span class="tok-type">void</span>),

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), param: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(param) {
                _ = field_name;
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@TypeOf</span>(param)) {
                    <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getConstantIndex(param)),
                    <span class="tok-kw">else</span> =&gt; param,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getConstantIndex</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>, constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (constant.unwrap()) {
                    .constant =&gt; |c| c + adapter.numGlobals(),
                    .global =&gt; |global| <span class="tok-builtin">@intCast</span>(adapter.globals.getIndex(global.unwrap(adapter.builder)).?),
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">numConstants</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.globals.count() + adapter.builder.constant_items.len);
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">numGlobals</span>(adapter: <a href="std.zig.llvm.Builder.html#std.zig.llvm.Builder.toBitcode">ConstantAdapter</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.globals.count());
            }
        };

        <span class="tok-kw">const</span> constant_adapter = ConstantAdapter{
            .builder = self,
            .globals = &amp;globals,
        };<span class="tok-comment">

        // Globals
        </span>{
            <span class="tok-kw">var</span> section_map: <a href="std.html">std</a>.<a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<a href="std.zig.llvm.Builder.String.html">String</a>, <span class="tok-type">void</span>) = .empty;
            <span class="tok-kw">defer</span> section_map.deinit(self.gpa);
            <span class="tok-kw">try</span> section_map.ensureUnusedCapacity(self.gpa, globals.count());

            <span class="tok-kw">for</span> (self.variables.items) |variable| {
                <span class="tok-kw">if</span> (variable.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> section = blk: {
                    <span class="tok-kw">if</span> (variable.section == .none) <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
                    <span class="tok-kw">const</span> gop = section_map.getOrPutAssumeCapacity(variable.section);
                    <span class="tok-kw">if</span> (!gop.found_existing) {
                        <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                            .code = <span class="tok-number">5</span>,
                            .string = variable.section.slice(self).?,
                        });
                    }
                    <span class="tok-kw">break</span> :blk gop.index + <span class="tok-number">1</span>;
                };

                <span class="tok-kw">const</span> initid = <span class="tok-kw">if</span> (variable.init == .no_init)
                    <span class="tok-number">0</span>
                <span class="tok-kw">else</span>
                    (constant_adapter.getConstantIndex(variable.init) + <span class="tok-number">1</span>);

                <span class="tok-kw">const</span> strtab = variable.global.strtab(self);

                <span class="tok-kw">const</span> global = variable.global.ptrConst(self);
                <span class="tok-kw">try</span> module_block.writeAbbrev(Module.Variable{
                    .strtab_offset = strtab.offset,
                    .strtab_size = strtab.size,
                    .type_index = global.<span class="tok-type">type</span>,
                    .is_const = .{
                        .is_const = <span class="tok-kw">switch</span> (variable.mutability) {
                            .global =&gt; <span class="tok-null">false</span>,
                            .constant =&gt; <span class="tok-null">true</span>,
                        },
                        .addr_space = global.addr_space,
                    },
                    .initid = initid,
                    .linkage = global.linkage,
                    .alignment = variable.alignment.toLlvm(),
                    .section = section,
                    .visibility = global.visibility,
                    .thread_local = variable.thread_local,
                    .unnamed_addr = global.unnamed_addr,
                    .externally_initialized = global.externally_initialized,
                    .dllstorageclass = global.dll_storage_class,
                    .preemption = global.preemption,
                });
            }

            <span class="tok-kw">for</span> (self.functions.items) |func| {
                <span class="tok-kw">if</span> (func.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> section = blk: {
                    <span class="tok-kw">if</span> (func.section == .none) <span class="tok-kw">break</span> :blk <span class="tok-number">0</span>;
                    <span class="tok-kw">const</span> gop = section_map.getOrPutAssumeCapacity(func.section);
                    <span class="tok-kw">if</span> (!gop.found_existing) {
                        <span class="tok-kw">try</span> module_block.writeAbbrev(Module.String{
                            .code = <span class="tok-number">5</span>,
                            .string = func.section.slice(self).?,
                        });
                    }
                    <span class="tok-kw">break</span> :blk gop.index + <span class="tok-number">1</span>;
                };

                <span class="tok-kw">const</span> paramattr_index = <span class="tok-kw">if</span> (self.function_attributes_set.getIndex(func.attributes)) |index|
                    index + <span class="tok-number">1</span>
                <span class="tok-kw">else</span>
                    <span class="tok-number">0</span>;

                <span class="tok-kw">const</span> strtab = func.global.strtab(self);

                <span class="tok-kw">const</span> global = func.global.ptrConst(self);
                <span class="tok-kw">try</span> module_block.writeAbbrev(Module.Function{
                    .strtab_offset = strtab.offset,
                    .strtab_size = strtab.size,
                    .type_index = global.<span class="tok-type">type</span>,
                    .call_conv = func.call_conv,
                    .is_proto = func.instructions.len == <span class="tok-number">0</span>,
                    .linkage = global.linkage,
                    .paramattr = paramattr_index,
                    .alignment = func.alignment.toLlvm(),
                    .section = section,
                    .visibility = global.visibility,
                    .unnamed_addr = global.unnamed_addr,
                    .dllstorageclass = global.dll_storage_class,
                    .preemption = global.preemption,
                    .addr_space = global.addr_space,
                });
            }

            <span class="tok-kw">for</span> (self.aliases.items) |alias| {
                <span class="tok-kw">if</span> (alias.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

                <span class="tok-kw">const</span> strtab = alias.global.strtab(self);

                <span class="tok-kw">const</span> global = alias.global.ptrConst(self);
                <span class="tok-kw">try</span> module_block.writeAbbrev(Module.Alias{
                    .strtab_offset = strtab.offset,
                    .strtab_size = strtab.size,
                    .type_index = global.<span class="tok-type">type</span>,
                    .addr_space = global.addr_space,
                    .aliasee = constant_adapter.getConstantIndex(alias.aliasee),
                    .linkage = global.linkage,
                    .visibility = global.visibility,
                    .thread_local = alias.thread_local,
                    .unnamed_addr = global.unnamed_addr,
                    .dllstorageclass = global.dll_storage_class,
                    .preemption = global.preemption,
                });
            }
        }<span class="tok-comment">

        // CONSTANTS_BLOCK
        </span>{
            <span class="tok-kw">const</span> Constants = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Constants.html">Constants</a>;
            <span class="tok-kw">var</span> constants_block = <span class="tok-kw">try</span> module_block.enterSubBlock(Constants, <span class="tok-null">true</span>);

            <span class="tok-kw">var</span> current_type: <a href="std.zig.llvm.Builder.Type.html">Type</a> = .none;
            <span class="tok-kw">const</span> tags = self.constant_items.items(.tag);
            <span class="tok-kw">const</span> datas = self.constant_items.items(.data);
            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..self.constant_items.len) |index| {
                record.clearRetainingCapacity();
                <span class="tok-kw">const</span> constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> = <span class="tok-builtin">@enumFromInt</span>(index);
                <span class="tok-kw">const</span> constant_type = constant.typeOf(self);
                <span class="tok-kw">if</span> (constant_type != current_type) {
                    <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.SetType{ .type_id = constant_type });
                    current_type = constant_type;
                }
                <span class="tok-kw">const</span> data = datas[index];
                <span class="tok-kw">switch</span> (tags[index]) {
                    .<span class="tok-null">null</span>,
                    .zeroinitializer,
                    .none,
                    =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Null{}),
                    .undef =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Undef{}),
                    .poison =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Poison{}),
                    .positive_integer,
                    .negative_integer,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra: *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.html#std.math.big.Limb">Limb</a>)) <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a> =
                            <span class="tok-builtin">@ptrCast</span>(self.constant_limbs.items[data..][<span class="tok-number">0</span>..<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a>]);
                        <span class="tok-kw">const</span> bigint: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a> = .{
                            .limbs = self.constant_limbs
                                .items[data + <a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html">Integer</a>.<a href="std.zig.llvm.Builder.Constant.Integer.html#std.zig.llvm.Builder.Constant.Integer.limbs">limbs</a> ..][<span class="tok-number">0</span>..extra.limbs_len],
                            .positive = <span class="tok-kw">switch</span> (tag) {
                                .positive_integer =&gt; <span class="tok-null">true</span>,
                                .negative_integer =&gt; <span class="tok-null">false</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> bit_count = extra.<span class="tok-type">type</span>.scalarBits(self);
                        <span class="tok-kw">const</span> val: <span class="tok-type">i64</span> = <span class="tok-kw">if</span> (bit_count &lt;= <span class="tok-number">64</span>)
                            bigint.toInt(<span class="tok-type">i64</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>
                        <span class="tok-kw">else</span> <span class="tok-kw">if</span> (bigint.toInt(<span class="tok-type">u64</span>)) |val|
                            <span class="tok-builtin">@bitCast</span>(val)
                        <span class="tok-kw">else</span> |_| {
                            <span class="tok-kw">const</span> limbs = <span class="tok-kw">try</span> record.addManyAsSlice(
                                self.gpa,
                                <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">u24</span>, bit_count, <span class="tok-number">64</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
                            );
                            bigint.writeTwosComplement(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(limbs), .little);
                            <span class="tok-kw">for</span> (limbs) |*limb| {
                                <span class="tok-kw">const</span> val = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(<span class="tok-type">i64</span>, <span class="tok-builtin">@bitCast</span>(limb.*));
                                limb.* = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (val &gt;= <span class="tok-number">0</span>)
                                    val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">0</span>
                                <span class="tok-kw">else</span>
                                    -%val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">1</span>);
                            }
                            <span class="tok-kw">try</span> constants_block.writeUnabbrev(<span class="tok-number">5</span>, record.items);
                            <span class="tok-kw">continue</span>;
                        };
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Integer{
                            .value = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (val &gt;= <span class="tok-number">0</span>)
                                val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">0</span>
                            <span class="tok-kw">else</span>
                                -%val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">1</span>),
                        });
                    },
                    .half,
                    .bfloat,
                    =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Half{ .value = <span class="tok-builtin">@truncate</span>(data) }),
                    .float =&gt; <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Float{ .value = data }),
                    .double =&gt; {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Double.html">Double</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Double{
                            .value = (<span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.hi) &lt;&lt; <span class="tok-number">32</span>) | extra.lo,
                        });
                    },
                    .x86_fp80 =&gt; {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp80.html">Fp80</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Fp80{
                            .hi = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.hi) &lt;&lt; <span class="tok-number">48</span> | <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.lo_hi) &lt;&lt; <span class="tok-number">16</span> |
                                extra.lo_lo &gt;&gt; <span class="tok-number">16</span>,
                            .lo = <span class="tok-builtin">@truncate</span>(extra.lo_lo),
                        });
                    },
                    .fp128,
                    .ppc_fp128,
                    =&gt; {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Fp128.html">Fp128</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Fp128{
                            .lo = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.lo_hi) &lt;&lt; <span class="tok-number">32</span> | <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.lo_lo),
                            .hi = <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.hi_hi) &lt;&lt; <span class="tok-number">32</span> | <span class="tok-builtin">@as</span>(<span class="tok-type">u64</span>, extra.hi_lo),
                        });
                    },
                    .array,
                    .vector,
                    .structure,
                    .packed_structure,
                    =&gt; {
                        <span class="tok-kw">var</span> extra = self.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Aggregate.html">Aggregate</a>, data);
                        <span class="tok-kw">const</span> len: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(extra.data.<span class="tok-type">type</span>.aggregateLen(self));
                        <span class="tok-kw">const</span> values = extra.trail.next(len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, self);

                        <span class="tok-kw">try</span> constants_block.writeAbbrevAdapted(
                            Constants.Aggregate{ .values = values },
                            constant_adapter,
                        );
                    },
                    .splat =&gt; {
                        <span class="tok-kw">const</span> ConstantsWriter = <span class="tok-builtin">@TypeOf</span>(constants_block);
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Splat.html">Splat</a>, data);
                        <span class="tok-kw">const</span> vector_len = extra.<span class="tok-type">type</span>.vectorLen(self);
                        <span class="tok-kw">const</span> c = constant_adapter.getConstantIndex(extra.value);

                        <span class="tok-kw">try</span> bitcode.writeBits(
                            ConstantsWriter.abbrevId(Constants.Aggregate),
                            ConstantsWriter.abbrev_len,
                        );
                        <span class="tok-kw">try</span> bitcode.writeVBR(vector_len, <span class="tok-number">6</span>);
                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..vector_len) |_| {
                            <span class="tok-kw">try</span> bitcode.writeBits(c, Constants.Aggregate.ops[<span class="tok-number">1</span>].array_fixed);
                        }
                    },
                    .string =&gt; {
                        <span class="tok-kw">const</span> str: <a href="std.zig.llvm.Builder.String.html">String</a> = <span class="tok-builtin">@enumFromInt</span>(data);
                        <span class="tok-kw">if</span> (str == .none) {
                            <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.Null{});
                        } <span class="tok-kw">else</span> {
                            <span class="tok-kw">const</span> slice = str.slice(self).?;
                            <span class="tok-kw">if</span> (slice.len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> slice[slice.len - <span class="tok-number">1</span>] == <span class="tok-number">0</span>)
                                <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.CString{ .string = slice[<span class="tok-number">0</span> .. slice.len - <span class="tok-number">1</span>] })
                            <span class="tok-kw">else</span>
                                <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.String{ .string = slice });
                        }
                    },
                    .bitcast,
                    .inttoptr,
                    .ptrtoint,
                    .addrspacecast,
                    .trunc,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Cast.html">Cast</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrevAdapted(Constants.Cast{
                            .type_index = extra.<span class="tok-type">type</span>,
                            .val = extra.val,
                            .opcode = tag.toCastOpcode(),
                        }, constant_adapter);
                    },
                    .add,
                    .@&quot;add nsw&quot;,
                    .@&quot;add nuw&quot;,
                    .sub,
                    .@&quot;sub nsw&quot;,
                    .@&quot;sub nuw&quot;,
                    .shl,
                    .xor,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Binary.html">Binary</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrevAdapted(Constants.Binary{
                            .opcode = tag.toBinaryOpcode(),
                            .lhs = extra.lhs,
                            .rhs = extra.rhs,
                        }, constant_adapter);
                    },
                    .getelementptr,
                    .@&quot;getelementptr inbounds&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">var</span> extra = self.constantExtraDataTrail(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.GetElementPtr.html">GetElementPtr</a>, data);
                        <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.info.indices_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, self);
                        <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">1</span> + <span class="tok-number">2</span> + <span class="tok-number">2</span> * indices.len);

                        record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.<span class="tok-type">type</span>));

                        record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.base.typeOf(self)));
                        record.appendAssumeCapacity(constant_adapter.getConstantIndex(extra.data.base));

                        <span class="tok-kw">for</span> (indices) |i| {
                            record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(i.typeOf(self)));
                            record.appendAssumeCapacity(constant_adapter.getConstantIndex(i));
                        }

                        <span class="tok-kw">try</span> constants_block.writeUnabbrev(<span class="tok-kw">switch</span> (tag) {
                            .getelementptr =&gt; <span class="tok-number">12</span>,
                            .@&quot;getelementptr inbounds&quot; =&gt; <span class="tok-number">20</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        }, record.items);
                    },
                    .@&quot;asm&quot;,
                    .@&quot;asm sideeffect&quot;,
                    .@&quot;asm alignstack&quot;,
                    .@&quot;asm sideeffect alignstack&quot;,
                    .@&quot;asm inteldialect&quot;,
                    .@&quot;asm sideeffect inteldialect&quot;,
                    .@&quot;asm alignstack inteldialect&quot;,
                    .@&quot;asm sideeffect alignstack inteldialect&quot;,
                    .@&quot;asm unwind&quot;,
                    .@&quot;asm sideeffect unwind&quot;,
                    .@&quot;asm alignstack unwind&quot;,
                    .@&quot;asm sideeffect alignstack unwind&quot;,
                    .@&quot;asm inteldialect unwind&quot;,
                    .@&quot;asm sideeffect inteldialect unwind&quot;,
                    .@&quot;asm alignstack inteldialect unwind&quot;,
                    .@&quot;asm sideeffect alignstack inteldialect unwind&quot;,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.Assembly.html">Assembly</a>, data);

                        <span class="tok-kw">const</span> assembly_slice = extra.assembly.slice(self).?;
                        <span class="tok-kw">const</span> constraints_slice = extra.constraints.slice(self).?;

                        <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">4</span> + assembly_slice.len + constraints_slice.len);

                        record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.<span class="tok-type">type</span>));
                        record.appendAssumeCapacity(<span class="tok-kw">switch</span> (tag) {
                            .@&quot;asm&quot; =&gt; <span class="tok-number">0</span>,
                            .@&quot;asm sideeffect&quot; =&gt; <span class="tok-number">0b0001</span>,
                            .@&quot;asm sideeffect alignstack&quot; =&gt; <span class="tok-number">0b0011</span>,
                            .@&quot;asm sideeffect inteldialect&quot; =&gt; <span class="tok-number">0b0101</span>,
                            .@&quot;asm sideeffect alignstack inteldialect&quot; =&gt; <span class="tok-number">0b0111</span>,
                            .@&quot;asm sideeffect unwind&quot; =&gt; <span class="tok-number">0b1001</span>,
                            .@&quot;asm sideeffect alignstack unwind&quot; =&gt; <span class="tok-number">0b1011</span>,
                            .@&quot;asm sideeffect inteldialect unwind&quot; =&gt; <span class="tok-number">0b1101</span>,
                            .@&quot;asm sideeffect alignstack inteldialect unwind&quot; =&gt; <span class="tok-number">0b1111</span>,
                            .@&quot;asm alignstack&quot; =&gt; <span class="tok-number">0b0010</span>,
                            .@&quot;asm inteldialect&quot; =&gt; <span class="tok-number">0b0100</span>,
                            .@&quot;asm alignstack inteldialect&quot; =&gt; <span class="tok-number">0b0110</span>,
                            .@&quot;asm unwind&quot; =&gt; <span class="tok-number">0b1000</span>,
                            .@&quot;asm alignstack unwind&quot; =&gt; <span class="tok-number">0b1010</span>,
                            .@&quot;asm inteldialect unwind&quot; =&gt; <span class="tok-number">0b1100</span>,
                            .@&quot;asm alignstack inteldialect unwind&quot; =&gt; <span class="tok-number">0b1110</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                        });

                        record.appendAssumeCapacity(assembly_slice.len);
                        <span class="tok-kw">for</span> (assembly_slice) |c| record.appendAssumeCapacity(c);

                        record.appendAssumeCapacity(constraints_slice.len);
                        <span class="tok-kw">for</span> (constraints_slice) |c| record.appendAssumeCapacity(c);

                        <span class="tok-kw">try</span> constants_block.writeUnabbrev(<span class="tok-number">30</span>, record.items);
                    },
                    .blockaddress =&gt; {
                        <span class="tok-kw">const</span> extra = self.constantExtraData(<a href="std.zig.llvm.Builder.Constant.html">Constant</a>.<a href="std.zig.llvm.Builder.Constant.BlockAddress.html">BlockAddress</a>, data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.BlockAddress{
                            .type_id = extra.function.typeOf(self),
                            .function = constant_adapter.getConstantIndex(extra.function.toConst(self)),
                            .block = <span class="tok-builtin">@intFromEnum</span>(extra.block),
                        });
                    },
                    .dso_local_equivalent,
                    .no_cfi,
                    =&gt; |tag| {
                        <span class="tok-kw">const</span> function: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Index.html">Index</a> = <span class="tok-builtin">@enumFromInt</span>(data);
                        <span class="tok-kw">try</span> constants_block.writeAbbrev(Constants.DsoLocalEquivalentOrNoCfi{
                            .code = <span class="tok-kw">switch</span> (tag) {
                                .dso_local_equivalent =&gt; <span class="tok-number">27</span>,
                                .no_cfi =&gt; <span class="tok-number">29</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .type_id = function.typeOf(self),
                            .function = constant_adapter.getConstantIndex(function.toConst(self)),
                        });
                    },
                }
            }

            <span class="tok-kw">try</span> constants_block.end();
        }<span class="tok-comment">

        // METADATA_KIND_BLOCK
        </span>{
            <span class="tok-kw">const</span> MetadataKindBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataKindBlock.html">MetadataKindBlock</a>;
            <span class="tok-kw">var</span> metadata_kind_block = <span class="tok-kw">try</span> module_block.enterSubBlock(MetadataKindBlock, <span class="tok-null">true</span>);

            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FixedMetadataKind.html">FixedMetadataKind</a>).@&quot;enum&quot;.fields) |field| {<span class="tok-comment">
                // don't include `dbg` in stripped functions
                </span><span class="tok-kw">if</span> (!(self.strip <span class="tok-kw">and</span> <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, field.name, <span class="tok-str">&quot;dbg&quot;</span>))) {
                    <span class="tok-kw">try</span> metadata_kind_block.writeAbbrev(MetadataKindBlock.Kind{
                        .id = field.value,
                        .name = field.name,
                    });
                }
            }

            <span class="tok-kw">try</span> metadata_kind_block.end();
        }

        <span class="tok-kw">const</span> MetadataAdapter = <span class="tok-kw">struct</span> {
            builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
            constant_adapter: ConstantAdapter,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(
                builder: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.html">Builder</a>,
                const_adapter: ConstantAdapter,
            ) <span class="tok-builtin">@This</span>() {
                <span class="tok-kw">return</span> .{
                    .builder = builder,
                    .constant_adapter = const_adapter,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), value: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(value) {
                _ = field_name;
                <span class="tok-kw">const</span> Ty = <span class="tok-builtin">@TypeOf</span>(value);
                <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (Ty) {
                    <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getMetadataIndex(value)),
                    <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getMetadataStringIndex(value)),
                    <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.constant_adapter.getConstantIndex(value)),
                    <span class="tok-kw">else</span> =&gt; value,
                };
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMetadataIndex</span>(adapter: <span class="tok-builtin">@This</span>(), metadata: <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">if</span> (metadata == .none) <span class="tok-kw">return</span> <span class="tok-number">0</span>;
                <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(adapter.builder.metadata_string_map.count() +
                    <span class="tok-builtin">@intFromEnum</span>(metadata.unwrap(adapter.builder)) - <span class="tok-number">1</span>);
            }

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getMetadataStringIndex</span>(_: <span class="tok-builtin">@This</span>(), metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a>) <span class="tok-type">u32</span> {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intFromEnum</span>(metadata_string);
            }
        };

        <span class="tok-kw">const</span> metadata_adapter = MetadataAdapter.init(self, constant_adapter);<span class="tok-comment">

        // METADATA_BLOCK
        </span>{
            <span class="tok-kw">const</span> MetadataBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataBlock.html">MetadataBlock</a>;
            <span class="tok-kw">var</span> metadata_block = <span class="tok-kw">try</span> module_block.enterSubBlock(MetadataBlock, <span class="tok-null">true</span>);

            <span class="tok-kw">const</span> MetadataBlockWriter = <span class="tok-builtin">@TypeOf</span>(metadata_block);<span class="tok-comment">

            // Emit all MetadataStrings
            </span><span class="tok-kw">if</span> (self.metadata_string_map.count() &gt; <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> strings_offset, <span class="tok-kw">const</span> strings_size = blk: {
                    <span class="tok-kw">var</span> strings_offset: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">var</span> strings_size: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">for</span> (<span class="tok-number">1</span>..self.metadata_string_map.count()) |metadata_string_index| {
                        <span class="tok-kw">const</span> metadata_string: MetadataString = <span class="tok-builtin">@enumFromInt</span>(metadata_string_index);
                        <span class="tok-kw">const</span> slice = metadata_string.slice(self);
                        strings_offset += bitcode.bitsVBR(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)), <span class="tok-number">6</span>);
                        strings_size += <span class="tok-builtin">@intCast</span>(slice.len * <span class="tok-number">8</span>);
                    }
                    <span class="tok-kw">break</span> :blk .{
                        std.mem.alignForward(<span class="tok-type">u32</span>, strings_offset, <span class="tok-number">32</span>) / <span class="tok-number">8</span>,
                        std.mem.alignForward(<span class="tok-type">u32</span>, strings_size, <span class="tok-number">32</span>) / <span class="tok-number">8</span>,
                    };
                };

                <span class="tok-kw">try</span> bitcode.writeBits(
                    <span class="tok-kw">comptime</span> MetadataBlockWriter.abbrevId(MetadataBlock.Strings),
                    MetadataBlockWriter.abbrev_len,
                );

                <span class="tok-kw">try</span> bitcode.writeVBR(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(self.metadata_string_map.count() - <span class="tok-number">1</span>)), <span class="tok-number">6</span>);
                <span class="tok-kw">try</span> bitcode.writeVBR(strings_offset, <span class="tok-number">6</span>);

                <span class="tok-kw">try</span> bitcode.writeVBR(strings_size + strings_offset, <span class="tok-number">6</span>);

                <span class="tok-kw">try</span> bitcode.alignTo32();

                <span class="tok-kw">for</span> (<span class="tok-number">1</span>..self.metadata_string_map.count()) |metadata_string_index| {
                    <span class="tok-kw">const</span> metadata_string: <a href="std.zig.llvm.Builder.MetadataString.html">MetadataString</a> = <span class="tok-builtin">@enumFromInt</span>(metadata_string_index);
                    <span class="tok-kw">const</span> slice = metadata_string.slice(self);
                    <span class="tok-kw">try</span> bitcode.writeVBR(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)), <span class="tok-number">6</span>);
                }

                <span class="tok-kw">try</span> bitcode.writeBlob(self.metadata_string_bytes.items);
            }

            <span class="tok-kw">for</span> (
                self.metadata_items.items(.tag)[<span class="tok-number">1</span>..],
                self.metadata_items.items(.data)[<span class="tok-number">1</span>..],
            ) |tag, data| {
                record.clearRetainingCapacity();
                <span class="tok-kw">switch</span> (tag) {
                    .none =&gt; <span class="tok-kw">unreachable</span>,
                    .file =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.File.html">File</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.File{
                            .filename = extra.filename,
                            .directory = extra.directory,
                        }, metadata_adapter);
                    },
                    .compile_unit,
                    .@&quot;compile_unit optimized&quot;,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompileUnit.html">CompileUnit</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.CompileUnit{
                            .file = extra.file,
                            .producer = extra.producer,
                            .is_optimized = <span class="tok-kw">switch</span> (kind) {
                                .compile_unit =&gt; <span class="tok-null">false</span>,
                                .@&quot;compile_unit optimized&quot; =&gt; <span class="tok-null">true</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .enums = extra.enums,
                            .globals = extra.globals,
                        }, metadata_adapter);
                    },
                    .subprogram,
                    .@&quot;subprogram local&quot;,
                    .@&quot;subprogram definition&quot;,
                    .@&quot;subprogram local definition&quot;,
                    .@&quot;subprogram optimized&quot;,
                    .@&quot;subprogram optimized local&quot;,
                    .@&quot;subprogram optimized definition&quot;,
                    .@&quot;subprogram optimized local definition&quot;,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subprogram.html">Subprogram</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Subprogram{
                            .scope = extra.file,
                            .name = extra.name,
                            .linkage_name = extra.linkage_name,
                            .file = extra.file,
                            .line = extra.line,
                            .ty = extra.ty,
                            .scope_line = extra.scope_line,
                            .sp_flags = <span class="tok-builtin">@bitCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">u3</span>, <span class="tok-builtin">@intCast</span>(
                                <span class="tok-builtin">@intFromEnum</span>(kind) - <span class="tok-builtin">@intFromEnum</span>(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tag.html">Tag</a>.<a href="#">subprogram</a>),
                            ))) &lt;&lt; <span class="tok-number">2</span>),
                            .flags = extra.di_flags,
                            .compile_unit = extra.compile_unit,
                        }, metadata_adapter);
                    },
                    .lexical_block =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LexicalBlock.html">LexicalBlock</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.LexicalBlock{
                            .scope = extra.scope,
                            .file = extra.file,
                            .line = extra.line,
                            .column = extra.column,
                        }, metadata_adapter);
                    },
                    .location =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Location.html">Location</a>, data);
                        <a href="std.debug.html#std.debug.assert">assert</a>(extra.scope != .none);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Location{
                            .line = extra.line,
                            .column = extra.column,
                            .scope = metadata_adapter.getMetadataIndex(extra.scope) - <span class="tok-number">1</span>,
                            .inlined_at = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(extra.inlined_at)),
                        });
                    },
                    .basic_bool_type,
                    .basic_unsigned_type,
                    .basic_signed_type,
                    .basic_float_type,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.BasicType.html">BasicType</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.BasicType{
                            .name = extra.name,
                            .size_in_bits = extra.bitSize(),
                            .encoding = <span class="tok-kw">switch</span> (kind) {
                                .basic_bool_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.ATE.html">ATE</a>.<a href="std.dwarf.ATE.html#std.dwarf.ATE.boolean">boolean</a>,
                                .basic_unsigned_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.ATE.html">ATE</a>.<a href="std.dwarf.ATE.html#std.dwarf.ATE.unsigned">unsigned</a>,
                                .basic_signed_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.ATE.html">ATE</a>.<a href="std.dwarf.ATE.html#std.dwarf.ATE.signed">signed</a>,
                                .basic_float_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.ATE.html">ATE</a>.<a href="std.dwarf.ATE.html#std.dwarf.ATE.float">float</a>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        }, metadata_adapter);
                    },
                    .composite_struct_type,
                    .composite_union_type,
                    .composite_enumeration_type,
                    .composite_array_type,
                    .composite_vector_type,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.CompositeType.html">CompositeType</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.CompositeType{
                            .tag = <span class="tok-kw">switch</span> (kind) {
                                .composite_struct_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.structure_type">structure_type</a>,
                                .composite_union_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.union_type">union_type</a>,
                                .composite_enumeration_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.enumeration_type">enumeration_type</a>,
                                .composite_array_type, .composite_vector_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.array_type">array_type</a>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .name = extra.name,
                            .file = extra.file,
                            .line = extra.line,
                            .scope = extra.scope,
                            .underlying_type = extra.underlying_type,
                            .size_in_bits = extra.bitSize(),
                            .align_in_bits = extra.bitAlign(),
                            .flags = <span class="tok-kw">if</span> (kind == .composite_vector_type) .{ .Vector = <span class="tok-null">true</span> } <span class="tok-kw">else</span> .{},
                            .elements = extra.fields_tuple,
                        }, metadata_adapter);
                    },
                    .derived_pointer_type,
                    .derived_member_type,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.DerivedType.html">DerivedType</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.DerivedType{
                            .tag = <span class="tok-kw">switch</span> (kind) {
                                .derived_pointer_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.pointer_type">pointer_type</a>,
                                .derived_member_type =&gt; <a href="std.dwarf.html">DW</a>.<a href="std.dwarf.TAG.html">TAG</a>.<a href="std.dwarf.TAG.html#std.dwarf.TAG.member">member</a>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                            .name = extra.name,
                            .file = extra.file,
                            .line = extra.line,
                            .scope = extra.scope,
                            .underlying_type = extra.underlying_type,
                            .size_in_bits = extra.bitSize(),
                            .align_in_bits = extra.bitAlign(),
                            .offset_in_bits = extra.bitOffset(),
                        }, metadata_adapter);
                    },
                    .subroutine_type =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.SubroutineType.html">SubroutineType</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.SubroutineType{
                            .types = extra.types_tuple,
                        }, metadata_adapter);
                    },
                    .enumerator_unsigned,
                    .enumerator_signed_positive,
                    .enumerator_signed_negative,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Enumerator.html">Enumerator</a>, data);
                        <span class="tok-kw">const</span> bigint: <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.big.html">big</a>.<a href="std.math.big.int.html">int</a>.<a href="std.math.big.int.Const.html">Const</a> = .{
                            .limbs = self.metadata_limbs.items[extra.limbs_index..][<span class="tok-number">0</span>..extra.limbs_len],
                            .positive = <span class="tok-kw">switch</span> (kind) {
                                .enumerator_unsigned,
                                .enumerator_signed_positive,
                                =&gt; <span class="tok-null">true</span>,
                                .enumerator_signed_negative =&gt; <span class="tok-null">false</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> flags: MetadataBlock.Enumerator.Flags = .{
                            .unsigned = <span class="tok-kw">switch</span> (kind) {
                                .enumerator_unsigned =&gt; <span class="tok-null">true</span>,
                                .enumerator_signed_positive,
                                .enumerator_signed_negative,
                                =&gt; <span class="tok-null">false</span>,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            },
                        };
                        <span class="tok-kw">const</span> val: <span class="tok-type">i64</span> = <span class="tok-kw">if</span> (bigint.toInt(<span class="tok-type">i64</span>)) |val|
                            val
                        <span class="tok-kw">else</span> |_| <span class="tok-kw">if</span> (bigint.toInt(<span class="tok-type">u64</span>)) |val|
                            <span class="tok-builtin">@bitCast</span>(val)
                        <span class="tok-kw">else</span> |_| {
                            <span class="tok-kw">const</span> limbs_len = <a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.divCeil">divCeil</a>(<span class="tok-type">u32</span>, extra.bit_width, <span class="tok-number">64</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
                            <span class="tok-kw">try</span> record.ensureTotalCapacity(self.gpa, <span class="tok-number">3</span> + limbs_len);
                            record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(
                                <span class="tok-builtin">@typeInfo</span>(MetadataBlock.Enumerator.Flags).@&quot;struct&quot;.backing_integer.?,
                                <span class="tok-builtin">@bitCast</span>(flags),
                            ));
                            record.appendAssumeCapacity(extra.bit_width);
                            record.appendAssumeCapacity(metadata_adapter.getMetadataStringIndex(extra.name));
                            <span class="tok-kw">const</span> limbs = record.addManyAsSliceAssumeCapacity(limbs_len);
                            bigint.writeTwosComplement(<a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.sliceAsBytes">sliceAsBytes</a>(limbs), .little);
                            <span class="tok-kw">for</span> (limbs) |*limb| {
                                <span class="tok-kw">const</span> val = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.littleToNative">littleToNative</a>(<span class="tok-type">i64</span>, <span class="tok-builtin">@bitCast</span>(limb.*));
                                limb.* = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (val &gt;= <span class="tok-number">0</span>)
                                    val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">0</span>
                                <span class="tok-kw">else</span>
                                    -%val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">1</span>);
                            }
                            <span class="tok-kw">try</span> metadata_block.writeUnabbrev(<span class="tok-builtin">@intFromEnum</span>(MetadataBlock.Enumerator.id), record.items);
                            <span class="tok-kw">continue</span>;
                        };
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Enumerator{
                            .flags = flags,
                            .bit_width = extra.bit_width,
                            .name = extra.name,
                            .value = <span class="tok-builtin">@bitCast</span>(<span class="tok-kw">if</span> (val &gt;= <span class="tok-number">0</span>)
                                val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">0</span>
                            <span class="tok-kw">else</span>
                                -%val &lt;&lt; <span class="tok-number">1</span> | <span class="tok-number">1</span>),
                        }, metadata_adapter);
                    },
                    .subrange =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Subrange.html">Subrange</a>, data);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Subrange{
                            .count = extra.count,
                            .lower_bound = extra.lower_bound,
                        }, metadata_adapter);
                    },
                    .expression =&gt; {
                        <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Expression.html">Expression</a>, data);

                        <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <span class="tok-type">u32</span>, self);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Expression{
                            .elements = elements,
                        }, metadata_adapter);
                    },
                    .tuple =&gt; {
                        <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Tuple.html">Tuple</a>, data);

                        <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, self);

                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Node{
                            .elements = elements,
                        }, metadata_adapter);
                    },
                    .str_tuple =&gt; {
                        <span class="tok-kw">var</span> extra = self.metadataExtraDataTrail(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.StrTuple.html">StrTuple</a>, data);

                        <span class="tok-kw">const</span> elements = extra.trail.next(extra.data.elements_len, <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, self);

                        <span class="tok-kw">const</span> all_elems = <span class="tok-kw">try</span> self.gpa.alloc(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>, elements.len + <span class="tok-number">1</span>);
                        <span class="tok-kw">defer</span> self.gpa.free(all_elems);
                        all_elems[<span class="tok-number">0</span>] = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataStringIndex(extra.data.str));
                        <span class="tok-kw">for</span> (elements, all_elems[<span class="tok-number">1</span>..]) |elem, *out_elem| {
                            out_elem.* = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(elem));
                        }

                        <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Node{
                            .elements = all_elems,
                        });
                    },
                    .module_flag =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.ModuleFlag.html">ModuleFlag</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Node{
                            .elements = &amp;.{
                                <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(extra.behavior)),
                                <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataStringIndex(extra.name)),
                                <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(extra.constant)),
                            },
                        });
                    },
                    .local_var =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.LocalVar.html">LocalVar</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.LocalVar{
                            .scope = extra.scope,
                            .name = extra.name,
                            .file = extra.file,
                            .line = extra.line,
                            .ty = extra.ty,
                        }, metadata_adapter);
                    },
                    .parameter =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.Parameter.html">Parameter</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Parameter{
                            .scope = extra.scope,
                            .name = extra.name,
                            .file = extra.file,
                            .line = extra.line,
                            .ty = extra.ty,
                            .arg = extra.arg_no,
                        }, metadata_adapter);
                    },
                    .global_var,
                    .@&quot;global_var local&quot;,
                    =&gt; |kind| {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVar.html">GlobalVar</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.GlobalVar{
                            .scope = extra.scope,
                            .name = extra.name,
                            .linkage_name = extra.linkage_name,
                            .file = extra.file,
                            .line = extra.line,
                            .ty = extra.ty,
                            .local = kind == .@&quot;global_var local&quot;,
                        }, metadata_adapter);
                    },
                    .global_var_expression =&gt; {
                        <span class="tok-kw">const</span> extra = self.metadataExtraData(<a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.GlobalVarExpression.html">GlobalVarExpression</a>, data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.GlobalVarExpression{
                            .variable = extra.variable,
                            .expression = extra.expression,
                        }, metadata_adapter);
                    },
                    .constant =&gt; {
                        <span class="tok-kw">const</span> constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a> = <span class="tok-builtin">@enumFromInt</span>(data);
                        <span class="tok-kw">try</span> metadata_block.writeAbbrevAdapted(MetadataBlock.Constant{
                            .ty = constant.typeOf(self),
                            .constant = constant,
                        }, metadata_adapter);
                    },
                }
            }<span class="tok-comment">

            // Write named metadata
            </span><span class="tok-kw">for</span> (self.metadata_named.keys(), self.metadata_named.values()) |name, operands| {
                <span class="tok-kw">const</span> slice = name.slice(self);
                <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Name{
                    .name = slice,
                });

                <span class="tok-kw">const</span> elements = self.metadata_extra.items[operands.index..][<span class="tok-number">0</span>..operands.len];
                <span class="tok-kw">for</span> (elements) |*e| {
                    e.* = metadata_adapter.getMetadataIndex(<span class="tok-builtin">@enumFromInt</span>(e.*)) - <span class="tok-number">1</span>;
                }

                <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.NamedNode{
                    .elements = <span class="tok-builtin">@ptrCast</span>(elements),
                });
            }<span class="tok-comment">

            // Write global attached metadata
            </span>{
                <span class="tok-kw">for</span> (globals.keys()) |global| {
                    <span class="tok-kw">const</span> global_ptr = global.ptrConst(self);
                    <span class="tok-kw">if</span> (global_ptr.dbg == .none) <span class="tok-kw">continue</span>;

                    <span class="tok-kw">switch</span> (global_ptr.kind) {
                        .function =&gt; |f| <span class="tok-kw">if</span> (f.ptrConst(self).instructions.len != <span class="tok-number">0</span>) <span class="tok-kw">continue</span>,
                        <span class="tok-kw">else</span> =&gt; {},
                    }

                    <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.GlobalDeclAttachment{
                        .value = <span class="tok-builtin">@enumFromInt</span>(constant_adapter.getConstantIndex(global.toConst())),
                        .kind = .dbg,
                        .metadata = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(global_ptr.dbg) - <span class="tok-number">1</span>),
                    });
                }
            }

            <span class="tok-kw">try</span> metadata_block.end();
        }<span class="tok-comment">

        // OPERAND_BUNDLE_TAGS_BLOCK
        </span>{
            <span class="tok-kw">const</span> OperandBundleTags = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.OperandBundleTags.html">OperandBundleTags</a>;
            <span class="tok-kw">var</span> operand_bundle_tags_block = <span class="tok-kw">try</span> module_block.enterSubBlock(OperandBundleTags, <span class="tok-null">true</span>);

            <span class="tok-kw">try</span> operand_bundle_tags_block.writeAbbrev(OperandBundleTags.OperandBundleTag{
                .tag = <span class="tok-str">&quot;cold&quot;</span>,
            });

            <span class="tok-kw">try</span> operand_bundle_tags_block.end();
        }<span class="tok-comment">

        // Block info
        </span>{
            <span class="tok-kw">const</span> BlockInfo = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.BlockInfo.html">BlockInfo</a>;
            <span class="tok-kw">var</span> block_info_block = <span class="tok-kw">try</span> module_block.enterSubBlock(BlockInfo, <span class="tok-null">true</span>);

            <span class="tok-kw">try</span> block_info_block.writeUnabbrev(BlockInfo.set_block_id, &amp;.{<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionBlock.html">FunctionBlock</a>.<a href="std.zig.llvm.ir.FunctionBlock.html#std.zig.llvm.ir.FunctionBlock.id">id</a>});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionBlock.html">FunctionBlock</a>.<a href="std.zig.llvm.ir.FunctionBlock.html#std.zig.llvm.ir.FunctionBlock.abbrevs">abbrevs</a>) |abbrev| {
                <span class="tok-kw">try</span> block_info_block.defineAbbrev(&amp;abbrev.ops);
            }

            <span class="tok-kw">try</span> block_info_block.writeUnabbrev(BlockInfo.set_block_id, &amp;.{<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html">FunctionValueSymbolTable</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html#std.zig.llvm.ir.FunctionValueSymbolTable.id">id</a>});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html">FunctionValueSymbolTable</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html#std.zig.llvm.ir.FunctionValueSymbolTable.abbrevs">abbrevs</a>) |abbrev| {
                <span class="tok-kw">try</span> block_info_block.defineAbbrev(&amp;abbrev.ops);
            }

            <span class="tok-kw">try</span> block_info_block.writeUnabbrev(BlockInfo.set_block_id, &amp;.{<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html">FunctionMetadataBlock</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html#std.zig.llvm.ir.FunctionMetadataBlock.id">id</a>});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html">FunctionMetadataBlock</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html#std.zig.llvm.ir.FunctionMetadataBlock.abbrevs">abbrevs</a>) |abbrev| {
                <span class="tok-kw">try</span> block_info_block.defineAbbrev(&amp;abbrev.ops);
            }

            <span class="tok-kw">try</span> block_info_block.writeUnabbrev(BlockInfo.set_block_id, &amp;.{<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html">MetadataAttachmentBlock</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html#std.zig.llvm.ir.MetadataAttachmentBlock.id">id</a>});
            <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html">MetadataAttachmentBlock</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html#std.zig.llvm.ir.MetadataAttachmentBlock.abbrevs">abbrevs</a>) |abbrev| {
                <span class="tok-kw">try</span> block_info_block.defineAbbrev(&amp;abbrev.ops);
            }

            <span class="tok-kw">try</span> block_info_block.end();
        }<span class="tok-comment">

        // FUNCTION_BLOCKS
        </span>{
            <span class="tok-kw">const</span> FunctionAdapter = <span class="tok-kw">struct</span> {
                constant_adapter: ConstantAdapter,
                metadata_adapter: MetadataAdapter,
                func: *<span class="tok-kw">const</span> <a href="std.zig.llvm.Builder.Function.html">Function</a>,
                instruction_index: <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Index.html">Index</a>,

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(adapter: <span class="tok-builtin">@This</span>(), value: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-builtin">@TypeOf</span>(value) {
                    _ = field_name;
                    <span class="tok-kw">const</span> Ty = <span class="tok-builtin">@TypeOf</span>(value);
                    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (Ty) {
                        <a href="std.zig.llvm.Builder.Value.html">Value</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getOffsetValueIndex(value)),
                        <a href="std.zig.llvm.Builder.Constant.html">Constant</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(adapter.getOffsetConstantIndex(value)),
                        <a href="std.zig.llvm.Builder.FunctionAttributes.html">FunctionAttributes</a> =&gt; <span class="tok-builtin">@enumFromInt</span>(<span class="tok-kw">switch</span> (value) {
                            .none =&gt; <span class="tok-number">0</span>,
                            <span class="tok-kw">else</span> =&gt; <span class="tok-number">1</span> + adapter.constant_adapter.builder.function_attributes_set.getIndex(value).?,
                        }),
                        <span class="tok-kw">else</span> =&gt; value,
                    };
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getValueIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-kw">switch</span> (value.unwrap()) {
                        .instruction =&gt; |instruction| instruction.valueIndex(adapter.func) + adapter.firstInstr(),
                        .constant =&gt; |constant| adapter.constant_adapter.getConstantIndex(constant),
                        .metadata =&gt; |metadata| {
                            <span class="tok-kw">const</span> real_metadata = metadata.unwrap(adapter.metadata_adapter.builder);
                            <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromEnum</span>(real_metadata) &lt; <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a>)
                                <span class="tok-kw">return</span> adapter.metadata_adapter.getMetadataIndex(real_metadata) - <span class="tok-number">1</span>;

                            <span class="tok-kw">return</span> <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@intFromEnum</span>(metadata) -
                                <a href="std.zig.llvm.Builder.Metadata.html">Metadata</a>.<a href="std.zig.llvm.Builder.Metadata.html#std.zig.llvm.Builder.Metadata.first_local_metadata">first_local_metadata</a> +
                                adapter.metadata_adapter.builder.metadata_string_map.count() - <span class="tok-number">1</span> +
                                adapter.metadata_adapter.builder.metadata_map.count() - <span class="tok-number">1</span>);
                        },
                    });
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetValueIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> adapter.offset() -% adapter.getValueIndex(value);
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetValueSignedIndex</span>(adapter: <span class="tok-builtin">@This</span>(), value: <a href="std.zig.llvm.Builder.Value.html">Value</a>) <span class="tok-type">i32</span> {
                    <span class="tok-kw">const</span> signed_offset: <span class="tok-type">i32</span> = <span class="tok-builtin">@intCast</span>(adapter.offset());
                    <span class="tok-kw">const</span> signed_value: <span class="tok-type">i32</span> = <span class="tok-builtin">@intCast</span>(adapter.getValueIndex(value));
                    <span class="tok-kw">return</span> signed_offset - signed_value;
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOffsetConstantIndex</span>(adapter: <span class="tok-builtin">@This</span>(), constant: <a href="std.zig.llvm.Builder.Constant.html">Constant</a>) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> adapter.offset() - adapter.constant_adapter.getConstantIndex(constant);
                }

                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">offset</span>(adapter: <span class="tok-builtin">@This</span>()) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> adapter.instruction_index.valueIndex(adapter.func) + adapter.firstInstr();
                }

                <span class="tok-kw">fn</span> <span class="tok-fn">firstInstr</span>(adapter: <span class="tok-builtin">@This</span>()) <span class="tok-type">u32</span> {
                    <span class="tok-kw">return</span> adapter.constant_adapter.numConstants();
                }
            };

            <span class="tok-kw">for</span> (self.functions.items, <span class="tok-number">0</span>..) |func, func_index| {
                <span class="tok-kw">const</span> FunctionBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionBlock.html">FunctionBlock</a>;
                <span class="tok-kw">if</span> (func.global.getReplacement(self) != .none) <span class="tok-kw">continue</span>;

                <span class="tok-kw">if</span> (func.instructions.len == <span class="tok-number">0</span>) <span class="tok-kw">continue</span>;

                <span class="tok-kw">var</span> function_block = <span class="tok-kw">try</span> module_block.enterSubBlock(FunctionBlock, <span class="tok-null">false</span>);

                <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.DeclareBlocks{ .num_blocks = func.blocks.len });

                <span class="tok-kw">var</span> adapter: FunctionAdapter = .{
                    .constant_adapter = constant_adapter,
                    .metadata_adapter = metadata_adapter,
                    .func = &amp;func,
                    .instruction_index = <span class="tok-builtin">@enumFromInt</span>(<span class="tok-number">0</span>),
                };<span class="tok-comment">

                // Emit function level metadata block
                </span><span class="tok-kw">if</span> (!func.strip <span class="tok-kw">and</span> func.debug_values.len &gt; <span class="tok-number">0</span>) {
                    <span class="tok-kw">const</span> MetadataBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionMetadataBlock.html">FunctionMetadataBlock</a>;
                    <span class="tok-kw">var</span> metadata_block = <span class="tok-kw">try</span> function_block.enterSubBlock(MetadataBlock, <span class="tok-null">false</span>);

                    <span class="tok-kw">for</span> (func.debug_values) |value| {
                        <span class="tok-kw">try</span> metadata_block.writeAbbrev(MetadataBlock.Value{
                            .ty = value.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self),
                            .value = <span class="tok-builtin">@enumFromInt</span>(adapter.getValueIndex(value.toValue())),
                        });
                    }

                    <span class="tok-kw">try</span> metadata_block.end();
                }

                <span class="tok-kw">const</span> tags = func.instructions.items(.tag);
                <span class="tok-kw">const</span> datas = func.instructions.items(.data);

                <span class="tok-kw">var</span> has_location = <span class="tok-null">false</span>;

                <span class="tok-kw">var</span> block_incoming_len: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
                <span class="tok-kw">for</span> (tags, datas, <span class="tok-number">0</span>..) |tag, data, instr_index| {
                    adapter.instruction_index = <span class="tok-builtin">@enumFromInt</span>(instr_index);
                    record.clearRetainingCapacity();

                    <span class="tok-kw">switch</span> (tag) {
                        .arg =&gt; <span class="tok-kw">continue</span>,
                        .block =&gt; {
                            block_incoming_len = data;
                            <span class="tok-kw">continue</span>;
                        },
                        .@&quot;unreachable&quot; =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Unreachable{}),
                        .call,
                        .@&quot;musttail call&quot;,
                        .@&quot;notail call&quot;,
                        .@&quot;tail call&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, data);

                            <span class="tok-kw">if</span> (extra.data.info.has_op_bundle_cold) {
                                <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ColdOperandBundle{});
                            }

                            <span class="tok-kw">const</span> call_conv = extra.data.info.call_conv;
                            <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrevAdapted(FunctionBlock.Call{
                                .attributes = extra.data.attributes,
                                .call_type = <span class="tok-kw">switch</span> (kind) {
                                    .call =&gt; .{ .call_conv = call_conv },
                                    .@&quot;tail call&quot; =&gt; .{ .tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    .@&quot;musttail call&quot; =&gt; .{ .must_tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    .@&quot;notail call&quot; =&gt; .{ .no_tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                },
                                .type_id = extra.data.ty,
                                .callee = extra.data.callee,
                                .args = args,
                            }, adapter);
                        },
                        .@&quot;call fast&quot;,
                        .@&quot;musttail call fast&quot;,
                        .@&quot;notail call fast&quot;,
                        .@&quot;tail call fast&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Call.html">Call</a>, data);

                            <span class="tok-kw">if</span> (extra.data.info.has_op_bundle_cold) {
                                <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ColdOperandBundle{});
                            }

                            <span class="tok-kw">const</span> call_conv = extra.data.info.call_conv;
                            <span class="tok-kw">const</span> args = extra.trail.next(extra.data.args_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrevAdapted(FunctionBlock.CallFast{
                                .attributes = extra.data.attributes,
                                .call_type = <span class="tok-kw">switch</span> (kind) {
                                    .@&quot;call fast&quot; =&gt; .{ .call_conv = call_conv },
                                    .@&quot;tail call fast&quot; =&gt; .{ .tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    .@&quot;musttail call fast&quot; =&gt; .{ .must_tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    .@&quot;notail call fast&quot; =&gt; .{ .no_tail = <span class="tok-null">true</span>, .call_conv = call_conv },
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                },
                                .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                                .type_id = extra.data.ty,
                                .callee = extra.data.callee,
                                .args = args,
                            }, adapter);
                        },
                        .add,
                        .@&quot;and&quot;,
                        .fadd,
                        .fdiv,
                        .fmul,
                        .mul,
                        .frem,
                        .fsub,
                        .sdiv,
                        .sub,
                        .udiv,
                        .xor,
                        .shl,
                        .lshr,
                        .@&quot;or&quot;,
                        .urem,
                        .srem,
                        .ashr,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Binary{
                                .opcode = kind.toBinaryOpcode(),
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                            });
                        },
                        .@&quot;sdiv exact&quot;,
                        .@&quot;udiv exact&quot;,
                        .@&quot;lshr exact&quot;,
                        .@&quot;ashr exact&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BinaryExact{
                                .opcode = kind.toBinaryOpcode(),
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                            });
                        },
                        .@&quot;add nsw&quot;,
                        .@&quot;add nuw&quot;,
                        .@&quot;add nuw nsw&quot;,
                        .@&quot;mul nsw&quot;,
                        .@&quot;mul nuw&quot;,
                        .@&quot;mul nuw nsw&quot;,
                        .@&quot;sub nsw&quot;,
                        .@&quot;sub nuw&quot;,
                        .@&quot;sub nuw nsw&quot;,
                        .@&quot;shl nsw&quot;,
                        .@&quot;shl nuw&quot;,
                        .@&quot;shl nuw nsw&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BinaryNoWrap{
                                .opcode = kind.toBinaryOpcode(),
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .flags = <span class="tok-kw">switch</span> (kind) {
                                    .@&quot;add nsw&quot;,
                                    .@&quot;mul nsw&quot;,
                                    .@&quot;sub nsw&quot;,
                                    .@&quot;shl nsw&quot;,
                                    =&gt; .{ .no_unsigned_wrap = <span class="tok-null">false</span>, .no_signed_wrap = <span class="tok-null">true</span> },
                                    .@&quot;add nuw&quot;,
                                    .@&quot;mul nuw&quot;,
                                    .@&quot;sub nuw&quot;,
                                    .@&quot;shl nuw&quot;,
                                    =&gt; .{ .no_unsigned_wrap = <span class="tok-null">true</span>, .no_signed_wrap = <span class="tok-null">false</span> },
                                    .@&quot;add nuw nsw&quot;,
                                    .@&quot;mul nuw nsw&quot;,
                                    .@&quot;sub nuw nsw&quot;,
                                    .@&quot;shl nuw nsw&quot;,
                                    =&gt; .{ .no_unsigned_wrap = <span class="tok-null">true</span>, .no_signed_wrap = <span class="tok-null">true</span> },
                                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                                },
                            });
                        },
                        .@&quot;fadd fast&quot;,
                        .@&quot;fdiv fast&quot;,
                        .@&quot;fmul fast&quot;,
                        .@&quot;frem fast&quot;,
                        .@&quot;fsub fast&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BinaryFast{
                                .opcode = kind.toBinaryOpcode(),
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                            });
                        },
                        .alloca,
                        .@&quot;alloca inalloca&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Alloca.html">Alloca</a>, data);
                            <span class="tok-kw">const</span> alignment = extra.info.alignment.toLlvm();
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Alloca{
                                .inst_type = extra.<span class="tok-type">type</span>,
                                .len_type = extra.len.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self),
                                .len_value = adapter.getValueIndex(extra.len),
                                .flags = .{
                                    .align_lower = <span class="tok-builtin">@truncate</span>(alignment),
                                    .inalloca = kind == .@&quot;alloca inalloca&quot;,
                                    .explicit_type = <span class="tok-null">true</span>,
                                    .swift_error = <span class="tok-null">false</span>,
                                    .align_upper = <span class="tok-builtin">@truncate</span>(alignment &lt;&lt; <span class="tok-number">5</span>),
                                },
                            });
                        },
                        .bitcast,
                        .inttoptr,
                        .ptrtoint,
                        .fptosi,
                        .fptoui,
                        .sitofp,
                        .uitofp,
                        .addrspacecast,
                        .fptrunc,
                        .trunc,
                        .fpext,
                        .sext,
                        .zext,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Cast.html">Cast</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Cast{
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .type_index = extra.<span class="tok-type">type</span>,
                                .opcode = kind.toCastOpcode(),
                            });
                        },
                        .@&quot;fcmp false&quot;,
                        .@&quot;fcmp oeq&quot;,
                        .@&quot;fcmp oge&quot;,
                        .@&quot;fcmp ogt&quot;,
                        .@&quot;fcmp ole&quot;,
                        .@&quot;fcmp olt&quot;,
                        .@&quot;fcmp one&quot;,
                        .@&quot;fcmp ord&quot;,
                        .@&quot;fcmp true&quot;,
                        .@&quot;fcmp ueq&quot;,
                        .@&quot;fcmp uge&quot;,
                        .@&quot;fcmp ugt&quot;,
                        .@&quot;fcmp ule&quot;,
                        .@&quot;fcmp ult&quot;,
                        .@&quot;fcmp une&quot;,
                        .@&quot;fcmp uno&quot;,
                        .@&quot;icmp eq&quot;,
                        .@&quot;icmp ne&quot;,
                        .@&quot;icmp sge&quot;,
                        .@&quot;icmp sgt&quot;,
                        .@&quot;icmp sle&quot;,
                        .@&quot;icmp slt&quot;,
                        .@&quot;icmp uge&quot;,
                        .@&quot;icmp ugt&quot;,
                        .@&quot;icmp ule&quot;,
                        .@&quot;icmp ult&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Cmp{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .pred = kind.toCmpPredicate(),
                            });
                        },
                        .@&quot;fcmp fast false&quot;,
                        .@&quot;fcmp fast oeq&quot;,
                        .@&quot;fcmp fast oge&quot;,
                        .@&quot;fcmp fast ogt&quot;,
                        .@&quot;fcmp fast ole&quot;,
                        .@&quot;fcmp fast olt&quot;,
                        .@&quot;fcmp fast one&quot;,
                        .@&quot;fcmp fast ord&quot;,
                        .@&quot;fcmp fast true&quot;,
                        .@&quot;fcmp fast ueq&quot;,
                        .@&quot;fcmp fast uge&quot;,
                        .@&quot;fcmp fast ugt&quot;,
                        .@&quot;fcmp fast ule&quot;,
                        .@&quot;fcmp fast ult&quot;,
                        .@&quot;fcmp fast une&quot;,
                        .@&quot;fcmp fast uno&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Binary.html">Binary</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.CmpFast{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .pred = kind.toCmpPredicate(),
                                .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                            });
                        },
                        .fneg =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.FNeg{
                            .val = adapter.getOffsetValueIndex(<span class="tok-builtin">@enumFromInt</span>(data)),
                        }),
                        .@&quot;fneg fast&quot; =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.FNegFast{
                            .val = adapter.getOffsetValueIndex(<span class="tok-builtin">@enumFromInt</span>(data)),
                            .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                        }),
                        .extractvalue =&gt; {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractValue.html">ExtractValue</a>, data);
                            <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ExtractValue{
                                .val = adapter.getOffsetValueIndex(extra.data.val),
                                .indices = indices,
                            });
                        },
                        .extractelement =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ExtractElement.html">ExtractElement</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ExtractElement{
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .index = adapter.getOffsetValueIndex(extra.index),
                            });
                        },
                        .indirectbr =&gt; {
                            <span class="tok-kw">var</span> extra =
                                func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.IndirectBr.html">IndirectBr</a>, datas[instr_index]);
                            <span class="tok-kw">const</span> targets =
                                extra.trail.next(extra.data.targets_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrevAdapted(
                                FunctionBlock.IndirectBr{
                                    .ty = extra.data.addr.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self),
                                    .addr = extra.data.addr,
                                    .targets = targets,
                                },
                                adapter,
                            );
                        },
                        .insertelement =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertElement.html">InsertElement</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.InsertElement{
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .elem = adapter.getOffsetValueIndex(extra.elem),
                                .index = adapter.getOffsetValueIndex(extra.index),
                            });
                        },
                        .insertvalue =&gt; {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.InsertValue.html">InsertValue</a>, datas[instr_index]);
                            <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <span class="tok-type">u32</span>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.InsertValue{
                                .val = adapter.getOffsetValueIndex(extra.data.val),
                                .elem = adapter.getOffsetValueIndex(extra.data.elem),
                                .indices = indices,
                            });
                        },
                        .select =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Select{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .cond = adapter.getOffsetValueIndex(extra.cond),
                            });
                        },
                        .@&quot;select fast&quot; =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Select.html">Select</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.SelectFast{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .cond = adapter.getOffsetValueIndex(extra.cond),
                                .fast_math = <a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>.<a href="std.zig.llvm.Builder.FastMath.html#std.zig.llvm.Builder.FastMath.fast">fast</a>,
                            });
                        },
                        .shufflevector =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.ShuffleVector.html">ShuffleVector</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.ShuffleVector{
                                .lhs = adapter.getOffsetValueIndex(extra.lhs),
                                .rhs = adapter.getOffsetValueIndex(extra.rhs),
                                .mask = adapter.getOffsetValueIndex(extra.mask),
                            });
                        },
                        .getelementptr,
                        .@&quot;getelementptr inbounds&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.GetElementPtr.html">GetElementPtr</a>, data);
                            <span class="tok-kw">const</span> indices = extra.trail.next(extra.data.indices_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;func);
                            <span class="tok-kw">try</span> function_block.writeAbbrevAdapted(
                                FunctionBlock.GetElementPtr{
                                    .is_inbounds = kind == .@&quot;getelementptr inbounds&quot;,
                                    .type_index = extra.data.<span class="tok-type">type</span>,
                                    .base = extra.data.base,
                                    .indices = indices,
                                },
                                adapter,
                            );
                        },
                        .load =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Load{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .ty = extra.<span class="tok-type">type</span>,
                                .alignment = extra.info.alignment.toLlvm(),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                            });
                        },
                        .@&quot;load atomic&quot; =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Load.html">Load</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.LoadAtomic{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .ty = extra.<span class="tok-type">type</span>,
                                .alignment = extra.info.alignment.toLlvm(),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                                .success_ordering = extra.info.success_ordering,
                                .sync_scope = extra.info.sync_scope,
                            });
                        },
                        .store =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Store{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .alignment = extra.info.alignment.toLlvm(),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                            });
                        },
                        .@&quot;store atomic&quot; =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Store.html">Store</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.StoreAtomic{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .alignment = extra.info.alignment.toLlvm(),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                                .success_ordering = extra.info.success_ordering,
                                .sync_scope = extra.info.sync_scope,
                            });
                        },
                        .br =&gt; {
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BrUnconditional{
                                .block = data,
                            });
                        },
                        .br_cond =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.BrConditional{
                                .then_block = <span class="tok-builtin">@intFromEnum</span>(extra.then),
                                .else_block = <span class="tok-builtin">@intFromEnum</span>(extra.@&quot;else&quot;),
                                .condition = adapter.getOffsetValueIndex(extra.cond),
                            });
                        },
                        .@&quot;switch&quot; =&gt; {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, data);

                            <span class="tok-kw">try</span> record.ensureUnusedCapacity(self.gpa, <span class="tok-number">3</span> + extra.data.cases_len * <span class="tok-number">2</span>);<span class="tok-comment">

                            // Conditional type
                            </span>record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.val.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self)));<span class="tok-comment">

                            // Conditional
                            </span>record.appendAssumeCapacity(adapter.getOffsetValueIndex(extra.data.val));<span class="tok-comment">

                            // Default block
                            </span>record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.default));

                            <span class="tok-kw">const</span> vals = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Constant.html">Constant</a>, &amp;func);
                            <span class="tok-kw">const</span> blocks = extra.trail.next(extra.data.cases_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;func);
                            <span class="tok-kw">for</span> (vals, blocks) |val, block| {
                                record.appendAssumeCapacity(adapter.constant_adapter.getConstantIndex(val));
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(block));
                            }

                            <span class="tok-kw">try</span> function_block.writeUnabbrev(<span class="tok-number">12</span>, record.items);
                        },
                        .va_arg =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.VaArg.html">VaArg</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.VaArg{
                                .list_type = extra.list.typeOf(<span class="tok-builtin">@enumFromInt</span>(func_index), self),
                                .list = adapter.getOffsetValueIndex(extra.list),
                                .<span class="tok-type">type</span> = extra.<span class="tok-type">type</span>,
                            });
                        },
                        .phi,
                        .@&quot;phi fast&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">var</span> extra = func.extraDataTrail(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Phi.html">Phi</a>, data);
                            <span class="tok-kw">const</span> vals = extra.trail.next(block_incoming_len, <a href="std.zig.llvm.Builder.Value.html">Value</a>, &amp;func);
                            <span class="tok-kw">const</span> blocks = extra.trail.next(block_incoming_len, <a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Block.html">Block</a>.<a href="std.zig.llvm.Builder.WipFunction.Block.Index.html">Index</a>, &amp;func);

                            <span class="tok-kw">try</span> record.ensureUnusedCapacity(
                                self.gpa,
                                <span class="tok-number">1</span> + block_incoming_len * <span class="tok-number">2</span> + <span class="tok-builtin">@intFromBool</span>(kind == .@&quot;phi fast&quot;),
                            );

                            record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(extra.data.<span class="tok-type">type</span>));

                            <span class="tok-kw">for</span> (vals, blocks) |val, block| {
                                <span class="tok-kw">const</span> offset_value = adapter.getOffsetValueSignedIndex(val);
                                <span class="tok-kw">const</span> abs_value: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@abs</span>(offset_value));
                                <span class="tok-kw">const</span> signed_vbr = <span class="tok-kw">if</span> (offset_value &gt; <span class="tok-number">0</span>) abs_value &lt;&lt; <span class="tok-number">1</span> <span class="tok-kw">else</span> ((abs_value &lt;&lt; <span class="tok-number">1</span>) | <span class="tok-number">1</span>);
                                record.appendAssumeCapacity(signed_vbr);
                                record.appendAssumeCapacity(<span class="tok-builtin">@intFromEnum</span>(block));
                            }

                            <span class="tok-kw">if</span> (kind == .@&quot;phi fast&quot;) record.appendAssumeCapacity(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@bitCast</span>(<a href="std.zig.llvm.Builder.FastMath.html">FastMath</a>{})));

                            <span class="tok-kw">try</span> function_block.writeUnabbrev(<span class="tok-number">16</span>, record.items);
                        },
                        .ret =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Ret{
                            .val = adapter.getOffsetValueIndex(<span class="tok-builtin">@enumFromInt</span>(data)),
                        }),
                        .@&quot;ret void&quot; =&gt; <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.RetVoid{}),
                        .atomicrmw =&gt; {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.AtomicRmw.html">AtomicRmw</a>, data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.AtomicRmw{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .val = adapter.getOffsetValueIndex(extra.val),
                                .operation = extra.info.atomic_rmw_operation,
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                                .success_ordering = extra.info.success_ordering,
                                .sync_scope = extra.info.sync_scope,
                                .alignment = extra.info.alignment.toLlvm(),
                            });
                        },
                        .cmpxchg,
                        .@&quot;cmpxchg weak&quot;,
                        =&gt; |kind| {
                            <span class="tok-kw">const</span> extra = func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.CmpXchg.html">CmpXchg</a>, data);

                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.CmpXchg{
                                .ptr = adapter.getOffsetValueIndex(extra.ptr),
                                .cmp = adapter.getOffsetValueIndex(extra.cmp),
                                .new = adapter.getOffsetValueIndex(extra.new),
                                .is_volatile = extra.info.access_kind == .@&quot;volatile&quot;,
                                .success_ordering = extra.info.success_ordering,
                                .sync_scope = extra.info.sync_scope,
                                .failure_ordering = extra.info.failure_ordering,
                                .is_weak = kind == .@&quot;cmpxchg weak&quot;,
                                .alignment = extra.info.alignment.toLlvm(),
                            });
                        },
                        .fence =&gt; {
                            <span class="tok-kw">const</span> info: <a href="std.zig.llvm.Builder.MemoryAccessInfo.html">MemoryAccessInfo</a> = <span class="tok-builtin">@bitCast</span>(data);
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.Fence{
                                .ordering = info.success_ordering,
                                .sync_scope = info.sync_scope,
                            });
                        },
                    }

                    <span class="tok-kw">if</span> (!func.strip) {
                        <span class="tok-kw">if</span> (func.debug_locations.get(adapter.instruction_index)) |debug_location| {
                            <span class="tok-kw">switch</span> (debug_location) {
                                .no_location =&gt; has_location = <span class="tok-null">false</span>,
                                .location =&gt; |location| {
                                    <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.DebugLoc{
                                        .line = location.line,
                                        .column = location.column,
                                        .scope = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(location.scope)),
                                        .inlined_at = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(location.inlined_at)),
                                    });
                                    has_location = <span class="tok-null">true</span>;
                                },
                            }
                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (has_location) {
                            <span class="tok-kw">try</span> function_block.writeAbbrev(FunctionBlock.DebugLocAgain{});
                        }
                    }
                }<span class="tok-comment">

                // VALUE_SYMTAB
                </span><span class="tok-kw">if</span> (!func.strip) {
                    <span class="tok-kw">const</span> ValueSymbolTable = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.FunctionValueSymbolTable.html">FunctionValueSymbolTable</a>;

                    <span class="tok-kw">var</span> value_symtab_block = <span class="tok-kw">try</span> function_block.enterSubBlock(ValueSymbolTable, <span class="tok-null">false</span>);

                    <span class="tok-kw">for</span> (func.blocks, <span class="tok-number">0</span>..) |block, block_index| {
                        <span class="tok-kw">const</span> name = block.instruction.name(&amp;func);

                        <span class="tok-kw">if</span> (name == .none <span class="tok-kw">or</span> name == .empty) <span class="tok-kw">continue</span>;

                        <span class="tok-kw">try</span> value_symtab_block.writeAbbrev(ValueSymbolTable.BlockEntry{
                            .value_id = <span class="tok-builtin">@intCast</span>(block_index),
                            .string = name.slice(self).?,
                        });
                    }<span class="tok-comment">

                    // TODO: Emit non block entries if the builder ever starts assigning names to non blocks

                    </span><span class="tok-kw">try</span> value_symtab_block.end();
                }<span class="tok-comment">

                // METADATA_ATTACHMENT_BLOCK
                </span>{
                    <span class="tok-kw">const</span> MetadataAttachmentBlock = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.MetadataAttachmentBlock.html">MetadataAttachmentBlock</a>;
                    <span class="tok-kw">var</span> metadata_attach_block = <span class="tok-kw">try</span> function_block.enterSubBlock(MetadataAttachmentBlock, <span class="tok-null">false</span>);

                    dbg: {
                        <span class="tok-kw">if</span> (func.strip) <span class="tok-kw">break</span> :dbg;
                        <span class="tok-kw">const</span> dbg = func.global.ptrConst(self).dbg;
                        <span class="tok-kw">if</span> (dbg == .none) <span class="tok-kw">break</span> :dbg;
                        <span class="tok-kw">try</span> metadata_attach_block.writeAbbrev(MetadataAttachmentBlock.AttachmentGlobalSingle{
                            .kind = .dbg,
                            .metadata = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(dbg) - <span class="tok-number">1</span>),
                        });
                    }

                    <span class="tok-kw">var</span> instr_index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
                    <span class="tok-kw">for</span> (func.instructions.items(.tag), func.instructions.items(.data)) |instr_tag, data| <span class="tok-kw">switch</span> (instr_tag) {
                        .arg, .block =&gt; {},<span class="tok-comment"> // not an actual instruction
                        </span><span class="tok-kw">else</span> =&gt; {
                            instr_index += <span class="tok-number">1</span>;
                        },
                        .br_cond, .@&quot;switch&quot; =&gt; {
                            <span class="tok-kw">const</span> weights = <span class="tok-kw">switch</span> (instr_tag) {
                                .br_cond =&gt; func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.BrCond.html">BrCond</a>, data).weights,
                                .@&quot;switch&quot; =&gt; func.extraData(<a href="std.zig.llvm.Builder.Function.html">Function</a>.<a href="std.zig.llvm.Builder.Function.Instruction.html">Instruction</a>.<a href="std.zig.llvm.Builder.Function.Instruction.Switch.html">Switch</a>, data).weights,
                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
                            };
                            <span class="tok-kw">switch</span> (weights) {
                                .none =&gt; {},
                                .unpredictable =&gt; <span class="tok-kw">try</span> metadata_attach_block.writeAbbrev(MetadataAttachmentBlock.AttachmentInstructionSingle{
                                    .inst = instr_index,
                                    .kind = .unpredictable,
                                    .metadata = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(.empty_tuple) - <span class="tok-number">1</span>),
                                }),
                                _ =&gt; <span class="tok-kw">try</span> metadata_attach_block.writeAbbrev(MetadataAttachmentBlock.AttachmentInstructionSingle{
                                    .inst = instr_index,
                                    .kind = .prof,
                                    .metadata = <span class="tok-builtin">@enumFromInt</span>(metadata_adapter.getMetadataIndex(<span class="tok-builtin">@enumFromInt</span>(<span class="tok-builtin">@intFromEnum</span>(weights))) - <span class="tok-number">1</span>),
                                }),
                            }
                            instr_index += <span class="tok-number">1</span>;
                        },
                    };

                    <span class="tok-kw">try</span> metadata_attach_block.end();
                }

                <span class="tok-kw">try</span> function_block.end();
            }
        }

        <span class="tok-kw">try</span> module_block.end();
    }<span class="tok-comment">

    // STRTAB_BLOCK
    </span>{
        <span class="tok-kw">const</span> Strtab = <a href="std.zig.llvm.ir.html">ir</a>.<a href="std.zig.llvm.ir.Strtab.html">Strtab</a>;
        <span class="tok-kw">var</span> strtab_block = <span class="tok-kw">try</span> bitcode.enterTopBlock(Strtab);

        <span class="tok-kw">try</span> strtab_block.writeAbbrev(Strtab.Blob{ .blob = self.strtab_string_bytes.items });

        <span class="tok-kw">try</span> strtab_block.end();
    }

    <span class="tok-kw">return</span> bitcode.toOwnedSlice();
}

<span class="tok-kw">const</span> Allocator = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> assert = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> bitcode_writer = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;bitcode_writer.zig&quot;</span>);
<span class="tok-kw">const</span> Builder = <span class="tok-builtin">@This</span>();
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> DW = <a href="std.html">std</a>.<a href="std.dwarf.html">dwarf</a>;
<span class="tok-kw">const</span> ir = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;ir.zig&quot;</span>);
<span class="tok-kw">const</span> log = <a href="std.html">std</a>.<a href="std.log.html">log</a>.<a href="std.log.html#std.log.scoped">scoped</a>(.llvm);
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;../../std.zig&quot;</span>);</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
