<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.html" class="">crypto</a></li><li><a href="std.crypto.html" class="">25519</a></li><li><a href="std.crypto.25519.ed25519.html" class="">ed25519</a></li><li><a href="std.crypto.25519.ed25519.Ed25519.html" class="">Ed25519</a></li><li><a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html" class="active">KeyPair</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.crypto.25519.ed25519.Ed25519.KeyPair" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.crypto.25519.ed25519.Ed25519.KeyPair</span><a href="#src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair">[src]</a></h1><div class="tldDocs"><p>An Ed25519 key pair.</p>
</div><div class="sectFields"><h2 class="sectionHeader">Fields</h2><div class="listFields"><div><pre><code>public_key: <a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html">PublicKey</a></code></pre><div class="fieldDocs"><p>Public part.</p>
</div></div><div><pre><code>secret_key: <a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a></code></pre><div class="fieldDocs"><p>Secret scalar.</p>
</div></div></div></div><div class="sectValues"><h2 class="sectionHeader">Values</h2><div class="listValues"><div class="decl"><h2 id="std.crypto.25519.ed25519.Ed25519.noise_length" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">noise_length</span><a href="#src.zig-std.crypto.25519.ed25519.Ed25519.noise_length">[src]</a></h2><div class="tldDocs"><p>Length (in bytes) of optional random bytes, for non-deterministic signatures.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.25519.ed25519.Ed25519.noise_length">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> noise_length = <span class="tok-number">32</span></code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.crypto.25519.ed25519.Ed25519.KeyPair.generateDeterministic" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">generateDeterministic</span><a href="#src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.generateDeterministic">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generateDeterministic</span>(seed: [<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>]<span class="tok-type">u8</span>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a></code></pre></div><div class="tldDocs"><p>Deterministically derive a key pair from a cryptograpically secure secret seed.</p>
<p>To create a new key, applications should generally call <code>generate()</code> instead of this function.</p>
<p>As in RFC 8032, an Ed25519 public key is generated by hashing
the secret key using the SHA-512 function, and interpreting the
bit-swapped, clamped lower-half of the output as the secret scalar.</p>
<p>For this reason, an EdDSA secret key is commonly called a seed,
from which the actual secret is derived.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>seed: [<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.generateDeterministic">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generateDeterministic</span>(seed: [<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>]<span class="tok-type">u8</span>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a> {
    <span class="tok-kw">var</span> az: [<a href="std.crypto.sha2.html#std.crypto.sha2.Sha512">Sha512</a>.<a href="#">digest_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> h = <a href="std.crypto.sha2.html#std.crypto.sha2.Sha512">Sha512</a>.<a href="#">init</a>(.{});
    h.update(&amp;seed);
    h.final(&amp;az);
    <span class="tok-kw">const</span> pk_p = <a href="std.crypto.25519.edwards25519.Edwards25519.html">Curve</a>.<a href="std.crypto.25519.edwards25519.Edwards25519.html#std.crypto.25519.edwards25519.Edwards25519.basePoint">basePoint</a>.<a href="#">clampedMul</a>(az[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IdentityElement;
    <span class="tok-kw">const</span> pk_bytes = pk_p.toBytes();
    <span class="tok-kw">var</span> sk_bytes: [<a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a>.<a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html#std.crypto.25519.ed25519.Ed25519.SecretKey.encoded_length">encoded_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    sk_bytes[<span class="tok-number">0</span>..<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>].* = seed;
    sk_bytes[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>..].* = pk_bytes;
    <span class="tok-kw">return</span> <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>{
        .public_key = <a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html">PublicKey</a>.<a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html#std.crypto.25519.ed25519.Ed25519.PublicKey.fromBytes">fromBytes</a>(pk_bytes) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
        .secret_key = <span class="tok-kw">try</span> <a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a>.<a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html#std.crypto.25519.ed25519.Ed25519.SecretKey.fromBytes">fromBytes</a>(sk_bytes),
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.25519.ed25519.Ed25519.KeyPair.generate" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">generate</span><a href="#src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.generate">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generate</span>() <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a></code></pre></div><div class="tldDocs"><p>Generate a new, random key pair.</p>
<p><code>crypto.random.bytes</code> must be supported by the target.</p>
</div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.generate">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generate</span>() <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a> {
    <span class="tok-kw">var</span> random_seed: [<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">bytes</a>(&amp;random_seed);
        <span class="tok-kw">return</span> <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html#std.crypto.25519.ed25519.Ed25519.KeyPair.generateDeterministic">generateDeterministic</a>(random_seed) <span class="tok-kw">catch</span> {
            <span class="tok-builtin">@branchHint</span>(.unlikely);
            <span class="tok-kw">continue</span>;
        };
    }
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.25519.ed25519.Ed25519.KeyPair.fromSecretKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fromSecretKey</span><a href="#src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.fromSecretKey">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSecretKey</span>(secret_key: <a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a>) (<a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a> || <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a></code></pre></div><div class="tldDocs"><p>Create a key pair from an existing secret key.</p>
<p>Note that with EdDSA, storing the seed, and recovering the key pair
from it is recommended over storing the entire secret key.
The seed of an exiting key pair can be obtained with
<code>key_pair.secret_key.seed()</code>, and the secret key can then be
recomputed using <code>SecretKey.generateDeterministic()</code>.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>secret_key: <a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.fromSecretKey">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSecretKey</span>(secret_key: <a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a>) (<a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a> || <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a> {<span class="tok-comment">
    // It is critical for EdDSA to use the correct public key.
    // In order to enforce this, a SecretKey implicitly includes a copy of the public key.
    // With runtime safety, we can still afford checking that the public key is correct.
    </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) {
        <span class="tok-kw">const</span> pk_p = <span class="tok-kw">try</span> <a href="std.crypto.25519.edwards25519.Edwards25519.html">Curve</a>.<a href="std.crypto.25519.edwards25519.Edwards25519.html#std.crypto.25519.edwards25519.Edwards25519.fromBytes">fromBytes</a>(secret_key.publicKeyBytes());
        <span class="tok-kw">const</span> recomputed_kp = <span class="tok-kw">try</span> <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html#std.crypto.25519.ed25519.Ed25519.KeyPair.generateDeterministic">generateDeterministic</a>(secret_key.seed());
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;recomputed_kp.public_key.toBytes(), &amp;pk_p.toBytes())) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonCanonical;
        }
    }
    <span class="tok-kw">return</span> <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>{
        .public_key = <span class="tok-kw">try</span> <a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html">PublicKey</a>.<a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html#std.crypto.25519.ed25519.Ed25519.PublicKey.fromBytes">fromBytes</a>(secret_key.publicKeyBytes()),
        .secret_key = secret_key,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.25519.ed25519.Ed25519.KeyPair.sign" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sign</span><a href="#src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.sign">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sign</span>(key_pair: <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, noise: ?[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.KeyMismatchError">KeyMismatchError</a> || <a href="std.crypto.errors.html#std.crypto.errors.WeakPublicKeyError">WeakPublicKeyError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.Signature.html">Signature</a></code></pre></div><div class="tldDocs"><p>Sign a message using the key pair.
The noise can be null in order to create deterministic signatures.
If deterministic signatures are not required, the noise should be randomly generated instead.
This helps defend against fault attacks.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>key_pair: <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a></code></pre></div><div><pre><code>msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>noise: ?[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.sign">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sign</span>(key_pair: <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, noise: ?[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.KeyMismatchError">KeyMismatchError</a> || <a href="std.crypto.errors.html#std.crypto.errors.WeakPublicKeyError">WeakPublicKeyError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.Signature.html">Signature</a> {
    <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;key_pair.secret_key.publicKeyBytes(), &amp;key_pair.public_key.toBytes())) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.KeyMismatch;
    }
    <span class="tok-kw">const</span> scalar_and_prefix = key_pair.secret_key.scalarAndPrefix();
    <span class="tok-kw">return</span> key_pair.public_key.computeNonceAndSign(
        msg,
        noise,
        scalar_and_prefix.scalar,
        &amp;scalar_and_prefix.prefix,
    );
}</code></pre></details></div></div><div class="decl"><h2 id="std.crypto.25519.ed25519.Ed25519.KeyPair.signer" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">signer</span><a href="#src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.signer">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signer</span>(key_pair: <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>, noise: ?[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.KeyMismatchError">KeyMismatchError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.WeakPublicKeyError">WeakPublicKeyError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.Signer.html">Signer</a></code></pre></div><div class="tldDocs"><p>Create a Signer, that can be used for incremental signing.
Note that the signature is not deterministic.
The noise parameter, if set, should be something unique for each message,
such as a random nonce, or a counter.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>key_pair: <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a></code></pre></div><div><pre><code>noise: ?[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair.signer">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signer</span>(key_pair: <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>, noise: ?[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.KeyMismatchError">KeyMismatchError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.WeakPublicKeyError">WeakPublicKeyError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.Signer.html">Signer</a> {
    <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;key_pair.secret_key.publicKeyBytes(), &amp;key_pair.public_key.toBytes())) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.KeyMismatch;
    }
    <span class="tok-kw">const</span> scalar_and_prefix = key_pair.secret_key.scalarAndPrefix();
    <span class="tok-kw">var</span> h = <a href="std.crypto.sha2.html#std.crypto.sha2.Sha512">Sha512</a>.<a href="#">init</a>(.{});
    h.update(&amp;scalar_and_prefix.prefix);
    <span class="tok-kw">var</span> noise2: [<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">bytes</a>(&amp;noise2);
    h.update(&amp;noise2);
    <span class="tok-kw">if</span> (noise) |*z| {
        h.update(z);
    }
    <span class="tok-kw">var</span> nonce64: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    h.final(&amp;nonce64);
    <span class="tok-kw">const</span> nonce = <a href="std.crypto.25519.edwards25519.Edwards25519.html">Curve</a>.<a href="std.crypto.25519.scalar.html">scalar</a>.<a href="std.crypto.25519.scalar.html#std.crypto.25519.scalar.reduce64">reduce64</a>(nonce64);

    <span class="tok-kw">return</span> <a href="std.crypto.25519.ed25519.Ed25519.Signer.html">Signer</a>.<a href="std.crypto.25519.ed25519.Ed25519.Signer.html#std.crypto.25519.ed25519.Ed25519.Signer.init">init</a>(scalar_and_prefix.scalar, nonce, key_pair.public_key);
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.crypto.25519.ed25519.Ed25519.KeyPair">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KeyPair = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Length (in bytes) of a seed required to create a key pair.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> seed_length = <a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>;

    <span class="tok-comment">/// Public part.</span>
    public_key: <a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html">PublicKey</a>,
    <span class="tok-comment">/// Secret scalar.</span>
    secret_key: <a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a>,

    <span class="tok-comment">/// Deterministically derive a key pair from a cryptograpically secure secret seed.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// To create a new key, applications should generally call `generate()` instead of this function.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// As in RFC 8032, an Ed25519 public key is generated by hashing</span>
    <span class="tok-comment">/// the secret key using the SHA-512 function, and interpreting the</span>
    <span class="tok-comment">/// bit-swapped, clamped lower-half of the output as the secret scalar.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// For this reason, an EdDSA secret key is commonly called a seed,</span>
    <span class="tok-comment">/// from which the actual secret is derived.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generateDeterministic</span>(seed: [<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>]<span class="tok-type">u8</span>) <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>!<a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a> {
        <span class="tok-kw">var</span> az: [<a href="std.crypto.sha2.html#std.crypto.sha2.Sha512">Sha512</a>.<a href="#">digest_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">var</span> h = <a href="std.crypto.sha2.html#std.crypto.sha2.Sha512">Sha512</a>.<a href="#">init</a>(.{});
        h.update(&amp;seed);
        h.final(&amp;az);
        <span class="tok-kw">const</span> pk_p = <a href="std.crypto.25519.edwards25519.Edwards25519.html">Curve</a>.<a href="std.crypto.25519.edwards25519.Edwards25519.html#std.crypto.25519.edwards25519.Edwards25519.basePoint">basePoint</a>.<a href="#">clampedMul</a>(az[<span class="tok-number">0</span>..<span class="tok-number">32</span>].*) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IdentityElement;
        <span class="tok-kw">const</span> pk_bytes = pk_p.toBytes();
        <span class="tok-kw">var</span> sk_bytes: [<a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a>.<a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html#std.crypto.25519.ed25519.Ed25519.SecretKey.encoded_length">encoded_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        sk_bytes[<span class="tok-number">0</span>..<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>].* = seed;
        sk_bytes[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>..].* = pk_bytes;
        <span class="tok-kw">return</span> <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>{
            .public_key = <a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html">PublicKey</a>.<a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html#std.crypto.25519.ed25519.Ed25519.PublicKey.fromBytes">fromBytes</a>(pk_bytes) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>,
            .secret_key = <span class="tok-kw">try</span> <a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a>.<a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html#std.crypto.25519.ed25519.Ed25519.SecretKey.fromBytes">fromBytes</a>(sk_bytes),
        };
    }

    <span class="tok-comment">/// Generate a new, random key pair.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// `crypto.random.bytes` must be supported by the target.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">generate</span>() <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a> {
        <span class="tok-kw">var</span> random_seed: [<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">seed_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">bytes</a>(&amp;random_seed);
            <span class="tok-kw">return</span> <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html#std.crypto.25519.ed25519.Ed25519.KeyPair.generateDeterministic">generateDeterministic</a>(random_seed) <span class="tok-kw">catch</span> {
                <span class="tok-builtin">@branchHint</span>(.unlikely);
                <span class="tok-kw">continue</span>;
            };
        }
    }

    <span class="tok-comment">/// Create a key pair from an existing secret key.</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// Note that with EdDSA, storing the seed, and recovering the key pair</span>
    <span class="tok-comment">/// from it is recommended over storing the entire secret key.</span>
    <span class="tok-comment">/// The seed of an exiting key pair can be obtained with</span>
    <span class="tok-comment">/// `key_pair.secret_key.seed()`, and the secret key can then be</span>
    <span class="tok-comment">/// recomputed using `SecretKey.generateDeterministic()`.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromSecretKey</span>(secret_key: <a href="std.crypto.25519.ed25519.Ed25519.SecretKey.html">SecretKey</a>) (<a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.EncodingError">EncodingError</a> || <a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a> {<span class="tok-comment">
        // It is critical for EdDSA to use the correct public key.
        // In order to enforce this, a SecretKey implicitly includes a copy of the public key.
        // With runtime safety, we can still afford checking that the public key is correct.
        </span><span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.runtime_safety">runtime_safety</a>) {
            <span class="tok-kw">const</span> pk_p = <span class="tok-kw">try</span> <a href="std.crypto.25519.edwards25519.Edwards25519.html">Curve</a>.<a href="std.crypto.25519.edwards25519.Edwards25519.html#std.crypto.25519.edwards25519.Edwards25519.fromBytes">fromBytes</a>(secret_key.publicKeyBytes());
            <span class="tok-kw">const</span> recomputed_kp = <span class="tok-kw">try</span> <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html#std.crypto.25519.ed25519.Ed25519.KeyPair.generateDeterministic">generateDeterministic</a>(secret_key.seed());
            <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;recomputed_kp.public_key.toBytes(), &amp;pk_p.toBytes())) {
                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NonCanonical;
            }
        }
        <span class="tok-kw">return</span> <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>{
            .public_key = <span class="tok-kw">try</span> <a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html">PublicKey</a>.<a href="std.crypto.25519.ed25519.Ed25519.PublicKey.html#std.crypto.25519.ed25519.Ed25519.PublicKey.fromBytes">fromBytes</a>(secret_key.publicKeyBytes()),
            .secret_key = secret_key,
        };
    }

    <span class="tok-comment">/// Sign a message using the key pair.</span>
    <span class="tok-comment">/// The noise can be null in order to create deterministic signatures.</span>
    <span class="tok-comment">/// If deterministic signatures are not required, the noise should be randomly generated instead.</span>
    <span class="tok-comment">/// This helps defend against fault attacks.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sign</span>(key_pair: <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>, msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, noise: ?[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.KeyMismatchError">KeyMismatchError</a> || <a href="std.crypto.errors.html#std.crypto.errors.WeakPublicKeyError">WeakPublicKeyError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.Signature.html">Signature</a> {
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;key_pair.secret_key.publicKeyBytes(), &amp;key_pair.public_key.toBytes())) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.KeyMismatch;
        }
        <span class="tok-kw">const</span> scalar_and_prefix = key_pair.secret_key.scalarAndPrefix();
        <span class="tok-kw">return</span> key_pair.public_key.computeNonceAndSign(
            msg,
            noise,
            scalar_and_prefix.scalar,
            &amp;scalar_and_prefix.prefix,
        );
    }

    <span class="tok-comment">/// Create a Signer, that can be used for incremental signing.</span>
    <span class="tok-comment">/// Note that the signature is not deterministic.</span>
    <span class="tok-comment">/// The noise parameter, if set, should be something unique for each message,</span>
    <span class="tok-comment">/// such as a random nonce, or a counter.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">signer</span>(key_pair: <a href="std.crypto.25519.ed25519.Ed25519.KeyPair.html">KeyPair</a>, noise: ?[<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span>) (<a href="std.crypto.errors.html#std.crypto.errors.IdentityElementError">IdentityElementError</a> || <a href="std.crypto.errors.html#std.crypto.errors.KeyMismatchError">KeyMismatchError</a> || <a href="std.crypto.errors.html#std.crypto.errors.NonCanonicalError">NonCanonicalError</a> || <a href="std.crypto.errors.html#std.crypto.errors.WeakPublicKeyError">WeakPublicKeyError</a>)!<a href="std.crypto.25519.ed25519.Ed25519.Signer.html">Signer</a> {
        <span class="tok-kw">if</span> (!<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, &amp;key_pair.secret_key.publicKeyBytes(), &amp;key_pair.public_key.toBytes())) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.KeyMismatch;
        }
        <span class="tok-kw">const</span> scalar_and_prefix = key_pair.secret_key.scalarAndPrefix();
        <span class="tok-kw">var</span> h = <a href="std.crypto.sha2.html#std.crypto.sha2.Sha512">Sha512</a>.<a href="#">init</a>(.{});
        h.update(&amp;scalar_and_prefix.prefix);
        <span class="tok-kw">var</span> noise2: [<a href="std.crypto.25519.ed25519.Ed25519.html#std.crypto.25519.ed25519.Ed25519.noise_length">noise_length</a>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        <a href="std.crypto.html">crypto</a>.<a href="std.crypto.tlcsprng.html#std.crypto.tlcsprng.interface">random</a>.<a href="#">bytes</a>(&amp;noise2);
        h.update(&amp;noise2);
        <span class="tok-kw">if</span> (noise) |*z| {
            h.update(z);
        }
        <span class="tok-kw">var</span> nonce64: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
        h.final(&amp;nonce64);
        <span class="tok-kw">const</span> nonce = <a href="std.crypto.25519.edwards25519.Edwards25519.html">Curve</a>.<a href="std.crypto.25519.scalar.html">scalar</a>.<a href="std.crypto.25519.scalar.html#std.crypto.25519.scalar.reduce64">reduce64</a>(nonce64);

        <span class="tok-kw">return</span> <a href="std.crypto.25519.ed25519.Ed25519.Signer.html">Signer</a>.<a href="std.crypto.25519.ed25519.Ed25519.Signer.html#std.crypto.25519.ed25519.Ed25519.Signer.init">init</a>(scalar_and_prefix.scalar, nonce, key_pair.public_key);
    }
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
