<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zig Documentation</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style type="text/css">
      *, *::before, *::after {
        box-sizing: border-box;
      }
      body {
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        font-size: 16px;
        color: #000000;
      }
      .hidden {
        display: none;
      }
      table {
        width: 100%;
      }
      a {
        color: #2A6286;
      }
      details summary {
        cursor: pointer;
      }
      pre {
        font-family: "Source Code Pro",monospace;
        font-size: 1rem;
        background-color: #F5F5F5;
        padding: 1rem;
        margin: 0;
        overflow-x: auto;
      }
      :not(pre) > code {
        white-space: break-spaces;
      }
      code, code a {
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
      }
      code a {
        color: #000000;
      }
      .listFields > div, .listParams > div {
        margin-bottom: 1rem;
      }
      .declHeader a {
        font-size: 0.7rem;
        padding-left: 1rem;
      }
      .declHeader .declHeaderIdentifier {
        padding-left: 0.75rem;
      }
      .fieldDocs {
        border: 1px solid #F5F5F5;
        border-top: 0px;
        padding: 1px 1rem;
      }

      #logo {
        width: 8rem;
        padding: 0.5rem 1rem;
      }

      #navWrap {
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
        margin-left: 11rem;
      }

      #search {
        width: 100%;
      }

      nav {
        width: 10rem;
        float: left;
      }
      nav h2 {
        font-size: 1.2rem;
        text-decoration: underline;
        margin: 0;
        padding: 0.5rem 0;
        text-align: center;
      }
      nav p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      section {
        clear: both;
        padding-top: 1rem;
      }
      section .declHeader {
        font-size: 1.3rem;
        border-bottom: 1px dashed;
        margin: 0 0;
      }
      section .sectionHeader {
        font-size: 1.3rem;
        margin: 0.5rem 0;
        padding: 0;
        border-bottom: 1px solid;
      }
      #listNav {
        list-style-type: none;
        margin: 0.5rem 0 0 0;
        padding: 0;
        overflow: hidden;
        background-color: #f1f1f1;
      }
      #listNav li {
        float:left;
      }
      #listNav li a {
        display: block;
        color: #000;
        text-align: center;
        padding: .5rem .8rem;
        text-decoration: none;
      }
      #listNav li a:hover {
        background-color: #555;
        color: #fff;
      }
      #listNav li a.active {
        background-color: #FFBB4D;
        color: #000;
      }
      .sectSource {
        margin-bottom: 2rem;
      }

      #helpDialog {
        width: 21rem;
        height: 21rem;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #333;
        color: #fff;
        border: 1px solid #fff;
      }
      #helpDialog h1 {
        text-align: center;
        font-size: 1.5rem;
      }
      #helpDialog dt, #helpDialog dd {
        display: inline;
        margin: 0 0.2rem;
      }
      kbd {
        color: #000;
        background-color: #fafbfc;
        border-color: #d1d5da;
        border-bottom-color: #c6cbd1;
        box-shadow-color: #c6cbd1;
        display: inline-block;
        padding: 0.3rem 0.2rem;
        font: 1.2rem monospace;
        line-height: 0.8rem;
        vertical-align: middle;
        border: solid 1px;
        border-radius: 3px;
        box-shadow: inset 0 -1px 0;
        cursor: default;
      }

      #errors {
        background-color: #faa;
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        max-height: min(20rem, 50vh);
        padding: 0.5rem;
        overflow: auto;
      }
      #errors h1 {
        font-size: 1.5rem;
      }
      #errors pre {
        background-color: #fcc;
      }
      
      .decl .decl {
        padding-left: 1rem;
        border-left: 4px solid;
        border-color: #555;
      }

      .listSearchResults li.selected {
        background-color: #93e196;
      }

      .tableFnErrors dt {
        font-weight: bold;
      }

      dl > div {
          padding: 0.5rem;
          border: 1px solid #c0c0c0;
          margin-top: 0.5rem;
      }

      td, th {
        text-align: unset;
        vertical-align: top;
        margin: 0;
        padding: 0.5rem;
        max-width: 20rem;
        text-overflow: ellipsis;
        overflow-x: hidden;
      }

      ul.columns {
        column-width: 20rem;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #111;
          color: #bbb;
        }
        pre {
          background-color: #222;
          color: #ccc;
        }
        a {
          color: #88f;
        }
        code a {
          color: #ccc;
        }
        .fieldDocs {
          border-color:#2A2A2A;
        }
        #listNav {
          background-color: #333;
        }
        #listNav li a {
          color: #fff;
        }
        #listNav li a:hover {
          background-color: #555;
          color: #fff;
        }
        #listNav li a.active {
          background-color: #FFBB4D;
          color: #000;
        }
        .listSearchResults li.selected {
          background-color: #000;
        }
        .listSearchResults li.selected a {
          color: #fff;
        }
        #errors {
          background-color: #800;
          color: #fff;
        }
        #errors pre {
          background-color: #a00;
          color: #fff;
        }
        dl > div {
          border-color: #373737;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
  </head>
  <body>
    <nav>
      <a class="logo" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 140">
        <g fill="#F7A41D">
          <g>
            <polygon points="46,22 28,44 19,30"/>
            <polygon points="46,22 33,33 28,44 22,44 22,95 31,95 20,100 12,117 0,117 0,22" shape-rendering="crispEdges"/>
            <polygon points="31,95 12,117 4,106"/>
          </g>
          <g>
            <polygon points="56,22 62,36 37,44"/>
            <polygon points="56,22 111,22 111,44 37,44 56,32" shape-rendering="crispEdges"/>
            <polygon points="116,95 97,117 90,104"/>
            <polygon points="116,95 100,104 97,117 42,117 42,95" shape-rendering="crispEdges"/>
            <polygon points="150,0 52,117 3,140 101,22"/>
          </g>
          <g>
            <polygon points="141,22 140,40 122,45"/>
            <polygon points="153,22 153,117 106,117 120,105 125,95 131,95 131,45 122,45 132,36 141,22" shape-rendering="crispEdges"/>
            <polygon points="125,95 130,110 106,117"/>
          </g>
        </g>
        <style>
        #text { fill: #121212 }
        @media (prefers-color-scheme: dark) { #text { fill: #f2f2f2 } }
        </style>
        <g id="text">
          <g>
            <polygon points="260,22 260,37 229,40 177,40 177,22" shape-rendering="crispEdges"/>
            <polygon points="260,37 207,99 207,103 176,103 229,40 229,37"/>
            <polygon points="261,99 261,117 176,117 176,103 206,99" shape-rendering="crispEdges"/>
          </g>
          <rect x="272" y="22" shape-rendering="crispEdges" width="22" height="95"/>
          <g>
            <polygon points="394,67 394,106 376,106 376,81 360,70 346,67" shape-rendering="crispEdges"/>
            <polygon points="360,68 376,81 346,67"/>
            <path d="M394,106c-10.2,7.3-24,12-37.7,12c-29,0-51.1-20.8-51.1-48.3c0-27.3,22.5-48.1,52-48.1    c14.3,0,29.2,5.5,38.9,14l-13,15c-7.1-6.3-16.8-10-25.9-10c-17,0-30.2,12.9-30.2,29.5c0,16.8,13.3,29.6,30.3,29.6    c5.7,0,12.8-2.3,19-5.5L394,106z"/>
          </g>
        </g>
        </svg>
      </a>
    </nav>
    <div id="navWrap">
      <input disabled type="search" id="search" autocomplete="off" spellcheck="false" placeholder="`s` to search, `?` to see more options">
      <div id="sectNav"><ul id="listNav"><li><a href="#" class="">std</a></li><li><a href="std.array_hash_map.html" class="active">array_hash_map</a></li></ul></div>
    </div>
    <section><div class="decl"><h1 id="std.array_hash_map" class="declHeader"><span class="declHeaderCategory">struct</span><span class="declHeaderIdentifier">std.array_hash_map</span><a href="#src.zig-std.array_hash_map">[src]</a></h1><div class="sectNamespaces"><h2 class="sectionHeader">Namespaces</h2><ul class="listNamespaces columns"><li><a href="std.array_hash_map.StringContext.html">std.array_hash_map.StringContext</a></li></ul></div><div class="sectTypes"><h2 class="sectionHeader">Types</h2><div class="listTypes"><div class="decl"><h2 id="std.array_hash_map.AutoArrayHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoArrayHashMap</span><a href="#src.zig-std.array_hash_map.AutoArrayHashMap">[src]</a></h2><div class="tldDocs"><p>An <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a></code> with default hash and equal functions.</p>
<p>See <code><a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a></code> for a description of the hash and equal implementations.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.AutoArrayHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoArrayHashMap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(K), !<a href="std.array_hash_map.html#std.array_hash_map.autoEqlIsCheap">autoEqlIsCheap</a>(K));
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.AutoArrayHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoArrayHashMapUnmanaged</span><a href="#src.zig-std.array_hash_map.AutoArrayHashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>An <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> with default hash and equal functions.</p>
<p>See <code><a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a></code> for a description of the hash and equal implementations.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">std.array_hash_map.ArrayHashMapUnmanaged.Entry</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">std.array_hash_map.ArrayHashMapUnmanaged.KV</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">std.array_hash_map.ArrayHashMapUnmanaged.Data</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">std.array_hash_map.ArrayHashMapUnmanaged.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.DataList" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMap type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{}</code></pre><div class="fieldDocs"><p>It is permitted to access this field directly.
After any modification to the keys, consider calling <code>reIndex</code>.</p>
</div></div><div><pre><code>index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>When entries length is less than <code>linear_scan_max</code>, this remains <code>null</code>.
Once entries length grows big enough, this field is allocated. There is
an IndexHeader followed by an array of Index(I) structs, where I is defined
by how many total indexes there are.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
    .entries = .{},
    .index_header = <span class="tok-null">null</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="tldDocs"><p>Convert from an unmanaged map to a managed map.  After calling this,
the promoted map should no longer be used.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = gpa,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    <span class="tok-kw">errdefer</span> self.deinit(gpa);
    <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>An empty <code>value_list</code> may be passed, in which case the values array becomes <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
    <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
    <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
        <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
        <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
    }
    <span class="tok-kw">try</span> self.reIndex(gpa);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.entries.deinit(gpa);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
    }
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.len = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">switch</span> (header.capacityIndexType()) {
            .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
            .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
            .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
        self.index_header = <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.entries.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
    <span class="tok-kw">return</span> self.entries.items(.key);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
    <span class="tok-kw">return</span> self.entries.items(.value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> .{
        .keys = slice.items(.key).ptr,
        .values = slice.items(.value).ptr,
        .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // &quot;If key exists this function cannot fail.&quot;
        </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            .found_existing = <span class="tok-null">true</span>,
            .index = index,
        };
    };
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
both the key and the value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = item_key,<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = i,
                };
            }
        }

        <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
        // The slice length changed, so we directly index the pointer.
        </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
            .found_existing = <span class="tok-null">false</span>,
            .index = index,
        };
    };

    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> res;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
        <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">return</span>;
        }
    }

    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
    <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
    <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

    <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
    self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
    self.index_header = new_header;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ctx: Context, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
    ctx: Context,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
    <span class="tok-kw">const</span> indexes_cap = header.capacity();
    <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
        .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
        // workaround for #6974
        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> i;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    };
    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // workaround for #6974
    </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> &amp;self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but is allocated
with the provided allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
    <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

    <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
        // TODO: I'm pretty sure this could be memcpy'd instead of
        // doing all this work.
        </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
        other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
        other.index_header = new_header;
    }
    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Recompute all hashes.
    </span><span class="tok-kw">if</span> (store_hash) {
        <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            hash.* = h;
        }
    }
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify an entry's key without reordering any entries.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
    key_ptr.* = new_key;
    <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses a stable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstable</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses an unstable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstableContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkRetainingCapacity(new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFreeContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacityContext</code> can be used
instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkAndFree(gpa, new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.popContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (self.index_header) |header|
        self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    self.entries.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> .{
        .key = item.key,
        .value = item.value,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.AutoArrayHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoArrayHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(K), !<a href="std.array_hash_map.html#std.array_hash_map.autoEqlIsCheap">autoEqlIsCheap</a>(K));
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.StringArrayHashMap" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StringArrayHashMap</span><a href="#src.zig-std.array_hash_map.StringArrayHashMap">[src]</a></h2><div class="tldDocs"><p>An <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a></code> with strings as keys.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.StringArrayHashMap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringArrayHashMap</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.array_hash_map.StringContext.html">StringContext</a>, <span class="tok-null">true</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.StringArrayHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">StringArrayHashMapUnmanaged</span><a href="#src.zig-std.array_hash_map.StringArrayHashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>An <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> with strings as keys.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>V: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">std.array_hash_map.ArrayHashMapUnmanaged.Entry</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">std.array_hash_map.ArrayHashMapUnmanaged.KV</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">std.array_hash_map.ArrayHashMapUnmanaged.Data</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">std.array_hash_map.ArrayHashMapUnmanaged.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.DataList" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMap type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{}</code></pre><div class="fieldDocs"><p>It is permitted to access this field directly.
After any modification to the keys, consider calling <code>reIndex</code>.</p>
</div></div><div><pre><code>index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>When entries length is less than <code>linear_scan_max</code>, this remains <code>null</code>.
Once entries length grows big enough, this field is allocated. There is
an IndexHeader followed by an array of Index(I) structs, where I is defined
by how many total indexes there are.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
    .entries = .{},
    .index_header = <span class="tok-null">null</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="tldDocs"><p>Convert from an unmanaged map to a managed map.  After calling this,
the promoted map should no longer be used.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = gpa,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    <span class="tok-kw">errdefer</span> self.deinit(gpa);
    <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>An empty <code>value_list</code> may be passed, in which case the values array becomes <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
    <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
    <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
        <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
        <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
    }
    <span class="tok-kw">try</span> self.reIndex(gpa);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.entries.deinit(gpa);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
    }
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.len = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">switch</span> (header.capacityIndexType()) {
            .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
            .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
            .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
        self.index_header = <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.entries.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
    <span class="tok-kw">return</span> self.entries.items(.key);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
    <span class="tok-kw">return</span> self.entries.items(.value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> .{
        .keys = slice.items(.key).ptr,
        .values = slice.items(.value).ptr,
        .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // &quot;If key exists this function cannot fail.&quot;
        </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            .found_existing = <span class="tok-null">true</span>,
            .index = index,
        };
    };
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
both the key and the value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = item_key,<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = i,
                };
            }
        }

        <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
        // The slice length changed, so we directly index the pointer.
        </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
            .found_existing = <span class="tok-null">false</span>,
            .index = index,
        };
    };

    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> res;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
        <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">return</span>;
        }
    }

    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
    <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
    <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

    <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
    self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
    self.index_header = new_header;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ctx: Context, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
    ctx: Context,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
    <span class="tok-kw">const</span> indexes_cap = header.capacity();
    <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
        .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
        // workaround for #6974
        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> i;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    };
    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // workaround for #6974
    </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> &amp;self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but is allocated
with the provided allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
    <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

    <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
        // TODO: I'm pretty sure this could be memcpy'd instead of
        // doing all this work.
        </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
        other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
        other.index_header = new_header;
    }
    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Recompute all hashes.
    </span><span class="tok-kw">if</span> (store_hash) {
        <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            hash.* = h;
        }
    }
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify an entry's key without reordering any entries.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
    key_ptr.* = new_key;
    <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses a stable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstable</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses an unstable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstableContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkRetainingCapacity(new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFreeContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacityContext</code> can be used
instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkAndFree(gpa, new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.popContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (self.index_header) |header|
        self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    self.entries.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> .{
        .key = item.key,
        .value = item.value,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.StringArrayHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringArrayHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.array_hash_map.StringContext.html">StringContext</a>, <span class="tok-null">true</span>);
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.ArrayHashMapWithAllocator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayHashMapWithAllocator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator">[src]</a></h2><div class="tldDocs"><p>A hash table of keys and values, each stored sequentially.</p>
<p>Insertion order is preserved. In general, this data structure supports the same
operations as <code><a href="std.array_list.html#std.array_list.ArrayList">std.ArrayList</a></code>.</p>
<p>Deletion operations:</p>
<ul>
<li><code>swapRemove</code> - O(1)</li>
<li><code>orderedRemove</code> - O(N)</li>
</ul>
<p>Modifying the hash map while iterating is allowed, however, one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.</p>
<p>See <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> for a variant of this data structure that accepts an
<code><a href="std.mem.Allocator.html">Allocator</a></code> as a parameter when needed rather than storing it.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>A namespace that provides these two functions:</p>
<ul>
<li><code>pub fn hash(self, K) u32</code></li>
<li><code>pub fn eql(self, K, K, usize) bool</code></li>
</ul>
<p>The final <code>usize</code> in the <code>eql</code> function represents the index of the key
that's already inside the map.</p>
</div></div><div><pre><code>store_hash: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>When <code>false</code>, this data structure is biased towards cheap <code>eql</code>
functions and avoids storing each key's hash in the table. Setting
<code>store_hash</code> to <code>true</code> incurs more memory cost but limits <code>eql</code> to
being called only once per insertion/deletion (provided there are no
hash collisions).</p>
</div></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMapUnmanaged type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Entry">[src]</a></h3><div class="tldDocs"><p>Pointers to a key and value in the backing store of this map.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless <code>ensureTotalCapacity</code>/<code>ensureUnusedCapacity</code> was previously used.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.KV">[src]</a></h3><div class="tldDocs"><p>A KV pair which has been copied out of the backing store</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Data" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Data</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Data">[src]</a></h3><div class="tldDocs"><p>The Data type used for the MultiArrayList backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Data">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Data</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.DataList" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">DataList</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>getOrPut variants return this structure, with pointers
to the backing store and a flag to indicate whether an
existing entry was found.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless <code>ensureTotalCapacity</code>/<code>ensureUnusedCapacity</code> was previously used.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Iterator">[src]</a></h3><div class="tldDocs"><p>An Iterator over Entry pointers.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create an ArrayHashMap instance which will use a specified allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call initContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.initContext">initContext</a>(allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K {
    <span class="tok-kw">return</span> self.unmanaged.keys();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V {
    <span class="tok-kw">return</span> self.unmanaged.values();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, new_capacity, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happuns, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.getIndexContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.swapRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.swapRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.unmanaged.swapRemoveAtContext(index, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.unmanaged.orderedRemoveAtContext(index, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context and allocator as this instance.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but the specified
allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash)</code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same allocator as this instance, but the
specified context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash)</code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, ctx);
    <span class="tok-kw">return</span> other.promoteContext(allocator, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.reIndexContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.sortContext(sort_ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.shrinkRetainingCapacityContext(new_len, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.shrinkAndFreeContext(self.allocator, new_len, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it if count is nonzero.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.popContext(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayHashMapWithAllocator</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-comment">/// A namespace that provides these two functions:</span>
    <span class="tok-comment">/// * `pub fn hash(self, K) u32`</span>
    <span class="tok-comment">/// * `pub fn eql(self, K, K, usize) bool`</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The final `usize` in the `eql` function represents the index of the key</span>
    <span class="tok-comment">/// that's already inside the map.</span>
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-comment">/// When `false`, this data structure is biased towards cheap `eql`</span>
    <span class="tok-comment">/// functions and avoids storing each key's hash in the table. Setting</span>
    <span class="tok-comment">/// `store_hash` to `true` incurs more memory cost but limits `eql` to</span>
    <span class="tok-comment">/// being called only once per insertion/deletion (provided there are no</span>
    <span class="tok-comment">/// hash collisions).</span>
    <span class="tok-kw">comptime</span> store_hash: <span class="tok-type">bool</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        unmanaged: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        ctx: Context,

        <span class="tok-comment">/// The ArrayHashMapUnmanaged type using the same settings as this managed map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, Context, store_hash);

        <span class="tok-comment">/// Pointers to a key and value in the backing store of this map.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Entry</a>;

        <span class="tok-comment">/// A KV pair which has been copied out of the backing store</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">KV</a>;

        <span class="tok-comment">/// The Data type used for the MultiArrayList backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Data</a>;
        <span class="tok-comment">/// The MultiArrayList type backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">DataList</a>;

        <span class="tok-comment">/// The stored hash type, either u32 or void.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Hash</a>;

        <span class="tok-comment">/// getOrPut variants return this structure, with pointers</span>
        <span class="tok-comment">/// to the backing store and a flag to indicate whether an</span>
        <span class="tok-comment">/// existing entry was found.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a>;

        <span class="tok-comment">/// An Iterator over Entry pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a>;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Create an ArrayHashMap instance which will use a specified allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call initContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.initContext">initContext</a>(allocator, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Frees the backing allocation and leaves the map in an undefined state.</span>
        <span class="tok-comment">/// Note that this does not free keys or values.  You must take care of that</span>
        <span class="tok-comment">/// before calling this function, if it is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.deinit(self.allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.lockPointers();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.unlockPointers();
        }

        <span class="tok-comment">/// Clears the map but retains the backing allocation for future use.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
        }

        <span class="tok-comment">/// Clears the map and releases the backing allocation</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
        }

        <span class="tok-comment">/// Returns the number of KV pairs stored in this map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.count();
        }

        <span class="tok-comment">/// Returns the backing array of keys in this map. Modifying the map may</span>
        <span class="tok-comment">/// invalidate this array. Modifying this array in a way that changes</span>
        <span class="tok-comment">/// key hashes or key equality puts the map into an unusable state until</span>
        <span class="tok-comment">/// `reIndex` is called.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K {
            <span class="tok-kw">return</span> self.unmanaged.keys();
        }
        <span class="tok-comment">/// Returns the backing array of values in this map. Modifying the map</span>
        <span class="tok-comment">/// may invalidate this array. It is permitted to modify the values in</span>
        <span class="tok-comment">/// this array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V {
            <span class="tok-kw">return</span> self.unmanaged.values();
        }

        <span class="tok-comment">/// Returns an iterator over the pairs in this map.</span>
        <span class="tok-comment">/// Modifying the map may invalidate this iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.iterator();
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, new_capacity, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.capacity();
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happuns, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Finds pointers to the key and value storage associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the index in the `entries` array where a key is stored</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.getIndexContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.getIndexAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find a pointer to the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find a pointer to the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Check whether a key is stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by swapping it with the last</span>
        <span class="tok-comment">/// element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by shifting all elements forward</span>
        <span class="tok-comment">/// thereby maintaining the current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.  Returns true if an entry</span>
        <span class="tok-comment">/// was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.swapRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.swapRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.  Returns true if an entry was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.unmanaged.swapRemoveAtContext(index, self.ctx);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.unmanaged.orderedRemoveAtContext(index, self.ctx);
        }

        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context and allocator as this instance.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context as this instance, but the specified</span>
        <span class="tok-comment">/// allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(allocator, self.ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same allocator as this instance, but the</span>
        <span class="tok-comment">/// specified context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the specified allocator and context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, ctx);
            <span class="tok-kw">return</span> other.promoteContext(allocator, ctx);
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            self.unmanaged.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.unmanaged = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Recomputes stored hashes and rebuilds the key indexes. If the</span>
        <span class="tok-comment">/// underlying keys have been modified directly, call this method to</span>
        <span class="tok-comment">/// recompute the denormalized metadata necessary for the operation of</span>
        <span class="tok-comment">/// the methods of this map that lookup entries by key.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// One use case for this is directly calling `entries.resize()` to grow</span>
        <span class="tok-comment">/// the underlying storage, and then setting the `keys` and `values`</span>
        <span class="tok-comment">/// directly without going through the methods of this map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// The time complexity of this operation is O(n).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.reIndexContext(self.allocator, self.ctx);
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.sortContext(sort_ctx, self.ctx);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.shrinkRetainingCapacityContext(new_len, self.ctx);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacity` can be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.shrinkAndFreeContext(self.allocator, new_len, self.ctx);
        }

        <span class="tok-comment">/// Removes the last inserted `Entry` in the hash map and returns it if count is nonzero.</span>
        <span class="tok-comment">/// Otherwise returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.popContext(self.ctx);
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.ArrayHashMapWithAllocator" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayHashMapWithAllocator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator">[src]</a></h2><div class="tldDocs"><p>A hash table of keys and values, each stored sequentially.</p>
<p>Insertion order is preserved. In general, this data structure supports the same
operations as <code><a href="std.array_list.html#std.array_list.ArrayList">std.ArrayList</a></code>.</p>
<p>Deletion operations:</p>
<ul>
<li><code>swapRemove</code> - O(1)</li>
<li><code>orderedRemove</code> - O(N)</li>
</ul>
<p>Modifying the hash map while iterating is allowed, however, one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.</p>
<p>See <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> for a variant of this data structure that accepts an
<code><a href="std.mem.Allocator.html">Allocator</a></code> as a parameter when needed rather than storing it.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>A namespace that provides these two functions:</p>
<ul>
<li><code>pub fn hash(self, K) u32</code></li>
<li><code>pub fn eql(self, K, K, usize) bool</code></li>
</ul>
<p>The final <code>usize</code> in the <code>eql</code> function represents the index of the key
that's already inside the map.</p>
</div></div><div><pre><code>store_hash: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>When <code>false</code>, this data structure is biased towards cheap <code>eql</code>
functions and avoids storing each key's hash in the table. Setting
<code>store_hash</code> to <code>true</code> incurs more memory cost but limits <code>eql</code> to
being called only once per insertion/deletion (provided there are no
hash collisions).</p>
</div></div></div></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Unmanaged</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMapUnmanaged type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>unmanaged: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Entry" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Entry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Entry">[src]</a></h3><div class="tldDocs"><p>Pointers to a key and value in the backing store of this map.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless <code>ensureTotalCapacity</code>/<code>ensureUnusedCapacity</code> was previously used.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Entry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Entry</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.KV" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">KV</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.KV">[src]</a></h3><div class="tldDocs"><p>A KV pair which has been copied out of the backing store</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.KV">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">KV</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Data" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Data</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Data">[src]</a></h3><div class="tldDocs"><p>The Data type used for the MultiArrayList backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Data">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Data</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.DataList" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">DataList</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Hash</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">GetOrPutResult</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">[src]</a></h3><div class="tldDocs"><p>getOrPut variants return this structure, with pointers
to the backing store and a flag to indicate whether an
existing entry was found.
Modifying the key is allowed only if it does not change the hash.
Modifying the value is allowed.
Entry pointers become invalid whenever this ArrayHashMap is modified,
unless <code>ensureTotalCapacity</code>/<code>ensureUnusedCapacity</code> was previously used.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.Iterator" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">Iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Iterator">[src]</a></h3><div class="tldDocs"><p>An Iterator over Entry pointers.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a></code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create an ArrayHashMap instance which will use a specified allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call initContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.initContext">initContext</a>(allocator, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.initContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">initContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.initContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.initContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = .empty,
        .allocator = allocator,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.deinit(self.allocator);
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.lockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    self.unmanaged.unlockPointers();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.count();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K {
    <span class="tok-kw">return</span> self.unmanaged.keys();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V {
    <span class="tok-kw">return</span> self.unmanaged.values();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a> {
    <span class="tok-kw">return</span> self.unmanaged.iterator();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
    <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, new_capacity, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>additional_count: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.capacity();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happuns, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
    <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.getIndexContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.unmanaged.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.swapRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.swapRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContext(key, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContextAdapted(key, ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.unmanaged.swapRemoveAtContext(index, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    self.unmanaged.orderedRemoveAtContext(index, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context and allocator as this instance.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but the specified
allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, self.ctx);
    <span class="tok-kw">return</span> other.promoteContext(allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash)</code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same allocator as this instance, but the
specified context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, ctx);
    <span class="tok-kw">return</span> other.promoteContext(self.allocator, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneWithAllocatorAndContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash)</code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the specified allocator and context.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.cloneWithAllocatorAndContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
    <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, ctx);
    <span class="tok-kw">return</span> other.promoteContext(allocator, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
    self.unmanaged.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.unmanaged = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.reIndexContext(self.allocator, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code></p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.sortContext(sort_ctx, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.shrinkRetainingCapacityContext(new_len, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.unmanaged.shrinkAndFreeContext(self.allocator, new_len, self.ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapWithAllocator.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapWithAllocator.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it if count is nonzero.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
    <span class="tok-kw">return</span> self.unmanaged.popContext(self.ctx);
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapWithAllocator">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayHashMapWithAllocator</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-comment">/// A namespace that provides these two functions:</span>
    <span class="tok-comment">/// * `pub fn hash(self, K) u32`</span>
    <span class="tok-comment">/// * `pub fn eql(self, K, K, usize) bool`</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The final `usize` in the `eql` function represents the index of the key</span>
    <span class="tok-comment">/// that's already inside the map.</span>
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-comment">/// When `false`, this data structure is biased towards cheap `eql`</span>
    <span class="tok-comment">/// functions and avoids storing each key's hash in the table. Setting</span>
    <span class="tok-comment">/// `store_hash` to `true` incurs more memory cost but limits `eql` to</span>
    <span class="tok-comment">/// being called only once per insertion/deletion (provided there are no</span>
    <span class="tok-comment">/// hash collisions).</span>
    <span class="tok-kw">comptime</span> store_hash: <span class="tok-type">bool</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        unmanaged: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        ctx: Context,

        <span class="tok-comment">/// The ArrayHashMapUnmanaged type using the same settings as this managed map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, Context, store_hash);

        <span class="tok-comment">/// Pointers to a key and value in the backing store of this map.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Entry</a>;

        <span class="tok-comment">/// A KV pair which has been copied out of the backing store</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">KV</a>;

        <span class="tok-comment">/// The Data type used for the MultiArrayList backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Data</a>;
        <span class="tok-comment">/// The MultiArrayList type backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">DataList</a>;

        <span class="tok-comment">/// The stored hash type, either u32 or void.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Hash</a>;

        <span class="tok-comment">/// getOrPut variants return this structure, with pointers</span>
        <span class="tok-comment">/// to the backing store and a flag to indicate whether an</span>
        <span class="tok-comment">/// existing entry was found.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a>;

        <span class="tok-comment">/// An Iterator over Entry pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a>;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Create an ArrayHashMap instance which will use a specified allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call initContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.initContext">initContext</a>(allocator, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Frees the backing allocation and leaves the map in an undefined state.</span>
        <span class="tok-comment">/// Note that this does not free keys or values.  You must take care of that</span>
        <span class="tok-comment">/// before calling this function, if it is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.deinit(self.allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.lockPointers();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.unlockPointers();
        }

        <span class="tok-comment">/// Clears the map but retains the backing allocation for future use.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
        }

        <span class="tok-comment">/// Clears the map and releases the backing allocation</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
        }

        <span class="tok-comment">/// Returns the number of KV pairs stored in this map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.count();
        }

        <span class="tok-comment">/// Returns the backing array of keys in this map. Modifying the map may</span>
        <span class="tok-comment">/// invalidate this array. Modifying this array in a way that changes</span>
        <span class="tok-comment">/// key hashes or key equality puts the map into an unusable state until</span>
        <span class="tok-comment">/// `reIndex` is called.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K {
            <span class="tok-kw">return</span> self.unmanaged.keys();
        }
        <span class="tok-comment">/// Returns the backing array of values in this map. Modifying the map</span>
        <span class="tok-comment">/// may invalidate this array. It is permitted to modify the values in</span>
        <span class="tok-comment">/// this array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V {
            <span class="tok-kw">return</span> self.unmanaged.values();
        }

        <span class="tok-comment">/// Returns an iterator over the pairs in this map.</span>
        <span class="tok-comment">/// Modifying the map may invalidate this iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.iterator();
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, new_capacity, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.capacity();
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happuns, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Finds pointers to the key and value storage associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the index in the `entries` array where a key is stored</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.getIndexContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.getIndexAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find a pointer to the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find a pointer to the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Check whether a key is stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by swapping it with the last</span>
        <span class="tok-comment">/// element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by shifting all elements forward</span>
        <span class="tok-comment">/// thereby maintaining the current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.  Returns true if an entry</span>
        <span class="tok-comment">/// was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.swapRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.swapRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.  Returns true if an entry was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.unmanaged.swapRemoveAtContext(index, self.ctx);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.unmanaged.orderedRemoveAtContext(index, self.ctx);
        }

        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context and allocator as this instance.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context as this instance, but the specified</span>
        <span class="tok-comment">/// allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(allocator, self.ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same allocator as this instance, but the</span>
        <span class="tok-comment">/// specified context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the specified allocator and context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, ctx);
            <span class="tok-kw">return</span> other.promoteContext(allocator, ctx);
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            self.unmanaged.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.unmanaged = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Recomputes stored hashes and rebuilds the key indexes. If the</span>
        <span class="tok-comment">/// underlying keys have been modified directly, call this method to</span>
        <span class="tok-comment">/// recompute the denormalized metadata necessary for the operation of</span>
        <span class="tok-comment">/// the methods of this map that lookup entries by key.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// One use case for this is directly calling `entries.resize()` to grow</span>
        <span class="tok-comment">/// the underlying storage, and then setting the `keys` and `values`</span>
        <span class="tok-comment">/// directly without going through the methods of this map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// The time complexity of this operation is O(n).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.reIndexContext(self.allocator, self.ctx);
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.sortContext(sort_ctx, self.ctx);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.shrinkRetainingCapacityContext(new_len, self.ctx);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacity` can be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.shrinkAndFreeContext(self.allocator, new_len, self.ctx);
        }

        <span class="tok-comment">/// Removes the last inserted `Entry` in the hash map and returns it if count is nonzero.</span>
        <span class="tok-comment">/// Otherwise returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.popContext(self.ctx);
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.ArrayHashMapUnmanaged" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">ArrayHashMapUnmanaged</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged">[src]</a></h2><div class="tldDocs"><p>A hash table of keys and values, each stored sequentially.</p>
<p>Insertion order is preserved. In general, this data structure supports the same
operations as <code><a href="std.array_list.html#std.array_list.ArrayListUnmanaged">std.ArrayListUnmanaged</a></code>.</p>
<p>Deletion operations:</p>
<ul>
<li><code>swapRemove</code> - O(1)</li>
<li><code>orderedRemove</code> - O(N)</li>
</ul>
<p>Modifying the hash map while iterating is allowed, however, one must understand
the (well defined) behavior when mixing insertions and deletions with iteration.</p>
<p>This type does not store an <code><a href="std.mem.Allocator.html">Allocator</a></code> field - the <code><a href="std.mem.Allocator.html">Allocator</a></code> must be passed in
with each function call that requires it. See <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a></code> for a type that stores
an <code><a href="std.mem.Allocator.html">Allocator</a></code> field for convenience.</p>
<p>Can be initialized directly using the default field values.</p>
<p>This type is designed to have low overhead for small numbers of entries. When
<code>store_hash</code> is <code>false</code> and the number of entries in the map is less than 9,
the overhead cost of using <code><a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a></code> rather than <code><a href="std.array_list.html#std.array_list.ArrayList">std.ArrayList</a></code> is
only a single pointer-sized integer.</p>
<p>Default initialization of this struct is deprecated; use <code>.empty</code> instead.</p>
</div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>V: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre><div class="fieldDocs"><p>A namespace that provides these two functions:</p>
<ul>
<li><code>pub fn hash(self, K) u32</code></li>
<li><code>pub fn eql(self, K, K, usize) bool</code></li>
</ul>
<p>The final <code>usize</code> in the <code>eql</code> function represents the index of the key
that's already inside the map.</p>
</div></div><div><pre><code>store_hash: <span class="tok-type">bool</span></code></pre><div class="fieldDocs"><p>When <code>false</code>, this data structure is biased towards cheap <code>eql</code>
functions and avoids storing each key's hash in the table. Setting
<code>store_hash</code> to <code>true</code> incurs more memory cost but limits <code>eql</code> to
being called only once per insertion/deletion (provided there are no
hash collisions).</p>
</div></div></div></div><div class="sectContainers"><h3 class="sectionHeader">Container Types</h3><ul class="listContainers columns"><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">std.array_hash_map.ArrayHashMapUnmanaged.Entry</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">std.array_hash_map.ArrayHashMapUnmanaged.KV</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">std.array_hash_map.ArrayHashMapUnmanaged.Data</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult</a></li><li><a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">std.array_hash_map.ArrayHashMapUnmanaged.Iterator</a></li></ul></div><div class="sectTypes"><h3 class="sectionHeader">Types</h3><div class="listTypes"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.DataList" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">DataList</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">[src]</a></h3><div class="tldDocs"><p>The MultiArrayList type backing this map</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.DataList">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>)</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Hash" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Hash</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">[src]</a></h3><div class="tldDocs"><p>The stored hash type, either u32 or void.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span></code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.Managed" class="declHeader"><span class="declHeaderCategory">Type</span><span class="declHeaderIdentifier">Managed</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">[src]</a></h3><div class="tldDocs"><p>The ArrayHashMap type using the same settings as this managed map.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.Managed">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash)</code></pre></details></div></div></div></div><div class="sectFields"><h3 class="sectionHeader">Fields</h3><div class="listFields"><div><pre><code>entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{}</code></pre><div class="fieldDocs"><p>It is permitted to access this field directly.
After any modification to the keys, consider calling <code>reIndex</code>.</p>
</div></div><div><pre><code>index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span></code></pre><div class="fieldDocs"><p>When entries length is less than <code>linear_scan_max</code>, this remains <code>null</code>.
Once entries length grows big enough, this field is allocated. There is
an IndexHeader followed by an array of Index(I) structs, where I is defined
by how many total indexes there are.</p>
</div></div><div><pre><code>pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{}</code></pre><div class="fieldDocs"><p>Used to detect memory safety violations.</p>
</div></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.empty" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">empty</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">[src]</a></h3><div class="tldDocs"><p>A map containing no keys or values.</p>
</div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.empty">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
    .entries = .{},
    .index_header = <span class="tok-null">null</span>,
}</code></pre></details></div></div></div></div><div class="sectFns"><h3 class="sectionHeader">Functions</h3><div class="listFns"><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promote" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promote</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="tldDocs"><p>Convert from an unmanaged map to a managed map.  After calling this,
the promoted map should no longer be used.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promote">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.promoteContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">promoteContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.promoteContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
    <span class="tok-kw">return</span> .{
        .unmanaged = self,
        .allocator = gpa,
        .ctx = ctx,
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.init" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">init</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.init">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    <span class="tok-kw">errdefer</span> self.deinit(gpa);
    <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
    <span class="tok-kw">return</span> self;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>An empty <code>value_list</code> may be passed, in which case the values array becomes <code>undefined</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key_list: []<span class="tok-kw">const</span> K</code></pre></div><div><pre><code>value_list: []<span class="tok-kw">const</span> V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
    <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
    <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
        <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
    } <span class="tok-kw">else</span> {
        <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
        <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
    }
    <span class="tok-kw">try</span> self.reIndex(gpa);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.deinit" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">deinit</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Frees the backing allocation and leaves the map in an undefined state.
Note that this does not free keys or values.  You must take care of that
before calling this function, if it is needed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.deinit">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.assertUnlocked();
    self.entries.deinit(gpa);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
    }
    self.* = <span class="tok-null">undefined</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.lockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Puts the hash map into a state where any method call that would
cause an existing key or value pointer to become invalidated will
instead trigger an assertion.</p>
<p>An additional call to <code>lockPointers</code> in such state also triggers an
assertion.</p>
<p><code>unlockPointers</code> returns the hash map to the previous state.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.lockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">unlockPointers</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Undoes a call to <code>lockPointers</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.unlockPointers">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.unlock();
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map but retains the backing allocation for future use.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.len = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">switch</span> (header.capacityIndexType()) {
            .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
            .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
            .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
        }
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clearAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clears the map and releases the backing allocation</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clearAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
    <span class="tok-kw">if</span> (self.index_header) |header| {
        header.free(gpa);
        self.index_header = <span class="tok-null">null</span>;
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.count" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">count</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of KV pairs stored in this map.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.count">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.entries.len;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.keys" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">keys</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K</code></pre></div><div class="tldDocs"><p>Returns the backing array of keys in this map. Modifying the map may
invalidate this array. Modifying this array in a way that changes
key hashes or key equality puts the map into an unusable state until
<code>reIndex</code> is called.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.keys">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
    <span class="tok-kw">return</span> self.entries.items(.key);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.values" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">values</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V</code></pre></div><div class="tldDocs"><p>Returns the backing array of values in this map. Modifying the map
may invalidate this array. It is permitted to modify the values in
this array.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.values">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
    <span class="tok-kw">return</span> self.entries.items(.value);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.iterator" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">iterator</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a></code></pre></div><div class="tldDocs"><p>Returns an iterator over the pairs in this map.
Modifying the map may invalidate this iterator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.iterator">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> .{
        .keys = slice.items(.key).ptr,
        .values = slice.items(.value).ptr,
        .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If key exists this function cannot fail.
If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
        // &quot;If key exists this function cannot fail.&quot;
        </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            .found_existing = <span class="tok-null">true</span>,
            .index = index,
        };
    };
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointer points to it, and found_existing is true.
Otherwise, puts a new item with undefined value, and
the <code>Entry</code> pointer points to it. Caller should then initialize
the value (but not the key).
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
    <span class="tok-kw">if</span> (!gop.found_existing) {
        gop.key_ptr.* = key;
    }
    <span class="tok-kw">return</span> gop;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutAssumeCapacityAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="tldDocs"><p>If there is an existing item with <code>key</code>, then the result
<code>Entry</code> pointers point to it, and found_existing is true.
Otherwise, puts a new item with undefined key and value, and
the <code>Entry</code> pointers point to it. Caller must then initialize
both the key and the value.
If a new entry needs to be stored, this function asserts there
is enough capacity to store it.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutAssumeCapacityAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = item_key,<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = i,
                };
            }
        }

        <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
        // The slice length changed, so we directly index the pointer.
        </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
            .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
            // workaround for #6974
            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
            .found_existing = <span class="tok-null">false</span>,
            .index = index,
        };
    };

    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValue</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValue">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getOrPutValueContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getOrPutValueContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
    <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
    <span class="tok-kw">if</span> (!res.found_existing) {
        res.key_ptr.* = key;
        res.value_ptr.* = value;
    }
    <span class="tok-kw">return</span> res;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until the
<code>expected_count</code> will not cause an allocation, and therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureTotalCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureTotalCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
        <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
        <span class="tok-kw">return</span>;
    }

    <span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">return</span>;
        }
    }

    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
    <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
    <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

    <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
    self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
    self.index_header = new_header;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Increases capacity, guaranteeing that insertions up until
<code>additional_count</code> <strong>more</strong> items will not cause an allocation, and
therefore cannot fail.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">ensureUnusedCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>( self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, additional_capacity: <span class="tok-type">usize</span>, ctx: Context, ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>additional_capacity: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.ensureUnusedCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
    self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
    gpa: <a href="std.mem.Allocator.html">Allocator</a>,
    additional_capacity: <span class="tok-type">usize</span>,
    ctx: Context,
) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.capacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">capacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Returns the number of total elements which may be present before it is
no longer guaranteed that no allocations will be performed.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.capacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
    <span class="tok-kw">const</span> indexes_cap = header.capacity();
    <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.put" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">put</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPut</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.put">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Inserts a key-value pair into the hash map, asserting that no previous
entry with the same key is already present</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Clobbers any existing data. To detect if a put would clobber
existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobber</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Asserts there is enough capacity to store the new key-value pair.
Asserts that it does not clobber any existing data.
To detect if a put would clobber existing data, see <code>getOrPutAssumeCapacity</code>.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobber">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">putAssumeCapacityNoClobberContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.putAssumeCapacityNoClobberContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
    <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
    result.value_ptr.* = value;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPut" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPut</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPut">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Inserts a new <code>Entry</code> into the hash map, returning the previous one, if any.
If insertion happens, asserts there is enough capacity without allocating.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchPutAssumeCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>value: V</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchPutAssumeCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
    <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (gop.found_existing) {
        result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
            .key = gop.key_ptr.*,
            .value = gop.value_ptr.*,
        };
    }
    gop.value_ptr.* = value;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntry" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntry</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="tldDocs"><p>Finds pointers to the key and value storage associated with a key.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntry">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getEntryAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getEntryAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> slice = self.entries.slice();
    <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
        .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
        // workaround for #6974
        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
    };
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span></code></pre></div><div class="tldDocs"><p>Finds the index in the <code>entries</code> array where a key is stored</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getIndexAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getIndexAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
        // Linear scan.
        </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
        <span class="tok-kw">const</span> slice = self.entries.slice();
        <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
        <span class="tok-kw">const</span> keys_array = slice.items(.key);
        <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
            <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                <span class="tok-kw">return</span> i;
            }
        }
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    };
    <span class="tok-kw">switch</span> (header.capacityIndexType()) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
    }
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.get" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">get</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V</code></pre></div><div class="tldDocs"><p>Find the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.get">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
    <span class="tok-kw">return</span> self.getAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V</code></pre></div><div class="tldDocs"><p>Find a pointer to the value associated with a key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
    <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
    // workaround for #6974
    </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K</code></pre></div><div class="tldDocs"><p>Find the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
    <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtr</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K</code></pre></div><div class="tldDocs"><p>Find a pointer to the actual key associated with an adapted key</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtr">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
    <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getKeyPtrAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K</code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.getKeyPtrAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
    <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-kw">return</span> &amp;self.keys()[index];
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.contains" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">contains</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>Check whether a key is stored in the map</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.contains">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">containsAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.containsAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by swapping it with the last
element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchSwapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchSwapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map, and then returned from this function. The entry is
removed from the underlying array by shifting all elements forward
thereby maintaining the current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">fetchOrderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.fetchOrderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.  Returns true if an entry
was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemove</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span></code></pre></div><div class="tldDocs"><p>If there is an <code>Entry</code> with a matching key, it is deleted from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.  Returns true if an entry was removed, false otherwise.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemove">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveContextAdapted</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveContextAdapted">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by swapping it with the last element.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">swapRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.swapRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAt</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Deletes the item at the specified index in <code>entries</code> from
the hash map. The entry is removed from the underlying array
by shifting all elements forward, thereby maintaining the
current ordering.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAt">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">orderedRemoveAtContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.orderedRemoveAtContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.clone" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">clone</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Create a copy of the hash map which can be modified separately.
The copy uses the same context as this instance, but is allocated
with the provided allocator.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.clone">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.cloneContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">cloneContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.cloneContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
    other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
    <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

    <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
        // TODO: I'm pretty sure this could be memcpy'd instead of
        // doing all this work.
        </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
        other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
        other.index_header = new_header;
    }
    <span class="tok-kw">return</span> other;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.move" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">move</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div class="tldDocs"><p>Set the map to an empty state, making deinitialization a no-op, and
returning a copy of the original.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.move">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
    self.pointer_stability.assertUnlocked();
    <span class="tok-kw">const</span> result = self.*;
    self.* = .empty;
    <span class="tok-kw">return</span> result;
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndex" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndex</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Recomputes stored hashes and rebuilds the key indexes. If the
underlying keys have been modified directly, call this method to
recompute the denormalized metadata necessary for the operation of
the methods of this map that lookup entries by key.</p>
<p>One use case for this is directly calling <code>entries.resize()</code> to grow
the underlying storage, and then setting the <code>keys</code> and <code>values</code>
directly without going through the methods of this map.</p>
<p>The time complexity of this operation is O(n).</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndex">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">reIndexContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.reIndexContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
    // Recompute all hashes.
    </span><span class="tok-kw">if</span> (store_hash) {
        <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            hash.* = h;
        }
    }
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKey" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKey</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Modify an entry's key without reordering any entries.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKey">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">setKeyContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>new_key: K</code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
    key_ptr.* = new_key;
    <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
    <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sort" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sort</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses a stable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sort">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstable</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Sorts the entries and then rebuilds the index.
<code>sort_ctx</code> must have this method:
<code>fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool</code>
Uses an unstable sorting algorithm.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstable">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">sortUnstableContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.sortUnstableContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacity</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacity">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkRetainingCapacityContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Keeps capacity the same.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. Any deinitialization of
discarded entries must take place <em>after</em> calling this function.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkRetainingCapacityContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkRetainingCapacity(new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFree</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacity</code> can be used instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFree">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">shrinkAndFreeContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span></code></pre></div><div class="tldDocs"><p>Shrinks the underlying <code>Entry</code> array to <code>new_len</code> elements and
discards any associated index entries. Reduces allocated capacity.</p>
<p>Asserts the discarded entries remain initialized and capable of
performing hash and equality checks. It is a bug to call this
function if the discarded entries require deinitialization. For
that use case, <code>shrinkRetainingCapacityContext</code> can be used
instead.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>gpa: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div><div><pre><code>new_len: <span class="tok-type">usize</span></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.shrinkAndFreeContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

    // Remove index entries from the new length onwards.
    // Explicitly choose to ONLY remove index entries and not the underlying array list
    // entries as we're going to remove them in the subsequent shrink call.
    </span><span class="tok-kw">if</span> (self.index_header) |header| {
        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
        <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
            self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    }
    self.entries.shrinkAndFree(gpa, new_len);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.pop" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">pop</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="tldDocs"><p>Removes the last inserted <code>Entry</code> in the hash map and returns it.
Otherwise returns null.</p>
</div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.pop">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
    <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
}</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.ArrayHashMapUnmanaged.popContext" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">popContext</span><a href="#src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">[src]</a></h3><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a></code></pre></div><div class="sectParams"><h4 class="sectionHeader">Parameters</h4><div class="listParams"><div><pre><code>self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a></code></pre></div><div><pre><code>ctx: Context</code></pre></div></div></div><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged.popContext">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
    <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    self.pointer_stability.lock();
    <span class="tok-kw">defer</span> self.pointer_stability.unlock();

    <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
    <span class="tok-kw">if</span> (self.index_header) |header|
        self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
    self.entries.len -= <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> .{
        .key = item.key,
        .value = item.value,
    };
}</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.ArrayHashMapUnmanaged">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayHashMapUnmanaged</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-comment">/// A namespace that provides these two functions:</span>
    <span class="tok-comment">/// * `pub fn hash(self, K) u32`</span>
    <span class="tok-comment">/// * `pub fn eql(self, K, K, usize) bool`</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The final `usize` in the `eql` function represents the index of the key</span>
    <span class="tok-comment">/// that's already inside the map.</span>
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-comment">/// When `false`, this data structure is biased towards cheap `eql`</span>
    <span class="tok-comment">/// functions and avoids storing each key's hash in the table. Setting</span>
    <span class="tok-comment">/// `store_hash` to `true` incurs more memory cost but limits `eql` to</span>
    <span class="tok-comment">/// being called only once per insertion/deletion (provided there are no</span>
    <span class="tok-comment">/// hash collisions).</span>
    <span class="tok-kw">comptime</span> store_hash: <span class="tok-type">bool</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// It is permitted to access this field directly.</span>
        <span class="tok-comment">/// After any modification to the keys, consider calling `reIndex`.</span>
        entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{},

        <span class="tok-comment">/// When entries length is less than `linear_scan_max`, this remains `null`.</span>
        <span class="tok-comment">/// Once entries length grows big enough, this field is allocated. There is</span>
        <span class="tok-comment">/// an IndexHeader followed by an array of Index(I) structs, where I is defined</span>
        <span class="tok-comment">/// by how many total indexes there are.</span>
        index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span>,

        <span class="tok-comment">/// Used to detect memory safety violations.</span>
        pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{},

        <span class="tok-comment">/// A map containing no keys or values.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
            .entries = .{},
            .index_header = <span class="tok-null">null</span>,
        };

        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
        };

        <span class="tok-comment">/// A KV pair which has been copied out of the backing store</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <span class="tok-kw">struct</span> {
            key: K,
            value: V,
        };

        <span class="tok-comment">/// The Data type used for the MultiArrayList backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">struct</span> {
            hash: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Hash">Hash</a>,
            key: K,
            value: V,
        };

        <span class="tok-comment">/// The MultiArrayList type backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>);

        <span class="tok-comment">/// The stored hash type, either u32 or void.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span>;

        <span class="tok-comment">/// getOrPut variants return this structure, with pointers</span>
        <span class="tok-comment">/// to the backing store and a flag to indicate whether an</span>
        <span class="tok-comment">/// existing entry was found.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
            found_existing: <span class="tok-type">bool</span>,
            index: <span class="tok-type">usize</span>,
        };

        <span class="tok-comment">/// The ArrayHashMap type using the same settings as this managed map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash);

        <span class="tok-comment">/// Some functions require a context only if hashes are not stored.</span>
        <span class="tok-comment">/// To keep the api simple, this type is only used internally.</span>
        <span class="tok-kw">const</span> ByIndexContext = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">void</span> <span class="tok-kw">else</span> Context;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">const</span> linear_scan_max = <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@min</span>(
            <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.cache_line">cache_line</a> / <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Hash">Hash</a>))),
            <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.cache_line">cache_line</a> / <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@sizeOf</span>(K))),
        ))));

        <span class="tok-kw">const</span> RemovalType = <span class="tok-kw">enum</span> {
            swap,
            ordered,
        };

        <span class="tok-kw">const</span> Oom = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>;

        <span class="tok-comment">/// Convert from an unmanaged map to a managed map.  After calling this,</span>
        <span class="tok-comment">/// the promoted map should no longer be used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = self,
                .allocator = gpa,
                .ctx = ctx,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
            <span class="tok-kw">errdefer</span> self.deinit(gpa);
            <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// An empty `value_list` may be passed, in which case the values array becomes `undefined`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
            <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
            <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
                <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
            } <span class="tok-kw">else</span> {
                <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
                <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
            }
            <span class="tok-kw">try</span> self.reIndex(gpa);
        }

        <span class="tok-comment">/// Frees the backing allocation and leaves the map in an undefined state.</span>
        <span class="tok-comment">/// Note that this does not free keys or values.  You must take care of that</span>
        <span class="tok-comment">/// before calling this function, if it is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.assertUnlocked();
            self.entries.deinit(gpa);
            <span class="tok-kw">if</span> (self.index_header) |header| {
                header.free(gpa);
            }
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.unlock();
        }

        <span class="tok-comment">/// Clears the map but retains the backing allocation for future use.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.entries.len = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                    .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
                    .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
                    .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
                }
            }
        }

        <span class="tok-comment">/// Clears the map and releases the backing allocation</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
            <span class="tok-kw">if</span> (self.index_header) |header| {
                header.free(gpa);
                self.index_header = <span class="tok-null">null</span>;
            }
        }

        <span class="tok-comment">/// Returns the number of KV pairs stored in this map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.entries.len;
        }

        <span class="tok-comment">/// Returns the backing array of keys in this map. Modifying the map may</span>
        <span class="tok-comment">/// invalidate this array. Modifying this array in a way that changes</span>
        <span class="tok-comment">/// key hashes or key equality puts the map into an unusable state until</span>
        <span class="tok-comment">/// `reIndex` is called.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
            <span class="tok-kw">return</span> self.entries.items(.key);
        }
        <span class="tok-comment">/// Returns the backing array of values in this map. Modifying the map</span>
        <span class="tok-comment">/// may invalidate this array. It is permitted to modify the values in</span>
        <span class="tok-comment">/// this array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
            <span class="tok-kw">return</span> self.entries.items(.value);
        }

        <span class="tok-comment">/// Returns an iterator over the pairs in this map.</span>
        <span class="tok-comment">/// Modifying the map may invalidate this iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">return</span> .{
                .keys = slice.items(.key).ptr,
                .values = slice.items(.value).ptr,
                .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
            };
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            keys: [*]K,
            values: [*]V,
            len: <span class="tok-type">u32</span>,
            index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
                <span class="tok-kw">if</span> (it.index &gt;= it.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                <span class="tok-kw">const</span> result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
                    .key_ptr = &amp;it.keys[it.index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;it.values[it.index],
                };
                it.index += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-comment">/// Reset the iterator to the initial index</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(it: *<a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a>) <span class="tok-type">void</span> {
                it.index = <span class="tok-number">0</span>;
            }
        };

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
                // &quot;If key exists this function cannot fail.&quot;
                </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = index,
                };
            };
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined key and value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// both the key and the value.</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                            .key_ptr = item_key,<span class="tok-comment">
                            // workaround for #6974
                            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                            .found_existing = <span class="tok-null">true</span>,
                            .index = i,
                        };
                    }
                }

                <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
                // The slice length changed, so we directly index the pointer.
                </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
                    .found_existing = <span class="tok-null">false</span>,
                    .index = index,
                };
            };

            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
            <span class="tok-kw">if</span> (!res.found_existing) {
                res.key_ptr.* = key;
                res.value_ptr.* = value;
            }
            <span class="tok-kw">return</span> res;
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
                <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
                    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
                    <span class="tok-kw">return</span>;
                }
            }

            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
            <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

            <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
            self.index_header = new_header;
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            gpa: <a href="std.mem.Allocator.html">Allocator</a>,
            additional_capacity: <span class="tok-type">usize</span>,
        ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            gpa: <a href="std.mem.Allocator.html">Allocator</a>,
            additional_capacity: <span class="tok-type">usize</span>,
            ctx: Context,
        ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
            <span class="tok-kw">const</span> indexes_cap = header.capacity();
            <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
            <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Finds pointers to the key and value storage associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
                .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
                // workaround for #6974
                </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            };
        }

        <span class="tok-comment">/// Finds the index in the `entries` array where a key is stored</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                        <span class="tok-kw">return</span> i;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            };
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">getIndexWithHeaderGeneric</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> slot = self.getSlotByKey(key, ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> indexes[slot].entry_index;
        }

        <span class="tok-comment">/// Find the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
            <span class="tok-kw">return</span> self.getAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.values()[index];
        }

        <span class="tok-comment">/// Find a pointer to the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
            <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
            // workaround for #6974
            </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
        }

        <span class="tok-comment">/// Find the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
            <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.keys()[index];
        }

        <span class="tok-comment">/// Find a pointer to the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
            <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> &amp;self.keys()[index];
        }

        <span class="tok-comment">/// Check whether a key is stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by swapping it with the last</span>
        <span class="tok-comment">/// element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by shifting all elements forward</span>
        <span class="tok-comment">/// thereby maintaining the current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.  Returns true if an entry</span>
        <span class="tok-comment">/// was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.  Returns true if an entry was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context as this instance, but is allocated</span>
        <span class="tok-comment">/// with the provided allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
            other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
            <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

            <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
                // TODO: I'm pretty sure this could be memcpy'd instead of
                // doing all this work.
                </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
                other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
                other.index_header = new_header;
            }
            <span class="tok-kw">return</span> other;
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            self.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.* = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Recomputes stored hashes and rebuilds the key indexes. If the</span>
        <span class="tok-comment">/// underlying keys have been modified directly, call this method to</span>
        <span class="tok-comment">/// recompute the denormalized metadata necessary for the operation of</span>
        <span class="tok-comment">/// the methods of this map that lookup entries by key.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// One use case for this is directly calling `entries.resize()` to grow</span>
        <span class="tok-comment">/// the underlying storage, and then setting the `keys` and `values`</span>
        <span class="tok-comment">/// directly without going through the methods of this map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// The time complexity of this operation is O(n).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
            // Recompute all hashes.
            </span><span class="tok-kw">if</span> (store_hash) {
                <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
                    <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
                    hash.* = h;
                }
            }
            <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
        }

        <span class="tok-comment">/// Modify an entry's key without reordering any entries.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
            key_ptr.* = new_key;
            <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
            <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">rebuildIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.entries.capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) <span class="tok-kw">return</span>;<span class="tok-comment">

            // We're going to rebuild the index header and replace the existing one (if any). The
            // indexes should sized such that they will be at most 60% full.
            </span><span class="tok-kw">const</span> bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(self.entries.capacity);
            <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, bit_index);
            <span class="tok-kw">if</span> (self.index_header) |header| header.free(gpa);
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
            self.index_header = new_header;
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-comment">/// Uses a stable sorting algorithm.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-comment">/// Uses an unstable sorting algorithm.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">sortContextInternal</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            <span class="tok-kw">comptime</span> mode: <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.Mode.html">Mode</a>,
            sort_ctx: <span class="tok-kw">anytype</span>,
            ctx: Context,
        ) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">switch</span> (mode) {
                .stable =&gt; self.entries.sort(sort_ctx),
                .unstable =&gt; self.entries.sortUnstable(sort_ctx),
            }
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
            header.reset();
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

            // Remove index entries from the new length onwards.
            // Explicitly choose to ONLY remove index entries and not the underlying array list
            // entries as we're going to remove them in the subsequent shrink call.
            </span><span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
                <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
                    self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            }
            self.entries.shrinkRetainingCapacity(new_len);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacity` can be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacityContext` can be used</span>
        <span class="tok-comment">/// instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

            // Remove index entries from the new length onwards.
            // Explicitly choose to ONLY remove index entries and not the underlying array list
            // entries as we're going to remove them in the subsequent shrink call.
            </span><span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
                <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
                    self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            }
            self.entries.shrinkAndFree(gpa, new_len);
        }

        <span class="tok-comment">/// Removes the last inserted `Entry` in the hash map and returns it.</span>
        <span class="tok-comment">/// Otherwise returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
            <span class="tok-kw">if</span> (self.index_header) |header|
                self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            self.entries.len -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> .{
                .key = item.key,
                .value = item.value,
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveByKey</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> key_hash = <span class="tok-kw">if</span> (store_hash) key_ctx.hash(key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) hashes_array[i] == key_hash <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                    <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> key_ctx.eql(key, item_key.*, i)) {
                        <span class="tok-kw">const</span> removed_entry: <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = .{
                            .key = keys_array[i],
                            .value = slice.items(.value)[i],
                        };
                        <span class="tok-kw">switch</span> (removal_type) {
                            .swap =&gt; self.entries.swapRemove(i),
                            .ordered =&gt; self.entries.orderedRemove(i),
                        }
                        <span class="tok-kw">return</span> removed_entry;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            };
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u32</span>, removal_type),
            };
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveByKeyGeneric</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>,
            <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> entry_index = self.removeFromIndexByKey(key, key_ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> removed_entry: <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = .{
                .key = slice.items(.key)[entry_index],
                .value = slice.items(.value)[entry_index],
            };
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
            <span class="tok-kw">return</span> removed_entry;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByKey</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> key_hash = <span class="tok-kw">if</span> (store_hash) key_ctx.hash(key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) hashes_array[i] == key_hash <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                    <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> key_ctx.eql(key, item_key.*, i)) {
                        <span class="tok-kw">switch</span> (removal_type) {
                            .swap =&gt; self.entries.swapRemove(i),
                            .ordered =&gt; self.entries.orderedRemove(i),
                        }
                        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            };
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u32</span>, removal_type),
            };
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeByKeyGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> entry_index = self.removeFromIndexByKey(key, key_ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(entry_index &lt; self.entries.len);
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {
                <span class="tok-kw">switch</span> (removal_type) {
                    .swap =&gt; self.entries.swapRemove(entry_index),
                    .ordered =&gt; self.entries.orderedRemove(entry_index),
                }
                <span class="tok-kw">return</span>;
            };
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u32</span>, removal_type),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndexGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            self.removeFromIndexByIndexGeneric(entry_index, ctx, header, I, indexes);
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromArrayAndUpdateIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I), <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> last_index = self.entries.len - <span class="tok-number">1</span>;<span class="tok-comment"> // overflow =&gt; remove from empty map
            </span><span class="tok-kw">switch</span> (removal_type) {
                .swap =&gt; {
                    <span class="tok-kw">if</span> (last_index != entry_index) {<span class="tok-comment">
                        // Because of the swap remove, now we need to update the index that was
                        // pointing to the last entry and is now pointing to this removed item slot.
                        </span>self.updateEntryIndex(header, last_index, entry_index, ctx, I, indexes);
                    }<span class="tok-comment">
                    // updateEntryIndex reads from the old entry index,
                    // so it needs to run before removal.
                    </span>self.entries.swapRemove(entry_index);
                },
                .ordered =&gt; {
                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = entry_index;
                    <span class="tok-kw">while</span> (i &lt; last_index) : (i += <span class="tok-number">1</span>) {<span class="tok-comment">
                        // Because of the ordered remove, everything from the entry index onwards has
                        // been shifted forward so we'll need to update the index entries.
                        </span>self.updateEntryIndex(header, i + <span class="tok-number">1</span>, i, ctx, I, indexes);
                    }<span class="tok-comment">
                    // updateEntryIndex reads from the old entry index,
                    // so it needs to run before removal.
                    </span>self.entries.orderedRemove(entry_index);
                },
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">updateEntryIndex</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>,
            old_entry_index: <span class="tok-type">usize</span>,
            new_entry_index: <span class="tok-type">usize</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>,
            indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I),
        ) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByIndex(old_entry_index, ctx, header, I, indexes);
            indexes[slot].entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_entry_index));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u8</span>, header.indexes(<span class="tok-type">u8</span>)),
                .<span class="tok-type">u16</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u16</span>, header.indexes(<span class="tok-type">u16</span>)),
                .<span class="tok-type">u32</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u32</span>, header.indexes(<span class="tok-type">u32</span>)),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByIndexGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByIndex(entry_index, ctx, header, I, indexes);
            <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.removeSlot">removeSlot</a>(slot, header, I, indexes);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByKey(key, ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> removed_entry_index = indexes[slot].entry_index;
            <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.removeSlot">removeSlot</a>(slot, header, I, indexes);
            <span class="tok-kw">return</span> removed_entry_index;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeSlot</span>(removed_slot: <span class="tok-type">usize</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> start_index = removed_slot +% <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> last_slot = removed_slot;
            <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = start_index;
            <span class="tok-kw">while</span> (index != end_index) : (index +%= <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];
                <span class="tok-kw">if</span> (slot_data.isEmpty() <span class="tok-kw">or</span> slot_data.distance_from_start_index == <span class="tok-number">0</span>) {
                    indexes[last_slot].setEmpty();
                    <span class="tok-kw">return</span>;
                }
                indexes[last_slot] = .{
                    .entry_index = slot_data.entry_index,
                    .distance_from_start_index = slot_data.distance_from_start_index - <span class="tok-number">1</span>,
                };
                last_slot = slot;
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSlotByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) slice.items(.hash)[entry_index] <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, slice.items(.key)[entry_index]);
            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];<span class="tok-comment">

                // This is the fundamental property of the array hash map index.  If this
                // assert fails, it probably means that the entry was not in the index.
                </span><a href="std.debug.html#std.debug.assert">assert</a>(!slot_data.isEmpty());
                <a href="std.debug.html#std.debug.assert">assert</a>(slot_data.distance_from_start_index &gt;= distance_from_start_index);

                <span class="tok-kw">if</span> (slot_data.entry_index == entry_index) {
                    <span class="tok-kw">return</span> slot;
                }
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-comment">/// Must `ensureTotalCapacity`/`ensureUnusedCapacity` before calling this.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutInternal</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
            <span class="tok-kw">const</span> keys_array = slice.items(.key);
            <span class="tok-kw">const</span> values_array = slice.items(.value);
            <span class="tok-kw">const</span> indexes = header.indexes(I);

            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">var</span> slot = header.constrainIndex(index);
                <span class="tok-kw">var</span> slot_data = indexes[slot];<span class="tok-comment">

                // If the slot is empty, there can be no more items in this run.
                // We didn't find a matching item, so this must be new.
                // Put it in the empty slot.
                </span><span class="tok-kw">if</span> (slot_data.isEmpty()) {
                    <span class="tok-kw">const</span> new_index = self.entries.addOneAssumeCapacity();
                    indexes[slot] = .{
                        .distance_from_start_index = distance_from_start_index,
                        .entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_index)),
                    };<span class="tok-comment">

                    // update the hash if applicable
                    </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[new_index] = h;

                    <span class="tok-kw">return</span> .{
                        .found_existing = <span class="tok-null">false</span>,
                        .key_ptr = &amp;keys_array.ptr[new_index],<span class="tok-comment">
                        // workaround for #6974
                        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array.ptr[new_index],
                        .index = new_index,
                    };
                }<span class="tok-comment">

                // This pointer survives the following append because we call
                // entries.ensureTotalCapacity before getOrPutInternal.
                </span><span class="tok-kw">const</span> i = slot_data.entry_index;
                <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) h == hashes_array[i] <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, keys_array[i], i)) {
                    <span class="tok-kw">return</span> .{
                        .found_existing = <span class="tok-null">true</span>,
                        .key_ptr = &amp;keys_array[slot_data.entry_index],<span class="tok-comment">
                        // workaround for #6974
                        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array[slot_data.entry_index],
                        .index = slot_data.entry_index,
                    };
                }<span class="tok-comment">

                // If the entry is closer to its target than our current distance,
                // the entry we are looking for does not exist.  It would be in
                // this slot instead if it was here.  So stop looking, and switch
                // to insert mode.
                </span><span class="tok-kw">if</span> (slot_data.distance_from_start_index &lt; distance_from_start_index) {<span class="tok-comment">
                    // In this case, we did not find the item. We will put a new entry.
                    // However, we will use this index for the new entry, and move
                    // the previous index down the line, to keep the max distance_from_start_index
                    // as small as possible.
                    </span><span class="tok-kw">const</span> new_index = self.entries.addOneAssumeCapacity();
                    <span class="tok-kw">if</span> (store_hash) hashes_array.ptr[new_index] = h;
                    indexes[slot] = .{
                        .entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_index)),
                        .distance_from_start_index = distance_from_start_index,
                    };
                    distance_from_start_index = slot_data.distance_from_start_index;
                    <span class="tok-kw">var</span> displaced_index = slot_data.entry_index;<span class="tok-comment">

                    // Find somewhere to put the index we replaced by shifting
                    // following indexes backwards.
                    </span>index +%= <span class="tok-number">1</span>;
                    distance_from_start_index += <span class="tok-number">1</span>;
                    <span class="tok-kw">while</span> (index != end_index) : ({
                        index +%= <span class="tok-number">1</span>;
                        distance_from_start_index += <span class="tok-number">1</span>;
                    }) {
                        slot = header.constrainIndex(index);
                        slot_data = indexes[slot];
                        <span class="tok-kw">if</span> (slot_data.isEmpty()) {
                            indexes[slot] = .{
                                .entry_index = displaced_index,
                                .distance_from_start_index = distance_from_start_index,
                            };
                            <span class="tok-kw">return</span> .{
                                .found_existing = <span class="tok-null">false</span>,
                                .key_ptr = &amp;keys_array.ptr[new_index],<span class="tok-comment">
                                // workaround for #6974
                                </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array.ptr[new_index],
                                .index = new_index,
                            };
                        }

                        <span class="tok-kw">if</span> (slot_data.distance_from_start_index &lt; distance_from_start_index) {
                            indexes[slot] = .{
                                .entry_index = displaced_index,
                                .distance_from_start_index = distance_from_start_index,
                            };
                            displaced_index = slot_data.entry_index;
                            distance_from_start_index = slot_data.distance_from_start_index;
                        }
                    }
                    <span class="tok-kw">unreachable</span>;
                }
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSlotByKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
            <span class="tok-kw">const</span> keys_array = slice.items(.key);
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);

            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];
                <span class="tok-kw">if</span> (slot_data.isEmpty() <span class="tok-kw">or</span> slot_data.distance_from_start_index &lt; distance_from_start_index)
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                <span class="tok-kw">const</span> i = slot_data.entry_index;
                <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) h == hashes_array[i] <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, keys_array[i], i))
                    <span class="tok-kw">return</span> slot;
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">insertAllEntriesIntoNewHeader</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u32</span>),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">insertAllEntriesIntoNewHeaderGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> items = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> slice.items(.key);
            <span class="tok-kw">const</span> indexes = header.indexes(I);

            entry_loop: <span class="tok-kw">for</span> (items, <span class="tok-number">0</span>..) |key, i| {
                <span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) key <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
                <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
                <span class="tok-kw">const</span> end_index = start_index +% indexes.len;
                <span class="tok-kw">var</span> index = start_index;
                <span class="tok-kw">var</span> entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(i));
                <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (index != end_index) : ({
                    index +%= <span class="tok-number">1</span>;
                    distance_from_start_index += <span class="tok-number">1</span>;
                }) {
                    <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                    <span class="tok-kw">const</span> next_index = indexes[slot];
                    <span class="tok-kw">if</span> (next_index.isEmpty()) {
                        indexes[slot] = .{
                            .distance_from_start_index = distance_from_start_index,
                            .entry_index = entry_index,
                        };
                        <span class="tok-kw">continue</span> :entry_loop;
                    }
                    <span class="tok-kw">if</span> (next_index.distance_from_start_index &lt; distance_from_start_index) {
                        indexes[slot] = .{
                            .distance_from_start_index = distance_from_start_index,
                            .entry_index = entry_index,
                        };
                        distance_from_start_index = next_index.distance_from_start_index;
                        entry_index = next_index.entry_index;
                    }
                }
                <span class="tok-kw">unreachable</span>;
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">checkedHash</span>(ctx: <span class="tok-kw">anytype</span>, key: <span class="tok-kw">anytype</span>) <span class="tok-type">u32</span> {<span class="tok-comment">
            // If you get a compile error on the next line, it means that your
            // generic hash function doesn't accept your key.
            </span><span class="tok-kw">return</span> ctx.hash(key);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">checkedEql</span>(ctx: <span class="tok-kw">anytype</span>, a: <span class="tok-kw">anytype</span>, b: K, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {<span class="tok-comment">
            // If you get a compile error on the next line, it means that your
            // generic eql function doesn't accept (self, adapt key, K, index).
            </span><span class="tok-kw">return</span> ctx.eql(a, b, b_index);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpState</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, <span class="tok-kw">comptime</span> keyFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> valueFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call dumpStateContext instead.&quot;</span>);
            self.dumpStateContext(keyFmt, valueFmt, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">dumpStateContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, <span class="tok-kw">comptime</span> keyFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> valueFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> p = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>;
            p(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>)});
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hash_status = <span class="tok-kw">if</span> (store_hash) <span class="tok-str">&quot;stored&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;computed&quot;</span>;
            p(<span class="tok-str">&quot;  len={} capacity={} hashes {s}\n&quot;</span>, .{ slice.len, slice.capacity, hash_status });
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> mask: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (self.index_header) |header| header.mask() <span class="tok-kw">else</span> ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">while</span> (i &lt; slice.len) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> hash = <span class="tok-kw">if</span> (store_hash) slice.items(.hash)[i] <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, slice.items(.key)[i]);
                <span class="tok-kw">if</span> (store_hash) {
                    p(
                        <span class="tok-str">&quot;  [{}]: key=&quot;</span> ++ keyFmt ++ <span class="tok-str">&quot; value=&quot;</span> ++ valueFmt ++ <span class="tok-str">&quot; hash=0x{x} slot=[0x{x}]\n&quot;</span>,
                        .{ i, slice.items(.key)[i], slice.items(.value)[i], hash, hash &amp; mask },
                    );
                } <span class="tok-kw">else</span> {
                    p(
                        <span class="tok-str">&quot;  [{}]: key=&quot;</span> ++ keyFmt ++ <span class="tok-str">&quot; value=&quot;</span> ++ valueFmt ++ <span class="tok-str">&quot; slot=[0x{x}]\n&quot;</span>,
                        .{ i, slice.items(.key)[i], slice.items(.value)[i], hash &amp; mask },
                    );
                }
            }
            <span class="tok-kw">if</span> (self.index_header) |header| {
                p(<span class="tok-str">&quot;\n&quot;</span>, .{});
                <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                    .<span class="tok-type">u8</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u8</span>),
                    .<span class="tok-type">u16</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u16</span>),
                    .<span class="tok-type">u32</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u32</span>),
                }
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">dumpIndex</span>(header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> p = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>;
            p(<span class="tok-str">&quot;  index len=0x{x} type={}\n&quot;</span>, .{ header.length(), header.capacityIndexType() });
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">if</span> (indexes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
            <span class="tok-kw">var</span> is_empty = <span class="tok-null">false</span>;
            <span class="tok-kw">for</span> (indexes, <span class="tok-number">0</span>..) |idx, i| {
                <span class="tok-kw">if</span> (idx.isEmpty()) {
                    is_empty = <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">if</span> (is_empty) {
                        is_empty = <span class="tok-null">false</span>;
                        p(<span class="tok-str">&quot;  ...\n&quot;</span>, .{});
                    }
                    p(<span class="tok-str">&quot;  [0x{x}]: [{}] +{}\n&quot;</span>, .{ i, idx.entry_index, idx.distance_from_start_index });
                }
            }
            <span class="tok-kw">if</span> (is_empty) {
                p(<span class="tok-str">&quot;  ...\n&quot;</span>, .{});
            }
        }
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.AutoContext" class="declHeader"><span class="declHeaderCategory">Type Function</span><span class="declHeaderIdentifier">AutoContext</span><a href="#src.zig-std.array_hash_map.AutoContext">[src]</a></h2><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectValues"><h3 class="sectionHeader">Values</h3><div class="listValues"><div class="decl"><h3 id="std.array_hash_map.AutoContext.hash" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">hash</span><a href="#src.zig-std.array_hash_map.AutoContext.hash">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.AutoContext.hash">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> hash = <a href="std.array_hash_map.html#std.array_hash_map.getAutoHashFn">getAutoHashFn</a>(K, <span class="tok-builtin">@This</span>())</code></pre></details></div></div><div class="decl"><h3 id="std.array_hash_map.AutoContext.eql" class="declHeader"><span class="declHeaderCategory">Constant</span><span class="declHeaderIdentifier">eql</span><a href="#src.zig-std.array_hash_map.AutoContext.eql">[src]</a></h3><div class="sectSource"><h4 class="sectionHeader" id="src.zig-std.array_hash_map.AutoContext.eql">Source Code</h4><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> eql = <a href="std.array_hash_map.html#std.array_hash_map.getAutoEqlFn">getAutoEqlFn</a>(K, <span class="tok-builtin">@This</span>())</code></pre></details></div></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.AutoContext">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoContext</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hash = <a href="std.array_hash_map.html#std.array_hash_map.getAutoHashFn">getAutoHashFn</a>(K, <span class="tok-builtin">@This</span>());
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> eql = <a href="std.array_hash_map.html#std.array_hash_map.getAutoEqlFn">getAutoEqlFn</a>(K, <span class="tok-builtin">@This</span>());
    };
}</code></pre></details></div></div></div></div><div class="sectFns"><h2 class="sectionHeader">Functions</h2><div class="listFns"><div class="decl"><h2 id="std.array_hash_map.eqlString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">eqlString</span><a href="#src.zig-std.array_hash_map.eqlString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlString</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div><div><pre><code>b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.eqlString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlString</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, b);
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.hashString" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">hashString</span><a href="#src.zig-std.array_hash_map.hashString">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hashString</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u32</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.hashString">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hashString</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, s)));
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.f" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">f</span><a href="#src.zig-std.array_hash_map.f">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">f</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-type">void</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>allocator: <a href="std.mem.Allocator.html">Allocator</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.f">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">f</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(allocator);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;<span class="tok-comment">
    // put more than `linear_scan_max` in so index_header gets allocated.
    </span><span class="tok-kw">while</span> (i &lt;= <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) <span class="tok-kw">try</span> map.put(i, i);
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.lessThan" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">lessThan</span><a href="#src.zig-std.array_hash_map.lessThan">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a_index: <span class="tok-type">usize</span>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>ctx: <span class="tok-builtin">@This</span>()</code></pre></div><div><pre><code>a_index: <span class="tok-type">usize</span></code></pre></div><div><pre><code>b_index: <span class="tok-type">usize</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.lessThan">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a_index: <span class="tok-type">usize</span>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> ctx.keys[a_index] &lt; ctx.keys[b_index];
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.getHashPtrAddrFn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getHashPtrAddrFn</span><a href="#src.zig-std.array_hash_map.getHashPtrAddrFn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getHashPtrAddrFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.getHashPtrAddrFn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getHashPtrAddrFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: Context, key: K) <span class="tok-type">u32</span> {
            _ = ctx;
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.getAutoHashFn">getAutoHashFn</a>(<span class="tok-type">usize</span>, <span class="tok-type">void</span>)({}, <span class="tok-builtin">@intFromPtr</span>(key));
        }
    }.hash;
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.getTrivialEqlFn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getTrivialEqlFn</span><a href="#src.zig-std.array_hash_map.getTrivialEqlFn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getTrivialEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K) <span class="tok-type">bool</span>)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.getTrivialEqlFn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getTrivialEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K) <span class="tok-type">bool</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: Context, a: K, b: K) <span class="tok-type">bool</span> {
            _ = ctx;
            <span class="tok-kw">return</span> a == b;
        }
    }.eql;
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.getAutoHashFn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAutoHashFn</span><a href="#src.zig-std.array_hash_map.getAutoHashFn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.getAutoHashFn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: Context, key: K) <span class="tok-type">u32</span> {
            _ = ctx;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(K)) {
                <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key)));
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> hasher = <a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
                <a href="std.hash.auto_hash.html#std.hash.auto_hash.autoHash">autoHash</a>(&amp;hasher, key);
                <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
            }
        }
    }.hash;
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.getAutoEqlFn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAutoEqlFn</span><a href="#src.zig-std.array_hash_map.getAutoEqlFn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K, <span class="tok-type">usize</span>) <span class="tok-type">bool</span>)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.getAutoEqlFn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K, <span class="tok-type">usize</span>) <span class="tok-type">bool</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: Context, a: K, b: K, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            _ = b_index;
            _ = ctx;
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(a, b);
        }
    }.eql;
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.autoEqlIsCheap" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">autoEqlIsCheap</span><a href="#src.zig-std.array_hash_map.autoEqlIsCheap">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">autoEqlIsCheap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>) <span class="tok-type">bool</span></code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.autoEqlIsCheap">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">autoEqlIsCheap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(K)) {
        .<span class="tok-type">bool</span>,
        .int,
        .float,
        .pointer,
        .<span class="tok-type">comptime_float</span>,
        .<span class="tok-type">comptime_int</span>,
        .@&quot;enum&quot;,
        .@&quot;fn&quot;,
        .error_set,
        .@&quot;anyframe&quot;,
        .enum_literal,
        =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
}</code></pre></details></div></div><div class="decl"><h2 id="std.array_hash_map.getAutoHashStratFn" class="declHeader"><span class="declHeaderCategory">Function</span><span class="declHeaderIdentifier">getAutoHashStratFn</span><a href="#src.zig-std.array_hash_map.getAutoHashStratFn">[src]</a></h2><div class="fnProto"><pre><code class="fnProtoCode"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashStratFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> strategy: <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.auto_hash.HashStrategy.html">Strategy</a>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>)</code></pre></div><div class="sectParams"><h3 class="sectionHeader">Parameters</h3><div class="listParams"><div><pre><code>K: <span class="tok-type">type</span></code></pre></div><div><pre><code>Context: <span class="tok-type">type</span></code></pre></div><div><pre><code>strategy: <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.auto_hash.HashStrategy.html">Strategy</a></code></pre></div></div></div><div class="sectSource"><h3 class="sectionHeader" id="src.zig-std.array_hash_map.getAutoHashStratFn">Source Code</h3><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashStratFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> strategy: <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.auto_hash.HashStrategy.html">Strategy</a>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: Context, key: K) <span class="tok-type">u32</span> {
            _ = ctx;
            <span class="tok-kw">var</span> hasher = <a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
            <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.auto_hash.html#std.hash.auto_hash.hash">autoHashStrat</a>(&amp;hasher, key, strategy);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@truncate</span>(hasher.final()));
        }
    }.hash;
}</code></pre></details></div></div></div></div><div class="sectSource"><h2 class="sectionHeader" id="src.zig-std.array_hash_map">Source Code</h2><details><summary>Source code</summary><pre><code class="sourceText"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std.zig&quot;</span>);
<span class="tok-kw">const</span> debug = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>;
<span class="tok-kw">const</span> assert = <a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.assert">assert</a>;
<span class="tok-kw">const</span> testing = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>;
<span class="tok-kw">const</span> math = <a href="std.html">std</a>.<a href="std.math.html">math</a>;
<span class="tok-kw">const</span> mem = <a href="std.html">std</a>.<a href="std.mem.html">mem</a>;
<span class="tok-kw">const</span> autoHash = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.auto_hash.html#std.hash.auto_hash.autoHash">autoHash</a>;
<span class="tok-kw">const</span> Wyhash = <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>;
<span class="tok-kw">const</span> Allocator = <a href="std.mem.html">mem</a>.<a href="std.mem.Allocator.html">Allocator</a>;
<span class="tok-kw">const</span> hash_map = <span class="tok-builtin">@This</span>();

<span class="tok-comment">/// An `ArrayHashMap` with default hash and equal functions.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See `AutoContext` for a description of the hash and equal implementations.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoArrayHashMap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(K), !<a href="std.array_hash_map.html#std.array_hash_map.autoEqlIsCheap">autoEqlIsCheap</a>(K));
}

<span class="tok-comment">/// An `ArrayHashMapUnmanaged` with default hash and equal functions.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See `AutoContext` for a description of the hash and equal implementations.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoArrayHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(K), !<a href="std.array_hash_map.html#std.array_hash_map.autoEqlIsCheap">autoEqlIsCheap</a>(K));
}

<span class="tok-comment">/// An `ArrayHashMap` with strings as keys.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringArrayHashMap</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.array_hash_map.StringContext.html">StringContext</a>, <span class="tok-null">true</span>);
}

<span class="tok-comment">/// An `ArrayHashMapUnmanaged` with strings as keys.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">StringArrayHashMapUnmanaged</span>(<span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, V, <a href="std.array_hash_map.StringContext.html">StringContext</a>, <span class="tok-null">true</span>);
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> StringContext = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(self: <span class="tok-builtin">@This</span>(), s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
        _ = self;
        <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.hashString">hashString</a>(s);
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(self: <span class="tok-builtin">@This</span>(), a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
        _ = self;
        _ = b_index;
        <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.eqlString">eqlString</a>(a, b);
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlString</span>(a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.eql">eql</a>(<span class="tok-type">u8</span>, a, b);
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hashString</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@truncate</span>(<a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, s)));
}

<span class="tok-comment">/// Deprecated in favor of `ArrayHashMapWithAllocator` (no code changes needed)</span>
<span class="tok-comment">/// or `ArrayHashMapUnmanaged` (will need to update callsites to pass an</span>
<span class="tok-comment">/// allocator). After Zig 0.14.0 is released, `ArrayHashMapWithAllocator` will</span>
<span class="tok-comment">/// be removed and `ArrayHashMapUnmanaged` will be a deprecated alias. After</span>
<span class="tok-comment">/// Zig 0.15.0 is released, the deprecated alias `ArrayHashMapUnmanaged` will</span>
<span class="tok-comment">/// be removed.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArrayHashMap = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMapWithAllocator</a>;

<span class="tok-comment">/// A hash table of keys and values, each stored sequentially.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Insertion order is preserved. In general, this data structure supports the same</span>
<span class="tok-comment">/// operations as `std.ArrayList`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Deletion operations:</span>
<span class="tok-comment">/// * `swapRemove` - O(1)</span>
<span class="tok-comment">/// * `orderedRemove` - O(N)</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Modifying the hash map while iterating is allowed, however, one must understand</span>
<span class="tok-comment">/// the (well defined) behavior when mixing insertions and deletions with iteration.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// See `ArrayHashMapUnmanaged` for a variant of this data structure that accepts an</span>
<span class="tok-comment">/// `Allocator` as a parameter when needed rather than storing it.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayHashMapWithAllocator</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-comment">/// A namespace that provides these two functions:</span>
    <span class="tok-comment">/// * `pub fn hash(self, K) u32`</span>
    <span class="tok-comment">/// * `pub fn eql(self, K, K, usize) bool`</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The final `usize` in the `eql` function represents the index of the key</span>
    <span class="tok-comment">/// that's already inside the map.</span>
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-comment">/// When `false`, this data structure is biased towards cheap `eql`</span>
    <span class="tok-comment">/// functions and avoids storing each key's hash in the table. Setting</span>
    <span class="tok-comment">/// `store_hash` to `true` incurs more memory cost but limits `eql` to</span>
    <span class="tok-comment">/// being called only once per insertion/deletion (provided there are no</span>
    <span class="tok-comment">/// hash collisions).</span>
    <span class="tok-kw">comptime</span> store_hash: <span class="tok-type">bool</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        unmanaged: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>,
        allocator: <a href="std.mem.Allocator.html">Allocator</a>,
        ctx: Context,

        <span class="tok-comment">/// The ArrayHashMapUnmanaged type using the same settings as this managed map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Unmanaged = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(K, V, Context, store_hash);

        <span class="tok-comment">/// Pointers to a key and value in the backing store of this map.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Entry</a>;

        <span class="tok-comment">/// A KV pair which has been copied out of the backing store</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">KV</a>;

        <span class="tok-comment">/// The Data type used for the MultiArrayList backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Data</a>;
        <span class="tok-comment">/// The MultiArrayList type backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">DataList</a>;

        <span class="tok-comment">/// The stored hash type, either u32 or void.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Hash</a>;

        <span class="tok-comment">/// getOrPut variants return this structure, with pointers</span>
        <span class="tok-comment">/// to the backing store and a flag to indicate whether an</span>
        <span class="tok-comment">/// existing entry was found.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">GetOrPutResult</a>;

        <span class="tok-comment">/// An Iterator over Entry pointers.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Unmanaged">Unmanaged</a>.<a href="#">Iterator</a>;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// Create an ArrayHashMap instance which will use a specified allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call initContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.initContext">initContext</a>(allocator, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initContext</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = .empty,
                .allocator = allocator,
                .ctx = ctx,
            };
        }

        <span class="tok-comment">/// Frees the backing allocation and leaves the map in an undefined state.</span>
        <span class="tok-comment">/// Note that this does not free keys or values.  You must take care of that</span>
        <span class="tok-comment">/// before calling this function, if it is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.deinit(self.allocator);
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.lockPointers();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            self.unmanaged.unlockPointers();
        }

        <span class="tok-comment">/// Clears the map but retains the backing allocation for future use.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearRetainingCapacity();
        }

        <span class="tok-comment">/// Clears the map and releases the backing allocation</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.clearAndFree(self.allocator);
        }

        <span class="tok-comment">/// Returns the number of KV pairs stored in this map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.count();
        }

        <span class="tok-comment">/// Returns the backing array of keys in this map. Modifying the map may</span>
        <span class="tok-comment">/// invalidate this array. Modifying this array in a way that changes</span>
        <span class="tok-comment">/// key hashes or key equality puts the map into an unusable state until</span>
        <span class="tok-comment">/// `reIndex` is called.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []K {
            <span class="tok-kw">return</span> self.unmanaged.keys();
        }
        <span class="tok-comment">/// Returns the backing array of values in this map. Modifying the map</span>
        <span class="tok-comment">/// may invalidate this array. It is permitted to modify the values in</span>
        <span class="tok-comment">/// this array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) []V {
            <span class="tok-kw">return</span> self.unmanaged.values();
        }

        <span class="tok-comment">/// Returns an iterator over the pairs in this map.</span>
        <span class="tok-comment">/// Modifying the map may invalidate this iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: *<span class="tok-kw">const</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Iterator">Iterator</a> {
            <span class="tok-kw">return</span> self.unmanaged.iterator();
        }

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContext(self.allocator, key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutContextAdapted(self.allocator, key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutAssumeCapacityAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.GetOrPutResult">GetOrPutResult</a> {
            <span class="tok-kw">return</span> self.unmanaged.getOrPutValueContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_capacity: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureTotalCapacityContext(self.allocator, new_capacity, self.ctx);
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, additional_count: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.ensureUnusedCapacityContext(self.allocator, additional_count, self.ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.capacity();
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putNoClobberContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.putAssumeCapacityNoClobberContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) !?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutContext(self.allocator, key, value, self.ctx);
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happuns, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchPutAssumeCapacityContext(key, value, self.ctx);
        }

        <span class="tok-comment">/// Finds pointers to the key and value storage associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.Entry">Entry</a> {
            <span class="tok-kw">return</span> self.unmanaged.getEntryAdapted(key, ctx);
        }

        <span class="tok-comment">/// Finds the index in the `entries` array where a key is stored</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.getIndexContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.unmanaged.getIndexAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">return</span> self.unmanaged.getAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find a pointer to the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">return</span> self.unmanaged.getPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyAdapted(key, ctx);
        }

        <span class="tok-comment">/// Find a pointer to the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">return</span> self.unmanaged.getKeyPtrAdapted(key, ctx);
        }

        <span class="tok-comment">/// Check whether a key is stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.containsAdapted(key, ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by swapping it with the last</span>
        <span class="tok-comment">/// element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchSwapRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by shifting all elements forward</span>
        <span class="tok-comment">/// thereby maintaining the current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.fetchOrderedRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.  Returns true if an entry</span>
        <span class="tok-comment">/// was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.swapRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.swapRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.  Returns true if an entry was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContext(key, self.ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.unmanaged.orderedRemoveContextAdapted(key, ctx, self.ctx);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.unmanaged.swapRemoveAtContext(index, self.ctx);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            self.unmanaged.orderedRemoveAtContext(index, self.ctx);
        }

        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context and allocator as this instance.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, self.ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context as this instance, but the specified</span>
        <span class="tok-comment">/// allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, self.ctx);
            <span class="tok-kw">return</span> other.promoteContext(allocator, self.ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same allocator as this instance, but the</span>
        <span class="tok-comment">/// specified context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(self.allocator, ctx);
            <span class="tok-kw">return</span> other.promoteContext(self.allocator, ctx);
        }
        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the specified allocator and context.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneWithAllocatorAndContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, allocator: <a href="std.mem.Allocator.html">Allocator</a>, ctx: <span class="tok-kw">anytype</span>) !<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, <span class="tok-builtin">@TypeOf</span>(ctx), store_hash) {
            <span class="tok-kw">var</span> other = <span class="tok-kw">try</span> self.unmanaged.cloneContext(allocator, ctx);
            <span class="tok-kw">return</span> other.promoteContext(allocator, ctx);
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a> {
            self.unmanaged.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.unmanaged = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Recomputes stored hashes and rebuilds the key indexes. If the</span>
        <span class="tok-comment">/// underlying keys have been modified directly, call this method to</span>
        <span class="tok-comment">/// recompute the denormalized metadata necessary for the operation of</span>
        <span class="tok-comment">/// the methods of this map that lookup entries by key.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// One use case for this is directly calling `entries.resize()` to grow</span>
        <span class="tok-comment">/// the underlying storage, and then setting the `keys` and `values`</span>
        <span class="tok-comment">/// directly without going through the methods of this map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// The time complexity of this operation is O(n).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.reIndexContext(self.allocator, self.ctx);
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.sortContext(sort_ctx, self.ctx);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.shrinkRetainingCapacityContext(new_len, self.ctx);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacity` can be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.unmanaged.shrinkAndFreeContext(self.allocator, new_len, self.ctx);
        }

        <span class="tok-comment">/// Removes the last inserted `Entry` in the hash map and returns it if count is nonzero.</span>
        <span class="tok-comment">/// Otherwise returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">Self</a>) ?<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator.KV">KV</a> {
            <span class="tok-kw">return</span> self.unmanaged.popContext(self.ctx);
        }
    };
}

<span class="tok-comment">/// A hash table of keys and values, each stored sequentially.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Insertion order is preserved. In general, this data structure supports the same</span>
<span class="tok-comment">/// operations as `std.ArrayListUnmanaged`.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Deletion operations:</span>
<span class="tok-comment">/// * `swapRemove` - O(1)</span>
<span class="tok-comment">/// * `orderedRemove` - O(N)</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Modifying the hash map while iterating is allowed, however, one must understand</span>
<span class="tok-comment">/// the (well defined) behavior when mixing insertions and deletions with iteration.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This type does not store an `Allocator` field - the `Allocator` must be passed in</span>
<span class="tok-comment">/// with each function call that requires it. See `ArrayHashMap` for a type that stores</span>
<span class="tok-comment">/// an `Allocator` field for convenience.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Can be initialized directly using the default field values.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// This type is designed to have low overhead for small numbers of entries. When</span>
<span class="tok-comment">/// `store_hash` is `false` and the number of entries in the map is less than 9,</span>
<span class="tok-comment">/// the overhead cost of using `ArrayHashMapUnmanaged` rather than `std.ArrayList` is</span>
<span class="tok-comment">/// only a single pointer-sized integer.</span>
<span class="tok-comment">///</span>
<span class="tok-comment">/// Default initialization of this struct is deprecated; use `.empty` instead.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ArrayHashMapUnmanaged</span>(
    <span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>,
    <span class="tok-kw">comptime</span> V: <span class="tok-type">type</span>,
    <span class="tok-comment">/// A namespace that provides these two functions:</span>
    <span class="tok-comment">/// * `pub fn hash(self, K) u32`</span>
    <span class="tok-comment">/// * `pub fn eql(self, K, K, usize) bool`</span>
    <span class="tok-comment">///</span>
    <span class="tok-comment">/// The final `usize` in the `eql` function represents the index of the key</span>
    <span class="tok-comment">/// that's already inside the map.</span>
    <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>,
    <span class="tok-comment">/// When `false`, this data structure is biased towards cheap `eql`</span>
    <span class="tok-comment">/// functions and avoids storing each key's hash in the table. Setting</span>
    <span class="tok-comment">/// `store_hash` to `true` incurs more memory cost but limits `eql` to</span>
    <span class="tok-comment">/// being called only once per insertion/deletion (provided there are no</span>
    <span class="tok-comment">/// hash collisions).</span>
    <span class="tok-kw">comptime</span> store_hash: <span class="tok-type">bool</span>,
) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-comment">/// It is permitted to access this field directly.</span>
        <span class="tok-comment">/// After any modification to the keys, consider calling `reIndex`.</span>
        entries: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.DataList">DataList</a> = .{},

        <span class="tok-comment">/// When entries length is less than `linear_scan_max`, this remains `null`.</span>
        <span class="tok-comment">/// Once entries length grows big enough, this field is allocated. There is</span>
        <span class="tok-comment">/// an IndexHeader followed by an array of Index(I) structs, where I is defined</span>
        <span class="tok-comment">/// by how many total indexes there are.</span>
        index_header: ?*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-null">null</span>,

        <span class="tok-comment">/// Used to detect memory safety violations.</span>
        pointer_stability: <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.SafetyLock.html">SafetyLock</a> = .{},

        <span class="tok-comment">/// A map containing no keys or values.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> empty: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{
            .entries = .{},
            .index_header = <span class="tok-null">null</span>,
        };

        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Entry = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
        };

        <span class="tok-comment">/// A KV pair which has been copied out of the backing store</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> KV = <span class="tok-kw">struct</span> {
            key: K,
            value: V,
        };

        <span class="tok-comment">/// The Data type used for the MultiArrayList backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">struct</span> {
            hash: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Hash">Hash</a>,
            key: K,
            value: V,
        };

        <span class="tok-comment">/// The MultiArrayList type backing this map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DataList = <a href="std.html">std</a>.<a href="std.multi_array_list.html#std.multi_array_list.MultiArrayList">MultiArrayList</a>(<a href="std.array_hash_map.ArrayHashMapUnmanaged.Data.html">Data</a>);

        <span class="tok-comment">/// The stored hash type, either u32 or void.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Hash = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">u32</span> <span class="tok-kw">else</span> <span class="tok-type">void</span>;

        <span class="tok-comment">/// getOrPut variants return this structure, with pointers</span>
        <span class="tok-comment">/// to the backing store and a flag to indicate whether an</span>
        <span class="tok-comment">/// existing entry was found.</span>
        <span class="tok-comment">/// Modifying the key is allowed only if it does not change the hash.</span>
        <span class="tok-comment">/// Modifying the value is allowed.</span>
        <span class="tok-comment">/// Entry pointers become invalid whenever this ArrayHashMap is modified,</span>
        <span class="tok-comment">/// unless `ensureTotalCapacity`/`ensureUnusedCapacity` was previously used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> GetOrPutResult = <span class="tok-kw">struct</span> {
            key_ptr: *K,
            value_ptr: *V,
            found_existing: <span class="tok-type">bool</span>,
            index: <span class="tok-type">usize</span>,
        };

        <span class="tok-comment">/// The ArrayHashMap type using the same settings as this managed map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Managed = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(K, V, Context, store_hash);

        <span class="tok-comment">/// Some functions require a context only if hashes are not stored.</span>
        <span class="tok-comment">/// To keep the api simple, this type is only used internally.</span>
        <span class="tok-kw">const</span> ByIndexContext = <span class="tok-kw">if</span> (store_hash) <span class="tok-type">void</span> <span class="tok-kw">else</span> Context;

        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-kw">const</span> linear_scan_max = <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@min</span>(
            <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.cache_line">cache_line</a> / <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Hash">Hash</a>))),
            <a href="std.html">std</a>.<a href="std.atomic.html">atomic</a>.<a href="std.atomic.html#std.atomic.cache_line">cache_line</a> / <span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-builtin">@max</span>(<span class="tok-number">1</span>, <span class="tok-builtin">@sizeOf</span>(K))),
        ))));

        <span class="tok-kw">const</span> RemovalType = <span class="tok-kw">enum</span> {
            swap,
            ordered,
        };

        <span class="tok-kw">const</span> Oom = <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>;

        <span class="tok-comment">/// Convert from an unmanaged map to a managed map.  After calling this,</span>
        <span class="tok-comment">/// the promoted map should no longer be used.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call promoteContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.promoteContext(gpa, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promoteContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.Managed">Managed</a> {
            <span class="tok-kw">return</span> .{
                .unmanaged = self,
                .allocator = gpa,
                .ctx = ctx,
            };
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">var</span> self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
            <span class="tok-kw">errdefer</span> self.deinit(gpa);
            <span class="tok-kw">try</span> self.reinit(gpa, key_list, value_list);
            <span class="tok-kw">return</span> self;
        }

        <span class="tok-comment">/// An empty `value_list` may be passed, in which case the values array becomes `undefined`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key_list: []<span class="tok-kw">const</span> K, value_list: []<span class="tok-kw">const</span> V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">try</span> self.entries.resize(gpa, key_list.len);
            <span class="tok-builtin">@memcpy</span>(self.keys(), key_list);
            <span class="tok-kw">if</span> (value_list.len == <span class="tok-number">0</span>) {
                <span class="tok-builtin">@memset</span>(self.values(), <span class="tok-null">undefined</span>);
            } <span class="tok-kw">else</span> {
                <a href="std.debug.html#std.debug.assert">assert</a>(key_list.len == value_list.len);
                <span class="tok-builtin">@memcpy</span>(self.values(), value_list);
            }
            <span class="tok-kw">try</span> self.reIndex(gpa);
        }

        <span class="tok-comment">/// Frees the backing allocation and leaves the map in an undefined state.</span>
        <span class="tok-comment">/// Note that this does not free keys or values.  You must take care of that</span>
        <span class="tok-comment">/// before calling this function, if it is needed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.assertUnlocked();
            self.entries.deinit(gpa);
            <span class="tok-kw">if</span> (self.index_header) |header| {
                header.free(gpa);
            }
            self.* = <span class="tok-null">undefined</span>;
        }

        <span class="tok-comment">/// Puts the hash map into a state where any method call that would</span>
        <span class="tok-comment">/// cause an existing key or value pointer to become invalidated will</span>
        <span class="tok-comment">/// instead trigger an assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// An additional call to `lockPointers` in such state also triggers an</span>
        <span class="tok-comment">/// assertion.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// `unlockPointers` returns the hash map to the previous state.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
        }

        <span class="tok-comment">/// Undoes a call to `lockPointers`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unlockPointers</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.unlock();
        }

        <span class="tok-comment">/// Clears the map but retains the backing allocation for future use.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.entries.len = <span class="tok-number">0</span>;
            <span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                    .<span class="tok-type">u8</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u8</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>).empty),
                    .<span class="tok-type">u16</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u16</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>).empty),
                    .<span class="tok-type">u32</span> =&gt; <span class="tok-builtin">@memset</span>(header.indexes(<span class="tok-type">u32</span>), <a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>).empty),
                }
            }
        }

        <span class="tok-comment">/// Clears the map and releases the backing allocation</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clearAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.entries.shrinkAndFree(gpa, <span class="tok-number">0</span>);
            <span class="tok-kw">if</span> (self.index_header) |header| {
                header.free(gpa);
                self.index_header = <span class="tok-null">null</span>;
            }
        }

        <span class="tok-comment">/// Returns the number of KV pairs stored in this map.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">count</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.entries.len;
        }

        <span class="tok-comment">/// Returns the backing array of keys in this map. Modifying the map may</span>
        <span class="tok-comment">/// invalidate this array. Modifying this array in a way that changes</span>
        <span class="tok-comment">/// key hashes or key equality puts the map into an unusable state until</span>
        <span class="tok-comment">/// `reIndex` is called.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">keys</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []K {
            <span class="tok-kw">return</span> self.entries.items(.key);
        }
        <span class="tok-comment">/// Returns the backing array of values in this map. Modifying the map</span>
        <span class="tok-comment">/// may invalidate this array. It is permitted to modify the values in</span>
        <span class="tok-comment">/// this array.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">values</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) []V {
            <span class="tok-kw">return</span> self.entries.items(.value);
        }

        <span class="tok-comment">/// Returns an iterator over the pairs in this map.</span>
        <span class="tok-comment">/// Modifying the map may invalidate this iterator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">return</span> .{
                .keys = slice.items(.key).ptr,
                .values = slice.items(.value).ptr,
                .len = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(slice.len)),
            };
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Iterator = <span class="tok-kw">struct</span> {
            keys: [*]K,
            values: [*]V,
            len: <span class="tok-type">u32</span>,
            index: <span class="tok-type">u32</span> = <span class="tok-number">0</span>,

            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(it: *<a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
                <span class="tok-kw">if</span> (it.index &gt;= it.len) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
                <span class="tok-kw">const</span> result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
                    .key_ptr = &amp;it.keys[it.index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;it.values[it.index],
                };
                it.index += <span class="tok-number">1</span>;
                <span class="tok-kw">return</span> result;
            }

            <span class="tok-comment">/// Reset the iterator to the initial index</span>
            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(it: *<a href="std.array_hash_map.ArrayHashMapUnmanaged.Iterator.html">Iterator</a>) <span class="tok-type">void</span> {
                it.index = <span class="tok-number">0</span>;
            }
        };

        <span class="tok-comment">/// If key exists this function cannot fail.</span>
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContext(gpa, key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutContextAdapted(gpa, key, key_ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            self.ensureTotalCapacityContext(gpa, self.entries.len + <span class="tok-number">1</span>, ctx) <span class="tok-kw">catch</span> |err| {<span class="tok-comment">
                // &quot;If key exists this function cannot fail.&quot;
                </span><span class="tok-kw">const</span> index = self.getIndexAdapted(key, key_ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> err;
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
                    .found_existing = <span class="tok-null">true</span>,
                    .index = index,
                };
            };
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityAdapted(key, key_ctx);
        }

        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointer points to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined value, and</span>
        <span class="tok-comment">/// the `Entry` pointer points to it. Caller should then initialize</span>
        <span class="tok-comment">/// the value (but not the key).</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutAssumeCapacityContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityAdapted(key, ctx);
            <span class="tok-kw">if</span> (!gop.found_existing) {
                gop.key_ptr.* = key;
            }
            <span class="tok-kw">return</span> gop;
        }
        <span class="tok-comment">/// If there is an existing item with `key`, then the result</span>
        <span class="tok-comment">/// `Entry` pointers point to it, and found_existing is true.</span>
        <span class="tok-comment">/// Otherwise, puts a new item with undefined key and value, and</span>
        <span class="tok-comment">/// the `Entry` pointers point to it. Caller must then initialize</span>
        <span class="tok-comment">/// both the key and the value.</span>
        <span class="tok-comment">/// If a new entry needs to be stored, this function asserts there</span>
        <span class="tok-comment">/// is enough capacity to store it.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutAssumeCapacityAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                        <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                            .key_ptr = item_key,<span class="tok-comment">
                            // workaround for #6974
                            </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[i],
                            .found_existing = <span class="tok-null">true</span>,
                            .index = i,
                        };
                    }
                }

                <span class="tok-kw">const</span> index = self.entries.addOneAssumeCapacity();<span class="tok-comment">
                // The slice length changed, so we directly index the pointer.
                </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[index] = h;

                <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a>{
                    .key_ptr = &amp;keys_array.ptr[index],<span class="tok-comment">
                    // workaround for #6974
                    </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value).ptr[index],
                    .found_existing = <span class="tok-null">false</span>,
                    .index = index,
                };
            };

            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getOrPutInternal(key, ctx, header, <span class="tok-type">u32</span>),
            }
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValue</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getOrPutValueContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getOrPutValueContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutValueContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> res = <span class="tok-kw">try</span> self.getOrPutContextAdapted(gpa, key, ctx, ctx);
            <span class="tok-kw">if</span> (!res.found_existing) {
                res.key_ptr.* = key;
                res.value_ptr.* = value;
            }
            <span class="tok-kw">return</span> res;
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until the</span>
        <span class="tok-comment">/// `expected_count` will not cause an allocation, and therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, new_capacity, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureTotalCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_capacity: <span class="tok-type">usize</span>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">if</span> (new_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) {
                <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
                <span class="tok-kw">return</span>;
            }

            <span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">if</span> (new_capacity &lt;= header.capacity()) {
                    <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
                    <span class="tok-kw">return</span>;
                }
            }

            <span class="tok-kw">try</span> self.entries.ensureTotalCapacity(gpa, new_capacity);
            <span class="tok-kw">const</span> new_bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(new_capacity);
            <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, new_bit_index);

            <span class="tok-kw">if</span> (self.index_header) |old_header| old_header.free(gpa);
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
            self.index_header = new_header;
        }

        <span class="tok-comment">/// Increases capacity, guaranteeing that insertions up until</span>
        <span class="tok-comment">/// `additional_count` **more** items will not cause an allocation, and</span>
        <span class="tok-comment">/// therefore cannot fail.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacity</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            gpa: <a href="std.mem.Allocator.html">Allocator</a>,
            additional_capacity: <span class="tok-type">usize</span>,
        ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call ensureTotalCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.ensureUnusedCapacityContext(gpa, additional_capacity, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">ensureUnusedCapacityContext</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            gpa: <a href="std.mem.Allocator.html">Allocator</a>,
            additional_capacity: <span class="tok-type">usize</span>,
            ctx: Context,
        ) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">return</span> self.ensureTotalCapacityContext(gpa, self.count() + additional_capacity, ctx);
        }

        <span class="tok-comment">/// Returns the number of total elements which may be present before it is</span>
        <span class="tok-comment">/// no longer guaranteed that no allocations will be performed.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> entry_cap = self.entries.capacity;
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>, entry_cap);
            <span class="tok-kw">const</span> indexes_cap = header.capacity();
            <span class="tok-kw">return</span> <span class="tok-builtin">@min</span>(entry_cap, indexes_cap);
        }

        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPut`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">put</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Inserts a key-value pair into the hash map, asserting that no previous</span>
        <span class="tok-comment">/// entry with the same key is already present</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putNoClobberContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Clobbers any existing data. To detect if a put would clobber</span>
        <span class="tok-comment">/// existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Asserts there is enough capacity to store the new key-value pair.</span>
        <span class="tok-comment">/// Asserts that it does not clobber any existing data.</span>
        <span class="tok-comment">/// To detect if a put would clobber existing data, see `getOrPutAssumeCapacity`.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobber</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call putAssumeCapacityNoClobberContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.putAssumeCapacityNoClobberContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">putAssumeCapacityNoClobberContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> result = self.getOrPutAssumeCapacityContext(key, ctx);
            <a href="std.debug.html#std.debug.assert">assert</a>(!result.found_existing);
            result.value_ptr.* = value;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPut</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutContext(gpa, key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, key: K, value: V, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> self.getOrPutContext(gpa, key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Inserts a new `Entry` into the hash map, returning the previous one, if any.</span>
        <span class="tok-comment">/// If insertion happens, asserts there is enough capacity without allocating.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchPutAssumeCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchPutAssumeCapacityContext(key, value, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchPutAssumeCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, value: V, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> gop = self.getOrPutAssumeCapacityContext(key, ctx);
            <span class="tok-kw">var</span> result: ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = <span class="tok-null">null</span>;
            <span class="tok-kw">if</span> (gop.found_existing) {
                result = <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a>{
                    .key = gop.key_ptr.*,
                    .value = gop.value_ptr.*,
                };
            }
            gop.value_ptr.* = value;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Finds pointers to the key and value storage associated with a key.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntry</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getEntryContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getEntryContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">return</span> self.getEntryAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getEntryAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a> {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">return</span> <a href="std.array_hash_map.ArrayHashMapUnmanaged.Entry.html">Entry</a>{
                .key_ptr = &amp;slice.items(.key)[index],<span class="tok-comment">
                // workaround for #6974
                </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;slice.items(.value)[index],
            };
        }

        <span class="tok-comment">/// Finds the index in the `entries` array where a key is stored</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndex</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getIndexContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getIndexContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getIndexAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = slice.items(.hash);
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">if</span> (hashes_array[i] == h <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, item_key.*, i)) {
                        <span class="tok-kw">return</span> i;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            };
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.getIndexWithHeaderGeneric(key, ctx, header, <span class="tok-type">u32</span>),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">getIndexWithHeaderGeneric</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> slot = self.getSlotByKey(key, ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> indexes[slot].entry_index;
        }

        <span class="tok-comment">/// Find the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">get</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?V {
            <span class="tok-kw">return</span> self.getAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?V {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.values()[index];
        }

        <span class="tok-comment">/// Find a pointer to the value associated with a key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*V {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*V {
            <span class="tok-kw">return</span> self.getPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*V {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;<span class="tok-comment">
            // workaround for #6974
            </span><span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(*V, <span class="tok-null">undefined</span>) <span class="tok-kw">else</span> &amp;self.values()[index];
        }

        <span class="tok-comment">/// Find the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?K {
            <span class="tok-kw">return</span> self.getKeyAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?K {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> self.keys()[index];
        }

        <span class="tok-comment">/// Find a pointer to the actual key associated with an adapted key</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtr</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?*K {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call getKeyPtrContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.getKeyPtrContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?*K {
            <span class="tok-kw">return</span> self.getKeyPtrAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getKeyPtrAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?*K {
            <span class="tok-kw">const</span> index = self.getIndexAdapted(key, ctx) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">return</span> &amp;self.keys()[index];
        }

        <span class="tok-comment">/// Check whether a key is stored in the map</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">contains</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call containsContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.containsContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.containsAdapted(key, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">containsAdapted</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.getIndexAdapted(key, ctx) != <span class="tok-null">null</span>;
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by swapping it with the last</span>
        <span class="tok-comment">/// element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchSwapRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchSwapRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchSwapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchSwapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map, and then returned from this function. The entry is</span>
        <span class="tok-comment">/// removed from the underlying array by shifting all elements forward</span>
        <span class="tok-comment">/// thereby maintaining the current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call fetchOrderedRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.fetchOrderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchOrderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.fetchRemoveByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.  Returns true if an entry</span>
        <span class="tok-comment">/// was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// If there is an `Entry` with a matching key, it is deleted from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.  Returns true if an entry was removed, false otherwise.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemove</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(Context) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveContext(key, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: K, ctx: Context) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, ctx);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveContextAdapted instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveContextAdapted(key, ctx, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveContextAdapted</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">bool</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">return</span> self.removeByKey(key, key_ctx, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by swapping it with the last element.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call swapRemoveAtContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.swapRemoveAtContext(index, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">swapRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .swap);
        }

        <span class="tok-comment">/// Deletes the item at the specified index in `entries` from</span>
        <span class="tok-comment">/// the hash map. The entry is removed from the underlying array</span>
        <span class="tok-comment">/// by shifting all elements forward, thereby maintaining the</span>
        <span class="tok-comment">/// current ordering.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAt</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call orderedRemoveAtContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.orderedRemoveAtContext(index, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">orderedRemoveAtContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, index: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            self.removeByIndex(index, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, .ordered);
        }

        <span class="tok-comment">/// Create a copy of the hash map which can be modified separately.</span>
        <span class="tok-comment">/// The copy uses the same context as this instance, but is allocated</span>
        <span class="tok-comment">/// with the provided allocator.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call cloneContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.cloneContext(gpa, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">cloneContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            <span class="tok-kw">var</span> other: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> = .{};
            other.entries = <span class="tok-kw">try</span> self.entries.clone(gpa);
            <span class="tok-kw">errdefer</span> other.entries.deinit(gpa);

            <span class="tok-kw">if</span> (self.index_header) |header| {<span class="tok-comment">
                // TODO: I'm pretty sure this could be memcpy'd instead of
                // doing all this work.
                </span><span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, header.bit_index);
                other.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
                other.index_header = new_header;
            }
            <span class="tok-kw">return</span> other;
        }

        <span class="tok-comment">/// Set the map to an empty state, making deinitialization a no-op, and</span>
        <span class="tok-comment">/// returning a copy of the original.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">move</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a> {
            self.pointer_stability.assertUnlocked();
            <span class="tok-kw">const</span> result = self.*;
            self.* = .empty;
            <span class="tok-kw">return</span> result;
        }

        <span class="tok-comment">/// Recomputes stored hashes and rebuilds the key indexes. If the</span>
        <span class="tok-comment">/// underlying keys have been modified directly, call this method to</span>
        <span class="tok-comment">/// recompute the denormalized metadata necessary for the operation of</span>
        <span class="tok-comment">/// the methods of this map that lookup entries by key.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// One use case for this is directly calling `entries.resize()` to grow</span>
        <span class="tok-comment">/// the underlying storage, and then setting the `keys` and `values`</span>
        <span class="tok-comment">/// directly without going through the methods of this map.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// The time complexity of this operation is O(n).</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call reIndexContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.reIndexContext(gpa, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reIndexContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {<span class="tok-comment">
            // Recompute all hashes.
            </span><span class="tok-kw">if</span> (store_hash) {
                <span class="tok-kw">for</span> (self.keys(), self.entries.items(.hash)) |key, *hash| {
                    <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
                    hash.* = h;
                }
            }
            <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, ctx);
        }

        <span class="tok-comment">/// Modify an entry's key without reordering any entries.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call setKeyContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.setKeyContext">setKeyContext</a>(self, gpa, index, new_key, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">setKeyContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, index: <span class="tok-type">usize</span>, new_key: K, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">const</span> key_ptr = &amp;self.entries.items(.key)[index];
            key_ptr.* = new_key;
            <span class="tok-kw">if</span> (store_hash) self.entries.items(.hash)[index] = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key_ptr.*);
            <span class="tok-kw">try</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.rebuildIndex">rebuildIndex</a>(self, gpa, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">rebuildIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, ctx: Context) <a href="std.mem.Allocator.html#std.mem.Allocator.Error">Oom</a>!<span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (self.entries.capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.linear_scan_max">linear_scan_max</a>) <span class="tok-kw">return</span>;<span class="tok-comment">

            // We're going to rebuild the index header and replace the existing one (if any). The
            // indexes should sized such that they will be at most 60% full.
            </span><span class="tok-kw">const</span> bit_index = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.findBitIndex">findBitIndex</a>(self.entries.capacity);
            <span class="tok-kw">const</span> new_header = <span class="tok-kw">try</span> <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>.<a href="std.array_hash_map.IndexHeader.html#std.array_hash_map.IndexHeader.alloc">alloc</a>(gpa, bit_index);
            <span class="tok-kw">if</span> (self.index_header) |header| header.free(gpa);
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, new_header);
            self.index_header = new_header;
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-comment">/// Uses a stable sorting algorithm.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sort</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortContext instead.&quot;</span>);
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Sorts the entries and then rebuilds the index.</span>
        <span class="tok-comment">/// `sort_ctx` must have this method:</span>
        <span class="tok-comment">/// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`</span>
        <span class="tok-comment">/// Uses an unstable sorting algorithm.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstable</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call sortUnstableContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.sortContextInternal(.unstable, sort_ctx, <span class="tok-null">undefined</span>);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .stable, sort_ctx, ctx);
        }

        <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sortUnstableContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, sort_ctx: <span class="tok-kw">anytype</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.sortContextInternal">sortContextInternal</a>(self, .unstable, sort_ctx, ctx);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">sortContextInternal</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            <span class="tok-kw">comptime</span> mode: <a href="std.html">std</a>.<a href="std.sort.html">sort</a>.<a href="std.sort.Mode.html">Mode</a>,
            sort_ctx: <span class="tok-kw">anytype</span>,
            ctx: Context,
        ) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">switch</span> (mode) {
                .stable =&gt; self.entries.sort(sort_ctx),
                .unstable =&gt; self.entries.sortUnstable(sort_ctx),
            }
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;
            header.reset();
            self.insertAllEntriesIntoNewHeader(<span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacity</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkRetainingCapacityContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.shrinkRetainingCapacityContext(new_len, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Keeps capacity the same.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. Any deinitialization of</span>
        <span class="tok-comment">/// discarded entries must take place *after* calling this function.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkRetainingCapacityContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

            // Remove index entries from the new length onwards.
            // Explicitly choose to ONLY remove index entries and not the underlying array list
            // entries as we're going to remove them in the subsequent shrink call.
            </span><span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
                <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
                    self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            }
            self.entries.shrinkRetainingCapacity(new_len);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacity` can be used instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFree</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call shrinkAndFreeContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.shrinkAndFreeContext(gpa, new_len, <span class="tok-null">undefined</span>);
        }

        <span class="tok-comment">/// Shrinks the underlying `Entry` array to `new_len` elements and</span>
        <span class="tok-comment">/// discards any associated index entries. Reduces allocated capacity.</span>
        <span class="tok-comment">///</span>
        <span class="tok-comment">/// Asserts the discarded entries remain initialized and capable of</span>
        <span class="tok-comment">/// performing hash and equality checks. It is a bug to call this</span>
        <span class="tok-comment">/// function if the discarded entries require deinitialization. For</span>
        <span class="tok-comment">/// that use case, `shrinkRetainingCapacityContext` can be used</span>
        <span class="tok-comment">/// instead.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">shrinkAndFreeContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_len: <span class="tok-type">usize</span>, ctx: Context) <span class="tok-type">void</span> {
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();<span class="tok-comment">

            // Remove index entries from the new length onwards.
            // Explicitly choose to ONLY remove index entries and not the underlying array list
            // entries as we're going to remove them in the subsequent shrink call.
            </span><span class="tok-kw">if</span> (self.index_header) |header| {
                <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = new_len;
                <span class="tok-kw">while</span> (i &lt; self.entries.len) : (i += <span class="tok-number">1</span>)
                    self.removeFromIndexByIndex(i, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            }
            self.entries.shrinkAndFree(gpa, new_len);
        }

        <span class="tok-comment">/// Removes the last inserted `Entry` in the hash map and returns it.</span>
        <span class="tok-comment">/// Otherwise returns null.</span>
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">pop</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call popContext instead.&quot;</span>);
            <span class="tok-kw">return</span> self.popContext(<span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">popContext</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: Context) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">if</span> (self.entries.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            self.pointer_stability.lock();
            <span class="tok-kw">defer</span> self.pointer_stability.unlock();

            <span class="tok-kw">const</span> item = self.entries.get(self.entries.len - <span class="tok-number">1</span>);
            <span class="tok-kw">if</span> (self.index_header) |header|
                self.removeFromIndexByIndex(self.entries.len - <span class="tok-number">1</span>, <span class="tok-kw">if</span> (store_hash) {} <span class="tok-kw">else</span> ctx, header);
            self.entries.len -= <span class="tok-number">1</span>;
            <span class="tok-kw">return</span> .{
                .key = item.key,
                .value = item.value,
            };
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveByKey</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> key_hash = <span class="tok-kw">if</span> (store_hash) key_ctx.hash(key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) hashes_array[i] == key_hash <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                    <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> key_ctx.eql(key, item_key.*, i)) {
                        <span class="tok-kw">const</span> removed_entry: <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = .{
                            .key = keys_array[i],
                            .value = slice.items(.value)[i],
                        };
                        <span class="tok-kw">switch</span> (removal_type) {
                            .swap =&gt; self.entries.swapRemove(i),
                            .ordered =&gt; self.entries.orderedRemove(i),
                        }
                        <span class="tok-kw">return</span> removed_entry;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            };
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.fetchRemoveByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u32</span>, removal_type),
            };
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">fetchRemoveByKeyGeneric</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>,
            <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) ?<a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> entry_index = self.removeFromIndexByKey(key, key_ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> removed_entry: <a href="std.array_hash_map.ArrayHashMapUnmanaged.KV.html">KV</a> = .{
                .key = slice.items(.key)[entry_index],
                .value = slice.items(.value)[entry_index],
            };
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
            <span class="tok-kw">return</span> removed_entry;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByKey</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            key: <span class="tok-kw">anytype</span>,
            key_ctx: <span class="tok-kw">anytype</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>,
        ) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {<span class="tok-comment">
                // Linear scan.
                </span><span class="tok-kw">const</span> key_hash = <span class="tok-kw">if</span> (store_hash) key_ctx.hash(key) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> slice = self.entries.slice();
                <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
                <span class="tok-kw">const</span> keys_array = slice.items(.key);
                <span class="tok-kw">for</span> (keys_array, <span class="tok-number">0</span>..) |*item_key, i| {
                    <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) hashes_array[i] == key_hash <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                    <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> key_ctx.eql(key, item_key.*, i)) {
                        <span class="tok-kw">switch</span> (removal_type) {
                            .swap =&gt; self.entries.swapRemove(i),
                            .ordered =&gt; self.entries.orderedRemove(i),
                        }
                        <span class="tok-kw">return</span> <span class="tok-null">true</span>;
                    }
                }
                <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            };
            <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.removeByKeyGeneric(key, key_ctx, ctx, header, <span class="tok-type">u32</span>, removal_type),
            };
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeByKeyGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, key_ctx: <span class="tok-kw">anytype</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">const</span> entry_index = self.removeFromIndexByKey(key, key_ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
            <span class="tok-kw">return</span> <span class="tok-null">true</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <a href="std.debug.html#std.debug.assert">assert</a>(entry_index &lt; self.entries.len);
            <span class="tok-kw">const</span> header = self.index_header <span class="tok-kw">orelse</span> {
                <span class="tok-kw">switch</span> (removal_type) {
                    .swap =&gt; self.entries.swapRemove(entry_index),
                    .ordered =&gt; self.entries.orderedRemove(entry_index),
                }
                <span class="tok-kw">return</span>;
            };
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u8</span>, removal_type),
                .<span class="tok-type">u16</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u16</span>, removal_type),
                .<span class="tok-type">u32</span> =&gt; self.removeByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u32</span>, removal_type),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeByIndexGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            self.removeFromIndexByIndexGeneric(entry_index, ctx, header, I, indexes);
            self.removeFromArrayAndUpdateIndex(entry_index, ctx, header, I, indexes, removal_type);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromArrayAndUpdateIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I), <span class="tok-kw">comptime</span> removal_type: <a href="std.array_hash_map.ArrayHashMapUnmanaged.RemovalType.html">RemovalType</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> last_index = self.entries.len - <span class="tok-number">1</span>;<span class="tok-comment"> // overflow =&gt; remove from empty map
            </span><span class="tok-kw">switch</span> (removal_type) {
                .swap =&gt; {
                    <span class="tok-kw">if</span> (last_index != entry_index) {<span class="tok-comment">
                        // Because of the swap remove, now we need to update the index that was
                        // pointing to the last entry and is now pointing to this removed item slot.
                        </span>self.updateEntryIndex(header, last_index, entry_index, ctx, I, indexes);
                    }<span class="tok-comment">
                    // updateEntryIndex reads from the old entry index,
                    // so it needs to run before removal.
                    </span>self.entries.swapRemove(entry_index);
                },
                .ordered =&gt; {
                    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = entry_index;
                    <span class="tok-kw">while</span> (i &lt; last_index) : (i += <span class="tok-number">1</span>) {<span class="tok-comment">
                        // Because of the ordered remove, everything from the entry index onwards has
                        // been shifted forward so we'll need to update the index entries.
                        </span>self.updateEntryIndex(header, i + <span class="tok-number">1</span>, i, ctx, I, indexes);
                    }<span class="tok-comment">
                    // updateEntryIndex reads from the old entry index,
                    // so it needs to run before removal.
                    </span>self.entries.orderedRemove(entry_index);
                },
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">updateEntryIndex</span>(
            self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>,
            header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>,
            old_entry_index: <span class="tok-type">usize</span>,
            new_entry_index: <span class="tok-type">usize</span>,
            ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>,
            <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>,
            indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I),
        ) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByIndex(old_entry_index, ctx, header, I, indexes);
            indexes[slot].entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_entry_index));
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u8</span>, header.indexes(<span class="tok-type">u8</span>)),
                .<span class="tok-type">u16</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u16</span>, header.indexes(<span class="tok-type">u16</span>)),
                .<span class="tok-type">u32</span> =&gt; self.removeFromIndexByIndexGeneric(entry_index, ctx, header, <span class="tok-type">u32</span>, header.indexes(<span class="tok-type">u32</span>)),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByIndexGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByIndex(entry_index, ctx, header, I, indexes);
            <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.removeSlot">removeSlot</a>(slot, header, I, indexes);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeFromIndexByKey</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slot = self.getSlotByKey(key, ctx, header, I, indexes) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
            <span class="tok-kw">const</span> removed_entry_index = indexes[slot].entry_index;
            <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.removeSlot">removeSlot</a>(slot, header, I, indexes);
            <span class="tok-kw">return</span> removed_entry_index;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">removeSlot</span>(removed_slot: <span class="tok-type">usize</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> start_index = removed_slot +% <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> last_slot = removed_slot;
            <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = start_index;
            <span class="tok-kw">while</span> (index != end_index) : (index +%= <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];
                <span class="tok-kw">if</span> (slot_data.isEmpty() <span class="tok-kw">or</span> slot_data.distance_from_start_index == <span class="tok-number">0</span>) {
                    indexes[last_slot].setEmpty();
                    <span class="tok-kw">return</span>;
                }
                indexes[last_slot] = .{
                    .entry_index = slot_data.entry_index,
                    .distance_from_start_index = slot_data.distance_from_start_index - <span class="tok-number">1</span>,
                };
                last_slot = slot;
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSlotByIndex</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, entry_index: <span class="tok-type">usize</span>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) <span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) slice.items(.hash)[entry_index] <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, slice.items(.key)[entry_index]);
            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];<span class="tok-comment">

                // This is the fundamental property of the array hash map index.  If this
                // assert fails, it probably means that the entry was not in the index.
                </span><a href="std.debug.html#std.debug.assert">assert</a>(!slot_data.isEmpty());
                <a href="std.debug.html#std.debug.assert">assert</a>(slot_data.distance_from_start_index &gt;= distance_from_start_index);

                <span class="tok-kw">if</span> (slot_data.entry_index == entry_index) {
                    <span class="tok-kw">return</span> slot;
                }
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-comment">/// Must `ensureTotalCapacity`/`ensureUnusedCapacity` before calling this.</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">getOrPutInternal</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <a href="std.array_hash_map.ArrayHashMapUnmanaged.GetOrPutResult.html">GetOrPutResult</a> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
            <span class="tok-kw">const</span> keys_array = slice.items(.key);
            <span class="tok-kw">const</span> values_array = slice.items(.value);
            <span class="tok-kw">const</span> indexes = header.indexes(I);

            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">var</span> slot = header.constrainIndex(index);
                <span class="tok-kw">var</span> slot_data = indexes[slot];<span class="tok-comment">

                // If the slot is empty, there can be no more items in this run.
                // We didn't find a matching item, so this must be new.
                // Put it in the empty slot.
                </span><span class="tok-kw">if</span> (slot_data.isEmpty()) {
                    <span class="tok-kw">const</span> new_index = self.entries.addOneAssumeCapacity();
                    indexes[slot] = .{
                        .distance_from_start_index = distance_from_start_index,
                        .entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_index)),
                    };<span class="tok-comment">

                    // update the hash if applicable
                    </span><span class="tok-kw">if</span> (store_hash) hashes_array.ptr[new_index] = h;

                    <span class="tok-kw">return</span> .{
                        .found_existing = <span class="tok-null">false</span>,
                        .key_ptr = &amp;keys_array.ptr[new_index],<span class="tok-comment">
                        // workaround for #6974
                        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array.ptr[new_index],
                        .index = new_index,
                    };
                }<span class="tok-comment">

                // This pointer survives the following append because we call
                // entries.ensureTotalCapacity before getOrPutInternal.
                </span><span class="tok-kw">const</span> i = slot_data.entry_index;
                <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) h == hashes_array[i] <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, keys_array[i], i)) {
                    <span class="tok-kw">return</span> .{
                        .found_existing = <span class="tok-null">true</span>,
                        .key_ptr = &amp;keys_array[slot_data.entry_index],<span class="tok-comment">
                        // workaround for #6974
                        </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array[slot_data.entry_index],
                        .index = slot_data.entry_index,
                    };
                }<span class="tok-comment">

                // If the entry is closer to its target than our current distance,
                // the entry we are looking for does not exist.  It would be in
                // this slot instead if it was here.  So stop looking, and switch
                // to insert mode.
                </span><span class="tok-kw">if</span> (slot_data.distance_from_start_index &lt; distance_from_start_index) {<span class="tok-comment">
                    // In this case, we did not find the item. We will put a new entry.
                    // However, we will use this index for the new entry, and move
                    // the previous index down the line, to keep the max distance_from_start_index
                    // as small as possible.
                    </span><span class="tok-kw">const</span> new_index = self.entries.addOneAssumeCapacity();
                    <span class="tok-kw">if</span> (store_hash) hashes_array.ptr[new_index] = h;
                    indexes[slot] = .{
                        .entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(new_index)),
                        .distance_from_start_index = distance_from_start_index,
                    };
                    distance_from_start_index = slot_data.distance_from_start_index;
                    <span class="tok-kw">var</span> displaced_index = slot_data.entry_index;<span class="tok-comment">

                    // Find somewhere to put the index we replaced by shifting
                    // following indexes backwards.
                    </span>index +%= <span class="tok-number">1</span>;
                    distance_from_start_index += <span class="tok-number">1</span>;
                    <span class="tok-kw">while</span> (index != end_index) : ({
                        index +%= <span class="tok-number">1</span>;
                        distance_from_start_index += <span class="tok-number">1</span>;
                    }) {
                        slot = header.constrainIndex(index);
                        slot_data = indexes[slot];
                        <span class="tok-kw">if</span> (slot_data.isEmpty()) {
                            indexes[slot] = .{
                                .entry_index = displaced_index,
                                .distance_from_start_index = distance_from_start_index,
                            };
                            <span class="tok-kw">return</span> .{
                                .found_existing = <span class="tok-null">false</span>,
                                .key_ptr = &amp;keys_array.ptr[new_index],<span class="tok-comment">
                                // workaround for #6974
                                </span>.value_ptr = <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(*V) == <span class="tok-number">0</span>) <span class="tok-null">undefined</span> <span class="tok-kw">else</span> &amp;values_array.ptr[new_index],
                                .index = new_index,
                            };
                        }

                        <span class="tok-kw">if</span> (slot_data.distance_from_start_index &lt; distance_from_start_index) {
                            indexes[slot] = .{
                                .entry_index = displaced_index,
                                .distance_from_start_index = distance_from_start_index,
                            };
                            displaced_index = slot_data.entry_index;
                            distance_from_start_index = slot_data.distance_from_start_index;
                        }
                    }
                    <span class="tok-kw">unreachable</span>;
                }
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">getSlotByKey</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, key: <span class="tok-kw">anytype</span>, ctx: <span class="tok-kw">anytype</span>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>, indexes: []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I)) ?<span class="tok-type">usize</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hashes_array = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> {};
            <span class="tok-kw">const</span> keys_array = slice.items(.key);
            <span class="tok-kw">const</span> h = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);

            <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
            <span class="tok-kw">const</span> end_index = start_index +% indexes.len;

            <span class="tok-kw">var</span> index = start_index;
            <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
            <span class="tok-kw">while</span> (index != end_index) : ({
                index +%= <span class="tok-number">1</span>;
                distance_from_start_index += <span class="tok-number">1</span>;
            }) {
                <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                <span class="tok-kw">const</span> slot_data = indexes[slot];
                <span class="tok-kw">if</span> (slot_data.isEmpty() <span class="tok-kw">or</span> slot_data.distance_from_start_index &lt; distance_from_start_index)
                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;

                <span class="tok-kw">const</span> i = slot_data.entry_index;
                <span class="tok-kw">const</span> hash_match = <span class="tok-kw">if</span> (store_hash) h == hashes_array[i] <span class="tok-kw">else</span> <span class="tok-null">true</span>;
                <span class="tok-kw">if</span> (hash_match <span class="tok-kw">and</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedEql">checkedEql</a>(ctx, key, keys_array[i], i))
                    <span class="tok-kw">return</span> slot;
            }
            <span class="tok-kw">unreachable</span>;
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">insertAllEntriesIntoNewHeader</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">void</span> {
            <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u8</span>),
                .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u16</span>),
                .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> self.insertAllEntriesIntoNewHeaderGeneric(ctx, header, <span class="tok-type">u32</span>),
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">insertAllEntriesIntoNewHeaderGeneric</span>(self: *<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, ctx: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>, header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> items = <span class="tok-kw">if</span> (store_hash) slice.items(.hash) <span class="tok-kw">else</span> slice.items(.key);
            <span class="tok-kw">const</span> indexes = header.indexes(I);

            entry_loop: <span class="tok-kw">for</span> (items, <span class="tok-number">0</span>..) |key, i| {
                <span class="tok-kw">const</span> h = <span class="tok-kw">if</span> (store_hash) key <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, key);
                <span class="tok-kw">const</span> start_index = <a href="std.array_hash_map.html#std.array_hash_map.safeTruncate">safeTruncate</a>(<span class="tok-type">usize</span>, h);
                <span class="tok-kw">const</span> end_index = start_index +% indexes.len;
                <span class="tok-kw">var</span> index = start_index;
                <span class="tok-kw">var</span> entry_index = <span class="tok-builtin">@as</span>(I, <span class="tok-builtin">@intCast</span>(i));
                <span class="tok-kw">var</span> distance_from_start_index: I = <span class="tok-number">0</span>;
                <span class="tok-kw">while</span> (index != end_index) : ({
                    index +%= <span class="tok-number">1</span>;
                    distance_from_start_index += <span class="tok-number">1</span>;
                }) {
                    <span class="tok-kw">const</span> slot = header.constrainIndex(index);
                    <span class="tok-kw">const</span> next_index = indexes[slot];
                    <span class="tok-kw">if</span> (next_index.isEmpty()) {
                        indexes[slot] = .{
                            .distance_from_start_index = distance_from_start_index,
                            .entry_index = entry_index,
                        };
                        <span class="tok-kw">continue</span> :entry_loop;
                    }
                    <span class="tok-kw">if</span> (next_index.distance_from_start_index &lt; distance_from_start_index) {
                        indexes[slot] = .{
                            .distance_from_start_index = distance_from_start_index,
                            .entry_index = entry_index,
                        };
                        distance_from_start_index = next_index.distance_from_start_index;
                        entry_index = next_index.entry_index;
                    }
                }
                <span class="tok-kw">unreachable</span>;
            }
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">checkedHash</span>(ctx: <span class="tok-kw">anytype</span>, key: <span class="tok-kw">anytype</span>) <span class="tok-type">u32</span> {<span class="tok-comment">
            // If you get a compile error on the next line, it means that your
            // generic hash function doesn't accept your key.
            </span><span class="tok-kw">return</span> ctx.hash(key);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">checkedEql</span>(ctx: <span class="tok-kw">anytype</span>, a: <span class="tok-kw">anytype</span>, b: K, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {<span class="tok-comment">
            // If you get a compile error on the next line, it means that your
            // generic eql function doesn't accept (self, adapt key, K, index).
            </span><span class="tok-kw">return</span> ctx.eql(a, b, b_index);
        }

        <span class="tok-kw">fn</span> <span class="tok-fn">dumpState</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, <span class="tok-kw">comptime</span> keyFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> valueFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">if</span> (<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.ByIndexContext">ByIndexContext</a>) != <span class="tok-number">0</span>)
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Cannot infer context &quot;</span> ++ <span class="tok-builtin">@typeName</span>(Context) ++ <span class="tok-str">&quot;, call dumpStateContext instead.&quot;</span>);
            self.dumpStateContext(keyFmt, valueFmt, <span class="tok-null">undefined</span>);
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">dumpStateContext</span>(self: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>, <span class="tok-kw">comptime</span> keyFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> valueFmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ctx: Context) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> p = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>;
            p(<span class="tok-str">&quot;{s}:\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(<a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">Self</a>)});
            <span class="tok-kw">const</span> slice = self.entries.slice();
            <span class="tok-kw">const</span> hash_status = <span class="tok-kw">if</span> (store_hash) <span class="tok-str">&quot;stored&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;computed&quot;</span>;
            p(<span class="tok-str">&quot;  len={} capacity={} hashes {s}\n&quot;</span>, .{ slice.len, slice.capacity, hash_status });
            <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
            <span class="tok-kw">const</span> mask: <span class="tok-type">u32</span> = <span class="tok-kw">if</span> (self.index_header) |header| header.mask() <span class="tok-kw">else</span> ~<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>);
            <span class="tok-kw">while</span> (i &lt; slice.len) : (i += <span class="tok-number">1</span>) {
                <span class="tok-kw">const</span> hash = <span class="tok-kw">if</span> (store_hash) slice.items(.hash)[i] <span class="tok-kw">else</span> <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.checkedHash">checkedHash</a>(ctx, slice.items(.key)[i]);
                <span class="tok-kw">if</span> (store_hash) {
                    p(
                        <span class="tok-str">&quot;  [{}]: key=&quot;</span> ++ keyFmt ++ <span class="tok-str">&quot; value=&quot;</span> ++ valueFmt ++ <span class="tok-str">&quot; hash=0x{x} slot=[0x{x}]\n&quot;</span>,
                        .{ i, slice.items(.key)[i], slice.items(.value)[i], hash, hash &amp; mask },
                    );
                } <span class="tok-kw">else</span> {
                    p(
                        <span class="tok-str">&quot;  [{}]: key=&quot;</span> ++ keyFmt ++ <span class="tok-str">&quot; value=&quot;</span> ++ valueFmt ++ <span class="tok-str">&quot; slot=[0x{x}]\n&quot;</span>,
                        .{ i, slice.items(.key)[i], slice.items(.value)[i], hash &amp; mask },
                    );
                }
            }
            <span class="tok-kw">if</span> (self.index_header) |header| {
                p(<span class="tok-str">&quot;\n&quot;</span>, .{});
                <span class="tok-kw">switch</span> (header.capacityIndexType()) {
                    .<span class="tok-type">u8</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u8</span>),
                    .<span class="tok-type">u16</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u16</span>),
                    .<span class="tok-type">u32</span> =&gt; <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged.dumpIndex">dumpIndex</a>(header, <span class="tok-type">u32</span>),
                }
            }
        }
        <span class="tok-kw">fn</span> <span class="tok-fn">dumpIndex</span>(header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <span class="tok-type">void</span> {
            <span class="tok-kw">const</span> p = <a href="std.html">std</a>.<a href="std.debug.html">debug</a>.<a href="std.debug.html#std.debug.print">print</a>;
            p(<span class="tok-str">&quot;  index len=0x{x} type={}\n&quot;</span>, .{ header.length(), header.capacityIndexType() });
            <span class="tok-kw">const</span> indexes = header.indexes(I);
            <span class="tok-kw">if</span> (indexes.len == <span class="tok-number">0</span>) <span class="tok-kw">return</span>;
            <span class="tok-kw">var</span> is_empty = <span class="tok-null">false</span>;
            <span class="tok-kw">for</span> (indexes, <span class="tok-number">0</span>..) |idx, i| {
                <span class="tok-kw">if</span> (idx.isEmpty()) {
                    is_empty = <span class="tok-null">true</span>;
                } <span class="tok-kw">else</span> {
                    <span class="tok-kw">if</span> (is_empty) {
                        is_empty = <span class="tok-null">false</span>;
                        p(<span class="tok-str">&quot;  ...\n&quot;</span>, .{});
                    }
                    p(<span class="tok-str">&quot;  [0x{x}]: [{}] +{}\n&quot;</span>, .{ i, idx.entry_index, idx.distance_from_start_index });
                }
            }
            <span class="tok-kw">if</span> (is_empty) {
                p(<span class="tok-str">&quot;  ...\n&quot;</span>, .{});
            }
        }
    };
}

<span class="tok-kw">const</span> CapacityIndexType = <span class="tok-kw">enum</span> { <span class="tok-type">u8</span>, <span class="tok-type">u16</span>, <span class="tok-type">u32</span> };

<span class="tok-kw">fn</span> <span class="tok-fn">capacityIndexType</span>(bit_index: <span class="tok-type">u8</span>) <a href="std.array_hash_map.CapacityIndexType.html">CapacityIndexType</a> {
    <span class="tok-kw">if</span> (bit_index &lt;= <span class="tok-number">8</span>)
        <span class="tok-kw">return</span> .<span class="tok-type">u8</span>;
    <span class="tok-kw">if</span> (bit_index &lt;= <span class="tok-number">16</span>)
        <span class="tok-kw">return</span> .<span class="tok-type">u16</span>;
    <a href="std.debug.html#std.debug.assert">assert</a>(bit_index &lt;= <span class="tok-number">32</span>);
    <span class="tok-kw">return</span> .<span class="tok-type">u32</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">capacityIndexSize</span>(bit_index: <span class="tok-type">u8</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">switch</span> (<a href="std.array_hash_map.html#std.array_hash_map.capacityIndexType">capacityIndexType</a>(bit_index)) {
        .<span class="tok-type">u8</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u8</span>)),
        .<span class="tok-type">u16</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u16</span>)),
        .<span class="tok-type">u32</span> =&gt; <span class="tok-kw">return</span> <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(<span class="tok-type">u32</span>)),
    }
}

<span class="tok-comment">/// @truncate fails if the target type is larger than the</span>
<span class="tok-comment">/// target value.  This causes problems when one of the types</span>
<span class="tok-comment">/// is usize, which may be larger or smaller than u32 on different</span>
<span class="tok-comment">/// systems.  This version of truncate is safe to use if either</span>
<span class="tok-comment">/// parameter has dynamic size, and will perform widening conversion</span>
<span class="tok-comment">/// when needed.  Both arguments must have the same signedness.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">safeTruncate</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, val: <span class="tok-kw">anytype</span>) T {
    <span class="tok-kw">if</span> (<span class="tok-builtin">@bitSizeOf</span>(T) &gt;= <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-builtin">@TypeOf</span>(val)))
        <span class="tok-kw">return</span> val;
    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(T, <span class="tok-builtin">@truncate</span>(val));
}

<span class="tok-comment">/// A single entry in the lookup acceleration structure.  These structs</span>
<span class="tok-comment">/// are found in an array after the IndexHeader.  Hashes index into this</span>
<span class="tok-comment">/// array, and linear probing is used for collisions.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">Index</span>(<span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        <span class="tok-comment">/// The index of this entry in the backing store.  If the index is</span>
        <span class="tok-comment">/// empty, this is empty_sentinel.</span>
        entry_index: I,

        <span class="tok-comment">/// The distance between this slot and its ideal placement.  This is</span>
        <span class="tok-comment">/// used to keep maximum scan length small.  This value is undefined</span>
        <span class="tok-comment">/// if the index is empty.</span>
        distance_from_start_index: I,

        <span class="tok-comment">/// The special entry_index value marking an empty slot.</span>
        <span class="tok-kw">const</span> empty_sentinel = ~<span class="tok-builtin">@as</span>(I, <span class="tok-number">0</span>);

        <span class="tok-comment">/// A constant empty index</span>
        <span class="tok-kw">const</span> empty = <a href="std.array_hash_map.html#std.array_hash_map.Index">Self</a>{
            .entry_index = <a href="std.array_hash_map.html#std.array_hash_map.Index.empty_sentinel">empty_sentinel</a>,
            .distance_from_start_index = <span class="tok-null">undefined</span>,
        };

        <span class="tok-comment">/// Checks if a slot is empty</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">isEmpty</span>(idx: <a href="std.array_hash_map.html#std.array_hash_map.Index">Self</a>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> idx.entry_index == <a href="std.array_hash_map.html#std.array_hash_map.Index.empty_sentinel">empty_sentinel</a>;
        }

        <span class="tok-comment">/// Sets a slot to empty</span>
        <span class="tok-kw">fn</span> <span class="tok-fn">setEmpty</span>(idx: *<a href="std.array_hash_map.html#std.array_hash_map.Index">Self</a>) <span class="tok-type">void</span> {
            idx.entry_index = <a href="std.array_hash_map.html#std.array_hash_map.Index.empty_sentinel">empty_sentinel</a>;
            idx.distance_from_start_index = <span class="tok-null">undefined</span>;
        }
    };
}

<span class="tok-comment">/// the byte size of the index must fit in a usize.  This is a power of two</span>
<span class="tok-comment">/// length * the size of an Index(u32).  The index is 8 bytes (3 bits repr)</span>
<span class="tok-comment">/// and max_usize + 1 is not representable, so we need to subtract out 4 bits.</span>
<span class="tok-kw">const</span> max_representable_index_len = <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">usize</span>) - <span class="tok-number">4</span>;
<span class="tok-kw">const</span> max_bit_index = <span class="tok-builtin">@min</span>(<span class="tok-number">32</span>, <a href="std.array_hash_map.html#std.array_hash_map.max_representable_index_len">max_representable_index_len</a>);
<span class="tok-kw">const</span> min_bit_index = <span class="tok-number">5</span>;
<span class="tok-kw">const</span> max_capacity = (<span class="tok-number">1</span> &lt;&lt; <a href="std.array_hash_map.html#std.array_hash_map.max_bit_index">max_bit_index</a>) - <span class="tok-number">1</span>;
<span class="tok-kw">const</span> index_capacities = blk: {
    <span class="tok-kw">var</span> caps: [<a href="std.array_hash_map.html#std.array_hash_map.max_bit_index">max_bit_index</a> + <span class="tok-number">1</span>]<span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (caps[<span class="tok-number">0</span>..<a href="std.array_hash_map.html#std.array_hash_map.max_bit_index">max_bit_index</a>], <span class="tok-number">0</span>..) |*item, i| {
        item.* = (<span class="tok-number">1</span> &lt;&lt; i) * <span class="tok-number">3</span> / <span class="tok-number">5</span>;
    }
    caps[<a href="std.array_hash_map.html#std.array_hash_map.max_bit_index">max_bit_index</a>] = <a href="std.array_hash_map.html#std.array_hash_map.max_capacity">max_capacity</a>;
    <span class="tok-kw">break</span> :blk caps;
};

<span class="tok-comment">/// This struct is trailed by two arrays of length indexes_len</span>
<span class="tok-comment">/// of integers, whose integer size is determined by indexes_len.</span>
<span class="tok-comment">/// These arrays are indexed by constrainIndex(hash).  The</span>
<span class="tok-comment">/// entryIndexes array contains the index in the dense backing store</span>
<span class="tok-comment">/// where the entry's data can be found.  Entries which are not in</span>
<span class="tok-comment">/// use have their index value set to emptySentinel(I).</span>
<span class="tok-comment">/// The entryDistances array stores the distance between an entry</span>
<span class="tok-comment">/// and its ideal hash bucket.  This is used when adding elements</span>
<span class="tok-comment">/// to balance the maximum scan length.</span>
<span class="tok-kw">const</span> IndexHeader = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// This field tracks the total number of items in the arrays following</span>
    <span class="tok-comment">/// this header.  It is the bit index of the power of two number of indices.</span>
    <span class="tok-comment">/// This value is between min_bit_index and max_bit_index, inclusive.</span>
    bit_index: <span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)),

    <span class="tok-comment">/// Map from an incrementing index to an index slot in the attached arrays.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">constrainIndex</span>(header: <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, i: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {<span class="tok-comment">
        // This is an optimization for modulo of power of two integers;
        // it requires `indexes_len` to always be a power of two.
        </span><span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(i &amp; header.mask()));
    }

    <span class="tok-comment">/// Returns the attached array of indexes.  I must match the type</span>
    <span class="tok-comment">/// returned by capacityIndexType.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">indexes</span>(header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, <span class="tok-kw">comptime</span> I: <span class="tok-type">type</span>) []<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I) {
        <span class="tok-kw">const</span> start_ptr: [*]<a href="std.array_hash_map.html#std.array_hash_map.Index">Index</a>(I) = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(header)) + <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>)));
        <span class="tok-kw">return</span> start_ptr[<span class="tok-number">0</span>..header.length()];
    }

    <span class="tok-comment">/// Returns the type used for the index arrays.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">capacityIndexType</span>(header: <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <a href="std.array_hash_map.CapacityIndexType.html">CapacityIndexType</a> {
        <span class="tok-kw">return</span> <a href="std.array_hash_map.html">hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.capacityIndexType">capacityIndexType</a>(header.bit_index);
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">capacity</span>(self: <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">u32</span> {
        <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.index_capacities">index_capacities</a>[self.bit_index];
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">usize</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<span class="tok-type">usize</span>), <span class="tok-builtin">@intCast</span>(self.bit_index));
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">mask</span>(self: <a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">u32</span> {
        <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@intCast</span>(self.length() - <span class="tok-number">1</span>));
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">findBitIndex</span>(desired_capacity: <span class="tok-type">usize</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!<span class="tok-type">u8</span> {
        <span class="tok-kw">if</span> (desired_capacity &gt; <a href="std.array_hash_map.html#std.array_hash_map.max_capacity">max_capacity</a>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
        <span class="tok-kw">var</span> new_bit_index = <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@intCast</span>(<a href="std.html">std</a>.<a href="std.math.html">math</a>.<a href="std.math.html#std.math.log2_int_ceil">log2_int_ceil</a>(<span class="tok-type">usize</span>, desired_capacity)));
        <span class="tok-kw">if</span> (desired_capacity &gt; <a href="std.array_hash_map.html#std.array_hash_map.index_capacities">index_capacities</a>[new_bit_index]) new_bit_index += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (new_bit_index &lt; <a href="std.array_hash_map.html#std.array_hash_map.min_bit_index">min_bit_index</a>) new_bit_index = <a href="std.array_hash_map.html#std.array_hash_map.min_bit_index">min_bit_index</a>;
        <a href="std.debug.html#std.debug.assert">assert</a>(desired_capacity &lt;= <a href="std.array_hash_map.html#std.array_hash_map.index_capacities">index_capacities</a>[new_bit_index]);
        <span class="tok-kw">return</span> new_bit_index;
    }

    <span class="tok-comment">/// Allocates an index header, and fills the entryIndexes array with empty.</span>
    <span class="tok-comment">/// The distance array contents are undefined.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(gpa: <a href="std.mem.Allocator.html">Allocator</a>, new_bit_index: <span class="tok-type">u8</span>) <a href="std.mem.Allocator.html">Allocator</a>.<a href="std.mem.Allocator.html#std.mem.Allocator.Error">Error</a>!*<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> {
        <span class="tok-kw">const</span> len = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(<a href="std.math.html">math</a>.<a href="std.math.html#std.math.Log2Int">Log2Int</a>(<span class="tok-type">usize</span>), <span class="tok-builtin">@intCast</span>(new_bit_index));
        <span class="tok-kw">const</span> index_size = <a href="std.array_hash_map.html">hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.capacityIndexSize">capacityIndexSize</a>(new_bit_index);
        <span class="tok-kw">const</span> nbytes = <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) + index_size * len;
        <span class="tok-kw">const</span> bytes = <span class="tok-kw">try</span> gpa.alignedAlloc(<span class="tok-type">u8</span>, <span class="tok-builtin">@alignOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>), nbytes);
        <span class="tok-builtin">@memset</span>(bytes[<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>)..], <span class="tok-number">0xff</span>);
        <span class="tok-kw">const</span> result: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a> = <span class="tok-builtin">@alignCast</span>(<span class="tok-builtin">@ptrCast</span>(bytes.ptr));
        result.* = .{
            .bit_index = new_bit_index,
        };
        <span class="tok-kw">return</span> result;
    }

    <span class="tok-comment">/// Releases the memory for a header and its associated arrays.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>, gpa: <a href="std.mem.Allocator.html">Allocator</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> index_size = <a href="std.array_hash_map.html">hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.capacityIndexSize">capacityIndexSize</a>(header.bit_index);
        <span class="tok-kw">const</span> ptr: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>)) <span class="tok-type">u8</span> = <span class="tok-builtin">@ptrCast</span>(header);
        <span class="tok-kw">const</span> slice = ptr[<span class="tok-number">0</span> .. <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) + header.length() * index_size];
        gpa.free(slice);
    }

    <span class="tok-comment">/// Puts an IndexHeader into the state that it would be in after being freshly allocated.</span>
    <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(header: *<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) <span class="tok-type">void</span> {
        <span class="tok-kw">const</span> index_size = <a href="std.array_hash_map.html">hash_map</a>.<a href="std.array_hash_map.html#std.array_hash_map.capacityIndexSize">capacityIndexSize</a>(header.bit_index);
        <span class="tok-kw">const</span> ptr: [*]<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>)) <span class="tok-type">u8</span> = <span class="tok-builtin">@ptrCast</span>(header);
        <span class="tok-kw">const</span> nbytes = <span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>) + header.length() * index_size;
        <span class="tok-builtin">@memset</span>(ptr[<span class="tok-builtin">@sizeOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>)..nbytes], <span class="tok-number">0xff</span>);
    }<span class="tok-comment">

    // Verify that the header has sufficient alignment to produce aligned arrays.
    </span><span class="tok-kw">comptime</span> {
        <span class="tok-kw">if</span> (<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>) &gt; <span class="tok-builtin">@alignOf</span>(<a href="std.array_hash_map.IndexHeader.html">IndexHeader</a>))
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;IndexHeader must have a larger alignment than its indexes!&quot;</span>);
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;basic hash map usage&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">1</span>, <span class="tok-number">11</span>)) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">2</span>, <span class="tok-number">22</span>)) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">3</span>, <span class="tok-number">33</span>)) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">4</span>, <span class="tok-number">44</span>)) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> map.putNoClobber(<span class="tok-number">5</span>, <span class="tok-number">55</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">5</span>, <span class="tok-number">66</span>)).?.value == <span class="tok-number">55</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(<span class="tok-number">5</span>, <span class="tok-number">55</span>)).?.value == <span class="tok-number">66</span>);

    <span class="tok-kw">const</span> gop1 = <span class="tok-kw">try</span> map.getOrPut(<span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop1.found_existing == <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop1.value_ptr.* == <span class="tok-number">55</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop1.index == <span class="tok-number">4</span>);
    gop1.value_ptr.* = <span class="tok-number">77</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">5</span>).?.value_ptr.* == <span class="tok-number">77</span>);

    <span class="tok-kw">const</span> gop2 = <span class="tok-kw">try</span> map.getOrPut(<span class="tok-number">99</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop2.found_existing == <span class="tok-null">false</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop2.index == <span class="tok-number">5</span>);
    gop2.value_ptr.* = <span class="tok-number">42</span>;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">99</span>).?.value_ptr.* == <span class="tok-number">42</span>);

    <span class="tok-kw">const</span> gop3 = <span class="tok-kw">try</span> map.getOrPutValue(<span class="tok-number">5</span>, <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop3.value_ptr.* == <span class="tok-number">77</span>);

    <span class="tok-kw">const</span> gop4 = <span class="tok-kw">try</span> map.getOrPutValue(<span class="tok-number">100</span>, <span class="tok-number">41</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop4.value_ptr.* == <span class="tok-number">41</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.contains(<span class="tok-number">2</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">2</span>).?.value_ptr.* == <span class="tok-number">22</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">2</span>).? == <span class="tok-number">22</span>);

    <span class="tok-kw">const</span> rmv1 = map.fetchSwapRemove(<span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(rmv1.?.key == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(rmv1.?.value == <span class="tok-number">22</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.fetchSwapRemove(<span class="tok-number">2</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.swapRemove(<span class="tok-number">2</span>) == <span class="tok-null">false</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">2</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">2</span>) == <span class="tok-null">null</span>);<span class="tok-comment">

    // Since we've used `swapRemove` above, the index of this entry should remain unchanged.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getIndex(<span class="tok-number">100</span>).? == <span class="tok-number">1</span>);
    <span class="tok-kw">const</span> gop5 = <span class="tok-kw">try</span> map.getOrPut(<span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop5.found_existing == <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop5.value_ptr.* == <span class="tok-number">77</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop5.index == <span class="tok-number">4</span>);<span class="tok-comment">

    // Whereas, if we do an `orderedRemove`, it should move the index forward one spot.
    </span><span class="tok-kw">const</span> rmv2 = map.fetchOrderedRemove(<span class="tok-number">100</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(rmv2.?.key == <span class="tok-number">100</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(rmv2.?.value == <span class="tok-number">41</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.fetchOrderedRemove(<span class="tok-number">100</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.orderedRemove(<span class="tok-number">100</span>) == <span class="tok-null">false</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.getEntry(<span class="tok-number">100</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.get(<span class="tok-number">100</span>) == <span class="tok-null">null</span>);
    <span class="tok-kw">const</span> gop6 = <span class="tok-kw">try</span> map.getOrPut(<span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop6.found_existing == <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop6.value_ptr.* == <span class="tok-number">77</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop6.index == <span class="tok-number">3</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.swapRemove(<span class="tok-number">3</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;iterator hash map&quot;</span> {
    <span class="tok-kw">var</span> reset_map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> reset_map.deinit();<span class="tok-comment">

    // test ensureTotalCapacity with a 0 parameter
    </span><span class="tok-kw">try</span> reset_map.ensureTotalCapacity(<span class="tok-number">0</span>);

    <span class="tok-kw">try</span> reset_map.putNoClobber(<span class="tok-number">0</span>, <span class="tok-number">11</span>);
    <span class="tok-kw">try</span> reset_map.putNoClobber(<span class="tok-number">1</span>, <span class="tok-number">22</span>);
    <span class="tok-kw">try</span> reset_map.putNoClobber(<span class="tok-number">2</span>, <span class="tok-number">33</span>);

    <span class="tok-kw">const</span> keys = [_]<span class="tok-type">i32</span>{
        <span class="tok-number">0</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>,
    };

    <span class="tok-kw">const</span> values = [_]<span class="tok-type">i32</span>{
        <span class="tok-number">11</span>, <span class="tok-number">33</span>, <span class="tok-number">22</span>,
    };

    <span class="tok-kw">var</span> buffer = [_]<span class="tok-type">i32</span>{
        <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>,
    };

    <span class="tok-kw">var</span> it = reset_map.iterator();
    <span class="tok-kw">const</span> first_entry = it.next().?;
    it.reset();

    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (it.next()) |entry| : (count += <span class="tok-number">1</span>) {
        buffer[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(entry.key_ptr.*))] = entry.value_ptr.*;
    }
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(count == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(it.next() == <span class="tok-null">null</span>);

    <span class="tok-kw">for</span> (buffer, <span class="tok-number">0</span>..) |_, i| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(buffer[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(keys[i]))] == values[i]);
    }

    it.reset();
    count = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (it.next()) |entry| {
        buffer[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(entry.key_ptr.*))] = entry.value_ptr.*;
        count += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (count &gt;= <span class="tok-number">2</span>) <span class="tok-kw">break</span>;
    }

    <span class="tok-kw">for</span> (buffer[<span class="tok-number">0</span>..<span class="tok-number">2</span>], <span class="tok-number">0</span>..) |_, i| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(buffer[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(keys[i]))] == values[i]);
    }

    it.reset();
    <span class="tok-kw">const</span> entry = it.next().?;
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(entry.key_ptr.* == first_entry.key_ptr.*);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(entry.value_ptr.* == first_entry.value_ptr.*);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ensure capacity&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.ensureTotalCapacity(<span class="tok-number">20</span>);
    <span class="tok-kw">const</span> initial_capacity = map.capacity();
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(initial_capacity &gt;= <span class="tok-number">20</span>);
    <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.fetchPutAssumeCapacity(i, i + <span class="tok-number">10</span>) == <span class="tok-null">null</span>);
    }<span class="tok-comment">
    // shouldn't resize from putAssumeCapacity
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(initial_capacity == map.capacity());
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;ensure capacity leak&quot;</span> {
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.checkAllAllocationFailures">checkAllAllocationFailures</a>(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">f</span>(allocator: <a href="std.mem.Allocator.html">Allocator</a>) !<span class="tok-type">void</span> {
            <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(allocator);
            <span class="tok-kw">defer</span> map.deinit();

            <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;<span class="tok-comment">
            // put more than `linear_scan_max` in so index_header gets allocated.
            </span><span class="tok-kw">while</span> (i &lt;= <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) <span class="tok-kw">try</span> map.put(i, i);
        }
    }.f, .{});
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;big map&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, i + <span class="tok-number">10</span>);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, i + <span class="tok-number">10</span>), map.get(i));
    }
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), map.get(i));
    }

    i = <span class="tok-number">4</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">12</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> map.put(i, i + <span class="tok-number">12</span>);
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">4</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, i + <span class="tok-number">10</span>), map.get(i));
    }
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">12</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, i + <span class="tok-number">12</span>), map.get(i));
    }
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), map.get(i));
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">4</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.orderedRemove(i));
    }
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.swapRemove(i));
    }

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">8</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), map.get(i));
    }
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">12</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, i + <span class="tok-number">12</span>), map.get(i));
    }
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">16</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-builtin">@as</span>(?<span class="tok-type">i32</span>, <span class="tok-null">null</span>), map.get(i));
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;clone&quot;</span> {
    <span class="tok-kw">var</span> original = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> original.deinit();<span class="tok-comment">

    // put more than `linear_scan_max` so we can test that the index header is properly cloned
    </span><span class="tok-kw">var</span> i: <span class="tok-type">u8</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> original.putNoClobber(i, i * <span class="tok-number">10</span>);
    }

    <span class="tok-kw">var</span> copy = <span class="tok-kw">try</span> original.clone();
    <span class="tok-kw">defer</span> copy.deinit();

    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(original.get(i).? == i * <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(copy.get(i).? == i * <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(original.getPtr(i).? != copy.getPtr(i).?);
    }

    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">20</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(original.get(i) == <span class="tok-null">null</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(copy.get(i) == <span class="tok-null">null</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;shrink&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();<span class="tok-comment">

    // This test is more interesting if we insert enough entries to allocate the index header.
    </span><span class="tok-kw">const</span> num_entries = <span class="tok-number">200</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; num_entries) : (i += <span class="tok-number">1</span>)
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(i, i * <span class="tok-number">10</span>)) == <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.unmanaged.index_header != <span class="tok-null">null</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.count() == num_entries);<span class="tok-comment">

    // Test `shrinkRetainingCapacity`.
    </span>map.shrinkRetainingCapacity(<span class="tok-number">17</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.count() == <span class="tok-number">17</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.capacity() &gt;= num_entries);
    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; num_entries) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> map.getOrPut(i);
        <span class="tok-kw">if</span> (i &lt; <span class="tok-number">17</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.found_existing == <span class="tok-null">true</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.value_ptr.* == i * <span class="tok-number">10</span>);
        } <span class="tok-kw">else</span> <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.found_existing == <span class="tok-null">false</span>);
    }<span class="tok-comment">

    // Test `shrinkAndFree`.
    </span>map.shrinkAndFree(<span class="tok-number">15</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.count() == <span class="tok-number">15</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.capacity() == <span class="tok-number">15</span>);
    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; num_entries) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> map.getOrPut(i);
        <span class="tok-kw">if</span> (i &lt; <span class="tok-number">15</span>) {
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.found_existing == <span class="tok-null">true</span>);
            <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.value_ptr.* == i * <span class="tok-number">10</span>);
        } <span class="tok-kw">else</span> <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.found_existing == <span class="tok-null">false</span>);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pop()&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();<span class="tok-comment">

    // Insert just enough entries so that the map expands. Afterwards,
    // pop all entries out of the map.

    </span><span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">9</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(i, i)) == <span class="tok-null">null</span>);
    }

    <span class="tok-kw">while</span> (map.pop()) |pop| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(pop.key == i - <span class="tok-number">1</span> <span class="tok-kw">and</span> pop.value == i - <span class="tok-number">1</span>);
        i -= <span class="tok-number">1</span>;
    }

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.count() == <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;reIndex&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapWithAllocator">ArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(<span class="tok-type">i32</span>), <span class="tok-null">true</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();<span class="tok-comment">

    // Populate via the API.
    </span><span class="tok-kw">const</span> num_indexed_entries = <span class="tok-number">200</span>;
    <span class="tok-kw">var</span> i: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; num_indexed_entries) : (i += <span class="tok-number">1</span>)
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>((<span class="tok-kw">try</span> map.fetchPut(i, i * <span class="tok-number">10</span>)) == <span class="tok-null">null</span>);<span class="tok-comment">

    // Make sure we allocated an index header.
    </span><span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.unmanaged.index_header != <span class="tok-null">null</span>);<span class="tok-comment">

    // Now write to the arrays directly.
    </span><span class="tok-kw">const</span> num_unindexed_entries = <span class="tok-number">20</span>;
    <span class="tok-kw">try</span> map.unmanaged.entries.resize(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>, num_indexed_entries + num_unindexed_entries);
    <span class="tok-kw">for</span> (map.keys()[num_indexed_entries..], map.values()[num_indexed_entries..], num_indexed_entries..) |*key, *value, j| {
        key.* = <span class="tok-builtin">@intCast</span>(j);
        value.* = <span class="tok-builtin">@intCast</span>(j * <span class="tok-number">10</span>);
    }<span class="tok-comment">

    // After reindexing, we should see everything.
    </span><span class="tok-kw">try</span> map.reIndex();
    i = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; num_indexed_entries + num_unindexed_entries) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> gop = <span class="tok-kw">try</span> map.getOrPut(i);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.found_existing == <span class="tok-null">true</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.value_ptr.* == i * <span class="tok-number">10</span>);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(gop.index == i);
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;auto store_hash&quot;</span> {
    <span class="tok-kw">const</span> HasCheapEql = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> HasExpensiveEql = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>([<span class="tok-number">32</span>]<span class="tok-type">i32</span>, <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@FieldType</span>(HasCheapEql.Data, <span class="tok-str">&quot;hash&quot;</span>) == <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@FieldType</span>(HasExpensiveEql.Data, <span class="tok-str">&quot;hash&quot;</span>) != <span class="tok-type">void</span>);

    <span class="tok-kw">const</span> HasCheapEqlUn = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> HasExpensiveEqlUn = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMapUnmanaged">AutoArrayHashMapUnmanaged</a>([<span class="tok-number">32</span>]<span class="tok-type">i32</span>, <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@FieldType</span>(HasCheapEqlUn.Data, <span class="tok-str">&quot;hash&quot;</span>) == <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(<span class="tok-builtin">@FieldType</span>(HasExpensiveEqlUn.Data, <span class="tok-str">&quot;hash&quot;</span>) != <span class="tok-type">void</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;sort&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">for</span> ([_]<span class="tok-type">i32</span>{ <span class="tok-number">8</span>, <span class="tok-number">3</span>, <span class="tok-number">12</span>, <span class="tok-number">10</span>, <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">9</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">13</span>, <span class="tok-number">14</span>, <span class="tok-number">15</span>, <span class="tok-number">16</span>, <span class="tok-number">1</span>, <span class="tok-number">11</span>, <span class="tok-number">17</span>, <span class="tok-number">7</span> }) |x| {
        <span class="tok-kw">try</span> map.put(x, x * <span class="tok-number">3</span>);
    }

    <span class="tok-kw">const</span> C = <span class="tok-kw">struct</span> {
        keys: []<span class="tok-type">i32</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">lessThan</span>(ctx: <span class="tok-builtin">@This</span>(), a_index: <span class="tok-type">usize</span>, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            <span class="tok-kw">return</span> ctx.keys[a_index] &lt; ctx.keys[b_index];
        }
    };

    map.sort(C{ .keys = map.keys() });

    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">for</span> (map.keys(), <span class="tok-number">0</span>..) |key, i| {
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(key == x);
        <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expect">expect</a>(map.values()[i] == x * <span class="tok-number">3</span>);
        x += <span class="tok-number">1</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;0 sized key&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">u0</span>, <span class="tok-type">i32</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">0</span>), <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> map.put(<span class="tok-number">0</span>, <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">0</span>), <span class="tok-number">5</span>);

    <span class="tok-kw">try</span> map.put(<span class="tok-number">0</span>, <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">0</span>), <span class="tok-number">10</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.swapRemove(<span class="tok-number">0</span>), <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">0</span>), <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;0 sized key and 0 sized value&quot;</span> {
    <span class="tok-kw">var</span> map = <a href="std.array_hash_map.html#std.array_hash_map.AutoArrayHashMap">AutoArrayHashMap</a>(<span class="tok-type">u0</span>, <span class="tok-type">u0</span>).init(<a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">0</span>), <span class="tok-null">null</span>);

    <span class="tok-kw">try</span> map.put(<span class="tok-number">0</span>, <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">0</span>), <span class="tok-number">0</span>);

    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.swapRemove(<span class="tok-number">0</span>), <span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(map.get(<span class="tok-number">0</span>), <span class="tok-null">null</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;setKey storehash true&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;

    <span class="tok-kw">var</span> map: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(<span class="tok-type">i32</span>), <span class="tok-null">true</span>) = .empty;
    <span class="tok-kw">defer</span> map.deinit(gpa);

    <span class="tok-kw">try</span> map.put(gpa, <span class="tok-number">12</span>, <span class="tok-number">34</span>);
    <span class="tok-kw">try</span> map.put(gpa, <span class="tok-number">56</span>, <span class="tok-number">78</span>);

    <span class="tok-kw">try</span> map.setKey(gpa, <span class="tok-number">0</span>, <span class="tok-number">42</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, map.count());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, map.contains(<span class="tok-number">12</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">34</span>, map.get(<span class="tok-number">42</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">78</span>, map.get(<span class="tok-number">56</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;setKey storehash false&quot;</span> {
    <span class="tok-kw">const</span> gpa = <a href="std.html">std</a>.<a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.allocator">allocator</a>;

    <span class="tok-kw">var</span> map: <a href="std.array_hash_map.html#std.array_hash_map.ArrayHashMapUnmanaged">ArrayHashMapUnmanaged</a>(<span class="tok-type">i32</span>, <span class="tok-type">i32</span>, <a href="std.array_hash_map.html#std.array_hash_map.AutoContext">AutoContext</a>(<span class="tok-type">i32</span>), <span class="tok-null">false</span>) = .empty;
    <span class="tok-kw">defer</span> map.deinit(gpa);

    <span class="tok-kw">try</span> map.put(gpa, <span class="tok-number">12</span>, <span class="tok-number">34</span>);
    <span class="tok-kw">try</span> map.put(gpa, <span class="tok-number">56</span>, <span class="tok-number">78</span>);

    <span class="tok-kw">try</span> map.setKey(gpa, <span class="tok-number">0</span>, <span class="tok-number">42</span>);
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">2</span>, map.count());
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-null">false</span>, map.contains(<span class="tok-number">12</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">34</span>, map.get(<span class="tok-number">42</span>));
    <span class="tok-kw">try</span> <a href="std.testing.html">testing</a>.<a href="std.testing.html#std.testing.expectEqual">expectEqual</a>(<span class="tok-number">78</span>, map.get(<span class="tok-number">56</span>));
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getHashPtrAddrFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: Context, key: K) <span class="tok-type">u32</span> {
            _ = ctx;
            <span class="tok-kw">return</span> <a href="std.array_hash_map.html#std.array_hash_map.getAutoHashFn">getAutoHashFn</a>(<span class="tok-type">usize</span>, <span class="tok-type">void</span>)({}, <span class="tok-builtin">@intFromPtr</span>(key));
        }
    }.hash;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getTrivialEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K) <span class="tok-type">bool</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: Context, a: K, b: K) <span class="tok-type">bool</span> {
            _ = ctx;
            <span class="tok-kw">return</span> a == b;
        }
    }.eql;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">AutoContext</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> hash = <a href="std.array_hash_map.html#std.array_hash_map.getAutoHashFn">getAutoHashFn</a>(K, <span class="tok-builtin">@This</span>());
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> eql = <a href="std.array_hash_map.html#std.array_hash_map.getAutoEqlFn">getAutoEqlFn</a>(K, <span class="tok-builtin">@This</span>());
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: Context, key: K) <span class="tok-type">u32</span> {
            _ = ctx;
            <span class="tok-kw">if</span> (<a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.hasUniqueRepresentation">hasUniqueRepresentation</a>(K)) {
                <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(<a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.hash">hash</a>(<span class="tok-number">0</span>, <a href="std.html">std</a>.<a href="std.mem.html">mem</a>.<a href="std.mem.html#std.mem.asBytes">asBytes</a>(&amp;key)));
            } <span class="tok-kw">else</span> {
                <span class="tok-kw">var</span> hasher = <a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
                <a href="std.hash.auto_hash.html#std.hash.auto_hash.autoHash">autoHash</a>(&amp;hasher, key);
                <span class="tok-kw">return</span> <span class="tok-builtin">@truncate</span>(hasher.final());
            }
        }
    }.hash;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoEqlFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>) (<span class="tok-kw">fn</span> (Context, K, K, <span class="tok-type">usize</span>) <span class="tok-type">bool</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(ctx: Context, a: K, b: K, b_index: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
            _ = b_index;
            _ = ctx;
            <span class="tok-kw">return</span> <a href="std.html">std</a>.<a href="std.meta.html">meta</a>.<a href="std.meta.html#std.meta.eql">eql</a>(a, b);
        }
    }.eql;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">autoEqlIsCheap</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(K)) {
        .<span class="tok-type">bool</span>,
        .int,
        .float,
        .pointer,
        .<span class="tok-type">comptime_float</span>,
        .<span class="tok-type">comptime_int</span>,
        .@&quot;enum&quot;,
        .@&quot;fn&quot;,
        .error_set,
        .@&quot;anyframe&quot;,
        .enum_literal,
        =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getAutoHashStratFn</span>(<span class="tok-kw">comptime</span> K: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> Context: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> strategy: <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.auto_hash.HashStrategy.html">Strategy</a>) (<span class="tok-kw">fn</span> (Context, K) <span class="tok-type">u32</span>) {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(ctx: Context, key: K) <span class="tok-type">u32</span> {
            _ = ctx;
            <span class="tok-kw">var</span> hasher = <a href="std.hash.wyhash.Wyhash.html">Wyhash</a>.<a href="std.hash.wyhash.Wyhash.html#std.hash.wyhash.Wyhash.init">init</a>(<span class="tok-number">0</span>);
            <a href="std.html">std</a>.<a href="std.hash.html">hash</a>.<a href="std.hash.auto_hash.html#std.hash.auto_hash.hash">autoHashStrat</a>(&amp;hasher, key, strategy);
            <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@truncate</span>(hasher.final()));
        }
    }.hash;
}</code></pre></details></div></div></section>
    <div class="sectSearchResults hidden">
      <h2>Search Results</h2>
      <ul class="listSearchResults"></ul>
    </div>
    <div class="sectSearchNoResults hidden">
      <h2>No Results Found</h2>
      <p>Press escape to exit search and then '?' to see more options.</p>
    </div>
    <div id="helpDialog" class="hidden">
      <h1>Keyboard Shortcuts</h1>
      <dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd></dl>
      <dl><dt><kbd>Esc</kbd></dt><dd>Clear focus; close this dialog</dd></dl>
      <dl><dt><kbd>s</kbd></dt><dd>Focus the search field</dd></dl>
      <dl><dt><kbd>u</kbd></dt><dd>Go to source code</dd></dl>
      <dl><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd></dl>
      <dl><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd></dl>
      <dl><dt><kbd>⏎</kbd></dt><dd>Go to active search result</dd></dl>
    </div>
    <div id="errors" class="hidden">
      <h1>Errors</h1>
      <pre id="errorsText"></pre>
    </div>
    <script src="main.js"></script>
  </body>
</html>
